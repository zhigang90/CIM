c
c  MM  March 2005
c
c  This file contains routines for the Fast Fourier Transformation
c  of real and complex periodic sequences. Both forward and backward
c  transformations are covered.
c
c  This code has been adapted from the libraries dfftpack and vfftpack
c  available from netlib (www.netlib.org).
c
c  There are no restrictions on the length of the sequence to be
c  transformed, altough the algorithm performs better when the length
c  is a multiple of the small integers 2, 3, 4 and 5.
c
c  Before transforming a sequence, an initialization has to be
c  performed by calling the appropriate routine. For a given
c  sequence type (real or complex) and sequence length n,
c  only one initialization is necessary, as long
c  as the contents of the work array wsave (see below) are not
c  changed between different forward or backward transformation.
c
c  Different sets of routines are used to transform one sequence
c  or a series of sequences of the same length.
c
c***********************************
c
c   real sequences
c
c***********************************
c
c  1)  initialisation:
c
c      call vrffti(n,wsave)
c
c           n       length of the sequence to be transformed
c
c           wsave   real work area of dimension n+15 to store
c                   the factorization of n and some precomputed
c                   trigonometric constants. This can be
c                   used for both forward and backward transforms
c                   of real sequences of a given length n.
c
c  2)  one real sequence
c
c     call dfftf(n,r,wsave)   (forward transformation)
c
c     call dfftb(n,r,wsave)   (backward transformation)
c
c           n       length of the sequence to be transformed
c
c           r       real array of length n containing the
c                   sequence to be transformed. In output
c                   r will contain the transformed sequence
c                   (see comments of routines dfftf and dfftb
c                    for how the results are stored)
c
c           wsave   work array as computed by vrffti
c
c  NOTE: a call to dfftf followed by a call to dfftb will produce
c        the original sequence multiplied by n (that is, dfftb is
c        the unnormalized inverse of dfftf)
c
c  3)  multiple real sequences of the same length n
c
c NOTE: the sequences must be stored as rows of the two
c       dimensional array r(mdimr,n)
c
c     call vrfftf (mi,mf,ms,n,r,mdimr,wsave) (forward transform)
c
c     call vrfftb (mi,mf,ms,n,r,mdimr,wsave) (backward transform)
c
c           mi       initial sequence to be transformed
c
c           mf       final sequence to be transformed
c
c           ms       step to reach next sequence to be transformed
c                    (i.e., all sequences generated by the loop
c                     do m=mi,mf,ms  will be transformed)
c
c           r       real 2 dimensional array of length mdimr*n
c                   containing the sequences to be tranformed
c                   ordered by row. In output it will contain the
c                   results (see initial comments of vrfftf and vrfftb)
c
c           mdimr   first dimension of the r array
c
c           wsave   work array as computed by vrffti
c
c  NOTE: a call to vrfftf followed by a call to vrfftb will produce
c        the original sequences multiplied by n (that is, vrfftb is
c        the unnormalized inverse of vrfftf)
c
c***********************************
c
c   complex  sequences
c
c***********************************
c
c  1)  initialisation:
c
c      call vzffti(n,wsave)
c
c           n       length of the sequence to be transformed
c
c           wsave   real work area of dimension 2*n+15 to store
c                   the factorization of n and some precomputed
c                   trigonometric constants. This can be
c                   used for both forward and backward transforms
c                   of complex sequences of a given length n.
c
c  2)  one complex sequence
c
c     call zfftf(n,c,wsave)   (forward transformation)
c
c     call zfftb(n,c,wsave)   (backward transformation)
c
c           n       length of the sequence to be transformed
c
c           c       complex array of length n containing the
c                   sequence to be transformed. In output
c                   c will contain the transformed sequence
c                   (see comments of routines vfftf and vfftb
c                    for how the results are stored)
c
c           wsave   work array as computed by vzffti
c
c  NOTE: a call to zfftf followed by a call to zfftb will produce
c        the original sequence multiplied by n (that is, zfftb is
c        the unnormalized inverse of zfftf)
c
c  3)  multiple complex sequences of the same length n
c
c NOTE: the sequences must be stored as rows of the two
c       dimensional complex array c(mdimr,n)
c
c     call vzfftf (mi,mf,ms,n,c,mdimr,wsave) (forward transform)
c
c     call vzfftb (mi,mf,ms,n,c,mdimr,wsave) (backward transform)
c
c           mi       initial sequence to be transformed
c
c           mf       final sequence to be transformed
c
c           ms       step to reach next sequence to be transformed
c                    (i.e., all sequences generated by the loop
c                     do m=mi,mf,ms  will be transformed)
c
c           c       complex 2 dimensional array of length mdimr*n
c                   containing the sequences to be tranformed
c                   ordered by row. In output it will contain the
c                   results (see initial comments of vzfftf and vzfftb)
c
c           mdimr   first dimension of the r array
c
c           wsave   work array as computed by vzffti
c
c  NOTE: a call to vzfftf followed by a call to vzfftb will produce
c        the original sequences multiplied by n (that is, vzfftb is
c        the unnormalized inverse of vzfftf)
c
c======================================================================

      subroutine dfftf (n,r,wsave)
c
c  subroutine dfftf computes the fourier coefficients (forward
c  transform) of a real periodic sequences.  specifically,
c  he subroutine claculates the independent fourier coefficients
c  described below at output parameter r.
c
c  the array wsave which is used by subroutine dfftf must be
c  initialized by calling subroutine vrffti(n,wsave).
c
c
c  input parameters
c
c  n       the length of the sequences to be transformed.  the method
c          is most efficient when n is a product of small primes,
c          however n may be any positive integer.
c
c  r       a real array of size n containing the sequence to be
c          transformed.
c
c  wsave   a real one-dimensional work array which must be dimensioned
c          at least n+15.  the wsave array must be initialized by
c          calling subroutine vrffti.  a different wsave array must be
c          used for each different value of n.  this initialization does
c          not have to be repeated so long as n remains unchanged.  the
c          same wsave array may be used by dfftf and dfftb.
c
c  output parameters
c
c  r       contains the fourier coefficients f(k) for the
c          input sequence.  specifically, r(j),
c          j=1,2,..,n, contains the independent fourier coefficients
c          f(k), for the input sequence stored as
c
c             r(1) = real( f(0) ),
c                    = sum(j=0,n-1)[ x(j) ],
c
c             r(2*k) = real( f(k) )
c                      = sum(j=0,n-1)[x(j)*cos(2j*k*pi/n)]
c
c             r(2*k+1) = imag( f(k) )
c                        =-sum(j=0,n-1)[x(j)*sin(2j*k*pi/n)]
c
c                   for k = 1, 2, . . . , m-1,
c
c              and, when n is even,
c
c              r(n) = real( f(n/2) ).
c                     = sum(j=0,n-1)[ (-1)**j*x(j) ].
c
c
c  -----------------------------------------------------------------
c
c  note  -  a call of dfftf followed immediately by a call of dfftb
c  will return the original sequences r multipied by n.
c
c  -----------------------------------------------------------------
c***references  p. n. swarztrauber, vectorizing the ffts, in parallel
c               computations, (g. rodrigue, ed.), academic press, 1982,
c               pp. 51-83.
c
c     vrfftpk, version 1, august 1985
c

      use memory

      implicit real*8 (a-h,o-z)
      dimension  r(*),wsave(*)
c     common /big/bl(1000000)
c
      if (n .ne. 1) then
        call getmem(n,irt)        !   allocate work array rt(n)
        call rfftf1 (n,r,bl(irt),wsave(1),wsave(n+1))
        call retmem(1)            !   deallocate rt
      endif
c
      end
c======================================================================

      subroutine dfftb (n,r,wsave)
c
c  subroutine dfftb computes the synthesis (backward transform) of
c  a real periodic sequence from its fourier coefficients.
c
c  the array wsave which is used by subroutine dfftb must be
c  initialized by calling subroutine vrffti(n,wsave).
c
c
c  input parameters
c
c  n       the length of the sequence of coefficients to be
c          transformed.  the method is most efficient when n is a
c          product of small primes, however n may be any positive
c          integer.
c
c  r       areal array of size n containing the
c          coefficients to be transformed, stored in the following
c          way:
c
c                r(1) = real( f(0) ),
c
c                r(2*k) = real( f(k) )
c
c                r(2*k+1) = imag( f(k) )
c
c                   for k = 1, 2, . . . , m-1,
c
c                and, when n is even,
c
c                r(n) = real( f(n/2) ).
c
c  wsave   a real one-dimensional work array which must be dimensioned
c          at least n+15.  the wsave array must be initialized by
c          calling subroutine vrffti.  a different wsave array must be
c          used for each different value of n.  this initialization does
c          not have to be repeated so long as n remains unchanged.  the
c          same wsave array may be used by dfftb and dfftf.
c
c  output parameters
c
c  r       contains m real periodic sequence corresponding to the given
c          coefficients stored as
c
c               r(j) = x(j-1) ,   j = 1, 2, . . . , n, where
c
c               x(j) = f(0) + (-1)**j*f(n/2)
c                        + 2*sum(k=1,m)[ real(f(2k))*cos(2k*j*pi/n)
c                        - imag(f(2k+1))*sin(2k*j*pi/n) ]  ,
c
c                 when n is even, and
c
c               x(j) = f(0) +
c                        2*sum(k=1,m)[ real(f(2k))*cos(2k*j*pi/n)
c                        - imag(f(2k+1))*sin(2k*j*pi/n) ]  ,
c
c                 when n is odd.
c
c  -----------------------------------------------------------------
c
c  note  -  a call of dfftf followed immediately by a call of
c           of dfftb will return the original sequence r
c           multiplied by n. thus, dfftb is the  unormalized
c           inverse of dfftf.
c
c  -----------------------------------------------------------------
c
c***references  p. n. swarztrauber, vectorizing the ffts, in parallel
c               computations, (g. rodrigue, ed.), academic press, 1982,
c               pp. 51-83.
c
c     vrfftpk, version 1, august 1985
c

      use memory

      implicit real*8 (a-h,o-z)
      dimension r(*),wsave(*)
c     common /big/bl(1000000)
c
      if (n .ne. 1) then
        call getmem(n,irt)        !   allocate work array rt(n)
        call rfftb1 (n,r,bl(irt),wsave(1),wsave(n+1))
        call retmem(1)            !   deallocate rt
      endif
c
      end
c======================================================================

      subroutine vrfftf (mi,mf,ms,n,r,mdimr,wsave)
c
c  subroutine vrfftf computes the fourier coefficients (forward
c  transform) of a number of real periodic sequences.  specifically,
c  for each sequence the subroutine claculates the independent
c  fourier coefficients described below at output parameter r.
c
c  the array wsave which is used by subroutine vrfftf must be
c  initialized by calling subroutine vrffti(n,wsave).
c
c
c  input parameters
c
c  mi      initial sequence to be transformed
c  mf      final sequence to be transformed
c  ms      step to reach next sequence to be transformed
c
c  n       the length of the sequences to be transformed.  the method
c          is most efficient when n is a product of small primes,
c          however n may be any positive integer.
c
c  r       areal two-dimensional array of size mdimr * n containing the
c          the sequences to be transformed.  the sequences are stored
c          in the rows of r.  thus, the i-th sequence to be transformed,
c          x(i,j), j=0,1,...,n-1, is stored as
c
c               r(i,j) = x(i,j-1) , j=1, 2, . . . , n.
c
c  mdimr   the row (or first) dimension of the arrays r and rt exactly
c          as they appear in the calling program.  this parameter is
c          used to specify the variable dimension of these arrays.
c
c  wsave   a real one-dimensional work array which must be dimensioned
c          at least n+15.  the wsave array must be initialized by
c          calling subroutine vrffti.  a different wsave array must be
c          used for each different value of n.  this initialization does
c          not have to be repeated so long as n remains unchanged.  the
c          same wsave array may be used by vrfftf and vrfftb.
c
c  output parameters
c
c  r       contains the fourier coefficients f(k) for each of the m
c          input sequences.  specifically, row i of r, r(i,j),
c          j=1,2,..,n, contains the independent fourier coefficients
c          f(i,k), for the i-th input sequence stored as
c
c             r(i,1) = real( f(i,0) ),
c                    = sum(j=0,n-1)[ x(i,j) ],
c
c             r(i,2*k) = real( f(i,k) )
c                      = sum(j=0,n-1)[x(i,j)*cos(2j*k*pi/n)]
c
c             r(i,2*k+1) = imag( f(i,k) )
c                        =-sum(j=0,n-1)[x(i,j)*sin(2j*k*pi/n)]
c
c                   for k = 1, 2, . . . , m-1,
c
c              and, when n is even,
c
c              r(i,n) = real( f(i,n/2) ).
c                     = sum(j=0,n-1)[ (-1)**j*x(i,j) ].
c
c
c  -----------------------------------------------------------------
c
c  note  -  a call of vrfftf followed immediately by a call of vrfftb
c           will return the original sequences r multipied by n.
c
c  -----------------------------------------------------------------
c
c  vrfftf is a straightforward extension of the subprogram rfftf to
c  handle m simultaneous sequences.  rfftf was originally developed
c  by p. n. swarztrauber of ncar.
c
c***references  p. n. swarztrauber, vectorizing the ffts, in parallel
c               computations, (g. rodrigue, ed.), academic press, 1982,
c               pp. 51-83.
c
c     vrfftpk, version 1, august 1985
c

      use memory

      implicit real*8 (a-h,o-z)
      dimension       r(*)  ,wsave(*)
c     common /big/bl(1000000)
c
c  consistency check
c
      if(mi.le.0.or.mf.le.0)then
        call nerror(1,'vrfftf',
     $    ' mi and mf must be positive integers',mi,mf)
      endif
      if(ms.eq.0)then
        call nerror(1,'vrfftf',' ms must be nonzero',ms,0)
      endif
c
      if (n .ne. 1) then
        call getmem(mdimr*n,irt)  !   allocate work array rt(mdimr,n)
        call vrftf1 (mi,mf,ms,n,r,bl(irt),mdimr,wsave(1),wsave(n+1))
        call retmem(1)            !   deallocate rt
      endif
c
      end
c======================================================================

      subroutine vrfftb(mi,mf,ms,n,r,mdimr,wsave)
c
c  subroutine vrfftb computes the synthesis (backward transform) of a
c  number of real periodic sequences from their fourier coefficients.
c
c  the array wsave which is used by subroutine vrfftb must be
c  initialized by calling subroutine vrffti(n,wsave).
c
c
c  input parameters
c
c  mi      initial sequence to be transformed
c  mf      final sequence to be transformed
c  ms      step to reach next sequence to be transformed
c
c  n       the length of the sequences of coefficients to be
c          transformed.  the method is most efficient when n is a
c          product of small primes, however n may be any positive
c          integer.
c
c  r       areal two-dimensional array of size mdimr * n containing the
c          coefficients to be transformed.  each set of coefficients
c          f(k), k\0,1,..,n-1, is stored as a row of r.  specifically,
c          the i-th set of independent fourier coefficients is stored
c
c                r(i,1) = real( f(i,0) ),
c
c                r(i,2*k) = real( f(i,k) )
c
c                r(i,2*k+1) = imag( f(i,k) )
c
c                   for k = 1, 2, . . . , m-1,
c
c                and, when n is even,
c
c                r(i,n) = real( f(i,n/2) ).
c
c  mdimr   the row (or first) dimension of the arrays r and rt exactly
c          as they appear in the calling program.  this parameter is
c          used to specify the variable dimension of these arrays.
c
c  wsave   a real one-dimensional work array which must be dimensioned
c          at least n+15.  the wsave array must be initialized by
c          calling subroutine vrffti.  a different wsave array must be
c          used for each different value of n.  this initialization does
c          not have to be repeated so long as n remains unchanged.  the
c          same wsave array may be used by vrfftb and vrfftf.
c
c  output parameters
c
c  r       contains m real periodic sequences corresponding to the given
c          coefficients.  specifically, the i-th row of r contains the
c          real periodic sequence corresponding to the i-th set of
c          independent fourier coefficients f(i,k) stored as
c
c               r(i,j) = x(i,j-1) ,   j = 1, 2, . . . , n, where
c
c               x(i,j) = f(i,0) + (-1)**j*f(i,n/2)
c                        + 2*sum(k=1,m)[ real(f(i,2k))*cos(2k*j*pi/n)
c                        - imag(f(i,2k+1))*sin(2k*j*pi/n) ]  ,
c
c                 when n is even, and
c
c               x(i,j) = f(i,0) +
c                        2*sum(k=1,m)[ real(f(i,2k))*cos(2k*j*pi/n)
c                        - imag(f(i,2k+1))*sin(2k*j*pi/n) ]  ,
c
c                 when n is odd.
c
c  -----------------------------------------------------------------
c
c  note  -  a call of vrfftf followed immediately by a call of
c           of vrfftb will return the original sequences r
c           multiplied by n. thus, vrfftb is the  unormalized
c           inverse of vrfftf.
c
c  -----------------------------------------------------------------
c
c  vrfftb is a straightforward extension of the subprogram rfftb to
c  handle m simultaneous sequences.  rfftb was originally developed
c  by p. n. swarztrauber of ncar.
c
c***references  p. n. swarztrauber, vectorizing the ffts, in parallel
c               computations, (g. rodrigue, ed.), academic press, 1982,
c               pp. 51-83.
c
c     vrfftpk, version 1, august 1985
c

      use memory

      implicit real*8 (a-h,o-z)
      dimension     r(*),wsave(*)
c     common /big/bl(300)
c
c  consistency check
c
      if(mi.le.0.or.mf.le.0)then
        call nerror(1,'vrfftb',
     $    ' mi and mf must be positive integers',mi,mf)
      endif
      if(ms.eq.0)then
        call nerror(1,'vrfftb',' ms must be nonzero',ms,0)
      endif
c
      if (n .ne. 1) then
        call getmem(mdimr*n,irt)  !   allocate work array rt(mdimr,n)
        call vrftb1 (mi,mf,ms,n,r,bl(irt),mdimr,wsave(1),wsave(n+1))
        call retmem(1)            !   deallocate rt
      endif
c
      end
c======================================================================

      subroutine zfftf (n,c,wsave)
c
c subroutine zfftf computes the forward complex discrete fourier
c transform (the fourier analysis). equivalently , zfftf computes
c the fourier coefficients of a complex periodic sequence.
c the transform is defined below at output parameter c.
c
c the transform is not normalized. to obtain a normalized transform
c the output must be divided by n. otherwise a call of zfftf
c followed by a call of zfftb will multiply the sequence by n.
c
c the array wsave which is used by subroutine zfftf must be
c initialized by calling subroutine vzffti(n,wsave).
c
c input parameters
c
c
c n      the length of the complex sequence c. the method is
c        more efficient when n is the product of small primes. n
c
c c      a complex array of length n which contains the sequence
c
c wsave   a real work array which must be dimensioned at least 2*n+15
c         the wsave array must be initialized by calling subroutine
c         vzffti(n,wsave) and a  different wsave array must be used
c         for each different value of n. this initialization does
c         not have to be repeated so long as n remains unchanged.
c         the same wsave array can be used by zfftf and zfftb.
c
c output parameters
c
c c      for j=1,...,n
c
c            c(j)=the sum from k=1,...,n of
c
c                  c(k)*exp(-i*(j-1)*(k-1)*2*pi/n)
c
c                        where i=sqrt(-1)
c

      use memory

      implicit real*8 (a-h,o-z)
      dimension  c(*),wsave(*)
c     common /big/bl(1000000)
c
      if (n .ne. 1) then
        call getmem(2*n,ict)     ! allocate complex work array ct(n)
        call cfftf1 (n,c,bl(ict),wsave(1),wsave(n+n+1))
        call retmem(1)           ! deallocate ct
      endif
c
      end
c======================================================================

      subroutine zfftb (n,c,wsave)
c
c subroutine zfftb computes the backward complex discrete fourier
c transform (the fourier synthesis). equivalently , zfftb computes
c a complex periodic sequence from its fourier coefficients.
c the transform is defined below at output parameter c.
c
c a call of zfftf followed by a call of zfftb will multiply the
c sequence by n.
c
c the array wsave which is used by subroutine zfftb must be
c initialized by calling subroutine vzffti(n,wsave).
c
c input parameters
c
c
c n      the length of the complex sequence c. the method is
c        more efficient when n is the product of small primes.
c
c c      a complex array of length n which contains the sequence
c
c wsave   a real work array which must be dimensioned at least 2*n+15
c         the wsave array must be initialized by calling subroutine
c         vzffti(n,wsave) and a different wsave array must be used
c         for each different value of n.
c         the same wsave array can be used by zfftf and zfftb.
c
c output parameters
c
c c      for j=1,...,n
c
c            c(j)=the sum from k=1,...,n of
c
c                  c(k)*exp(i*(j-1)*(k-1)*2*pi/n)
c
c                        where i=sqrt(-1)
c

      use memory

      implicit real*8 (a-h,o-z)
      dimension c(*),wsave(*)
c     common /big/bl(1000000)
c
      if (n .ne. 1) then
        call getmem(2*n,ict)  ! allocate complex work array crt(n)
        call cfftb1 (n,c,bl(ict),wsave(1),wsave(n+n+1))
        call retmem(1)        ! deallocate ct
      endif
c
      end
c======================================================================

      subroutine vzfftf (mi,mf,ms,n,r,mdimr,wsave)
c
c vzfftf computes the fourier coefficients of a number of complex
c periodic sequences. the transform is defined below at
c output parameter r.
c
c the transform is not normalized. to obtain a normalized transform
c the output must be divided by n. otherwise a call of vzfftf
c followed by a call of vzfftb will multiply the sequence by n.
c
c the array wsave which is used by subroutine vzfftf must be
c initialized by calling subroutine vzffti(n,wsave).
c
c input parameters
c
c  mi      initial sequence to be transformed
c  mf      final sequence to be transformed
c  ms      step to reach next sequence to be transformed
c
c  n       the length of the sequences to be transformed.  the method
c          is most efficient when n is a product of small primes,
c          however n may be any positive integer.
c
c  r       a complex two-dimensional array of size mdimr * n
c          containing the sequences to be transformed.
c          the sequences are stored in the rows of r.
c          thus, the i-th sequence to be transformed,
c          x(i,j), j=0,1,...,n-1, is stored as
c
c               r(i,j) = x(i,j-1) , j=1, 2, . . . , n.
c
c  mdimr   the row (or first) dimension of the arrays r and rt exactly
c          as they appear in the calling program.  this parameter is
c          used to specify the variable dimension of these arrays.
c
c wsave   a real work array which must be dimensioned at least 2*n+15
c         the wsave array must be initialized by calling subroutine
c         vzffti(n,wsave) and a  different wsave array must be used
c         for each different value of n. this initialization does
c         not have to be repeated so long as n remains unchanged.
c         the same wsave array can be used by vzfftf and vzfftb.
c
c output parameters
c
c r      for each sequence m, and for for j=1,...,n
c
c            r(m,j)=the sum from k=1,...,n of
c
c                  r(m,k)*exp(-i*(j-1)*(k-1)*2*pi/n)
c
c                        where i=sqrt(-1)
c

      use memory

      implicit real*8 (a-h,o-z)
      dimension r(*),wsave(*)
c     common /big/bl(1000000)
c
c  consistency check
c
      if(mi.le.0.or.mf.le.0)then
        call nerror(1,'vzfftf',
     $    ' mi and mf must be positive integers',mi,mf)
      endif
      if(ms.eq.0)then
        call nerror(1,'vzfftb',' ms must be nonzero',ms,0)
      endif
c
      if (n .ne. 1) then
        call getmem(2*mdimr*n,irt) ! allocate complex array rt(mdimr,n)
        call vcftf1 (mi,mf,ms,n,r,bl(irt),mdimr,wsave(1),wsave(n+n+1))
        call retmem(1)             ! deallocate rt
      endif
c
      end
c======================================================================

      subroutine vzfftb (mi,mf,ms,n,r,mdimr,wsave)
c
c vzfftb computes a number of complex periodic sequences from
c their fourier coefficients.
c the transform is defined below at output parameter r.
c
c a call of vzfftf followed by a call of vzfftb will multiply the
c sequences by n.
c
c the array wsave which is used by subroutine zfftb must be
c initialized by calling subroutine vzffti(n,wsave).
c
c input parameters
c
c  mi      initial sequence to be transformed
c  mf      final sequence to be transformed
c  ms      step to reach next sequence to be transformed
c
c  n       the length of the sequences to be transformed.  the method
c          is most efficient when n is a product of small primes,
c          however n may be any positive integer.
c
c  r       a complex two-dimensional array of size mdimr * n
c          containing the sequences to be transformed.
c          the sequences are stored in the rows of r.
c          thus, the i-th sequence to be transformed,
c          x(i,j), j=0,1,...,n-1, is stored as
c
c               r(i,j) = x(i,j-1) , j=1, 2, . . . , n.
c
c  mdimr   the row (or first) dimension of the arrays r and rt exactly
c          as they appear in the calling program.  this parameter is
c          used to specify the variable dimension of these arrays.
c
c wsave   a real work array which must be dimensioned at least 2*n+15
c         the wsave array must be initialized by calling subroutine
c         vzffti(n,wsave) and a  different wsave array must be used
c         for each different value of n. this initialization does
c         not have to be repeated so long as n remains unchanged.
c         the same wsave array can be used by vzfftf and vzfftb.
c
c output parameters
c
c r      for each sequence m, and for for j=1,...,n
c
c            r(m,j)=the sum from k=1,...,n of
c
c                  r(m,k)*exp(i*(j-1)*(k-1)*2*pi/n)
c
c                        where i=sqrt(-1)
c

      use memory

      implicit real*8 (a-h,o-z)
      dimension  r(*),wsave(*)
c     common /big/bl(1000000)
c
c  consistency check
c
      if(mi.le.0.or.mf.le.0)then
        call nerror(1,'vzfftb',
     $    ' mi and mf must be positive integers',mi,mf)
      endif
      if(ms.eq.0)then
        call nerror(1,'vzfftb',' ms must be nonzero',ms,0)
      endif
c
      if (n .ne. 1) then
        call getmem(2*mdimr*n,irt) ! allocate complex array rt(mdimr,n)
        call vcftb1 (mi,mf,ms,n,r,bl(irt),mdimr,wsave(1),wsave(n+n+1))
        call retmem(1)             ! deallocate rt
      endif
c
      end
c======================================================================

      subroutine vrffti (n,wsave)
c
c  subroutine vrffti initializes the array wsave which is used
c  for transforming real periodic sequences.
c  the prime factorization of n together with a tabulation
c  of certain trigonometric functions are computed and stored
c  in the array wsave.
c
c  input parameter
c
c  n       the length of the sequence to be transformed.  there is no
c          restriction on n.
c
c  output parameter
c
c  wsave   a work array which must be dimensioned at least n+15.
c          the same work array can be used for dfftf, dfftb, vrfftf
c          and vrfftb as long as n remains unchanged.
c          different wsave arrays are required for different
c          values of n.  the contents of wsave must not be changed
c          between calls of dfftf, dfftb, vrfftf or vrfftb.
c
c***references  p. n. swarztrauber, vectorizing the ffts, in parallel
c               computations, (g. rodrigue, ed.), academic press, 1982,
c               pp. 51-83.
c     vrfftpk, version 1, august 1985
c
      implicit real*8 (a-h,o-z)
      dimension       wsave(*)
c
      if (n .ne. 1) then
        call rffti1(n,wsave(1),wsave(n+1))
      endif
c
      end
c======================================================================

      subroutine vzffti (n,wsave)
c
c  subroutine vzffti initializes the array wsave which is used
c  for transforming complex periodic sequences.
c  the prime factorization of n together with a tabulation
c  of certain trigonometric functions are computed and stored
c  in the array wsave.
c
c  input parameter
c
c  n       the length of the sequence to be transformed.  there is no
c          restriction on n.
c
c  output parameter
c
c  wsave   a work array which must be dimensioned at least 2*n+15.
c          the same work array can be used for zfftf, zfftb, vzfftf
c          and vzfftb as long as n remains unchanged.
c          different wsave arrays are required for different
c          values of n.  the contents of wsave must not be changed
c          between calls of zfftf, zfftb, vzfftf or vzfftb.
c
c***references  p. n. swarztrauber, vectorizing the ffts, in parallel
c               computations, (g. rodrigue, ed.), academic press, 1982,
c               pp. 51-83.
c     vrfftpk, version 1, august 1985
c
c
      implicit real*8 (a-h,o-z)
      dimension       wsave(*)
c
      if (n .ne. 1) then
        call vrfti1 (n,wsave(1),wsave(n+n+1))
      endif
c
      end
c======================================================================

      subroutine rffti1 (n,wa,ifac)
c
      implicit real*8 (a-h,o-z)
      dimension wa(*),ifac(*),ntryh(4)
      data ntryh(1),ntryh(2),ntryh(3),ntryh(4)/4,2,3,5/
      parameter (tpi = 6.28318530717958647692d0) ! 2 * %pi
c
      nl = n
      nf = 0
      j = 0
      ntry = 0       ! WARNING - added by JB as flagged as "undefined"
      call izeroit(ifac,15)
c
c  factorization loop
c
  101 j = j+1
        if (j.le.4) then
          ntry = ntryh(j)
        else
          ntry = ntry+2
        endif
  104   nq = nl/ntry
          nr = nl-ntry*nq
          if (nr.ne.0) goto 101
          nf = nf+1
          ifac(nf+2) = ntry
          nl = nq
          if (ntry.eq.2.and.nf.ne.1) then
            do i=2,nf
              ib = nf-i+2
              ifac(ib+2) = ifac(ib+1)
            enddo
            ifac(3) = 2
          endif
        if (nl .ne. 1) go to 104
c
      ifac(1) = n
      ifac(2) = nf
      argh = tpi/float(n)
      is = 0
      nfm1 = nf-1
      l1 = 1
c
c  compute trigonometric constants
c
      if (nfm1 .ne. 0) then
        do k1=1,nfm1
          ip = ifac(k1+2)
          ld = 0
          l2 = l1*ip
          ido = n/l2
          ipm = ip-1
          do j=1,ipm
            ld = ld+l1
            i = is
            argld = float(ld)*argh
            fi = 0.0d0
            do ii=3,ido,2
              i = i+2
              fi = fi+1.0d0
              arg = fi*argld
              wa(i-1) = cos(arg)
              wa(i) = sin(arg)
            enddo
            is = is+ido
          enddo
          l1 = l2
        enddo
      endif
c
      end
c======================================================================

      subroutine vrfti1 (n,wa,ifac)
c
      implicit real*8 (a-h,o-z)
      dimension wa(*),ifac(*),ntryh(4)
      data ntryh(1),ntryh(2),ntryh(3),ntryh(4)/3,4,2,5/
      parameter (tpi = 6.28318530717958647692d0) ! 2 * %pi
c
      nl = n
      nf = 0
      j = 0
      ntry = 0       ! WARNING - added by JB as flagged as "undefined"
c
c  factorization loop
c
  101 j = j+1
        if (j.le.4) then
          ntry = ntryh(j)
        else
          ntry = ntry+2
        endif
  104   nq = nl/ntry
          nr = nl-ntry*nq
          if (nr.ne.0) goto 101
          nf = nf+1
          ifac(nf+2) = ntry
          nl = nq
          if (ntry .eq. 2.and. nf.ne. 1) then
            do i=2,nf
              ib = nf-i+2
              ifac(ib+2) = ifac(ib+1)
            enddo
            ifac(3) = 2
          endif
        if (nl .ne. 1) go to 104
c
      ifac(1) = n
      ifac(2) = nf
      argh = tpi/float(n)
      i = 2
      l1 = 1
c
c  compute trigonometric constants
c
      do k1=1,nf
        ip = ifac(k1+2)
        ld = 0
        l2 = l1*ip
        ido = n/l2
        idot = ido+ido+2
        ipm = ip-1
        do j=1,ipm
          i1 = i
          wa(i-1) = 1.0d0
          wa(i) = 0.0d0
          ld = ld+l1
          fi = 0.0d0
          argld = float(ld)*argh
          do ii=4,idot,2
            i = i+2
            fi = fi+1.d0
            arg = fi*argld
            wa(i-1) = cos(arg)
            wa(i) = sin(arg)
          enddo
          if (ip .gt. 5) then
            wa(i1-1) = wa(i-1)
            wa(i1) = wa(i)
          endif
        enddo
        l1 = l2
      enddo
c
      end
c======================================================================

      subroutine rfftf1 (n,c,ch,wa,ifac)
c
      implicit real*8 (a-h,o-z)
      dimension ch(*),c(*),wa(*),ifac(*)
c
      nf = ifac(2)
      na = 1
      l2 = n
      iw = n
      do k1=1,nf
        kh = nf-k1
        ip = ifac(kh+3)
        l1 = l2/ip
        ido = n/l2
        idl1 = ido*l1
        iw = iw-(ip-1)*ido
        na = 1-na
        if (ip .eq. 4) then
          ix2 = iw+ido
          ix3 = ix2+ido
          if (na .eq. 0) then
            call radf4 (ido,l1,c,ch,wa(iw),wa(ix2),wa(ix3))
          else
            call radf4 (ido,l1,ch,c,wa(iw),wa(ix2),wa(ix3))
          endif
        else if (ip .eq. 2) then
          if (na .eq. 0) then
            call radf2 (ido,l1,c,ch,wa(iw))
          else
            call radf2 (ido,l1,ch,c,wa(iw))
          endif
        else if (ip .eq. 3) then
          ix2 = iw+ido
          if (na .eq. 0) then
            call radf3 (ido,l1,c,ch,wa(iw),wa(ix2))
          else
            call radf3 (ido,l1,ch,c,wa(iw),wa(ix2))
          endif
        else if (ip .eq. 5) then
          ix2 = iw+ido
          ix3 = ix2+ido
          ix4 = ix3+ido
          if (na .eq. 0) then
            call radf5 (ido,l1,c,ch,wa(iw),wa(ix2),wa(ix3),wa(ix4))
          else
            call radf5 (ido,l1,ch,c,wa(iw),wa(ix2),wa(ix3),wa(ix4))
          endif
        else
          if (ido .eq. 1) na = 1-na
          if (na .eq. 0) then
            call radfg (ido,ip,l1,idl1,c,c,c,ch,ch,wa(iw))
            na = 1
          else
            call radfg (ido,ip,l1,idl1,ch,ch,ch,c,c,wa(iw))
            na = 0
          endif
        endif
        l2 = l1
      enddo
c
      if (na .eq. 0) then
        do i=1,n
          c(i) = ch(i)
        enddo
      endif
c
      end
c======================================================================

      subroutine rfftb1 (n,c,ch,wa,ifac)
c
      implicit real*8 (a-h,o-z)
      dimension ch(*),c(*),wa(*),ifac(*)
c
      nf = ifac(2)
      na = 0
      l1 = 1
      iw = 1
      do k1=1,nf
        ip = ifac(k1+2)
        l2 = ip*l1
        ido = n/l2
        idl1 = ido*l1
        if (ip .eq. 4) then
          ix2 = iw+ido
          ix3 = ix2+ido
          if (na .eq. 0) then
            call radb4 (ido,l1,c,ch,wa(iw),wa(ix2),wa(ix3))
          else
            call radb4 (ido,l1,ch,c,wa(iw),wa(ix2),wa(ix3))
          endif
          na = 1-na
        else if (ip .eq. 2) then
          if (na .eq. 0) then
            call radb2 (ido,l1,c,ch,wa(iw))
          else
            call radb2 (ido,l1,ch,c,wa(iw))
          endif
          na = 1-na
        else if (ip .eq. 3) then
          ix2 = iw+ido
          if (na .eq. 0) then
            call radb3 (ido,l1,c,ch,wa(iw),wa(ix2))
          else
            call radb3 (ido,l1,ch,c,wa(iw),wa(ix2))
          endif
          na = 1-na
        else if (ip .eq. 5) then
          ix2 = iw+ido
          ix3 = ix2+ido
          ix4 = ix3+ido
          if (na .eq. 0) then
            call radb5 (ido,l1,c,ch,wa(iw),wa(ix2),wa(ix3),wa(ix4))
          else
            call radb5 (ido,l1,ch,c,wa(iw),wa(ix2),wa(ix3),wa(ix4))
          endif
          na = 1-na
        else
          if (na .eq. 0) then
            call radbg (ido,ip,l1,idl1,c,c,c,ch,ch,wa(iw))
          else
            call radbg (ido,ip,l1,idl1,ch,ch,ch,c,c,wa(iw))
          endif
          if (ido .eq. 1) na = 1-na
        endif
        l1 = l2
        iw = iw+(ip-1)*ido
      enddo
c
      if (na .ne. 0) then
        do i=1,n
          c(i) = ch(i)
        enddo
      endif
c
      end
c======================================================================

      subroutine vrftf1 (mi,mf,ms,n,c,ch,mdimc,wa,ifac)
c
      implicit real*8 (a-h,o-z)
      dimension ch(mdimc,*),c(mdimc,*),wa(*),ifac(*)
c
      nf = ifac(2)
      na = 1
      l2 = n
      iw = n
      do k1=1,nf
        kh = nf-k1
        ip = ifac(kh+3)
        l1 = l2/ip
        ido = n/l2
        idl1 = ido*l1
        iw = iw-(ip-1)*ido
        na = 1-na
        if (ip .eq. 4) then
          ix2 = iw+ido
          ix3 = ix2+ido
          if (na .eq. 0) then
            call vradf4 (mi,mf,ms,ido,l1,c,ch,mdimc,
     &                   wa(iw),wa(ix2),wa(ix3))
          else
            call vradf4 (mi,mf,ms,ido,l1,ch,c,mdimc,
     &                   wa(iw),wa(ix2),wa(ix3))
          endif
        else if (ip .eq. 2) then
          if (na .eq. 0) then
            call vradf2 (mi,mf,ms,ido,l1,c,ch,mdimc,wa(iw))
          else
            call vradf2 (mi,mf,ms,ido,l1,ch,c,mdimc,wa(iw))
          endif
        else if (ip .eq. 3) then
          ix2 = iw+ido
          if (na .eq. 0) then
            call vradf3 (mi,mf,ms,ido,l1,c,ch,mdimc,wa(iw),wa(ix2))
          else
            call vradf3 (mi,mf,ms,ido,l1,ch,c,mdimc,wa(iw),wa(ix2))
          endif
        else if (ip .eq. 5) then
          ix2 = iw+ido
          ix3 = ix2+ido
          ix4 = ix3+ido
          if (na .eq. 0) then
            call vradf5(mi,mf,ms,ido,l1,c,ch,mdimc,
     &                  wa(iw),wa(ix2),wa(ix3),wa(ix4))
          else
            call vradf5(mi,mf,ms,ido,l1,ch,c,mdimc,
     &                  wa(iw),wa(ix2),wa(ix3),wa(ix4))
          endif
        else
          if (ido .eq. 1) na = 1-na
          if (na .eq. 0)then
            call vradfg (mi,mf,ms,ido,ip,l1,idl1,c,c,c,ch,ch,mdimc,
     &                   wa(iw))
          na = 1
          else
            call vradfg (mi,mf,ms,ido,ip,l1,idl1,ch,ch,ch,c,c,mdimc,
     &                   wa(iw))
          na = 0
          endif
        endif
        l2 = l1
      enddo
c
      if (na .eq. 0) then
        do j=1,n
          do i=mi,mf,ms
            c(i,j) = ch(i,j)
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine vrftb1 (mi,mf,ms,n,c,ch,mdimc,wa,ifac)
c
c     vrfftpk, version 1, august 1985
c
      implicit real*8 (a-h,o-z)
      dimension ch(mdimc,n),c(mdimc,n),wa(n),ifac(15)
c
cc      write(6,*) ' in <vrftb1>  mi:',mi,' mf:',mf,' ms:',ms,'n:',n
cc      write(6,*) ' ifac: ',(ifac(i),i=1,15)
      nf = ifac(2)
      na = 0
      l1 = 1
      iw = 1
      do k1=1,nf
        ip = ifac(k1+2)
        l2 = ip*l1
        ido = n/l2
        idl1 = ido*l1
        if (ip .eq. 4) then
          ix2 = iw+ido
          ix3 = ix2+ido
          if (na .eq. 0) then
            call vradb4 (mi,mf,ms,ido,l1,c,ch,mdimc,
     &                   wa(iw),wa(ix2),wa(ix3))
          else
            call vradb4 (mi,mf,ms,ido,l1,ch,c,mdimc,
     &                   wa(iw),wa(ix2),wa(ix3))
          endif
          na = 1-na
        else if (ip .eq. 2) then
          if (na .eq. 0) then
            call vradb2 (mi,mf,ms,ido,l1,c,ch,mdimc,wa(iw))
          else
            call vradb2 (mi,mf,ms,ido,l1,ch,c,mdimc,wa(iw))
          endif
          na = 1-na
        else if (ip .eq. 3) then
          ix2 = iw+ido
          if (na .eq. 0) then
            call vradb3 (mi,mf,ms,ido,l1,c,ch,mdimc,wa(iw),wa(ix2))
          else
            call vradb3 (mi,mf,ms,ido,l1,ch,c,mdimc,wa(iw),wa(ix2))
          endif
          na = 1-na
        else if (ip .eq. 5) then
          ix2 = iw+ido
          ix3 = ix2+ido
          ix4 = ix3+ido
          if (na .eq. 0) then
            call vradb5 (mi,mf,ms,ido,l1,c,ch,mdimc,wa(iw),
     &                   wa(ix2),wa(ix3),wa(ix4))
          else
            call vradb5 (mi,mf,ms,ido,l1,ch,c,mdimc,wa(iw),
     &                   wa(ix2),wa(ix3),wa(ix4))
          endif
          na = 1-na
        else
          if (na .eq. 0) then
            call vradbg (mi,mf,ms,ido,ip,l1,idl1,c,c,c,ch,ch,mdimc,
     &                   wa(iw))
          else
            call vradbg (mi,mf,ms,ido,ip,l1,idl1,ch,ch,ch,c,c,mdimc,
     &                   wa(iw))
          endif
          if (ido .eq. 1) na = 1-na
        endif
        l1 = l2
        iw = iw+(ip-1)*ido
      enddo
c
      if (na .ne. 0) then
        do j=1,n
          do i=mi,mf,ms
            c(i,j) = ch(i,j)
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine cfftf1 (n,c,ch,wa,ifac)
c
      implicit real*8 (a-h,o-z)
      dimension ch(*),c(*),wa(*),ifac(*)
c
      nf = ifac(2)
      na = 0
      l1 = 1
      iw = 1
      do k1=1,nf
        ip = ifac(k1+2)
        l2 = ip*l1
        ido = n/l2
        idot = ido+ido
        idl1 = idot*l1
        if (ip .eq. 4) then
          ix2 = iw+idot
          ix3 = ix2+idot
          if (na .eq. 0) then
            call passf4 (idot,l1,c,ch,wa(iw),wa(ix2),wa(ix3))
          else
            call passf4 (idot,l1,ch,c,wa(iw),wa(ix2),wa(ix3))
          endif
          na = 1-na
        else if (ip .eq. 2) then
          if (na .eq. 0) then
            call passf2 (idot,l1,c,ch,wa(iw))
          else
            call passf2 (idot,l1,ch,c,wa(iw))
          endif
          na = 1-na
        else if (ip .eq. 3) then
          ix2 = iw+idot
          if (na .eq. 0) then
            call passf3 (idot,l1,c,ch,wa(iw),wa(ix2))
          else
            call passf3 (idot,l1,ch,c,wa(iw),wa(ix2))
          endif
          na = 1-na
        else if (ip .eq. 5) then
          ix2 = iw+idot
          ix3 = ix2+idot
          ix4 = ix3+idot
          if (na .eq. 0) then
            call passf5 (idot,l1,c,ch,wa(iw),wa(ix2),wa(ix3),wa(ix4))
          else
            call passf5 (idot,l1,ch,c,wa(iw),wa(ix2),wa(ix3),wa(ix4))
          endif
          na = 1-na
        else
          if (na .eq. 0) then
            call passf (nac,idot,ip,l1,idl1,c,c,c,ch,ch,wa(iw))
          else
            call passf (nac,idot,ip,l1,idl1,ch,ch,ch,c,c,wa(iw))
          endif
          if (nac .ne. 0) na = 1-na
        endif
        l1 = l2
        iw = iw+(ip-1)*idot
      enddo
c
      if (na .ne. 0) then
        n2 = n+n
        do i=1,n2
          c(i) = ch(i)
        enddo
      endif
c
      end
c======================================================================

      subroutine cfftb1 (n,c,ch,wa,ifac)
c
      implicit real*8 (a-h,o-z)
      dimension ch(*),c(*),wa(*),ifac(*)
c
      nf = ifac(2)
      na = 0
      l1 = 1
      iw = 1
      do k1=1,nf
        ip = ifac(k1+2)
        l2 = ip*l1
        ido = n/l2
        idot = ido+ido
        idl1 = idot*l1
        if (ip .eq. 4) then
          ix2 = iw+idot
          ix3 = ix2+idot
          if (na .eq. 0) then
            call passb4 (idot,l1,c,ch,wa(iw),wa(ix2),wa(ix3))
          else
            call passb4 (idot,l1,ch,c,wa(iw),wa(ix2),wa(ix3))
          endif
          na = 1-na
        else if (ip .eq. 2) then
          if (na .eq. 0) then
            call passb2 (idot,l1,c,ch,wa(iw))
          else
            call passb2 (idot,l1,ch,c,wa(iw))
          endif
          na = 1-na
        else if (ip .eq. 3) then
          ix2 = iw+idot
          if (na .eq. 0) then
            call passb3 (idot,l1,c,ch,wa(iw),wa(ix2))
          else
            call passb3 (idot,l1,ch,c,wa(iw),wa(ix2))
          endif
          na = 1-na
        else if (ip .eq. 5) then
          ix2 = iw+idot
          ix3 = ix2+idot
          ix4 = ix3+idot
          if (na .eq. 0) then
            call passb5 (idot,l1,c,ch,wa(iw),wa(ix2),wa(ix3),wa(ix4))
          else
            call passb5 (idot,l1,ch,c,wa(iw),wa(ix2),wa(ix3),wa(ix4))
          endif
          na = 1-na
        else
          if (na .eq. 0) then
            call passb (nac,idot,ip,l1,idl1,c,c,c,ch,ch,wa(iw))
          else
            call passb (nac,idot,ip,l1,idl1,ch,ch,ch,c,c,wa(iw))
          endif
          if (nac .ne. 0) na = 1-na
        endif
        l1 = l2
        iw = iw+(ip-1)*idot
      enddo
c
      if (na .ne. 0) then
        n2 = n+n
        do i=1,n2
          c(i) = ch(i)
        enddo
      endif
c
      end
c======================================================================

      subroutine vcftf1 (mi,mf,ms,n,c,ch,mdimc,wa,ifac)
c
      implicit real*8 (a-h,o-z)
      dimension  ch(2,mdimc,*),c(2,mdimc,*),wa(*),ifac(15)
c
      nf = ifac(2)
      na = 0
      l1 = 1
      iw = 1
      do k1=1,nf
        ip = ifac(k1+2)
        l2 = ip*l1
        ido = n/l2
        idot = ido+ido
        idl1 = ido*l1
        if (ip .eq. 4) then
          ix2 = iw+idot
          ix3 = ix2+idot
          if (na .eq. 0) then
            call vpassf4 (mi,mf,ms,ido,l1,c,ch,mdimc,
     &                    wa(iw),wa(ix2),wa(ix3))
          else
            call vpassf4 (mi,mf,ms,ido,l1,ch,c,mdimc,
     &                    wa(iw),wa(ix2),wa(ix3))
          endif
          na = 1-na
        else if (ip .eq. 2) then
          if (na .eq. 0) then
            call vpassf2 (mi,mf,ms,ido,l1,c,ch,mdimc,wa(iw))
          else
            call vpassf2 (mi,mf,ms,ido,l1,ch,c,mdimc,wa(iw))
          endif
          na = 1-na
        else if (ip .eq. 3) then
          ix2 = iw+idot
          if (na .eq. 0) then
            call vpassf3 (mi,mf,ms,ido,l1,c,ch,mdimc,wa(iw),wa(ix2))
          else
            call vpassf3 (mi,mf,ms,ido,l1,ch,c,mdimc,wa(iw),wa(ix2))
          endif
          na = 1-na
        else if (ip .eq. 5) then
          ix2 = iw+idot
          ix3 = ix2+idot
          ix4 = ix3+idot
          if (na .eq. 0) then
            call vpassf5 (mi,mf,ms,ido,l1,c,ch,mdimc,
     &                    wa(iw),wa(ix2),wa(ix3),wa(ix4))
          else
            call vpassf5 (mi,mf,ms,ido,l1,ch,c,mdimc,
     &                    wa(iw),wa(ix2),wa(ix3),wa(ix4))
          endif
          na = 1-na
        else
          if (na .eq. 0) then
            call vpassf(nac,mi,mf,ms,ido,ip,l1,idl1,c,c,c,ch,ch,mdimc,
     &                    wa(iw))
          else
            call vpassf(nac,mi,mf,ms,ido,ip,l1,idl1,ch,ch,ch,c,c,mdimc,
     &                    wa(iw))
          endif
          if (nac .ne. 0) na = 1-na
        endif
        l1 = l2
        iw = iw+(ip-1)*idot
      enddo
c
      if (na .ne. 0) then
        do i=1,n
          do im=mi,mf,ms
            c(1,im,i) = ch(1,im,i)
            c(2,im,i) = ch(2,im,i)
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine vcftb1 (mi,mf,ms,n,c,ch,mdimc,wa,ifac)
c
      implicit real*8 (a-h,o-z)
      dimension  ch(2,mdimc,*),c(2,mdimc,*),wa(*),ifac(15)
c
      nf = ifac(2)
      na = 0
      l1 = 1
      iw = 1
      do k1=1,nf
        ip = ifac(k1+2)
        l2 = ip*l1
        ido = n/l2
        idot = ido+ido
        idl1 = ido*l1
        if (ip .eq. 4) then
          ix2 = iw+idot
          ix3 = ix2+idot
          if (na .eq. 0) then
            call vpassb4 (mi,mf,ms,ido,l1,c,ch,mdimc,
     &                    wa(iw),wa(ix2),wa(ix3))
          else
            call vpassb4 (mi,mf,ms,ido,l1,ch,c,mdimc,
     &                    wa(iw),wa(ix2),wa(ix3))
          endif
          na = 1-na
        else if (ip .eq. 2) then
          if (na .eq. 0) then
            call vpassb2 (mi,mf,ms,ido,l1,c,ch,mdimc,wa(iw))
          else
            call vpassb2 (mi,mf,ms,ido,l1,ch,c,mdimc,wa(iw))
          endif
          na = 1-na
        else if (ip .eq. 3) then
          ix2 = iw+idot
          if (na .eq. 0) then
            call vpassb3 (mi,mf,ms,ido,l1,c,ch,mdimc,wa(iw),wa(ix2))
          else
            call vpassb3 (mi,mf,ms,ido,l1,ch,c,mdimc,wa(iw),wa(ix2))
          endif
          na = 1-na
        else if (ip .eq. 5) then
          ix2 = iw+idot
          ix3 = ix2+idot
          ix4 = ix3+idot
          if (na .eq. 0) then
            call vpassb5 (mi,mf,ms,ido,l1,c,ch,mdimc,
     &                    wa(iw),wa(ix2),wa(ix3),wa(ix4))
          else
            call vpassb5 (mi,mf,ms,ido,l1,ch,c,mdimc,
     &                    wa(iw),wa(ix2),wa(ix3),wa(ix4))
          endif
          na = 1-na
        else
          if (na .eq. 0) then
            call vpassb (nac,mi,mf,ms,ido,ip,l1,idl1,c,c,c,ch,ch,mdimc,
     &                    wa(iw))
          else
            call vpassb (nac,mi,mf,ms,ido,ip,l1,idl1,ch,ch,ch,c,c,mdimc,
     &                    wa(iw))
          endif
          if (nac .ne. 0) na = 1-na
        endif
        l1 = l2
        iw = iw+(ip-1)*idot
      enddo
c
      if (na .ne. 0) then
        do i=1,n
          do im=mi,mf,ms
            c(1,im,i) = ch(1,im,i)
            c(2,im,i) = ch(2,im,i)
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine radb2 (ido,l1,cc,ch,wa1)
c
      implicit real*8 (a-h,o-z)
      dimension cc(ido,2,l1),ch(ido,l1,2),wa1(1)
c
      do k=1,l1
        ch(1,k,1) = cc(1,1,k) + cc(ido,2,k)
        ch(1,k,2) = cc(1,1,k) - cc(ido,2,k)
      enddo
c
      if (ido.gt.2) then
        idp2 = ido+2
        do k=1,l1
          do i=3,ido,2
            ic = idp2-i
            ch(i-1,k,1) = cc(i-1,1,k) + cc(ic-1,2,k)
            tr2 = cc(i-1,1,k) - cc(ic-1,2,k)
            ch(i,k,1) = cc(i,1,k) - cc(ic,2,k)
            ti2 = cc(i,1,k) + cc(ic,2,k)
            ch(i-1,k,2) = wa1(i-2) * tr2 - wa1(i-1) * ti2
            ch(i,k,2)   = wa1(i-2) * ti2 + wa1(i-1) * tr2
          enddo
        enddo
      endif
c
      if (ido.gt.1.and.mod(ido,2) .ne. 1) then
        do k=1,l1
          ch(ido,k,1) =   cc(ido,1,k) + cc(ido,1,k)
          ch(ido,k,2) = -(cc(1,2,k)   + cc(1,2,k))
        enddo
      endif
c
      end
c======================================================================

      subroutine radb3 (ido,l1,cc,ch,wa1,wa2)
c
      implicit real*8 (a-h,o-z)
      dimension cc(ido,3,l1),ch(ido,l1,3),wa1(1),wa2(1)
c     *** taui is sqrt(3)/2 ***
      parameter (taur=-0.5d0,taui=0.86602540378443864676d0)
c
      do k=1,l1
        tr2 = cc(ido,2,k) + cc(ido,2,k)
        cr2 = cc(1,1,k)   + taur*tr2
        ch(1,k,1) = cc(1,1,k) + tr2
        ci3 = taui * (cc(1,3,k) + cc(1,3,k))
        ch(1,k,2) = cr2 - ci3
        ch(1,k,3) = cr2 + ci3
      enddo
c
      if (ido .ne. 1) then
        idp2 = ido+2
        do k=1,l1
          do i=3,ido,2
            ic = idp2-i
            tr2 = cc(i-1,3,k) + cc(ic-1,2,k)
            cr2 = cc(i-1,1,k) + taur*tr2
            ch(i-1,k,1) = cc(i-1,1,k) + tr2
            ti2 = cc(i,3,k) - cc(ic,2,k)
            ci2 = cc(i,1,k) + taur * ti2
            ch(i,k,1) = cc(i,1,k) + ti2
            cr3 = taui * (cc(i-1,3,k) - cc(ic-1,2,k))
            ci3 = taui * (cc(i,3,k)   + cc(ic,2,k))
            dr2 = cr2 - ci3
            dr3 = cr2 + ci3
            di2 = ci2 + cr3
            di3 = ci2 - cr3
            ch(i-1,k,2) = wa1(i-2) * dr2 - wa1(i-1) * di2
            ch(i,k,2)   = wa1(i-2) * di2 + wa1(i-1) * dr2
            ch(i-1,k,3) = wa2(i-2) * dr3 - wa2(i-1) * di3
            ch(i,k,3)   = wa2(i-2) * di3 + wa2(i-1) * dr3
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine radb4 (ido,l1,cc,ch,wa1,wa2,wa3)
c
      implicit real*8 (a-h,o-z)
      dimension cc(ido,4,l1),ch(ido,l1,4),wa1(1),wa2(1),wa3(1)
      parameter (sqrt2=1.41421356237309504880d0)
c
      do k=1,l1
        tr1 = cc(1,1,k)   - cc(ido,4,k)
        tr2 = cc(1,1,k)   + cc(ido,4,k)
        tr3 = cc(ido,2,k) + cc(ido,2,k)
        tr4 = cc(1,3,k)   + cc(1,3,k)
        ch(1,k,1) = tr2 + tr3
        ch(1,k,2) = tr1 - tr4
        ch(1,k,3) = tr2 - tr3
        ch(1,k,4) = tr1 + tr4
      enddo
c
      if (ido.gt.2) then
        idp2 = ido+2
        do k=1,l1
          do i=3,ido,2
            ic = idp2-i
            ti1 = cc(i,1,k)   + cc(ic,4,k)
            ti2 = cc(i,1,k)   - cc(ic,4,k)
            ti3 = cc(i,3,k)   - cc(ic,2,k)
            tr4 = cc(i,3,k)   + cc(ic,2,k)
            tr1 = cc(i-1,1,k) - cc(ic-1,4,k)
            tr2 = cc(i-1,1,k) + cc(ic-1,4,k)
            ti4 = cc(i-1,3,k) - cc(ic-1,2,k)
            tr3 = cc(i-1,3,k) + cc(ic-1,2,k)
            ch(i-1,k,1) = tr2 + tr3
            cr3 = tr2 - tr3
            ch(i,k,1)   = ti2 + ti3
            ci3 = ti2 - ti3
            cr2 = tr1 - tr4
            cr4 = tr1 + tr4
            ci2 = ti1 + ti4
            ci4 = ti1 - ti4
            ch(i-1,k,2) = wa1(i-2) * cr2 - wa1(i-1) * ci2
            ch(i,k,2)   = wa1(i-2) * ci2 + wa1(i-1) * cr2
            ch(i-1,k,3) = wa2(i-2) * cr3 - wa2(i-1) * ci3
            ch(i,k,3)   = wa2(i-2) * ci3 + wa2(i-1) * cr3
            ch(i-1,k,4) = wa3(i-2) * cr4 - wa3(i-1) * ci4
            ch(i,k,4)   = wa3(i-2) * ci4 + wa3(i-1) * cr4
          enddo
        enddo
      endif
c
      if (ido.gt.1.and.mod(ido,2) .ne. 1) then
        do k=1,l1
          ti1 = cc(1,2,k)   + cc(1,4,k)
          ti2 = cc(1,4,k)   - cc(1,2,k)
          tr1 = cc(ido,1,k) - cc(ido,3,k)
          tr2 = cc(ido,1,k) + cc(ido,3,k)
          ch(ido,k,1) = tr2 + tr2
          ch(ido,k,2) =  sqrt2 * (tr1 - ti1)
          ch(ido,k,3) = ti2 + ti2
          ch(ido,k,4) = -sqrt2 * (tr1 + ti1)
        enddo
      endif
c
      end
c======================================================================

      subroutine radb5 (ido,l1,cc,ch,wa1,wa2,wa3,wa4)
c
      implicit real*8 (a-h,o-z)
      dimension cc(ido,5,l1),ch(ido,l1,5),wa1(1),wa2(1),wa3(1),wa4(1)
c     *** tr11=cos(2*pi/5), ti11=sin(2*pi/5)
c     *** tr12=cos(4*pi/5), ti12=sin(4*pi/5)
      parameter (tr11 =  0.3090169943749474241d0,
     &           ti11 =  0.95105651629515357212d0,
     &           tr12 = -0.8090169943749474241d0,
     &           ti12 =  0.58778525229247312917d0)
c
      do k=1,l1
        ti5 = cc(1,3,k)   + cc(1,3,k)
        ti4 = cc(1,5,k)   + cc(1,5,k)
        tr2 = cc(ido,2,k) + cc(ido,2,k)
        tr3 = cc(ido,4,k) + cc(ido,4,k)
        ch(1,k,1) = cc(1,1,k) + tr2 + tr3
        cr2 = cc(1,1,k) + tr11 * tr2 + tr12 * tr3
        cr3 = cc(1,1,k) + tr12 * tr2 + tr11 * tr3
        ci5 =             ti11 * ti5 + ti12 * ti4
        ci4 =             ti12 * ti5 - ti11 * ti4
        ch(1,k,2) = cr2 - ci5
        ch(1,k,3) = cr3 - ci4
        ch(1,k,4) = cr3 + ci4
        ch(1,k,5) = cr2 + ci5
      enddo
c
      if (ido .ne. 1) then
        idp2 = ido+2
        do k=1,l1
          do i=3,ido,2
            ic = idp2-i
            ti5 = cc(i,3,k)   + cc(ic,2,k)
            ti2 = cc(i,3,k)   - cc(ic,2,k)
            ti4 = cc(i,5,k)   + cc(ic,4,k)
            ti3 = cc(i,5,k)   - cc(ic,4,k)
            tr5 = cc(i-1,3,k) - cc(ic-1,2,k)
            tr2 = cc(i-1,3,k) + cc(ic-1,2,k)
            tr4 = cc(i-1,5,k) - cc(ic-1,4,k)
            tr3 = cc(i-1,5,k) + cc(ic-1,4,k)
            ch(i-1,k,1) = cc(i-1,1,k) + tr2 + tr3
            ch(i,k,1)   = cc(i,1,k)   + ti2 + ti3
            cr2 = cc(i-1,1,k) + tr11 * tr2 + tr12 * tr3
            ci2 = cc(i,1,k)   + tr11 * ti2 + tr12 * ti3
            cr3 = cc(i-1,1,k) + tr12 * tr2 + tr11 * tr3
            ci3 = cc(i,1,k)   + tr12 * ti2 + tr11 * ti3
            cr5 =               ti11 * tr5 + ti12 * tr4
            ci5 =               ti11 * ti5 + ti12 * ti4
            cr4 =               ti12 * tr5 - ti11 * tr4
            ci4 =               ti12 * ti5 - ti11 * ti4
            dr3 = cr3 - ci4
            dr4 = cr3 + ci4
            di3 = ci3 + cr4
            di4 = ci3 - cr4
            dr5 = cr2 + ci5
            dr2 = cr2 - ci5
            di5 = ci2 - cr5
            di2 = ci2 + cr5
            ch(i-1,k,2) = wa1(i-2) * dr2 - wa1(i-1) * di2
            ch(i,k,2)   = wa1(i-2) * di2 + wa1(i-1) * dr2
            ch(i-1,k,3) = wa2(i-2) * dr3 - wa2(i-1) * di3
            ch(i,k,3)   = wa2(i-2) * di3 + wa2(i-1) * dr3
            ch(i-1,k,4) = wa3(i-2) * dr4 - wa3(i-1) * di4
            ch(i,k,4)   = wa3(i-2) * di4 + wa3(i-1) * dr4
            ch(i-1,k,5) = wa4(i-2) * dr5 - wa4(i-1) * di5
            ch(i,k,5)   = wa4(i-2) * di5 + wa4(i-1) * dr5
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine radbg (ido,ip,l1,idl1,cc,c1,c2,ch,ch2,wa)
c
      implicit real*8 (a-h,o-z)
      dimension ch(ido,l1,ip),cc(ido,ip,l1),c1(ido,l1,ip),c2(idl1,ip),
     2          ch2(idl1,ip),wa(1)
      parameter (tpi=6.2831853071795864769d0)     !  2 * %pi
c
      arg = tpi/float(ip)
      dcp = cos(arg)
      dsp = sin(arg)
      idp2 = ido+2
      nbd = (ido-1)/2
      ipp2 = ip+2
      ipph = (ip+1)/2
c
      if (ido .ge. l1) then
        do k=1,l1
          do i=1,ido
            ch(i,k,1) = cc(i,1,k)
          enddo
        enddo
      else
        do i=1,ido
          do k=1,l1
            ch(i,k,1) = cc(i,1,k)
          enddo
        enddo
      endif
c
      do j=2,ipph
        jc = ipp2-j
        j2 = j+j
        do k=1,l1
          ch(1,k,j)  = cc(ido,j2-2,k) + cc(ido,j2-2,k)
          ch(1,k,jc) = cc(1,j2-1,k)   + cc(1,j2-1,k)
        enddo
      enddo
c
      if (ido .ne. 1) then
        if (nbd .ge. l1) then
          do j=2,ipph
            jc = ipp2-j
            do k=1,l1
              do i=3,ido,2
                ic = idp2-i
                ch(i-1,k,j)  = cc(i-1,2*j-1,k) + cc(ic-1,2*j-2,k)
                ch(i-1,k,jc) = cc(i-1,2*j-1,k) - cc(ic-1,2*j-2,k)
                ch(i,k,j)    = cc(i,2*j-1,k)   - cc(ic,2*j-2,k)
                ch(i,k,jc)   = cc(i,2*j-1,k)   + cc(ic,2*j-2,k)
              enddo
            enddo
          enddo
        else
          do j=2,ipph
            jc = ipp2-j
            do i=3,ido,2
              ic = idp2-i
              do k=1,l1
                ch(i-1,k,j)  = cc(i-1,2*j-1,k) + cc(ic-1,2*j-2,k)
                ch(i-1,k,jc) = cc(i-1,2*j-1,k) - cc(ic-1,2*j-2,k)
                ch(i,k,j)    = cc(i,2*j-1,k)   - cc(ic,2*j-2,k)
                ch(i,k,jc)   = cc(i,2*j-1,k)   + cc(ic,2*j-2,k)
              enddo
            enddo
          enddo
        endif
      endif
c
      ar1 = 1.0d0
      ai1 = 0.0d0
      do l=2,ipph
        lc = ipp2-l
        ar1h = dcp*ar1-dsp*ai1
        ai1 = dcp*ai1+dsp*ar1
        ar1 = ar1h
        do ik=1,idl1
          c2(ik,l)  = ch2(ik,1) + ar1 * ch2(ik,2)
          c2(ik,lc) =             ai1 * ch2(ik,ip)
        enddo
        dc2 = ar1
        ds2 = ai1
        ar2 = ar1
        ai2 = ai1
        do j=3,ipph
          jc = ipp2-j
          ar2h = dc2*ar2-ds2*ai2
          ai2 = dc2*ai2+ds2*ar2
          ar2 = ar2h
          do ik=1,idl1
            c2(ik,l)  = c2(ik,l)  + ar2 * ch2(ik,j)
            c2(ik,lc) = c2(ik,lc) + ai2 * ch2(ik,jc)
          enddo
        enddo
      enddo
c
      do j=2,ipph
        do ik=1,idl1
          ch2(ik,1) = ch2(ik,1) + ch2(ik,j)
        enddo
      enddo
      do j=2,ipph
        jc = ipp2-j
        do k=1,l1
          ch(1,k,j)  = c1(1,k,j) - c1(1,k,jc)
          ch(1,k,jc) = c1(1,k,j) + c1(1,k,jc)
        enddo
      enddo
c
      if (ido .ne. 1) then
        if (nbd .ge. l1) then
          do j=2,ipph
            jc = ipp2-j
            do k=1,l1
              do i=3,ido,2
                ch(i-1,k,j)  = c1(i-1,k,j) - c1(i,k,jc)
                ch(i-1,k,jc) = c1(i-1,k,j) + c1(i,k,jc)
                ch(i,k,j)    = c1(i,k,j)   + c1(i-1,k,jc)
                ch(i,k,jc)   = c1(i,k,j)   - c1(i-1,k,jc)
              enddo
            enddo
          enddo
        else
          do j=2,ipph
            jc = ipp2-j
            do i=3,ido,2
              do k=1,l1
                ch(i-1,k,j)  = c1(i-1,k,j) - c1(i,k,jc)
                ch(i-1,k,jc) = c1(i-1,k,j) + c1(i,k,jc)
                ch(i,k,j)    = c1(i,k,j)   + c1(i-1,k,jc)
                ch(i,k,jc)   = c1(i,k,j)   - c1(i-1,k,jc)
              enddo
            enddo
          enddo
        endif
        do ik=1,idl1
          c2(ik,1) = ch2(ik,1)
        enddo
        do j=2,ip
          do k=1,l1
            c1(1,k,j) = ch(1,k,j)
          enddo
        enddo
        if (nbd .le. l1) then
          is = -ido
          do j=2,ip
            is = is+ido
            idij = is
            do i=3,ido,2
              idij = idij+2
              do k=1,l1
                c1(i-1,k,j)= wa(idij-1)*ch(i-1,k,j)-wa(idij)*ch(i,k,j)
                c1(i,k,j)  = wa(idij-1)*ch(i,k,j)  +wa(idij)*ch(i-1,k,j)
              enddo
            enddo
          enddo
        else
          is = -ido
          do j=2,ip
            is = is+ido
            do k=1,l1
              idij = is
              do i=3,ido,2
                idij = idij+2
                c1(i-1,k,j)= wa(idij-1)*ch(i-1,k,j)-wa(idij)*ch(i,k,j)
                c1(i,k,j)  = wa(idij-1)*ch(i,k,j)  +wa(idij)*ch(i-1,k,j)
              enddo
            enddo
          enddo
        endif
      endif
c
      end
c======================================================================

      subroutine radf2 (ido,l1,cc,ch,wa1)
c
      implicit  real*8 (a-h,o-z)
      dimension ch(ido,2,l1),cc(ido,l1,2),wa1(1)
c
      do k=1,l1
        ch(1,1,k)   = cc(1,k,1) + cc(1,k,2)
        ch(ido,2,k) = cc(1,k,1) - cc(1,k,2)
      enddo
c
      if (ido.gt.2) then
      idp2 = ido+2
        do k=1,l1
          do i=3,ido,2
            ic = idp2-i
            tr2 = wa1(i-2) * cc(i-1,k,2) + wa1(i-1) * cc(i,k,2)
            ti2 = wa1(i-2) * cc(i,k,2)   - wa1(i-1) * cc(i-1,k,2)
            ch(i,1,k)    =  cc(i,k,1)   + ti2
            ch(ic,2,k)   = -cc(i,k,1)   + ti2
            ch(i-1,1,k)  =  cc(i-1,k,1) + tr2
            ch(ic-1,2,k) =  cc(i-1,k,1) - tr2
          enddo
        enddo
      endif
c
      if (ido.gt.1.and.mod(ido,2) .ne. 1) then
        do k=1,l1
          ch(1,2,k)   = -cc(ido,k,2)
          ch(ido,1,k) =  cc(ido,k,1)
        enddo
      endif
c
      end
c======================================================================

      subroutine radf3 (ido,l1,cc,ch,wa1,wa2)
c
      implicit real*8 (a-h,o-z)
      dimension ch(ido,3,l1),cc(ido,l1,3),wa1(1),wa2(1)
c     *** taui is sqrt(3)/2 ***
      parameter (taur=-0.5d0,taui=0.86602540378443864676d0)
c
      do k=1,l1
        cr2 = cc(1,k,2) + cc(1,k,3)
        ch(1,1,k) = cc(1,k,1) + cr2
        ch(1,3,k) = taui * (cc(1,k,3) - cc(1,k,2))
        ch(ido,2,k) = cc(1,k,1) + taur * cr2
      enddo
c
      if (ido .ne. 1) then
        idp2 = ido+2
        do k=1,l1
          do i=3,ido,2
            ic = idp2-i
            dr2 = wa1(i-2) * cc(i-1,k,2) + wa1(i-1) * cc(i,k,2)
            di2 = wa1(i-2) * cc(i,k,2)   - wa1(i-1) * cc(i-1,k,2)
            dr3 = wa2(i-2) * cc(i-1,k,3) + wa2(i-1) * cc(i,k,3)
            di3 = wa2(i-2) * cc(i,k,3)   - wa2(i-1) * cc(i-1,k,3)
            cr2 = dr2 + dr3
            ci2 = di2 + di3
            ch(i-1,1,k) = cc(i-1,k,1) + cr2
            ch(i,1,k)   = cc(i,k,1)   + ci2
            tr2 = cc(i-1,k,1) + taur * cr2
            ti2 = cc(i,k,1)   + taur * ci2
            tr3 = taui * (di2 - di3)
            ti3 = taui * (dr3 - dr2)
            ch(i-1,3,k)  = tr2 + tr3
            ch(ic-1,2,k) = tr2 - tr3
            ch(i,3,k)    = ti2 + ti3
            ch(ic,2,k)   = ti3 - ti2
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine radf4 (ido,l1,cc,ch,wa1,wa2,wa3)
c
      implicit real*8 (a-h,o-z)
      dimension cc(ido,l1,4),ch(ido,4,l1),wa1(1),wa2(1),wa3(1)
      parameter (hsqt2=7.071067811865475d-1)              ! sqrt(2)/2
c
      do k=1,l1
        tr1 = cc(1,k,2) + cc(1,k,4)
        tr2 = cc(1,k,1) + cc(1,k,3)
        ch(1,1,k)   = tr1 + tr2
        ch(ido,4,k) = tr2 - tr1
        ch(ido,2,k) = cc(1,k,1) - cc(1,k,3)
        ch(1,3,k)   = cc(1,k,4) - cc(1,k,2)
      enddo
c
      if (ido.gt.2) then
        idp2 = ido+2
        do k=1,l1
          do i=3,ido,2
            ic = idp2-i
            cr2 = wa1(i-2) * cc(i-1,k,2) + wa1(i-1) * cc(i,k,2)
            ci2 = wa1(i-2) * cc(i,k,2)   - wa1(i-1) * cc(i-1,k,2)
            cr3 = wa2(i-2) * cc(i-1,k,3) + wa2(i-1) * cc(i,k,3)
            ci3 = wa2(i-2) * cc(i,k,3)   - wa2(i-1) * cc(i-1,k,3)
            cr4 = wa3(i-2) * cc(i-1,k,4) + wa3(i-1) * cc(i,k,4)
            ci4 = wa3(i-2) * cc(i,k,4)   - wa3(i-1) * cc(i-1,k,4)
            tr1 = cr2 + cr4
            tr4 = cr4 - cr2
            ti1 = ci2 + ci4
            ti4 = ci2 - ci4
            ti2 = cc(i,k,1)   + ci3
            ti3 = cc(i,k,1)   - ci3
            tr2 = cc(i-1,k,1) + cr3
            tr3 = cc(i-1,k,1) - cr3
            ch(i-1,1,k)  = tr1 + tr2
            ch(ic-1,4,k) = tr2 - tr1
            ch(i,1,k)    = ti1 + ti2
            ch(ic,4,k)   = ti1 - ti2
            ch(i-1,3,k)  = ti4 + tr3
            ch(ic-1,2,k) = tr3 - ti4
            ch(i,3,k)    = tr4 + ti3
            ch(ic,2,k)   = tr4 - ti3
          enddo
        enddo
      endif
c
      if (ido.gt.1.and.mod(ido,2) .ne. 1) then
        do k=1,l1
          ti1 = -hsqt2 * (cc(ido,k,2) + cc(ido,k,4))
          tr1 =  hsqt2 * (cc(ido,k,2) - cc(ido,k,4))
          ch(ido,1,k) =  tr1 + cc(ido,k,1)
          ch(ido,3,k) = -tr1 + cc(ido,k,1)
          ch(1,2,k)   =  ti1 - cc(ido,k,3)
          ch(1,4,k)   =  ti1 + cc(ido,k,3)
        enddo
      endif
c
      end
c======================================================================

      subroutine radf5 (ido,l1,cc,ch,wa1,wa2,wa3,wa4)
c
      implicit real*8 (a-h,o-z)
      dimension cc(ido,l1,5),ch(ido,5,l1),wa1(1),wa2(1),wa3(1),wa4(1)
      parameter (tr11 =  0.3090169943749474241d0,
     &           ti11 =  0.95105651629515357212d0,
     &           tr12 = -0.8090169943749474241d0,
     &           ti12 =  0.58778525229247312917d0)
c
      do k=1,l1
        cr2 = cc(1,k,5) + cc(1,k,2)
        ci5 = cc(1,k,5) - cc(1,k,2)
        cr3 = cc(1,k,4) + cc(1,k,3)
        ci4 = cc(1,k,4) - cc(1,k,3)
        ch(1,1,k)   = cc(1,k,1) + cr2+ cr3
        ch(ido,2,k) = cc(1,k,1) + tr11 * cr2 + tr12 * cr3
        ch(1,3,k)   = ti11 * ci5 + ti12 * ci4
        ch(ido,4,k) = cc(1,k,1) + tr12 * cr2 + tr11 * cr3
        ch(1,5,k)   = ti12 * ci5 - ti11 * ci4
      enddo
c
      if (ido .ne. 1) then
        idp2 = ido+2
        do k=1,l1
          do i=3,ido,2
            ic = idp2-i
            dr2 = wa1(i-2) * cc(i-1,k,2) + wa1(i-1) * cc(i,k,2)
            di2 = wa1(i-2) * cc(i,k,2)   - wa1(i-1) * cc(i-1,k,2)
            dr3 = wa2(i-2) * cc(i-1,k,3) + wa2(i-1) * cc(i,k,3)
            di3 = wa2(i-2) * cc(i,k,3)   - wa2(i-1) * cc(i-1,k,3)
            dr4 = wa3(i-2) * cc(i-1,k,4) + wa3(i-1) * cc(i,k,4)
            di4 = wa3(i-2) * cc(i,k,4)   - wa3(i-1) * cc(i-1,k,4)
            dr5 = wa4(i-2) * cc(i-1,k,5) + wa4(i-1) * cc(i,k,5)
            di5 = wa4(i-2) * cc(i,k,5)   - wa4(i-1) * cc(i-1,k,5)
            cr2 = dr2 + dr5
            ci5 = dr5 - dr2
            cr5 = di2 - di5
            ci2 = di2 + di5
            cr3 = dr3 + dr4
            ci4 = dr4 - dr3
            cr4 = di3 - di4
            ci3 = di3 + di4
            ch(i-1,1,k) = cc(i-1,k,1) + cr2 + cr3
            ch(i,1,k)   = cc(i,k,1)   + ci2 + ci3
            tr2 = cc(i-1,k,1) + tr11 * cr2 + tr12 * cr3
            ti2 = cc(i,k,1)   + tr11 * ci2 + tr12 * ci3
            tr3 = cc(i-1,k,1) + tr12 * cr2 + tr11 * cr3
            ti3 = cc(i,k,1)   + tr12 * ci2 + tr11 * ci3
            tr5 = ti11 * cr5 + ti12 * cr4
            ti5 = ti11 * ci5 + ti12 * ci4
            tr4 = ti12 * cr5 - ti11 * cr4
            ti4 = ti12 * ci5 - ti11 * ci4
            ch(i-1,3,k)  = tr2 + tr5
            ch(ic-1,2,k) = tr2 - tr5
            ch(i,3,k)    = ti2 + ti5
            ch(ic,2,k)   = ti5 - ti2
            ch(i-1,5,k)  = tr3 + tr4
            ch(ic-1,4,k) = tr3 - tr4
            ch(i,5,k)    = ti3 + ti4
            ch(ic,4,k)   = ti4 - ti3
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine radfg (ido,ip,l1,idl1,cc,c1,c2,ch,ch2,wa)
c
      implicit real*8 (a-h,o-z)
      dimension ch(ido,l1,ip),cc(ido,ip,l1),c1(ido,l1,ip),c2(idl1,ip),
     2          ch2(idl1,ip),wa(1)
      parameter (tpi=6.2831853071795864769d0)     !  2 * %pi
c
      arg = tpi/float(ip)
      dcp = cos(arg)
      dsp = sin(arg)
      ipph = (ip+1)/2
      ipp2 = ip+2
      idp2 = ido+2
      nbd = (ido-1)/2
      if (ido .ne. 1) then
        do ik=1,idl1
          ch2(ik,1) = c2(ik,1)
        enddo
        do j=2,ip
           do k=1,l1
              ch(1,k,j) = c1(1,k,j)
           enddo
        enddo
        if (nbd .le. l1) then
          is = -ido
          do j=2,ip
            is = is+ido
            idij = is
            do i=3,ido,2
              idij = idij+2
              do k=1,l1
                ch(i-1,k,j)= wa(idij-1)*c1(i-1,k,j)+wa(idij)*c1(i,k,j)
                ch(i,k,j)  = wa(idij-1)*c1(i,k,j)  -wa(idij)*c1(i-1,k,j)
              enddo
            enddo
          enddo
        else
          is = -ido
          do j=2,ip
            is = is+ido
            do k=1,l1
              idij = is
              do i=3,ido,2
                idij = idij+2
                ch(i-1,k,j)= wa(idij-1)*c1(i-1,k,j)+wa(idij)*c1(i,k,j)
                ch(i,k,j)  = wa(idij-1)*c1(i,k,j)  -wa(idij)*c1(i-1,k,j)
              enddo
            enddo
          enddo
        endif
        if (nbd .ge. l1) then
          do j=2,ipph
            jc = ipp2-j
            do k=1,l1
              do i=3,ido,2
                c1(i-1,k,j)  = ch(i-1,k,j)  + ch(i-1,k,jc)
                c1(i-1,k,jc) = ch(i,k,j)    - ch(i,k,jc)
                c1(i,k,j)    = ch(i,k,j)    + ch(i,k,jc)
                c1(i,k,jc)   = ch(i-1,k,jc) - ch(i-1,k,j)
              enddo
            enddo
          enddo
        else
          do j=2,ipph
            jc = ipp2-j
            do i=3,ido,2
              do k=1,l1
                c1(i-1,k,j)  = ch(i-1,k,j)  + ch(i-1,k,jc)
                c1(i-1,k,jc) = ch(i,k,j)    - ch(i,k,jc)
                c1(i,k,j)    = ch(i,k,j)    + ch(i,k,jc)
                c1(i,k,jc)   = ch(i-1,k,jc) - ch(i-1,k,j)
                enddo
            enddo
          enddo
        endif
      else
        do ik=1,idl1
          c2(ik,1) = ch2(ik,1)
        enddo
      endif
c
      do j=2,ipph
        jc = ipp2-j
        do k=1,l1
          c1(1,k,j)  = ch(1,k,j)  + ch(1,k,jc)
          c1(1,k,jc) = ch(1,k,jc) - ch(1,k,j)
        enddo
      enddo
c
      ar1 = 1.0d0
      ai1 = 0.0d0
      do l=2,ipph
        lc = ipp2-l
        ar1h = dcp * ar1 - dsp * ai1
        ai1  = dcp * ai1 + dsp * ar1
        ar1  = ar1h
        do ik=1,idl1
          ch2(ik,l)  = c2(ik,1) + ar1 * c2(ik,2)
          ch2(ik,lc) =            ai1 * c2(ik,ip)
        enddo
        dc2 = ar1
        ds2 = ai1
        ar2 = ar1
        ai2 = ai1
        do j=3,ipph
          jc = ipp2-j
          ar2h = dc2 * ar2 - ds2 * ai2
          ai2  = dc2 * ai2 + ds2 * ar2
          ar2  = ar2h
          do ik=1,idl1
            ch2(ik,l)  = ch2(ik,l)  + ar2 * c2(ik,j)
            ch2(ik,lc) = ch2(ik,lc) + ai2 * c2(ik,jc)
          enddo
        enddo
      enddo
c
      do j=2,ipph
        do ik=1,idl1
          ch2(ik,1) = ch2(ik,1) + c2(ik,j)
        enddo
      enddo
c
      if (ido .ge. l1) then
        do k=1,l1
          do i=1,ido
            cc(i,1,k) = ch(i,k,1)
          enddo
        enddo
      else
        do i=1,ido
          do k=1,l1
            cc(i,1,k) = ch(i,k,1)
          enddo
        enddo
      endif
c
      do j=2,ipph
        jc = ipp2-j
        j2 = j+j
        do k=1,l1
          cc(ido,j2-2,k) = ch(1,k,j)
          cc(1,j2-1,k)   = ch(1,k,jc)
        enddo
      enddo
      if (ido .ne. 1) then
        if (nbd .ge. l1) then
          do j=2,ipph
            jc = ipp2-j
            j2 = j+j
            do k=1,l1
              do i=3,ido,2
                ic = idp2-i
                cc(i-1,j2-1,k)  = ch(i-1,k,j) + ch(i-1,k,jc)
                cc(ic-1,j2-2,k) = ch(i-1,k,j) - ch(i-1,k,jc)
                cc(i,j2-1,k)    = ch(i,k,j)   + ch(i,k,jc)
                cc(ic,j2-2,k)   = ch(i,k,jc)  - ch(i,k,j)
              enddo
            enddo
          enddo
        else
          do j=2,ipph
            jc = ipp2-j
            j2 = j+j
            do i=3,ido,2
              ic = idp2-i
              do k=1,l1
                cc(i-1,j2-1,k)  = ch(i-1,k,j) + ch(i-1,k,jc)
                cc(ic-1,j2-2,k) = ch(i-1,k,j) - ch(i-1,k,jc)
                cc(i,j2-1,k)    = ch(i,k,j)   + ch(i,k,jc)
                cc(ic,j2-2,k)   = ch(i,k,jc)  - ch(i,k,j)
              enddo
            enddo
          enddo
        endif
      endif
c
      end
c======================================================================

      subroutine vradb2 (mi,mf,ms,ido,l1,cc,ch,mdimc,wa1)
c
c     vrfftpk, version 1, august 1985
c
      implicit real*8 (a-h,o-z)
      dimension cc(mdimc,ido,2,l1),ch(mdimc,ido,l1,2),wa1(ido)
c
      do k=1,l1
        do m=mi,mf,ms
          ch(m,1,k,1) = cc(m,1,1,k) + cc(m,ido,2,k)
          ch(m,1,k,2) = cc(m,1,1,k) - cc(m,ido,2,k)
        enddo
      enddo
c
      if (ido.gt.2) then
        idp2 = ido+2
        do i=3,ido,2
          ic = idp2-i
          im1=i-1
          icm1=ic-1
          wai1=wa1(i-1)
          wai2=wa1(i-2)
          do k=1,l1
            do m=mi,mf,ms
              ch(m,im1,k,1) = cc(m,im1,1,k)+cc(m,icm1,2,k)
              tr2 = cc(m,im1,1,k)-cc(m,icm1,2,k)
              ch(m,i,k,1) = cc(m,i,1,k)-cc(m,ic,2,k)
              ti2 = cc(m,i,1,k)+cc(m,ic,2,k)
              ch(m,im1,k,2) = wai2*tr2-wai1*ti2
              ch(m,i,k,2) = wai2*ti2+wai1*tr2
            enddo
          enddo
        enddo
      endif
c
      if (ido.gt.1.and.mod(ido,2) .ne. 1) then
        do k=1,l1
          do m=mi,mf,ms
            ch(m,ido,k,1) =   cc(m,ido,1,k) + cc(m,ido,1,k)
            ch(m,ido,k,2) = -(cc(m,1,2,k)   + cc(m,1,2,k))
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine vradb3 (mi,mf,ms,ido,l1,cc,ch,mdimc,wa1,wa2)
c
c     vrfftpk, version 1, august 1985
c
      implicit real*8 (a-h,o-z)
      dimension cc(mdimc,ido,3,l1),ch(mdimc,ido,l1,3),wa1(ido),wa2(ido)
C                                      sqrt(3)/2
      parameter (taur=-0.5d0,taui=0.86602540378443864676d0)
c
      do k=1,l1
        do m=mi,mf,ms
          tr2 = cc(m,ido,2,k)+cc(m,ido,2,k)
          cr2 = cc(m,1,1,k)+taur*tr2
          ch(m,1,k,1) = cc(m,1,1,k)+tr2
          ci3 = taui*(cc(m,1,3,k)+cc(m,1,3,k))
          ch(m,1,k,2) = cr2-ci3
          ch(m,1,k,3) = cr2+ci3
        enddo
      enddo
c
      if (ido .ne. 1) then
        idp2 = ido+2
        do i=3,ido,2
          ic = idp2-i
          im1=i-1
          icm1=ic-1
          wa11=wa1(im1)
          wa12=wa1(i-2)
          wa21=wa2(im1)
          wa22=wa2(i-2)
          do k=1,l1
            do m=mi,mf,ms
              tr2 = cc(m,im1,3,k)+cc(m,icm1,2,k)
              cr2 = cc(m,im1,1,k)+taur*tr2
              ch(m,im1,k,1) = cc(m,im1,1,k)+tr2
              ti2 = cc(m,i,3,k)-cc(m,ic,2,k)
              ci2 = cc(m,i,1,k)+taur*ti2
              ch(m,i,k,1) = cc(m,i,1,k)+ti2
              cr3 = taui*(cc(m,im1,3,k)-cc(m,icm1,2,k))
              ci3 = taui*(cc(m,i,3,k)+cc(m,ic,2,k))
              dr2 = cr2-ci3
              dr3 = cr2+ci3
              di2 = ci2+cr3
              di3 = ci2-cr3
              ch(m,im1,k,2) = wa12*dr2-wa11*di2
              ch(m,i,k,2) = wa12*di2+wa11*dr2
              ch(m,im1,k,3) = wa22*dr3-wa21*di3
              ch(m,i,k,3) = wa22*di3+wa21*dr3
            enddo
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine vradb4 (mi,mf,ms,ido,l1,cc,ch,mdimc,wa1,wa2,wa3)
c
c     vrfftpk, version 1, august 1985
c
      implicit real*8 (a-h,o-z)
      dimension cc(mdimc,ido,4,l1),ch(mdimc,ido,l1,4),
     &          wa1(ido),wa2(ido),wa3(ido)
      parameter (sqrt2=1.41421356237309504880d0)
c
      do k=1,l1
        do m=mi,mf,ms
          tr1 = cc(m,1,1,k)  -cc(m,ido,4,k)
          tr2 = cc(m,1,1,k)  +cc(m,ido,4,k)
          tr3 = cc(m,ido,2,k)+cc(m,ido,2,k)
          tr4 = cc(m,1,3,k)  +cc(m,1,3,k)
          ch(m,1,k,1) = tr2+tr3
          ch(m,1,k,2) = tr1-tr4
          ch(m,1,k,3) = tr2-tr3
          ch(m,1,k,4) = tr1+tr4
        enddo
      enddo
      if (ido.gt.2) then
        idp2 = ido+2
        do i=3,ido,2
          ic = idp2-i
          im1=i-1
          icm1=ic-1
          wa11=wa1(im1)
          wa12=wa1(i-2)
          wa21=wa2(im1)
          wa22=wa2(i-2)
          wa31=wa3(im1)
          wa32=wa3(i-2)
          do k=1,l1
            do m=mi,mf,ms
              ti1 = cc(m,i,1,k)  +cc(m,ic,4,k)
              ti2 = cc(m,i,1,k)  -cc(m,ic,4,k)
              ti3 = cc(m,i,3,k)  -cc(m,ic,2,k)
              tr4 = cc(m,i,3,k)  +cc(m,ic,2,k)
              tr1 = cc(m,im1,1,k)-cc(m,icm1,4,k)
              tr2 = cc(m,im1,1,k)+cc(m,icm1,4,k)
              ti4 = cc(m,im1,3,k)-cc(m,icm1,2,k)
              tr3 = cc(m,im1,3,k)+cc(m,icm1,2,k)
              ch(m,im1,k,1) = tr2+tr3
              cr3 = tr2-tr3
              ch(m,i,k,1) = ti2+ti3
              ci3 = ti2-ti3
              cr2 = tr1-tr4
              cr4 = tr1+tr4
              ci2 = ti1+ti4
              ci4 = ti1-ti4
              ch(m,im1,k,2) = wa12*cr2-wa11*ci2
              ch(m,i,k,2) = wa12*ci2+wa11*cr2
              ch(m,im1,k,3) = wa22*cr3-wa21*ci3
              ch(m,i,k,3) = wa22*ci3+wa21*cr3
              ch(m,im1,k,4) = wa32*cr4-wa31*ci4
              ch(m,i,k,4) = wa32*ci4+wa31*cr4
            enddo
          enddo
        enddo
      endif
c
      if (ido.gt.1.and.mod(ido,2) .ne. 1) then
        do k=1,l1
          do m=mi,mf,ms
            ti1 = cc(m,1,2,k)  +cc(m,1,4,k)
            ti2 = cc(m,1,4,k)  -cc(m,1,2,k)
            tr1 = cc(m,ido,1,k)-cc(m,ido,3,k)
            tr2 = cc(m,ido,1,k)+cc(m,ido,3,k)
            ch(m,ido,k,1) = tr2+tr2
            ch(m,ido,k,2) = sqrt2*(tr1-ti1)
            ch(m,ido,k,3) = ti2+ti2
            ch(m,ido,k,4) = -sqrt2*(tr1+ti1)
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine vradb5 (mi,mf,ms,ido,l1,cc,ch,mdimc,wa1,wa2,wa3,wa4)
c
c     vrfftpk, version 1, august 1985
c
      implicit real*8 (a-h,o-z)
      dimension cc(mdimc,ido,5,l1),ch(mdimc,ido,l1,5),
     1          wa1(ido),wa2(ido),wa3(ido),wa4(ido)
c     *** tr11=cos(2*pi/5), ti11=sin(2*pi/5)
c     *** tr12=cos(4*pi/5), ti12=sin(4*pi/5)
      parameter (tr11=0.3090169943749474241d0,
     +           ti11=0.95105651629515357212d0,
     +           tr12=-0.8090169943749474241d0,
     +           ti12=0.58778525229247312917d0)
c
      do k=1,l1
        do m=mi,mf,ms
          ti5 = cc(m,1,3,k)  +cc(m,1,3,k)
          ti4 = cc(m,1,5,k)  +cc(m,1,5,k)
          tr2 = cc(m,ido,2,k)+cc(m,ido,2,k)
          tr3 = cc(m,ido,4,k)+cc(m,ido,4,k)
          ch(m,1,k,1) = cc(m,1,1,k)+tr2+tr3
          cr2 = cc(m,1,1,k)+tr11*tr2+tr12*tr3
          cr3 = cc(m,1,1,k)+tr12*tr2+tr11*tr3
          ci5 = ti11*ti5+ti12*ti4
          ci4 = ti12*ti5-ti11*ti4
          ch(m,1,k,2) = cr2-ci5
          ch(m,1,k,3) = cr3-ci4
          ch(m,1,k,4) = cr3+ci4
          ch(m,1,k,5) = cr2+ci5
        enddo
      enddo
c
      if (ido .ne. 1) then
        idp2 = ido+2
        do i=3,ido,2
          ic = idp2-i
          im1=i-1
          icm1=ic-1
          wa11=wa1(im1)
          wa12=wa1(i-2)
          wa21=wa2(im1)
          wa22=wa2(i-2)
          wa31=wa3(im1)
          wa32=wa3(i-2)
          wa41=wa4(im1)
          wa42=wa4(i-2)
          do k=1,l1
            do m=mi,mf,ms
              ti5 = cc(m,i,3,k)  +cc(m,ic,2,k)
              ti2 = cc(m,i,3,k)  -cc(m,ic,2,k)
              ti4 = cc(m,i,5,k)  +cc(m,ic,4,k)
              ti3 = cc(m,i,5,k)  -cc(m,ic,4,k)
              tr5 = cc(m,im1,3,k)-cc(m,icm1,2,k)
              tr2 = cc(m,im1,3,k)+cc(m,icm1,2,k)
              tr4 = cc(m,im1,5,k)-cc(m,icm1,4,k)
              tr3 = cc(m,im1,5,k)+cc(m,icm1,4,k)
              ch(m,im1,k,1) = cc(m,im1,1,k)+tr2+tr3
              ch(m,i,k,1) = cc(m,i,1,k)+ti2+ti3
              cr2 = cc(m,im1,1,k)+tr11*tr2+tr12*tr3
              ci2 = cc(m,i,1,k)+tr11*ti2+tr12*ti3
              cr3 = cc(m,im1,1,k)+tr12*tr2+tr11*tr3
              ci3 = cc(m,i,1,k)+tr12*ti2+tr11*ti3
              cr5 = ti11*tr5+ti12*tr4
              ci5 = ti11*ti5+ti12*ti4
              cr4 = ti12*tr5-ti11*tr4
              ci4 = ti12*ti5-ti11*ti4
              dr3 = cr3-ci4
              dr4 = cr3+ci4
              di3 = ci3+cr4
              di4 = ci3-cr4
              dr5 = cr2+ci5
              dr2 = cr2-ci5
              di5 = ci2-cr5
              di2 = ci2+cr5
              ch(m,im1,k,2) = wa12*dr2-wa11*di2
              ch(m,i,k,2) = wa12*di2+wa11*dr2
              ch(m,i-1,k,3) = wa22*dr3-wa21*di3
              ch(m,i,k,3) = wa22*di3+wa21*dr3
              ch(m,im1,k,4) = wa32*dr4-wa31*di4
              ch(m,i,k,4) = wa32*di4+wa31*dr4
              ch(m,im1,k,5) = wa42*dr5-wa41*di5
              ch(m,i,k,5) = wa42*di5+wa41*dr5
            enddo
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine vradbg (mi,mf,ms,ido,ip,l1,idl1,cc,c1,c2,ch,ch2,mdimc,
     &                   wa)
c
c     vrfftpk, version 1, august 1985
c
      implicit real*8 (a-h,o-z)
      dimension ch(mdimc,ido,l1,ip),cc(mdimc,ido,ip,l1),
     1          c1(mdimc,ido,l1,ip),c2(mdimc,idl1,ip),
     2          ch2(mdimc,idl1,ip),wa(ido)
      parameter (tpi=6.2831853071795864769d0)     !  2 * %pi
c
      arg = tpi/float(ip)
      dcp = cos(arg)
      dsp = sin(arg)
      idp2 = ido+2
      nbd = (ido-1)/2
      ipp2 = ip+2
      ipph = (ip+1)/2
c
      if (ido .ge. l1) then
        do k=1,l1
          do i=1,ido
            do m=mi,mf,ms
              ch(m,i,k,1) = cc(m,i,1,k)
            enddo
          enddo
        enddo
      else
        do i=1,ido
          do k=1,l1
            do m=mi,mf,ms
              ch(m,i,k,1) = cc(m,i,1,k)
            enddo
          enddo
        enddo
      endif
c
      do j=2,ipph
        jc = ipp2-j
        j2m1=j+j-1
        j2m2=j2m1-1
        do k=1,l1
          do m=mi,mf,ms
            ch(m,1,k,j) = cc(m,ido,j2m2,k)+cc(m,ido,j2m2,k)
            ch(m,1,k,jc) = cc(m,1,j2m1,k)+cc(m,1,j2m1,k)
          enddo
        enddo
      enddo
c
      if (ido .ne. 1) then
        if (nbd .ge. l1) then
          do j=2,ipph
            jc = ipp2-j
            j2m1=j+j-1
            j2m2=j2m1-1
            do k=1,l1
              do i=3,ido,2
                ic = idp2-i
                im1=i-1
                icm1=ic-1
                do m=mi,mf,ms
                  ch(m,im1,k,j) = cc(m,im1,j2m1,k) + cc(m,icm1,j2m2,k)
                  ch(m,im1,k,jc)= cc(m,im1,j2m1,k) - cc(m,icm1,j2m2,k)
                  ch(m,i,k,j)   = cc(m,i,j2m1,k)   - cc(m,ic,j2m2,k)
                  ch(m,i,k,jc)  = cc(m,i,j2m1,k)   + cc(m,ic,j2m2,k)
                enddo
              enddo
            enddo
          enddo
        else
          do j=2,ipph
            jc = ipp2-j
            j2m1=j+j-1
            j2m2=j2m1-1
            do i=3,ido,2
              ic = idp2-i
              im1=i-1
              icm1=ic-1
              do k=1,l1
                do m=mi,mf,ms
                  ch(m,im1,k,j) = cc(m,im1,j2m1,k) + cc(m,icm1,j2m2,k)
                  ch(m,im1,k,jc)= cc(m,im1,j2m1,k) - cc(m,icm1,j2m2,k)
                  ch(m,i,k,j)   = cc(m,i,j2m1,k)   - cc(m,ic,j2m2,k)
                  ch(m,i,k,jc)  = cc(m,i,j2m1,k)   + cc(m,ic,j2m2,k)
                enddo
              enddo
            enddo
          enddo
        endif
      endif
c
      ar1 = 1.0d0
      ai1 = 0.0d0
      do l=2,ipph
        lc = ipp2-l
        ar1h = dcp*ar1-dsp*ai1
        ai1 = dcp*ai1+dsp*ar1
        ar1 = ar1h
        do ik=1,idl1
          do m=mi,mf,ms
            c2(m,ik,l)  = ch2(m,ik,1) + ar1 * ch2(m,ik,2)
            c2(m,ik,lc) =               ai1 * ch2(m,ik,ip)
          enddo
        enddo
        dc2 = ar1
        ds2 = ai1
        ar2 = ar1
        ai2 = ai1
        do j=3,ipph
          jc = ipp2-j
          ar2h = dc2*ar2-ds2*ai2
          ai2 = dc2*ai2+ds2*ar2
          ar2 = ar2h
          do ik=1,idl1
            do m=mi,mf,ms
              c2(m,ik,l)  = c2(m,ik,l)  + ar2 * ch2(m,ik,j)
              c2(m,ik,lc) = c2(m,ik,lc) + ai2 * ch2(m,ik,jc)
            enddo
          enddo
        enddo
      enddo
c
      do j=2,ipph
        do ik=1,idl1
          do m=mi,mf,ms
            ch2(m,ik,1) = ch2(m,ik,1)+ch2(m,ik,j)
          enddo
        enddo
      enddo
      do j=2,ipph
        jc = ipp2-j
        do k=1,l1
          do m=mi,mf,ms
            ch(m,1,k,j)  = c1(m,1,k,j) - c1(m,1,k,jc)
            ch(m,1,k,jc) = c1(m,1,k,j) + c1(m,1,k,jc)
          enddo
        enddo
      enddo
c
      if (ido .ne. 1) then
        if (nbd .ge. l1) then
          do j=2,ipph
            jc = ipp2-j
            do k=1,l1
              do i=3,ido,2
                im1=i-1
                do m=mi,mf,ms
                  ch(m,im1,k,j)  = c1(m,im1,k,j) - c1(m,i,k,jc)
                  ch(m,im1,k,jc) = c1(m,im1,k,j) + c1(m,i,k,jc)
                  ch(m,i,k,j)    = c1(m,i,k,j)   + c1(m,im1,k,jc)
                  ch(m,i,k,jc)   = c1(m,i,k,j)   - c1(m,im1,k,jc)
                enddo
              enddo
            enddo
          enddo
        else
          do j=2,ipph
            jc = ipp2-j
            do i=3,ido,2
              im1=i-1
              do k=1,l1
                do m=mi,mf,ms
                  ch(m,im1,k,j)  = c1(m,im1,k,j) - c1(m,i,k,jc)
                  ch(m,im1,k,jc) = c1(m,im1,k,j) + c1(m,i,k,jc)
                  ch(m,i,k,j)    = c1(m,i,k,j)   + c1(m,im1,k,jc)
                  ch(m,i,k,jc)   = c1(m,i,k,j)   - c1(m,im1,k,jc)
                enddo
              enddo
            enddo
          enddo
        endif
        do ik=1,idl1
          do m=mi,mf,ms
            c2(m,ik,1) = ch2(m,ik,1)
          enddo
        enddo
        do j=2,ip
          do k=1,l1
            do m=mi,mf,ms
              c1(m,1,k,j) = ch(m,1,k,j)
            enddo
          enddo
        enddo
        if (nbd .le. l1) then
          is = -ido
          do j=2,ip
            is = is+ido
            idij = is
            do i=3,ido,2
              im1=i-1
              idij = idij+2
              waij=wa(idij)
              waij1=wa(idij-1)
              do k=1,l1
                do m=mi,mf,ms
                  c1(m,im1,k,j) = waij1 * ch(m,im1,k,j)
     &                           -waij  * ch(m,i,k,j)
                  c1(m,i,k,j)   = waij1 * ch(m,i,k,j)
     &                           +waij  * ch(m,im1,k,j)
                enddo
              enddo
            enddo
          enddo
        else
          is = -ido
          do j=2,ip
            is = is+ido
            do k=1,l1
              idij = is
              do i=3,ido,2
                im1=i-1
                idij = idij+2
                waij=wa(idij)
                waij1=wa(idij-1)
                do m=mi,mf,ms
                  c1(m,im1,k,j) = waij1 * ch(m,im1,k,j)
     &                           -waij  * ch(m,i,k,j)
                  c1(m,i,k,j)   = waij1 * ch(m,i,k,j)
     &                           +waij  * ch(m,im1,k,j)
                enddo
              enddo
            enddo
          enddo
        endif
      endif
c
      end
c======================================================================

      subroutine vradf2 (mi,mf,ms,ido,l1,cc,ch,mdimc,wa1)
c
c     vrfftpk, version 1, august 1985
c
      implicit real*8 (a-h,o-z)
      dimension ch(mdimc,ido,2,l1),cc(mdimc,ido,l1,2),wa1(ido)
c
      do k=1,l1
        do m=mi,mf,ms
          ch(m,1,1,k)   = cc(m,1,k,1)+cc(m,1,k,2)
          ch(m,ido,2,k) = cc(m,1,k,1)-cc(m,1,k,2)
        enddo
      enddo
c
      if(ido.gt.2)then
        idp2 = ido+2
        do i=3,ido,2
          ic = idp2-i
          im1=i-1
          icm1=ic-1
          wa11=wa1(im1)
          wa12=wa1(i-2)
          do k=1,l1
            do m=mi,mf,ms
              tr2 = wa12*cc(m,im1,k,2)+wa11*cc(m,i,k,2)
              ti2 = wa12*cc(m,i,k,2)  -wa11*cc(m,im1,k,2)
              ch(m,i,1,k) = cc(m,i,k,1)+ti2
              ch(m,ic,2,k) = ti2-cc(m,i,k,1)
              ch(m,im1,1,k) = cc(m,im1,k,1)+tr2
              ch(m,icm1,2,k) = cc(m,im1,k,1)-tr2
            enddo
          enddo
        enddo
      endif
c
      if (ido.gt.1.and.mod(ido,2).ne.1) then
        do k=1,l1
          do m=mi,mf,ms
            ch(m,1,2,k)   = -cc(m,ido,k,2)
            ch(m,ido,1,k) =  cc(m,ido,k,1)
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine vradf3 (mi,mf,ms,ido,l1,cc,ch,mdimc,wa1,wa2)
c
c     vrfftpk, version 1, august 1985
c
      implicit real*8 (a-h,o-z)
      dimension ch(mdimc,ido,3,l1),cc(mdimc,ido,l1,3),wa1(ido),wa2(ido)
      parameter (arg=2.0943951023931954923d0)      ! 2/3 * pi
c
      taur=cos(arg)
      taui=sin(arg)
      do k=1,l1
        do m=mi,mf,ms
          cr2 = cc(m,1,k,2)+cc(m,1,k,3)
          ch(m,1,1,k) = cc(m,1,k,1)+cr2
          ch(m,1,3,k) = taui*(cc(m,1,k,3)-cc(m,1,k,2))
          ch(m,ido,2,k) = cc(m,1,k,1)+taur*cr2
        enddo
      enddo
c
      if (ido .ne. 1) then
        idp2 = ido+2
        do i=3,ido,2
          ic = idp2-i
          im1=i-1
          icm1=ic-1
          wa11=wa1(im1)
          wa12=wa1(i-2)
          wa21=wa2(im1)
          wa22=wa2(i-2)
          do k=1,l1
            do m=mi,mf,ms
              dr2 = wa12*cc(m,im1,k,2)+wa11*cc(m,i,k,2)
              di2 = wa12*cc(m,i,k,2)  -wa11*cc(m,im1,k,2)
              dr3 = wa22*cc(m,im1,k,3)+wa21*cc(m,i,k,3)
              di3 = wa22*cc(m,i,k,3)  -wa21*cc(m,im1,k,3)
              cr2 = dr2+dr3
              ci2 = di2+di3
              ch(m,im1,1,k) = cc(m,im1,k,1)+cr2
              ch(m,i,1,k)   = cc(m,i,k,1)+ci2
              tr2 = cc(m,im1,k,1)+taur*cr2
              ti2 = cc(m,i,k,1)+taur*ci2
              tr3 = taui*(di2-di3)
              ti3 = taui*(dr3-dr2)
              ch(m,im1,3,k) = tr2+tr3
              ch(m,icm1,2,k) = tr2-tr3
              ch(m,i,3,k) = ti2+ti3
              ch(m,ic,2,k) = ti3-ti2
            enddo
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine vradf4 (mi,mf,ms,ido,l1,cc,ch,mdimc,wa1,wa2,wa3)
c
c     vrfftpk, version 1, august 1985
c
      implicit real*8 (a-h,o-z)
      dimension cc(mdimc,ido,l1,4),ch(mdimc,ido,4,l1),
     &          wa1(*),wa2(*),wa3(*)
      parameter (hsqt2=7.071067811865475d-1)              ! sqrt(2)/2
c
      do k=1,l1
        do m=mi,mf,ms
          tr1 = cc(m,1,k,2)+cc(m,1,k,4)
          tr2 = cc(m,1,k,1)+cc(m,1,k,3)
          ch(m,1,1,k)   = tr1 + tr2
          ch(m,ido,4,k) = tr2 - tr1
          ch(m,ido,2,k) = cc(m,1,k,1)-cc(m,1,k,3)
          ch(m,1,3,k)   = cc(m,1,k,4)-cc(m,1,k,2)
        enddo
      enddo
c
      if(ido.gt.2)then
        idp2 = ido+2
        do i=3,ido,2
          ic = idp2-i
          im1=i-1
          icm1=ic-1
          wa11=wa1(im1)
          wa12=wa1(i-2)
          wa21=wa2(im1)
          wa22=wa2(i-2)
          wa31=wa3(im1)
          wa32=wa3(i-2)
          do k=1,l1
            do m=mi,mf,ms
              cr2 = wa12*cc(m,im1,k,2)+wa11*cc(m,i,k,2)
              ci2 = wa12*cc(m,i,k,2)  -wa11*cc(m,im1,k,2)
              cr3 = wa22*cc(m,im1,k,3)+wa21*cc(m,i,k,3)
              ci3 = wa22*cc(m,i,k,3)  -wa21*cc(m,im1,k,3)
              cr4 = wa32*cc(m,im1,k,4)+wa31*cc(m,i,k,4)
              ci4 = wa32*cc(m,i,k,4)  -wa31*cc(m,im1,k,4)
              tr1 = cr2+cr4
              tr4 = cr4-cr2
              ti1 = ci2+ci4
              ti4 = ci2-ci4
              ti2 = cc(m,i,k,1)+ci3
              ti3 = cc(m,i,k,1)-ci3
              tr2 = cc(m,im1,k,1)+cr3
              tr3 = cc(m,im1,k,1)-cr3
              ch(m,im1,1,k) = tr1+tr2
              ch(m,icm1,4,k) = tr2-tr1
              ch(m,i,1,k) = ti1+ti2
              ch(m,ic,4,k) = ti1-ti2
              ch(m,im1,3,k) = ti4+tr3
              ch(m,icm1,2,k) = tr3-ti4
              ch(m,i,3,k) = tr4+ti3
              ch(m,ic,2,k) = tr4-ti3
             enddo
           enddo
        enddo
      endif
c
      if (ido.gt.1.and.mod(ido,2) .ne. 1) then
        do k=1,l1
          do m=mi,mf,ms
            ti1 = -hsqt2*(cc(m,ido,k,2)+cc(m,ido,k,4))
            tr1 = hsqt2*(cc(m,ido,k,2)-cc(m,ido,k,4))
            ch(m,ido,1,k) = tr1+cc(m,ido,k,1)
            ch(m,ido,3,k) = cc(m,ido,k,1)-tr1
            ch(m,1,2,k) = ti1-cc(m,ido,k,3)
            ch(m,1,4,k) = ti1+cc(m,ido,k,3)
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine vradf5 (mi,mf,ms,ido,l1,cc,ch,mdimc,wa1,wa2,wa3,wa4)
c
c     vrfftpk, version 1, august 1985
c
      implicit real*8 (a-h,o-z)
      dimension  cc(mdimc,ido,l1,5),ch(mdimc,ido,5,l1),
     1           wa1(ido),wa2(ido),wa3(ido),wa4(ido)
      parameter (arg=1.2566370614359172954d0)      !  2/5 * pi
c
      tr11=cos(arg)
      ti11=sin(arg)
      tr12=cos(2.0d0*arg)
      ti12=sin(2.0d0*arg)
      do k=1,l1
        do m=mi,mf,ms
          cr2 = cc(m,1,k,5)+cc(m,1,k,2)
          ci5 = cc(m,1,k,5)-cc(m,1,k,2)
          cr3 = cc(m,1,k,4)+cc(m,1,k,3)
          ci4 = cc(m,1,k,4)-cc(m,1,k,3)
          ch(m,1,1,k)   = cc(m,1,k,1)+cr2+cr3
          ch(m,ido,2,k) = cc(m,1,k,1)+tr11*cr2+tr12*cr3
          ch(m,1,3,k)   = ti11*ci5+ti12*ci4
          ch(m,ido,4,k) = cc(m,1,k,1)+tr12*cr2+tr11*cr3
          ch(m,1,5,k)   = ti12*ci5-ti11*ci4
        enddo
      enddo
c
      if (ido .ne. 1) then
        idp2 = ido+2
        do i=3,ido,2
          ic = idp2-i
          im1=i-1
          icm1=ic-1
          wa11=wa1(im1)
          wa12=wa1(i-2)
          wa21=wa2(im1)
          wa22=wa2(i-2)
          wa31=wa3(im1)
          wa32=wa3(i-2)
          wa41=wa4(im1)
          wa42=wa4(i-2)
          do k=1,l1
            do m=mi,mf,ms
              dr2 = wa12*cc(m,im1,k,2)+wa11*cc(m,i,k,2)
              di2 = wa12*cc(m,i,k,2)  -wa11*cc(m,im1,k,2)
              dr3 = wa22*cc(m,im1,k,3)+wa21*cc(m,i,k,3)
              di3 = wa22*cc(m,i,k,3)  -wa21*cc(m,im1,k,3)
              dr4 = wa32*cc(m,im1,k,4)+wa31*cc(m,i,k,4)
              di4 = wa32*cc(m,i,k,4)  -wa31*cc(m,im1,k,4)
              dr5 = wa42*cc(m,im1,k,5)+wa41*cc(m,i,k,5)
              di5 = wa42*cc(m,i,k,5)  -wa41*cc(m,im1,k,5)
              cr2 = dr2+dr5
              ci5 = dr5-dr2
              cr5 = di2-di5
              ci2 = di2+di5
              cr3 = dr3+dr4
              ci4 = dr4-dr3
              cr4 = di3-di4
              ci3 = di3+di4
              ch(m,im1,1,k) = cc(m,im1,k,1)+cr2+cr3
              ch(m,i,1,k)   = cc(m,i,k,1)+ci2+ci3
              tr2 = cc(m,im1,k,1)+tr11*cr2+tr12*cr3
              ti2 = cc(m,i,k,1)+tr11*ci2+tr12*ci3
              tr3 = cc(m,im1,k,1)+tr12*cr2+tr11*cr3
              ti3 = cc(m,i,k,1)+tr12*ci2+tr11*ci3
              tr5 = ti11*cr5+ti12*cr4
              ti5 = ti11*ci5+ti12*ci4
              tr4 = ti12*cr5-ti11*cr4
              ti4 = ti12*ci5-ti11*ci4
              ch(m,im1,3,k) = tr2+tr5
              ch(m,icm1,2,k) = tr2-tr5
              ch(m,i,3,k) = ti2+ti5
              ch(m,ic,2,k) = ti5-ti2
              ch(m,im1,5,k) = tr3+tr4
              ch(m,icm1,4,k) = tr3-tr4
              ch(m,i,5,k) = ti3+ti4
              ch(m,ic,4,k) = ti4-ti3
            enddo
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine vradfg (mi,mf,ms,ido,ip,l1,idl1,cc,c1,c2,ch,ch2,mdimc,
     &                   wa)
c
c     vrfftpk, version 1, august 1985
c
      implicit real*8 (a-h,o-z)
      dimension   ch(mdimc,ido,l1,ip),cc(mdimc,ido,ip,l1),
     1            c1(mdimc,ido,l1,ip),c2(mdimc,idl1,ip),
     2            ch2(mdimc,idl1,ip),wa(ido)
      parameter (tpi=6.2831853071795864769d0)     !  2 * %pi
c
      arg = tpi/float(ip)
      dcp = cos(arg)
      dsp = sin(arg)
      ipph = (ip+1)/2
      ipp2 = ip+2
      idp2 = ido+2
      nbd = (ido-1)/2
c
      if (ido .ne. 1) then
        do ik=1,idl1
          do m=mi,mf,ms
            ch2(m,ik,1) = c2(m,ik,1)
          enddo
        enddo
        do j=2,ip
          do k=1,l1
            do m=mi,mf,ms
              ch(m,1,k,j) = c1(m,1,k,j)
            enddo
          enddo
        enddo
        if (nbd .le. l1) then
          is = -ido
          do j=2,ip
            is = is+ido
            idij = is
            do i=3,ido,2
              im1=i-1
              idij = idij+2
              waij=wa(idij)
              waij1=wa(idij-1)
              do k=1,l1
                do m=mi,mf,ms
                  ch(m,im1,k,j) = waij1*c1(m,im1,k,j)+waij*c1(m,i,k,j)
                  ch(m,i,k,j) = waij1*c1(m,i,k,j)-waij*c1(m,im1,k,j)
                enddo
              enddo
            enddo
          enddo
        else
          is = -ido
          do j=2,ip
            is = is+ido
            do k=1,l1
              idij = is
              do i=3,ido,2
                im1=i-1
                idij = idij+2
                waij=wa(idij)
                waij1=wa(idij-1)
                do m=mi,mf,ms
                  ch(m,im1,k,j) = waij1*c1(m,im1,k,j)+waij*c1(m,i,k,j)
                  ch(m,i,k,j) = waij1*c1(m,i,k,j)-waij*c1(m,im1,k,j)
                enddo
              enddo
            enddo
          enddo
        endif
        if (nbd .ge. l1) then
          do j=2,ipph
            jc = ipp2-j
            do k=1,l1
              do i=3,ido,2
                im1=i-1
                do m=mi,mf,ms
                  c1(m,im1,k,j) = ch(m,im1,k,j)+ch(m,im1,k,jc)
                  c1(m,im1,k,jc) = ch(m,i,k,j)-ch(m,i,k,jc)
                  c1(m,i,k,j) = ch(m,i,k,j)+ch(m,i,k,jc)
                  c1(m,i,k,jc) = ch(m,im1,k,jc)-ch(m,im1,k,j)
                enddo
              enddo
            enddo
          enddo
        else
          do j=2,ipph
            jc = ipp2-j
            do i=3,ido,2
              im1=i-1
              do k=1,l1
                do m=mi,mf,ms
                  c1(m,im1,k,j) = ch(m,im1,k,j)+ch(m,im1,k,jc)
                  c1(m,im1,k,jc) = ch(m,i,k,j)-ch(m,i,k,jc)
                  c1(m,i,k,j) = ch(m,i,k,j)+ch(m,i,k,jc)
                  c1(m,i,k,jc) = ch(m,im1,k,jc)-ch(m,im1,k,j)
                enddo
              enddo
            enddo
          enddo
        endif
      else
        do ik=1,idl1
          do m=mi,mf,ms
            c2(m,ik,1) = ch2(m,ik,1)
          enddo
        enddo
      endif
c
      do j=2,ipph
         jc = ipp2-j
         do k=1,l1
            do m=mi,mf,ms
            c1(m,1,k,j) = ch(m,1,k,j)+ch(m,1,k,jc)
            c1(m,1,k,jc) = ch(m,1,k,jc)-ch(m,1,k,j)
            enddo
         enddo
      enddo
c
      ar1 = 1.0d0
      ai1 = 0.0d0
      do l=2,ipph
         lc = ipp2-l
         ar1h = dcp*ar1-dsp*ai1
         ai1 = dcp*ai1+dsp*ar1
         ar1 = ar1h
         do ik=1,idl1
            do m=mi,mf,ms
            ch2(m,ik,l) = c2(m,ik,1)+ar1*c2(m,ik,2)
            ch2(m,ik,lc) = ai1*c2(m,ik,ip)
            enddo
         enddo
         dc2 = ar1
         ds2 = ai1
         ar2 = ar1
         ai2 = ai1
         do j=3,ipph
            jc = ipp2-j
            ar2h = dc2*ar2-ds2*ai2
            ai2 = dc2*ai2+ds2*ar2
            ar2 = ar2h
            do ik=1,idl1
               do m=mi,mf,ms
               ch2(m,ik,l) = ch2(m,ik,l)+ar2*c2(m,ik,j)
               ch2(m,ik,lc) = ch2(m,ik,lc)+ai2*c2(m,ik,jc)
               enddo
            enddo
         enddo
      enddo
      do j=2,ipph
         do ik=1,idl1
            do m=mi,mf,ms
            ch2(m,ik,1) = ch2(m,ik,1)+c2(m,ik,j)
            enddo
         enddo
      enddo
c
      if (ido .ge. l1) then
        do k=1,l1
          do i=1,ido
            do m=mi,mf,ms
              cc(m,i,1,k) = ch(m,i,k,1)
            enddo
          enddo
        enddo
      else
        do i=1,ido
          do k=1,l1
            do m=mi,mf,ms
              cc(m,i,1,k) = ch(m,i,k,1)
            enddo
          enddo
        enddo
      endif
      do j=2,ipph
         jc = ipp2-j
         j2 = j+j
         do k=1,l1
            do m=mi,mf,ms
            cc(m,ido,j2-2,k) = ch(m,1,k,j)
            cc(m,1,j2-1,k) = ch(m,1,k,jc)
            enddo
         enddo
      enddo
c
      if (ido .ne. 1) then
        if (nbd .ge. l1) then
          do j=2,ipph
            jc = ipp2-j
            j2m1=j+j-1
            j2m2=j2m1-1
            do k=1,l1
              do i=3,ido,2
                ic = idp2-i
                im1=i-1
                icm1=ic-1
                do m=mi,mf,ms
                  cc(m,im1,j2m1,k) = ch(m,im1,k,j)+ch(m,im1,k,jc)
                  cc(m,icm1,j2m2,k) = ch(m,im1,k,j)-ch(m,im1,k,jc)
                  cc(m,i,j2m1,k) = ch(m,i,k,j)+ch(m,i,k,jc)
                  cc(m,ic,j2m2,k) = ch(m,i,k,jc)-ch(m,i,k,j)
                enddo
              enddo
            enddo
          enddo
        else
          do j=2,ipph
            jc = ipp2-j
            j2m1=j+j-1
            j2m2=j2m1-1
            do i=3,ido,2
              ic = idp2-i
              im1=i-1
              icm1=ic-1
              do k=1,l1
                do m=mi,mf,ms
                  cc(m,im1,j2m1,k) = ch(m,im1,k,j)+ch(m,im1,k,jc)
                  cc(m,icm1,j2m2,k) = ch(m,im1,k,j)-ch(m,im1,k,jc)
                  cc(m,i,j2m1,k) = ch(m,i,k,j)+ch(m,i,k,jc)
                  cc(m,ic,j2m2,k) = ch(m,i,k,jc)-ch(m,i,k,j)
                enddo
              enddo
            enddo
          enddo
        endif
      endif
c
      end
c======================================================================

      subroutine passb2 (ido,l1,cc,ch,wa1)
c
      implicit  real*8 (a-h,o-z)
      dimension cc(ido,2,l1),ch(ido,l1,2),wa1(1)
c
      if (ido .le. 2) then
        do k=1,l1
          ch(1,k,1) = cc(1,1,k)+cc(1,2,k)
          ch(1,k,2) = cc(1,1,k)-cc(1,2,k)
          ch(2,k,1) = cc(2,1,k)+cc(2,2,k)
          ch(2,k,2) = cc(2,1,k)-cc(2,2,k)
        enddo
      else
        do k=1,l1
          do i=2,ido,2
            ch(i-1,k,1) = cc(i-1,1,k) + cc(i-1,2,k)
            tr2         = cc(i-1,1,k) - cc(i-1,2,k)
            ch(i,k,1)   = cc(i,1,k)   + cc(i,2,k)
            ti2         = cc(i,1,k)   - cc(i,2,k)
            ch(i,k,2)   = wa1(i-1) *ti2 + wa1(i) * tr2
            ch(i-1,k,2) = wa1(i-1) *tr2 - wa1(i) * ti2
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine passb3 (ido,l1,cc,ch,wa1,wa2)
c
      implicit real*8 (a-h,o-z)
      dimension cc(ido,3,l1),ch(ido,l1,3),wa1(1),wa2(1)
c     *** taui is sqrt(3)/2 ***
      parameter (taur=-0.5d0,taui=0.86602540378443864676d0)
c
      if (ido .eq. 2) then
        do k=1,l1
          tr2 = cc(1,2,k) + cc(1,3,k)
          cr2 = cc(1,1,k) + taur*tr2
          ch(1,k,1) = cc(1,1,k) + tr2
          ti2 = cc(2,2,k) + cc(2,3,k)
          ci2 = cc(2,1,k) + taur*ti2
          ch(2,k,1) = cc(2,1,k) + ti2
          cr3 = taui*(cc(1,2,k) - cc(1,3,k))
          ci3 = taui*(cc(2,2,k) - cc(2,3,k))
          ch(1,k,2) = cr2 - ci3
          ch(1,k,3) = cr2 + ci3
          ch(2,k,2) = ci2 + cr3
          ch(2,k,3) = ci2 - cr3
        enddo
      else
        do k=1,l1
          do i=2,ido,2
            tr2 = cc(i-1,2,k) + cc(i-1,3,k)
            cr2 = cc(i-1,1,k) + taur*tr2
            ch(i-1,k,1) = cc(i-1,1,k) + tr2
            ti2 = cc(i,2,k) + cc(i,3,k)
            ci2 = cc(i,1,k) + taur * ti2
            ch(i,k,1) = cc(i,1,k) + ti2
            cr3 = taui * (cc(i-1,2,k) - cc(i-1,3,k))
            ci3 = taui * (cc(i,2,k)   - cc(i,3,k))
            dr2 = cr2 - ci3
            dr3 = cr2 + ci3
            di2 = ci2 + cr3
            di3 = ci2 - cr3
            ch(i,k,2)   = wa1(i-1) * di2 + wa1(i) * dr2
            ch(i-1,k,2) = wa1(i-1) * dr2 - wa1(i) * di2
            ch(i,k,3)   = wa2(i-1) * di3 + wa2(i) * dr3
            ch(i-1,k,3) = wa2(i-1) * dr3 - wa2(i) * di3
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine passb4 (ido,l1,cc,ch,wa1,wa2,wa3)
c
      implicit real*8 (a-h,o-z)
      dimension cc(ido,4,l1),ch(ido,l1,4),wa1(1),wa2(1),wa3(1)
c
      if (ido .eq. 2) then
        do k=1,l1
          ti1 = cc(2,1,k) - cc(2,3,k)
          ti2 = cc(2,1,k) + cc(2,3,k)
          tr4 = cc(2,4,k) - cc(2,2,k)
          ti3 = cc(2,2,k) + cc(2,4,k)
          tr1 = cc(1,1,k) - cc(1,3,k)
          tr2 = cc(1,1,k) + cc(1,3,k)
          ti4 = cc(1,2,k) - cc(1,4,k)
          tr3 = cc(1,2,k) + cc(1,4,k)
          ch(1,k,1) = tr2 + tr3
          ch(1,k,3) = tr2 - tr3
          ch(2,k,1) = ti2 + ti3
          ch(2,k,3) = ti2 - ti3
          ch(1,k,2) = tr1 + tr4
          ch(1,k,4) = tr1 - tr4
          ch(2,k,2) = ti1 + ti4
          ch(2,k,4) = ti1 - ti4
        enddo
      else
        do k=1,l1
          do i=2,ido,2
            ti1 = cc(i,1,k)   - cc(i,3,k)
            ti2 = cc(i,1,k)   + cc(i,3,k)
            ti3 = cc(i,2,k)   + cc(i,4,k)
            tr4 = cc(i,4,k)   - cc(i,2,k)
            tr1 = cc(i-1,1,k) - cc(i-1,3,k)
            tr2 = cc(i-1,1,k) + cc(i-1,3,k)
            ti4 = cc(i-1,2,k) - cc(i-1,4,k)
            tr3 = cc(i-1,2,k) + cc(i-1,4,k)
            ch(i-1,k,1) = tr2 + tr3
            cr3 =         tr2 - tr3
            ch(i,k,1)   = ti2 + ti3
            ci3         = ti2 - ti3
            cr2         = tr1 + tr4
            cr4         = tr1 - tr4
            ci2         = ti1 + ti4
            ci4         = ti1 - ti4
            ch(i-1,k,2) = wa1(i-1) * cr2 - wa1(i) * ci2
            ch(i,k,2)   = wa1(i-1) * ci2 + wa1(i) * cr2
            ch(i-1,k,3) = wa2(i-1) * cr3 - wa2(i) * ci3
            ch(i,k,3)   = wa2(i-1) * ci3 + wa2(i) * cr3
            ch(i-1,k,4) = wa3(i-1) * cr4 - wa3(i) * ci4
            ch(i,k,4)   = wa3(i-1) * ci4 + wa3(i) * cr4
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine passb5 (ido,l1,cc,ch,wa1,wa2,wa3,wa4)
c
      implicit real*8 (a-h,o-z)
      dimension cc(ido,5,l1),ch(ido,l1,5),wa1(1),wa2(1),wa3(1),wa4(1)
c     *** tr11=cos(2*pi/5), ti11=sin(2*pi/5)
c     *** tr12=cos(4*pi/5), ti12=sin(4*pi/5)
      parameter (tr11 =  0.3090169943749474241d0,
     &           ti11 =  0.95105651629515357212d0,
     &           tr12 = -0.8090169943749474241d0,
     &           ti12 =  0.58778525229247312917d0)
c
      if (ido .eq. 2) then
        do k=1,l1
          ti5 = cc(2,2,k) - cc(2,5,k)
          ti2 = cc(2,2,k) + cc(2,5,k)
          ti4 = cc(2,3,k) - cc(2,4,k)
          ti3 = cc(2,3,k) + cc(2,4,k)
          tr5 = cc(1,2,k) - cc(1,5,k)
          tr2 = cc(1,2,k) + cc(1,5,k)
          tr4 = cc(1,3,k) - cc(1,4,k)
          tr3 = cc(1,3,k) + cc(1,4,k)
          ch(1,k,1) = cc(1,1,k) + tr2 + tr3
          ch(2,k,1) = cc(2,1,k) + ti2 + ti3
          cr2 = cc(1,1,k) + tr11 * tr2 + tr12 * tr3
          ci2 = cc(2,1,k) + tr11 * ti2 + tr12 * ti3
          cr3 = cc(1,1,k) + tr12 * tr2 + tr11 * tr3
          ci3 = cc(2,1,k) + tr12 * ti2 + tr11 * ti3
          cr5 =             ti11 * tr5 + ti12 * tr4
          ci5 =             ti11 * ti5 + ti12 * ti4
          cr4 =             ti12 * tr5 - ti11 * tr4
          ci4 =             ti12 * ti5 - ti11 * ti4
          ch(1,k,2) = cr2 - ci5
          ch(1,k,5) = cr2 + ci5
          ch(2,k,2) = ci2 + cr5
          ch(2,k,3) = ci3 + cr4
          ch(1,k,3) = cr3 - ci4
          ch(1,k,4) = cr3 + ci4
          ch(2,k,4) = ci3 - cr4
          ch(2,k,5) = ci2 - cr5
        enddo
      else
        do k=1,l1
          do i=2,ido,2
            ti5 = cc(i,2,k)   - cc(i,5,k)
            ti2 = cc(i,2,k)   + cc(i,5,k)
            ti4 = cc(i,3,k)   - cc(i,4,k)
            ti3 = cc(i,3,k)   + cc(i,4,k)
            tr5 = cc(i-1,2,k) - cc(i-1,5,k)
            tr2 = cc(i-1,2,k) + cc(i-1,5,k)
            tr4 = cc(i-1,3,k) - cc(i-1,4,k)
            tr3 = cc(i-1,3,k) + cc(i-1,4,k)
            ch(i-1,k,1) = cc(i-1,1,k) + tr2 + tr3
            ch(i,k,1)   = cc(i,1,k)   + ti2 + ti3
            cr2 = cc(i-1,1,k) + tr11 * tr2 + tr12 * tr3
            ci2 = cc(i,1,k)   + tr11 * ti2 + tr12 * ti3
            cr3 = cc(i-1,1,k) + tr12 * tr2 + tr11 * tr3
            ci3 = cc(i,1,k)   + tr12 * ti2 + tr11 * ti3
            cr5 =               ti11 * tr5 + ti12 * tr4
            ci5 =               ti11 * ti5 + ti12 * ti4
            cr4 =               ti12 * tr5 - ti11 * tr4
            ci4 =               ti12 * ti5 - ti11 * ti4
            dr3 = cr3 - ci4
            dr4 = cr3 + ci4
            di3 = ci3 + cr4
            di4 = ci3 - cr4
            dr5 = cr2 + ci5
            dr2 = cr2 - ci5
            di5 = ci2 - cr5
            di2 = ci2 + cr5
            ch(i-1,k,2) = wa1(i-1) * dr2 - wa1(i) * di2
            ch(i,k,2)   = wa1(i-1) * di2 + wa1(i) * dr2
            ch(i-1,k,3) = wa2(i-1) * dr3 - wa2(i) * di3
            ch(i,k,3)   = wa2(i-1) * di3 + wa2(i) * dr3
            ch(i-1,k,4) = wa3(i-1) * dr4 - wa3(i) * di4
            ch(i,k,4)   = wa3(i-1) * di4 + wa3(i) * dr4
            ch(i-1,k,5) = wa4(i-1) * dr5 - wa4(i) * di5
            ch(i,k,5)   = wa4(i-1) * di5 + wa4(i) * dr5
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine passb (nac,ido,ip,l1,idl1,cc,c1,c2,ch,ch2,wa)
c
      implicit real*8 (a-h,o-z)
      dimension  ch(ido,l1,ip),cc(ido,ip,l1),c1(ido,l1,ip),c2(idl1,ip),
     2           ch2(idl1,ip),wa(1)
c
      idot = ido/2
      nt = ip*idl1
      ipp2 = ip+2
      ipph = (ip+1)/2
      idp = ip*ido
c
      if (ido .ge. l1) then
        do j=2,ipph
          jc = ipp2-j
          do k=1,l1
            do i=1,ido
              ch(i,k,j)  = cc(i,j,k) + cc(i,jc,k)
              ch(i,k,jc) = cc(i,j,k) - cc(i,jc,k)
            enddo
          enddo
        enddo
        do k=1,l1
          do i=1,ido
            ch(i,k,1) = cc(i,1,k)
          enddo
        enddo
      else
        do j=2,ipph
          jc = ipp2-j
          do i=1,ido
            do k=1,l1
              ch(i,k,j)  = cc(i,j,k) + cc(i,jc,k)
              ch(i,k,jc) = cc(i,j,k) - cc(i,jc,k)
            enddo
          enddo
        enddo
        do i=1,ido
          do k=1,l1
            ch(i,k,1) = cc(i,1,k)
          enddo
        enddo
      endif
c
      idl = 2-ido
      inc = 0
      do l=2,ipph
        lc = ipp2-l
        idl = idl+ido
        do ik=1,idl1
          c2(ik,l)  = ch2(ik,1) + wa(idl-1) * ch2(ik,2)
          c2(ik,lc) =             wa(idl)   * ch2(ik,ip)
        enddo
        idlj = idl
        inc = inc+ido
        do j=3,ipph
          jc = ipp2-j
          idlj = idlj+inc
          if (idlj .gt. idp) idlj = idlj-idp
          war = wa(idlj-1)
          wai = wa(idlj)
          do ik=1,idl1
            c2(ik,l)  = c2(ik,l)  + war * ch2(ik,j)
            c2(ik,lc) = c2(ik,lc) + wai * ch2(ik,jc)
          enddo
        enddo
      enddo
      do j=2,ipph
        do ik=1,idl1
          ch2(ik,1) = ch2(ik,1) + ch2(ik,j)
        enddo
      enddo
      do j=2,ipph
        jc = ipp2-j
        do ik=2,idl1,2
          ch2(ik-1,j)  = c2(ik-1,j) - c2(ik,jc)
          ch2(ik-1,jc) = c2(ik-1,j) + c2(ik,jc)
          ch2(ik,j)    = c2(ik,j)   + c2(ik-1,jc)
          ch2(ik,jc)   = c2(ik,j)   - c2(ik-1,jc)
        enddo
      enddo
c
      nac = 1
      if (ido .ne. 2) then
        nac = 0
        do ik=1,idl1
          c2(ik,1) = ch2(ik,1)
        enddo
        do j=2,ip
          do k=1,l1
            c1(1,k,j) = ch(1,k,j)
            c1(2,k,j) = ch(2,k,j)
          enddo
        enddo
        if (idot .le. l1) then
          idij = 0
          do j=2,ip
            idij = idij+2
            do i=4,ido,2
              idij = idij+2
              do k=1,l1
                c1(i-1,k,j)= wa(idij-1)*ch(i-1,k,j)-wa(idij)*ch(i,k,j)
                c1(i,k,j)  = wa(idij-1)*ch(i,k,j)  +wa(idij)*ch(i-1,k,j)
              enddo
            enddo
          enddo
        else
          idj = 2-ido
          do j=2,ip
            idj = idj+ido
            do k=1,l1
              idij = idj
              do i=4,ido,2
                idij = idij+2
                c1(i-1,k,j)= wa(idij-1)*ch(i-1,k,j)-wa(idij)*ch(i,k,j)
                c1(i,k,j)  = wa(idij-1)*ch(i,k,j)  +wa(idij)*ch(i-1,k,j)
              enddo
            enddo
          enddo
        endif
      endif
c
      end
c======================================================================

      subroutine passf2 (ido,l1,cc,ch,wa1)
c
      implicit real*8 (a-h,o-z)
      dimension cc(ido,2,l1),ch(ido,l1,2),wa1(1)
c
      if (ido .le. 2) then
        do k=1,l1
          ch(1,k,1) = cc(1,1,k) + cc(1,2,k)
          ch(1,k,2) = cc(1,1,k) - cc(1,2,k)
          ch(2,k,1) = cc(2,1,k) + cc(2,2,k)
          ch(2,k,2) = cc(2,1,k) - cc(2,2,k)
        enddo
      else
        do k=1,l1
          do i=2,ido,2
            ch(i-1,k,1) = cc(i-1,1,k) + cc(i-1,2,k)
            tr2         = cc(i-1,1,k) - cc(i-1,2,k)
            ch(i,k,1)   = cc(i,1,k)   + cc(i,2,k)
            ti2         = cc(i,1,k)   - cc(i,2,k)
            ch(i,k,2)   = wa1(i-1) * ti2 - wa1(i) * tr2
            ch(i-1,k,2) = wa1(i-1) * tr2 + wa1(i) * ti2
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine passf3 (ido,l1,cc,ch,wa1,wa2)
c
      implicit real*8 (a-h,o-z)
      dimension cc(ido,3,l1),ch(ido,l1,3),wa1(1),wa2(1)
c     *** taui is -sqrt(3)/2 ***
      parameter (taur=-0.5d0,taui=-0.86602540378443864676d0)
c
      if (ido .eq. 2) then
        do k=1,l1
          tr2 = cc(1,2,k) + cc(1,3,k)
          cr2 = cc(1,1,k) + taur*tr2
          ch(1,k,1) = cc(1,1,k) + tr2
          ti2 = cc(2,2,k) + cc(2,3,k)
          ci2 = cc(2,1,k) + taur * ti2
          ch(2,k,1) = cc(2,1,k) + ti2
          cr3 = taui * (cc(1,2,k) - cc(1,3,k))
          ci3 = taui * (cc(2,2,k) - cc(2,3,k))
          ch(1,k,2) = cr2 - ci3
          ch(1,k,3) = cr2 + ci3
          ch(2,k,2) = ci2 + cr3
          ch(2,k,3) = ci2 - cr3
        enddo
      else
        do k=1,l1
          do i=2,ido,2
            tr2 = cc(i-1,2,k) + cc(i-1,3,k)
            cr2 = cc(i-1,1,k) + taur * tr2
            ch(i-1,k,1) = cc(i-1,1,k) + tr2
            ti2 = cc(i,2,k) + cc(i,3,k)
            ci2 = cc(i,1,k) + taur * ti2
            ch(i,k,1) = cc(i,1,k) + ti2
            cr3 = taui * (cc(i-1,2,k) - cc(i-1,3,k))
            ci3 = taui * (cc(i,2,k)   - cc(i,3,k))
            dr2 = cr2 - ci3
            dr3 = cr2 + ci3
            di2 = ci2 + cr3
            di3 = ci2 - cr3
            ch(i,k,2)   = wa1(i-1) * di2 - wa1(i) * dr2
            ch(i-1,k,2) = wa1(i-1) * dr2 + wa1(i) * di2
            ch(i,k,3)   = wa2(i-1) * di3 - wa2(i) * dr3
            ch(i-1,k,3) = wa2(i-1) * dr3 + wa2(i) * di3
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine passf4 (ido,l1,cc,ch,wa1,wa2,wa3)
c
      implicit real*8 (a-h,o-z)
      dimension cc(ido,4,l1),ch(ido,l1,4),wa1(1),wa2(1),wa3(1)
c
      if (ido .eq. 2) then
        do k=1,l1
          ti1 = cc(2,1,k) - cc(2,3,k)
          ti2 = cc(2,1,k) + cc(2,3,k)
          tr4 = cc(2,2,k) - cc(2,4,k)
          ti3 = cc(2,2,k) + cc(2,4,k)
          tr1 = cc(1,1,k) - cc(1,3,k)
          tr2 = cc(1,1,k) + cc(1,3,k)
          ti4 = cc(1,4,k) - cc(1,2,k)
          tr3 = cc(1,2,k) + cc(1,4,k)
          ch(1,k,1) = tr2 + tr3
          ch(1,k,3) = tr2 - tr3
          ch(2,k,1) = ti2 + ti3
          ch(2,k,3) = ti2 - ti3
          ch(1,k,2) = tr1 + tr4
          ch(1,k,4) = tr1 - tr4
          ch(2,k,2) = ti1 + ti4
          ch(2,k,4) = ti1 - ti4
        enddo
      else
        do k=1,l1
          do i=2,ido,2
            ti1 = cc(i,1,k)   - cc(i,3,k)
            ti2 = cc(i,1,k)   + cc(i,3,k)
            ti3 = cc(i,2,k)   + cc(i,4,k)
            tr4 = cc(i,2,k)   - cc(i,4,k)
            tr1 = cc(i-1,1,k) - cc(i-1,3,k)
            tr2 = cc(i-1,1,k) + cc(i-1,3,k)
            ti4 = cc(i-1,4,k) - cc(i-1,2,k)
            tr3 = cc(i-1,2,k) + cc(i-1,4,k)
            ch(i-1,k,1) = tr2 + tr3
            cr3 = tr2 - tr3
            ch(i,k,1) = ti2 + ti3
            ci3 = ti2 - ti3
            cr2 = tr1 + tr4
            cr4 = tr1 - tr4
            ci2 = ti1 + ti4
            ci4 = ti1 - ti4
            ch(i-1,k,2) = wa1(i-1) * cr2 + wa1(i) * ci2
            ch(i,k,2)   = wa1(i-1) * ci2 - wa1(i) * cr2
            ch(i-1,k,3) = wa2(i-1) * cr3 + wa2(i) * ci3
            ch(i,k,3)   = wa2(i-1) * ci3 - wa2(i) * cr3
            ch(i-1,k,4) = wa3(i-1) * cr4 + wa3(i) * ci4
            ch(i,k,4)   = wa3(i-1) * ci4 - wa3(i) * cr4
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine passf5 (ido,l1,cc,ch,wa1,wa2,wa3,wa4)
c
      implicit real*8 (a-h,o-z)
      dimension cc(ido,5,l1),ch(ido,l1,5),wa1(1),wa2(1),wa3(1),wa4(1)
c     *** tr11=cos(2*pi/5), ti11=-sin(2*pi/5)
c     *** tr12=-cos(4*pi/5), ti12=-sin(4*pi/5)
      parameter (tr11 =  0.3090169943749474241d0,
     &           ti11 = -0.95105651629515357212d0,
     &           tr12 = -0.8090169943749474241d0,
     &           ti12 = -0.58778525229247312917d0)
c
      if (ido .eq. 2) then
        do k=1,l1
          ti5 = cc(2,2,k) - cc(2,5,k)
          ti2 = cc(2,2,k) + cc(2,5,k)
          ti4 = cc(2,3,k) - cc(2,4,k)
          ti3 = cc(2,3,k) + cc(2,4,k)
          tr5 = cc(1,2,k) - cc(1,5,k)
          tr2 = cc(1,2,k) + cc(1,5,k)
          tr4 = cc(1,3,k) - cc(1,4,k)
          tr3 = cc(1,3,k) + cc(1,4,k)
          ch(1,k,1) = cc(1,1,k) + tr2 + tr3
          ch(2,k,1) = cc(2,1,k) + ti2 + ti3
          cr2 = cc(1,1,k) + tr11 * tr2 + tr12 * tr3
          ci2 = cc(2,1,k) + tr11 * ti2 + tr12 * ti3
          cr3 = cc(1,1,k) + tr12 * tr2 + tr11 * tr3
          ci3 = cc(2,1,k) + tr12 * ti2 + tr11 * ti3
          cr5 =             ti11 * tr5 + ti12 * tr4
          ci5 =             ti11 * ti5 + ti12 * ti4
          cr4 =             ti12 * tr5 - ti11 * tr4
          ci4 =             ti12 * ti5 - ti11 * ti4
          ch(1,k,2) = cr2 - ci5
          ch(1,k,5) = cr2 + ci5
          ch(2,k,2) = ci2 + cr5
          ch(2,k,3) = ci3 + cr4
          ch(1,k,3) = cr3 - ci4
          ch(1,k,4) = cr3 + ci4
          ch(2,k,4) = ci3 - cr4
          ch(2,k,5) = ci2 - cr5
        enddo
      else
        do k=1,l1
          do i=2,ido,2
            ti5 = cc(i,2,k)  - cc(i,5,k)
            ti2 = cc(i,2,k)  + cc(i,5,k)
            ti4 = cc(i,3,k)  - cc(i,4,k)
            ti3 = cc(i,3,k)  + cc(i,4,k)
            tr5 = cc(i-1,2,k)- cc(i-1,5,k)
            tr2 = cc(i-1,2,k)+ cc(i-1,5,k)
            tr4 = cc(i-1,3,k)- cc(i-1,4,k)
            tr3 = cc(i-1,3,k)+ cc(i-1,4,k)
            ch(i-1,k,1) = cc(i-1,1,k)+ tr2 + tr3
            ch(i,k,1)   = cc(i,1,k)  + ti2 + ti3
            cr2 = cc(i-1,1,k) + tr11 * tr2 + tr12 * tr3
            ci2 = cc(i,1,k)   + tr11 * ti2 + tr12 * ti3
            cr3 = cc(i-1,1,k) + tr12 * tr2 + tr11 * tr3
            ci3 = cc(i,1,k)   + tr12 * ti2 + tr11 * ti3
            cr5 =               ti11 * tr5 + ti12 * tr4
            ci5 =               ti11 * ti5 + ti12 * ti4
            cr4 =               ti12 * tr5 - ti11 * tr4
            ci4 =               ti12 * ti5 - ti11 * ti4
            dr3 = cr3 - ci4
            dr4 = cr3 + ci4
            di3 = ci3 + cr4
            di4 = ci3 - cr4
            dr5 = cr2 + ci5
            dr2 = cr2 - ci5
            di5 = ci2 - cr5
            di2 = ci2 + cr5
            ch(i-1,k,2) = wa1(i-1) * dr2 + wa1(i) * di2
            ch(i,k,2)   = wa1(i-1) * di2 - wa1(i) * dr2
            ch(i-1,k,3) = wa2(i-1) * dr3 + wa2(i) * di3
            ch(i,k,3)   = wa2(i-1) * di3 - wa2(i) * dr3
            ch(i-1,k,4) = wa3(i-1) * dr4 + wa3(i) * di4
            ch(i,k,4)   = wa3(i-1) * di4 - wa3(i) * dr4
            ch(i-1,k,5) = wa4(i-1) * dr5 + wa4(i) * di5
            ch(i,k,5)   = wa4(i-1) * di5 - wa4(i) * dr5
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine passf (nac,ido,ip,l1,idl1,cc,c1,c2,ch,ch2,wa)
c
      implicit real*8 (a-h,o-z)
      dimension ch(ido,l1,ip),cc(ido,ip,l1),c1(ido,l1,ip),c2(idl1,ip),
     2          ch2(idl1,ip),wa(1)
c
      nac=0
      idot = ido/2
      nt = ip*idl1
      ipp2 = ip+2
      ipph = (ip+1)/2
      idp = ip*ido
c
      if (ido .ge. l1) then
        do j=2,ipph
          jc = ipp2-j
          do k=1,l1
            do i=1,ido
              ch(i,k,j)  = cc(i,j,k) + cc(i,jc,k)
              ch(i,k,jc) = cc(i,j,k) - cc(i,jc,k)
            enddo
          enddo
        enddo
        do k=1,l1
          do i=1,ido
            ch(i,k,1) = cc(i,1,k)
          enddo
        enddo
      else
        do j=2,ipph
          jc = ipp2-j
          do i=1,ido
            do k=1,l1
              ch(i,k,j)  = cc(i,j,k) + cc(i,jc,k)
              ch(i,k,jc) = cc(i,j,k) - cc(i,jc,k)
            enddo
          enddo
        enddo
        do i=1,ido
          do k=1,l1
            ch(i,k,1) = cc(i,1,k)
          enddo
        enddo
      endif
c
      idl = 2-ido
      inc = 0
      do l=2,ipph
        lc = ipp2-l
        idl = idl+ido
        do ik=1,idl1
          c2(ik,l)  = ch2(ik,1)+ wa(idl-1) * ch2(ik,2)
          c2(ik,lc) =          - wa(idl)   * ch2(ik,ip)
        enddo
        idlj = idl
        inc = inc+ido
        do j=3,ipph
          jc = ipp2-j
          idlj = idlj+inc
          if (idlj .gt. idp) idlj = idlj-idp
          war = wa(idlj-1)
          wai = wa(idlj)
          do ik=1,idl1
            c2(ik,l)  = c2(ik,l)  + war * ch2(ik,j)
            c2(ik,lc) = c2(ik,lc) - wai * ch2(ik,jc)
          enddo
        enddo
      enddo
      do j=2,ipph
        do ik=1,idl1
          ch2(ik,1) = ch2(ik,1) + ch2(ik,j)
        enddo
      enddo
      do j=2,ipph
        jc = ipp2-j
        do ik=2,idl1,2
          ch2(ik-1,j)  = c2(ik-1,j) - c2(ik,jc)
          ch2(ik-1,jc) = c2(ik-1,j) + c2(ik,jc)
          ch2(ik,j)    = c2(ik,j)   + c2(ik-1,jc)
          ch2(ik,jc)   = c2(ik,j)   - c2(ik-1,jc)
        enddo
      enddo
c
      nac = 1
      if (ido .ne. 2) then
        nac = 0
        do ik=1,idl1
          c2(ik,1) = ch2(ik,1)
        enddo
        do j=2,ip
          do k=1,l1
            c1(1,k,j) = ch(1,k,j)
            c1(2,k,j) = ch(2,k,j)
          enddo
        enddo
        if (idot .le. l1) then
          idij = 0
          do j=2,ip
            idij = idij+2
            do i=4,ido,2
              idij = idij+2
              do k=1,l1
                c1(i-1,k,j)= wa(idij-1)*ch(i-1,k,j)+wa(idij)*ch(i,k,j)
                c1(i,k,j)  = wa(idij-1)*ch(i,k,j)  -wa(idij)*ch(i-1,k,j)
              enddo
            enddo
          enddo
        else
          idj = 2-ido
          do j=2,ip
            idj = idj+ido
            do k=1,l1
              idij = idj
              do i=4,ido,2
                idij = idij+2
                c1(i-1,k,j)= wa(idij-1)*ch(i-1,k,j)+wa(idij)*ch(i,k,j)
                c1(i,k,j)  = wa(idij-1)*ch(i,k,j)  -wa(idij)*ch(i-1,k,j)
              enddo
            enddo
          enddo
        endif
      endif
c
      end
c======================================================================

      subroutine vpassb2 (mi,mf,ms,ido,l1,cc,ch,mdimc,wa1)
c
      implicit real*8 (a-h,o-z)
      dimension cc(2*mdimc*ido*2*l1),ch(2*mdimc*ido*l1*2),wa1(1)
c
      mdc2=2*mdimc
      inc=(ido+ido)*mdc2
      idomc=ido*mdc2
      idol1mc=ido*l1*mdc2
      mic=2*(mi-1)+1
      mfc=2*mf
      msc=2*ms
      if (ido .le. 2) then
        i1k=-inc
        i2k=i1k+idomc
        ik1=-idomc
        ik2=ik1+idol1mc
        do k=1,l1
          i1k=i1k+inc
          i2k=i2k+inc
          ik1=ik1+idomc
          ik2=ik2+idomc
          do m=mic,mfc,msc
            ch(m+ik1) = cc(m+i1k) + cc(m+i2k)
            ch(m+ik2) = cc(m+i1k) - cc(m+i2k)
            ch(m+1+ik1) = cc(m+1+i1k) + cc(m+1+i2k)
            ch(m+1+ik2) = cc(m+1+i1k) - cc(m+1+i2k)
          enddo
        enddo
      else
        iw=0
        do i=0,idomc-1,mdc2
          iw=iw+2
          wa1w=wa1(iw)
          wa1w1=wa1(iw-1)
          i1k=i-inc
          i2k=i1k+idomc
          ik1=i-idomc
          ik2=ik1+idol1mc
          do k=1,l1
            i1k=i1k+inc
            i2k=i2k+inc
            ik1=ik1+idomc
            ik2=ik2+idomc
            do m=mic,mfc,msc
              ch(m+ik1) = cc(m+i1k) + cc(m+i2k)
              ch(m+1+ik1) = cc(m+1+i1k) + cc(m+1+i2k)
              tr2           = cc(m+i1k) - cc(m+i2k)
              ti2           = cc(m+1+i1k) - cc(m+1+i2k)
              ch(m+ik2) = wa1w1* tr2 - wa1w * ti2
              ch(m+1+ik2) = wa1w1* ti2 + wa1w * tr2
            enddo
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine vpassb3 (mi,mf,ms,ido,l1,cc,ch,mdimc,wa1,wa2)
c
      implicit real*8 (a-h,o-z)
      dimension  cc(2*mdimc*ido*3*l1),ch(2*mdimc*ido*l1*3),
     1           wa1(1),wa2(1)
c     *** taui is sqrt(3)/2 ***
      parameter (taur=-0.5d0,taui=0.86602540378443864676d0)
c
      mdc2=2*mdimc
      inc=3*ido*mdc2
      idomc=ido*mdc2
      idol1mc=ido*l1*mdc2
      mic=2*(mi-1)+1
      mfc=2*mf
      msc=2*ms
      if (ido .eq. 2) then
        i1k=-inc
        i2k=i1k+idomc
        i3k=i2k+idomc
        ik1=-idomc
        ik2=ik1+idol1mc
        ik3=ik2+idol1mc
        do k=1,l1
          i1k=i1k+inc
          i2k=i2k+inc
          i3k=i3k+inc
          ik1=ik1+idomc
          ik2=ik2+idomc
          ik3=ik3+idomc
          do m=mic,mfc,msc
            tr2 = cc(m+i2k)+cc(m+i3k)
            cr2 = cc(m+i1k)+taur*tr2
            ch(m+ik1) = cc(m+i1k)+tr2
            ti2 = cc(m+1+i2k)+cc(m+1+i3k)
            ci2 = cc(m+1+i1k)+taur*ti2
            ch(m+1+ik1) = cc(m+1+i1k)+ti2
            cr3 = taui*(cc(m+i2k)-cc(m+i3k))
            ci3 = taui*(cc(m+1+i2k)-cc(m+1+i3k))
            ch(m+ik2) = cr2-ci3
            ch(m+ik3) = cr2+ci3
            ch(m+1+ik2) = ci2+cr3
            ch(m+1+ik3) = ci2-cr3
          enddo
        enddo
      else
        iw=0
        do i=0,idomc-1,mdc2
          iw=iw+2
          wa1w=wa1(iw)
          wa1w1=wa1(iw-1)
          wa2w=wa2(iw)
          wa2w1=wa2(iw-1)
          i1k=i-inc
          i2k=i1k+idomc
          i3k=i2k+idomc
          ik1=i-idomc
          ik2=ik1+idol1mc
          ik3=ik2+idol1mc
          do k=1,l1
            i1k=i1k+inc
            i2k=i2k+inc
            i3k=i3k+inc
            ik1=ik1+idomc
            ik2=ik2+idomc
            ik3=ik3+idomc
            do m=mic,mfc,msc
              tr2 = cc(m+i2k)+cc(m+i3k)
              cr2 = cc(m+i1k)+taur*tr2
              ch(m+ik1) = cc(m+i1k)+tr2
              ti2 = cc(m+1+i2k)+cc(m+1+i3k)
              ci2 = cc(m+1+i1k)+taur*ti2
              ch(m+1+ik1) = cc(m+1+i1k)+ti2
              cr3 = taui*(cc(m+i2k)-cc(m+i3k))
              ci3 = taui*(cc(m+1+i2k)-cc(m+1+i3k))
              dr2 = cr2-ci3
              dr3 = cr2+ci3
              di2 = ci2+cr3
              di3 = ci2-cr3
              ch(m+1+ik2) = wa1w1*di2+wa1w*dr2
              ch(m+ik2) = wa1w1*dr2-wa1w*di2
              ch(m+1+ik3) = wa2w1*di3+wa2w*dr3
              ch(m+ik3) = wa2w1*dr3-wa2w*di3
            enddo
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine vpassb4 (mi,mf,ms,ido,l1,cc,ch,mdimc,wa1,wa2,wa3)
c
      implicit real*8 (a-h,o-z)
      dimension cc(2*mdimc*ido*4*l1),ch(2*mdimc*ido*l1*4),
     1          wa1(1),wa2(1),wa3(1)
c
      mdc2=2*mdimc
      inc=4*ido*mdc2
      idomc=ido*mdc2
      idol1mc=ido*l1*mdc2
      mic=2*(mi-1)+1
      mfc=2*mf
      msc=2*ms
      if (ido .eq. 2) then
        i1k=-inc
        i2k=i1k+idomc
        i3k=i2k+idomc
        i4k=i3k+idomc
        ik1=-idomc
        ik2=ik1+idol1mc
        ik3=ik2+idol1mc
        ik4=ik3+idol1mc
        do k=1,l1
          i1k=i1k+inc
          i2k=i2k+inc
          i3k=i3k+inc
          i4k=i4k+inc
          ik1=ik1+idomc
          ik2=ik2+idomc
          ik3=ik3+idomc
          ik4=ik4+idomc
          do m=mic,mfc,msc
            ti1 = cc(m+1+i1k)-cc(m+1+i3k)
            ti2 = cc(m+1+i1k)+cc(m+1+i3k)
            tr4 = cc(m+1+i4k)-cc(m+1+i2k)
            ti3 = cc(m+1+i2k)+cc(m+1+i4k)
            tr1 = cc(m+i1k)-cc(m+i3k)
            tr2 = cc(m+i1k)+cc(m+i3k)
            ti4 = cc(m+i2k)-cc(m+i4k)
            tr3 = cc(m+i2k)+cc(m+i4k)
            ch(m+ik1) = tr2+tr3
            ch(m+ik3) = tr2-tr3
            ch(m+1+ik1) = ti2+ti3
            ch(m+1+ik3) = ti2-ti3
            ch(m+ik2) = tr1+tr4
            ch(m+ik4) = tr1-tr4
            ch(m+1+ik2) = ti1+ti4
            ch(m+1+ik4) = ti1-ti4
          enddo
        enddo
      else
        iw=0
        do i=0,idomc-1,mdc2
          iw=iw+2
          wa1w=wa1(iw)
          wa1w1=wa1(iw-1)
          wa2w=wa2(iw)
          wa2w1=wa2(iw-1)
          wa3w=wa3(iw)
          wa3w1=wa3(iw-1)
          i1k=i-inc
          i2k=i1k+idomc
          i3k=i2k+idomc
          i4k=i3k+idomc
          ik1=i-idomc
          ik2=ik1+idol1mc
          ik3=ik2+idol1mc
          ik4=ik3+idol1mc
          do k=1,l1
            i1k=i1k+inc
            i2k=i2k+inc
            i3k=i3k+inc
            i4k=i4k+inc
            ik1=ik1+idomc
            ik2=ik2+idomc
            ik3=ik3+idomc
            ik4=ik4+idomc
            do m=mic,mfc,msc
              ti1 = cc(m+1+i1k)-cc(m+1+i3k)
              ti2 = cc(m+1+i1k)+cc(m+1+i3k)
              ti3 = cc(m+1+i2k)+cc(m+1+i4k)
              tr4 = cc(m+1+i4k)-cc(m+1+i2k)
              tr1 = cc(m+i1k)-cc(m+i3k)
              tr2 = cc(m+i1k)+cc(m+i3k)
              tr3 = cc(m+i2k)+cc(m+i4k)
              ti4 = cc(m+i2k)-cc(m+i4k)
              ch(m+ik1) = tr2+tr3
              cr3 = tr2-tr3
              ch(m+1+ik1) = ti2+ti3
              ci3 = ti2-ti3
              cr2 = tr1+tr4
              cr4 = tr1-tr4
              ci2 = ti1+ti4
              ci4 = ti1-ti4
              ch(m+ik2) = wa1w1*cr2-wa1w*ci2
              ch(m+1+ik2) = wa1w1*ci2+wa1w*cr2
              ch(m+ik3) = wa2w1*cr3-wa2w*ci3
              ch(m+1+ik3) = wa2w1*ci3+wa2w*cr3
              ch(m+ik4) = wa3w1*cr4-wa3w*ci4
              ch(m+1+ik4) = wa3w1*ci4+wa3w*cr4
            enddo
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine vpassb5 (mi,mf,ms,ido,l1,cc,ch,mdimc,wa1,wa2,wa3,wa4)
c
      implicit real*8 (a-h,o-z)
      dimension cc(2*mdimc*ido*5*l1),ch(2*mdimc*ido*l1*5),
     1          wa1(1),wa2(1),wa3(1),wa4(1)
c     *** tr11=cos(2*pi/5), ti11=sin(2*pi/5)
c     *** tr12=cos(4*pi/5), ti12=sin(4*pi/5)
      parameter (tr11= 0.3090169943749474241d0,
     &           ti11= 0.95105651629515357212d0,
     &           tr12=-0.8090169943749474241d0,
     &           ti12= 0.58778525229247312917d0)
c
      mdc2=2*mdimc
      inc=5*ido*mdc2
      idomc=ido*mdc2
      idol1mc=ido*l1*mdc2
      mic=2*(mi-1)+1
      mfc=2*mf
      msc=2*ms
      if (ido .eq. 2) then
        i1k=-inc
        i2k=i1k+idomc
        i3k=i2k+idomc
        i4k=i3k+idomc
        i5k=i4k+idomc
        ik1=-idomc
        ik2=ik1+idol1mc
        ik3=ik2+idol1mc
        ik4=ik3+idol1mc
        ik5=ik4+idol1mc
        do k=1,l1
          i1k=i1k+inc
          i2k=i2k+inc
          i3k=i3k+inc
          i4k=i4k+inc
          i5k=i5k+inc
          ik1=ik1+idomc
          ik2=ik2+idomc
          ik3=ik3+idomc
          ik4=ik4+idomc
          ik5=ik5+idomc
          do m=mic,mfc,msc
            ti5 = cc(m+1+i2k)-cc(m+1+i5k)
            ti2 = cc(m+1+i2k)+cc(m+1+i5k)
            ti4 = cc(m+1+i3k)-cc(m+1+i4k)
            ti3 = cc(m+1+i3k)+cc(m+1+i4k)
            tr5 = cc(m+i2k)-cc(m+i5k)
            tr2 = cc(m+i2k)+cc(m+i5k)
            tr4 = cc(m+i3k)-cc(m+i4k)
            tr3 = cc(m+i3k)+cc(m+i4k)
            ch(m+ik1) = cc(m+i1k)+tr2+tr3
            ch(m+1+ik1) = cc(m+1+i1k)+ti2+ti3
            cr2 = cc(m+i1k)+tr11*tr2+tr12*tr3
            ci2 = cc(m+1+i1k)+tr11*ti2+tr12*ti3
            cr3 = cc(m+i1k)+tr12*tr2+tr11*tr3
            ci3 = cc(m+1+i1k)+tr12*ti2+tr11*ti3
            cr5 = ti11*tr5+ti12*tr4
            ci5 = ti11*ti5+ti12*ti4
            cr4 = ti12*tr5-ti11*tr4
            ci4 = ti12*ti5-ti11*ti4
            ch(m+ik2) = cr2-ci5
            ch(m+ik5) = cr2+ci5
            ch(m+1+ik2) = ci2+cr5
            ch(m+1+ik3) = ci3+cr4
            ch(m+ik3) = cr3-ci4
            ch(m+ik4) = cr3+ci4
            ch(m+1+ik4) = ci3-cr4
            ch(m+1+ik5) = ci2-cr5
          enddo
        enddo
      else
        iw=0
        do i=0,idomc-1,mdc2
          iw=iw+2
          wa1w=wa1(iw)
          wa1w1=wa1(iw-1)
          wa2w=wa2(iw)
          wa2w1=wa2(iw-1)
          wa3w=wa3(iw)
          wa3w1=wa3(iw-1)
          wa4w=wa4(iw)
          wa4w1=wa4(iw-1)
          i1k=i-inc
          i2k=i1k+idomc
          i3k=i2k+idomc
          i4k=i3k+idomc
          i5k=i4k+idomc
          ik1=i-idomc
          ik2=ik1+idol1mc
          ik3=ik2+idol1mc
          ik4=ik3+idol1mc
          ik5=ik4+idol1mc
          do k=1,l1
            i1k=i1k+inc
            i2k=i2k+inc
            i3k=i3k+inc
            i4k=i4k+inc
            i5k=i5k+inc
            ik1=ik1+idomc
            ik2=ik2+idomc
            ik3=ik3+idomc
            ik4=ik4+idomc
            ik5=ik5+idomc
            do m=mic,mfc,msc
              ti5 = cc(m+1+i2k)-cc(m+1+i5k)
              ti2 = cc(m+1+i2k)+cc(m+1+i5k)
              ti4 = cc(m+1+i3k)-cc(m+1+i4k)
              ti3 = cc(m+1+i3k)+cc(m+1+i4k)
              tr5 = cc(m+i2k)-cc(m+i5k)
              tr2 = cc(m+i2k)+cc(m+i5k)
              tr4 = cc(m+i3k)-cc(m+i4k)
              tr3 = cc(m+i3k)+cc(m+i4k)
              ch(m+ik1) = cc(m+i1k)+tr2+tr3
              ch(m+1+ik1) = cc(m+1+i1k)+ti2+ti3
              cr2 = cc(m+i1k)+tr11*tr2+tr12*tr3
              ci2 = cc(m+1+i1k)+tr11*ti2+tr12*ti3
              cr3 = cc(m+i1k)+tr12*tr2+tr11*tr3
              ci3 = cc(m+1+i1k)+tr12*ti2+tr11*ti3
              cr5 = ti11*tr5+ti12*tr4
              ci5 = ti11*ti5+ti12*ti4
              cr4 = ti12*tr5-ti11*tr4
              ci4 = ti12*ti5-ti11*ti4
              dr3 = cr3-ci4
              dr4 = cr3+ci4
              di3 = ci3+cr4
              di4 = ci3-cr4
              dr5 = cr2+ci5
              dr2 = cr2-ci5
              di5 = ci2-cr5
              di2 = ci2+cr5
              ch(m+ik2) = wa1w1*dr2-wa1w*di2
              ch(m+1+ik2) = wa1w1*di2+wa1w*dr2
              ch(m+ik3) = wa2w1*dr3-wa2w*di3
              ch(m+1+ik3) = wa2w1*di3+wa2w*dr3
              ch(m+ik4) = wa3w1*dr4-wa3w*di4
              ch(m+1+ik4) = wa3w1*di4+wa3w*dr4
              ch(m+ik5) = wa4w1*dr5-wa4w*di5
              ch(m+1+ik5) = wa4w1*di5+wa4w*dr5
            enddo
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine vpassb (nac,mi,mf,ms,ido,ip,l1,idl1,cc,c1,c2,ch,ch2,
     &                   mdimc,wa)
c
      implicit real*8 (a-h,o-z)
      dimension ch(2,mdimc,ido,l1,ip),cc(2,mdimc,ido,ip,l1),
     1          c1(2,mdimc,ido,l1,ip),c2(2,mdimc,idl1,ip),
     2          ch2(2,mdimc,idl1,ip),wa(1)
c
      ido2=ido+ido
      idot = ido
      ipp2 = ip+2
      ipph = (ip+1)/2
      idp = ip*ido2
c
      if (ido .ge. l1) then
        do j=2,ipph
          jc = ipp2-j
          do k=1,l1
            do i=1,ido
              do m=mi,mf,ms
                ch(1,m,i,k,j)  = cc(1,m,i,j,k) + cc(1,m,i,jc,k)
                ch(2,m,i,k,j)  = cc(2,m,i,j,k) + cc(2,m,i,jc,k)
                ch(1,m,i,k,jc) = cc(1,m,i,j,k) - cc(1,m,i,jc,k)
                ch(2,m,i,k,jc) = cc(2,m,i,j,k) - cc(2,m,i,jc,k)
              enddo
            enddo
          enddo
        enddo
        do k=1,l1
          do i=1,ido
            do m=mi,mf,ms
              ch(1,m,i,k,1) = cc(1,m,i,1,k)
              ch(2,m,i,k,1) = cc(2,m,i,1,k)
            enddo
          enddo
        enddo
      else
        do j=2,ipph
          jc = ipp2-j
          do i=1,ido
            do k=1,l1
              do m=mi,mf,ms
                ch(1,m,i,k,j)  = cc(1,m,i,j,k) + cc(1,m,i,jc,k)
                ch(2,m,i,k,j)  = cc(2,m,i,j,k) + cc(2,m,i,jc,k)
                ch(1,m,i,k,jc) = cc(1,m,i,j,k) - cc(1,m,i,jc,k)
                ch(2,m,i,k,jc) = cc(2,m,i,j,k) - cc(2,m,i,jc,k)
              enddo
            enddo
          enddo
        enddo
        do i=1,ido
          do k=1,l1
            do m=mi,mf,ms
              ch(1,m,i,k,1) = cc(1,m,i,1,k)
              ch(2,m,i,k,1) = cc(2,m,i,1,k)
            enddo
          enddo
        enddo
      endif
c
      idl = 2-ido2
      inc = 0
      do l=2,ipph
        lc = ipp2-l
        idl = idl+ido2
        waidl=wa(idl)
        waidl1=wa(idl-1)
        do ik=1,idl1
          do m=mi,mf,ms
            c2(1,m,ik,l)  = ch2(1,m,ik,1) + waidl1 * ch2(1,m,ik,2)
            c2(2,m,ik,l)  = ch2(2,m,ik,1) + waidl1 * ch2(2,m,ik,2)
            c2(1,m,ik,lc) =                 waidl   * ch2(1,m,ik,ip)
            c2(2,m,ik,lc) =                 waidl   * ch2(2,m,ik,ip)
          enddo
        enddo
        idlj = idl
        inc = inc+ido2
        do j=3,ipph
          jc = ipp2-j
          idlj = idlj+inc
          if (idlj .gt. idp) idlj = idlj-idp
          war = wa(idlj-1)
          wai = wa(idlj)
          do ik=1,idl1
            do m=mi,mf,ms
              c2(1,m,ik,l)  = c2(1,m,ik,l)  + war * ch2(1,m,ik,j)
              c2(2,m,ik,l)  = c2(2,m,ik,l)  + war * ch2(2,m,ik,j)
              c2(1,m,ik,lc) = c2(1,m,ik,lc) + wai * ch2(1,m,ik,jc)
              c2(2,m,ik,lc) = c2(2,m,ik,lc) + wai * ch2(2,m,ik,jc)
            enddo
          enddo
        enddo
      enddo
      do j=2,ipph
        do ik=1,idl1
          do m=mi,mf,ms
            ch2(1,m,ik,1) = ch2(1,m,ik,1) + ch2(1,m,ik,j)
            ch2(2,m,ik,1) = ch2(2,m,ik,1) + ch2(2,m,ik,j)
          enddo
        enddo
      enddo
      do j=2,ipph
        jc = ipp2-j
        do ik=1,idl1
          do m=mi,mf,ms
            ch2(1,m,ik,j)  = c2(1,m,ik,j) - c2(2,m,ik,jc)
            ch2(1,m,ik,jc) = c2(1,m,ik,j) + c2(2,m,ik,jc)
            ch2(2,m,ik,j)  = c2(2,m,ik,j) + c2(1,m,ik,jc)
            ch2(2,m,ik,jc) = c2(2,m,ik,j) - c2(1,m,ik,jc)
          enddo
        enddo
      enddo
c
      nac = 1
      if (ido .ne. 1) then
        nac = 0
        do ik=1,idl1
          do m=mi,mf,ms
            c2(1,m,ik,1) = ch2(1,m,ik,1)
            c2(2,m,ik,1) = ch2(2,m,ik,1)
          enddo
        enddo
        do j=2,ip
          do k=1,l1
            do m=mi,mf,ms
              c1(1,m,1,k,j) = ch(1,m,1,k,j)
              c1(2,m,1,k,j) = ch(2,m,1,k,j)
            enddo
          enddo
        enddo
        if (idot .le. l1) then
          idij = 0
          do j=2,ip
            idij = idij+2
            do i=2,ido
              idij = idij+2
              waidij=wa(idij)
              waidij1=wa(idij-1)
              do k=1,l1
                do m=mi,mf,ms
                  c1(1,m,i,k,j) = waidij1 * ch(1,m,i,k,j)
     &                           -waidij   * ch(2,m,i,k,j)
                  c1(2,m,i,k,j) = waidij1 * ch(2,m,i,k,j)
     &                           +waidij   * ch(1,m,i,k,j)
                enddo
              enddo
            enddo
          enddo
        else
          idj = 2-ido2
          do j=2,ip
            idj = idj+ido2
            do k=1,l1
              idij = idj
              do i=2,ido
                idij = idij+2
                waidij=wa(idij)
                waidij1=wa(idij-1)
                do m=mi,mf,ms
                  c1(1,m,i,k,j) = waidij1 * ch(1,m,i,k,j)
     &                           -waidij   * ch(2,m,i,k,j)
                  c1(2,m,i,k,j) = waidij1 * ch(2,m,i,k,j)
     &                           +waidij   * ch(1,m,i,k,j)
                enddo
              enddo
            enddo
          enddo
        endif
      endif
c
      end
c======================================================================

      subroutine vpassf2 (mi,mf,ms,ido,l1,cc,ch,mdimc,wa1)
c
      implicit real*8 (a-h,o-z)
      dimension cc(2*mdimc*ido*2*l1),ch(2*mdimc*ido*l1*2),wa1(1)
c
      mdc2=2*mdimc
      inc=(ido+ido)*mdc2
      idomc=ido*mdc2
      idol1mc=ido*l1*mdc2
      mic=2*(mi-1)+1
      mfc=2*mf
      msc=2*ms
      if (ido .le. 1) then
        i1k=-inc
        i2k=i1k+idomc
        ik1=-idomc
        ik2=ik1+idol1mc
        do k=1,l1
          i1k=i1k+inc
          i2k=i2k+inc
          ik1=ik1+idomc
          ik2=ik2+idomc
          do m=mic,mfc,msc
            ch(m+ik1) = cc(m+i1k)+cc(m+i2k)
            ch(m+ik2) = cc(m+i1k)-cc(m+i2k)
            ch(m+1+ik1) = cc(m+1+i1k)+cc(m+1+i2k)
            ch(m+1+ik2) = cc(m+1+i1k)-cc(m+1+i2k)
          enddo
        enddo
      else
        iw=0
        do i=0,idomc-1,mdc2
          iw=iw+2
          wa1w=wa1(iw)
          wa1w1=wa1(iw-1)
          i1k=i-inc
          i2k=i1k+idomc
          ik1=i-idomc
          ik2=ik1+idol1mc
          do k=1,l1
            i1k=i1k+inc
            i2k=i2k+inc
            ik1=ik1+idomc
            ik2=ik2+idomc
            do m=mic,mfc,msc
              tr2 =           cc(m+i1k)-cc(m+i2k)
              ti2 =           cc(m+1+i1k)-cc(m+1+i2k)
              ch(m+ik1) = cc(m+i1k)+cc(m+i2k)
              ch(m+1+ik1) = cc(m+1+i1k)+cc(m+1+i2k)
              ch(m+1+ik2) = wa1w1*ti2-wa1w*tr2
              ch(m+ik2) = wa1w1*tr2+wa1w*ti2
            enddo
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine vpassf3 (mi,mf,ms,ido,l1,cc,ch,mdimc,wa1,wa2)
c
      implicit real*8 (a-h,o-z)
      dimension cc(2*mdimc*ido*3*l1),ch(2*mdimc*ido*l1*3),wa1(1),wa2(1)
c     *** taui is -sqrt(3)/2 ***
      parameter (taur=-0.5d0,taui=-0.86602540378443864676d0)
c
      mdc2=2*mdimc
      inc=3*ido*mdc2
      idomc=ido*mdc2
      idol1mc=ido*l1*mdc2
      mic=2*(mi-1)+1
      mfc=2*mf
      msc=2*ms
      if (ido .eq. 1) then
        i1k=-inc
        i2k=i1k+idomc
        i3k=i2k+idomc
        ik1=-idomc
        ik2=ik1+idol1mc
        ik3=ik2+idol1mc
        do k=1,l1
          i1k=i1k+inc
          i2k=i2k+inc
          i3k=i3k+inc
          ik1=ik1+idomc
          ik2=ik2+idomc
          ik3=ik3+idomc
          do m=mic,mfc,msc
            tr2 = cc(m+i2k)+cc(m+i3k)
            cr2 = cc(m+i1k)+taur*tr2
            ch(m+ik1) = cc(m+i1k)+tr2
            ti2 = cc(m+1+i2k)+cc(m+1+i3k)
            ci2 = cc(m+1+i1k)+taur*ti2
            ch(m+1+ik1) = cc(m+1+i1k)+ti2
            cr3 = taui*(cc(m+i2k)-cc(m+i3k))
            ci3 = taui*(cc(m+1+i2k)-cc(m+1+i3k))
            ch(m+ik2) = cr2-ci3
            ch(m+ik3) = cr2+ci3
            ch(m+1+ik2) = ci2+cr3
            ch(m+1+ik3) = ci2-cr3
          enddo
        enddo
      else
        iw=0
        do i=0,idomc-1,mdc2
          iw=iw+2
          wa1w=wa1(iw)
          wa1w1=wa1(iw-1)
          wa2w=wa2(iw)
          wa2w1=wa2(iw-1)
          i1k=i-inc
          i2k=i1k+idomc
          i3k=i2k+idomc
          ik1=i-idomc
          ik2=ik1+idol1mc
          ik3=ik2+idol1mc
          do k=1,l1
            i1k=i1k+inc
            i2k=i2k+inc
            i3k=i3k+inc
            ik1=ik1+idomc
            ik2=ik2+idomc
            ik3=ik3+idomc
            do m=mic,mfc,msc
              tr2 = cc(m+i2k)+cc(m+i3k)
              cr2 = cc(m+i1k)+taur*tr2
              ch(m+ik1) = cc(m+i1k)+tr2
              ti2 = cc(m+1+i2k)+cc(m+1+i3k)
              ci2 = cc(m+1+i1k)+taur*ti2
              ch(m+1+ik1) = cc(m+1+i1k)+ti2
              cr3 = taui*(cc(m+i2k)-cc(m+i3k))
              ci3 = taui*(cc(m+1+i2k)-cc(m+1+i3k))
              dr2 = cr2-ci3
              dr3 = cr2+ci3
              di2 = ci2+cr3
              di3 = ci2-cr3
              ch(m+1+ik2) = wa1w1*di2-wa1w*dr2
              ch(m+ik2) = wa1w1*dr2+wa1w*di2
              ch(m+1+ik3) = wa2w1*di3-wa2w*dr3
              ch(m+ik3) = wa2w1*dr3+wa2w*di3
            enddo
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine vpassf4 (mi,mf,ms,ido,l1,cc,ch,mdimc,wa1,wa2,wa3)
c
      implicit real*8 (a-h,o-z)
      dimension       cc(2*mdimc*ido*4*l1),ch(2*mdimc*ido*l1*4),
     1                wa1(1),wa2(1),wa3(1)
c
      mdc2=2*mdimc
      inc=4*ido*mdc2
      idomc=ido*mdc2
      idol1mc=ido*l1*mdc2
      mic=2*(mi-1)+1
      mfc=2*mf
      msc=2*ms
      if (ido .eq. 1) then
        i1k=-inc
        i2k=i1k+idomc
        i3k=i2k+idomc
        i4k=i3k+idomc
        ik1=-idomc
        ik2=ik1+idol1mc
        ik3=ik2+idol1mc
        ik4=ik3+idol1mc
        do k=1,l1
          i1k=i1k+inc
          i2k=i2k+inc
          i3k=i3k+inc
          i4k=i4k+inc
          ik1=ik1+idomc
          ik2=ik2+idomc
          ik3=ik3+idomc
          ik4=ik4+idomc
          do m=mic,mfc,msc
            ti1 = cc(m+1+i1k)-cc(m+1+i3k)
            ti2 = cc(m+1+i1k)+cc(m+1+i3k)
            tr4 = cc(m+1+i2k)-cc(m+1+i4k)
            ti3 = cc(m+1+i2k)+cc(m+1+i4k)
            tr1 = cc(m+i1k)-cc(m+i3k)
            tr2 = cc(m+i1k)+cc(m+i3k)
            ti4 = cc(m+i4k)-cc(m+i2k)
            tr3 = cc(m+i2k)+cc(m+i4k)
            ch(m+ik1) = tr2+tr3
            ch(m+ik3) = tr2-tr3
            ch(m+1+ik1) = ti2+ti3
            ch(m+1+ik3) = ti2-ti3
            ch(m+ik2) = tr1+tr4
            ch(m+ik4) = tr1-tr4
            ch(m+1+ik2) = ti1+ti4
            ch(m+1+ik4) = ti1-ti4
          enddo
        enddo
      else
        iw=0
        do i=0,idomc-1,mdc2
          iw=iw+2
          wa1w=wa1(iw)
          wa1w1=wa1(iw-1)
          wa2w=wa2(iw)
          wa2w1=wa2(iw-1)
          wa3w=wa3(iw)
          wa3w1=wa3(iw-1)
          i1k=i-inc
          i2k=i1k+idomc
          i3k=i2k+idomc
          i4k=i3k+idomc
          ik1=i-idomc
          ik2=ik1+idol1mc
          ik3=ik2+idol1mc
          ik4=ik3+idol1mc
          do k=1,l1
            i1k=i1k+inc
            i2k=i2k+inc
            i3k=i3k+inc
            i4k=i4k+inc
            ik1=ik1+idomc
            ik2=ik2+idomc
            ik3=ik3+idomc
            ik4=ik4+idomc
            do m=mic,mfc,msc
              ti1 = cc(m+1+i1k)-cc(m+1+i3k)
              ti2 = cc(m+1+i1k)+cc(m+1+i3k)
              ti3 = cc(m+1+i2k)+cc(m+1+i4k)
              tr4 = cc(m+1+i2k)-cc(m+1+i4k)
              tr1 = cc(m+i1k)-cc(m+i3k)
              tr2 = cc(m+i1k)+cc(m+i3k)
              ti4 = cc(m+i4k)-cc(m+i2k)
              tr3 = cc(m+i2k)+cc(m+i4k)
              ch(m+ik1) = tr2+tr3
              cr3 = tr2-tr3
              ch(m+1+ik1) = ti2+ti3
              ci3 = ti2-ti3
              cr2 = tr1+tr4
              cr4 = tr1-tr4
              ci2 = ti1+ti4
              ci4 = ti1-ti4
              ch(m+ik2) = wa1w1*cr2+wa1w*ci2
              ch(m+1+ik2) = wa1w1*ci2-wa1w*cr2
              ch(m+ik3) = wa2w1*cr3+wa2w*ci3
              ch(m+1+ik3) = wa2w1*ci3-wa2w*cr3
              ch(m+ik4) = wa3w1*cr4+wa3w*ci4
              ch(m+1+ik4) = wa3w1*ci4-wa3w*cr4
            enddo
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine vpassf5 (mi,mf,ms,ido,l1,cc,ch,mdimc,wa1,wa2,wa3,wa4)
c
      implicit real*8 (a-h,o-z)
      dimension cc(2*mdimc*ido*5*l1),ch(2*mdimc*ido*l1*5),
     1          wa1(1),wa2(1),wa3(1),wa4(1)
c     *** tr11=cos(2*pi/5), ti11=-sin(2*pi/5)
c     *** tr12=-cos(4*pi/5), ti12=-sin(4*pi/5)
      parameter (tr11= 0.3090169943749474241d0,
     &           ti11=-0.95105651629515357212d0,
     &           tr12=-0.8090169943749474241d0,
     &           ti12=-0.58778525229247312917d0)
c
      mdc2=2*mdimc
      inc=5*ido*mdc2
      idomc=ido*mdc2
      idol1mc=ido*l1*mdc2
      mic=2*(mi-1)+1
      mfc=2*mf
      msc=2*ms
      if (ido .eq. 1) then
        i1k=-inc
        i2k=i1k+idomc
        i3k=i2k+idomc
        i4k=i3k+idomc
        i5k=i4k+idomc
        ik1=-idomc
        ik2=ik1+idol1mc
        ik3=ik2+idol1mc
        ik4=ik3+idol1mc
        ik5=ik4+idol1mc
        do k=1,l1
          i1k=i1k+inc
          i2k=i2k+inc
          i3k=i3k+inc
          i4k=i4k+inc
          i5k=i5k+inc
          ik1=ik1+idomc
          ik2=ik2+idomc
          ik3=ik3+idomc
          ik4=ik4+idomc
          ik5=ik5+idomc
          do m=mic,mfc,msc
            ti5 = cc(m+1+i2k)-cc(m+1+i5k)
            ti2 = cc(m+1+i2k)+cc(m+1+i5k)
            ti4 = cc(m+1+i3k)-cc(m+1+i4k)
            ti3 = cc(m+1+i3k)+cc(m+1+i4k)
            tr5 = cc(m+i2k)-cc(m+i5k)
            tr2 = cc(m+i2k)+cc(m+i5k)
            tr4 = cc(m+i3k)-cc(m+i4k)
            tr3 = cc(m+i3k)+cc(m+i4k)
            ch(m+ik1) = cc(m+i1k)+tr2+tr3
            ch(m+1+ik1) = cc(m+1+i1k)+ti2+ti3
            cr2 = cc(m+i1k)+tr11*tr2+tr12*tr3
            ci2 = cc(m+1+i1k)+tr11*ti2+tr12*ti3
            cr3 = cc(m+i1k)+tr12*tr2+tr11*tr3
            ci3 = cc(m+1+i1k)+tr12*ti2+tr11*ti3
            cr5 = ti11*tr5+ti12*tr4
            ci5 = ti11*ti5+ti12*ti4
            cr4 = ti12*tr5-ti11*tr4
            ci4 = ti12*ti5-ti11*ti4
            ch(m+ik2) = cr2-ci5
            ch(m+ik5) = cr2+ci5
            ch(m+1+ik2) = ci2+cr5
            ch(m+1+ik3) = ci3+cr4
            ch(m+ik3) = cr3-ci4
            ch(m+ik4) = cr3+ci4
            ch(m+1+ik4) = ci3-cr4
            ch(m+1+ik5) = ci2-cr5
          enddo
        enddo
      else
        iw=0
        do i=0,idomc-1,mdc2
          iw=iw+2
          wa1w=wa1(iw)
          wa1w1=wa1(iw-1)
          wa2w=wa2(iw)
          wa2w1=wa2(iw-1)
          wa3w=wa3(iw)
          wa3w1=wa3(iw-1)
          wa4w=wa4(iw)
          wa4w1=wa4(iw-1)
          i1k=i-inc
          i2k=i1k+idomc
          i3k=i2k+idomc
          i4k=i3k+idomc
          i5k=i4k+idomc
          ik1=i-idomc
          ik2=ik1+idol1mc
          ik3=ik2+idol1mc
          ik4=ik3+idol1mc
          ik5=ik4+idol1mc
          do k=1,l1
            i1k=i1k+inc
            i2k=i2k+inc
            i3k=i3k+inc
            i4k=i4k+inc
            i5k=i5k+inc
            ik1=ik1+idomc
            ik2=ik2+idomc
            ik3=ik3+idomc
            ik4=ik4+idomc
            ik5=ik5+idomc
            do m=mic,mfc,msc
              ti5 = cc(m+1+i2k)-cc(m+1+i5k)
              ti2 = cc(m+1+i2k)+cc(m+1+i5k)
              ti4 = cc(m+1+i3k)-cc(m+1+i4k)
              ti3 = cc(m+1+i3k)+cc(m+1+i4k)
              tr5 = cc(m+i2k)-cc(m+i5k)
              tr2 = cc(m+i2k)+cc(m+i5k)
              tr4 = cc(m+i3k)-cc(m+i4k)
              tr3 = cc(m+i3k)+cc(m+i4k)
              ch(m+ik1) = cc(m+i1k)+tr2+tr3
              ch(m+1+ik1) = cc(m+1+i1k)+ti2+ti3
              cr2 = cc(m+i1k)+tr11*tr2+tr12*tr3
              ci2 = cc(m+1+i1k)+tr11*ti2+tr12*ti3
              cr3 = cc(m+i1k)+tr12*tr2+tr11*tr3
              ci3 = cc(m+1+i1k)+tr12*ti2+tr11*ti3
              cr5 = ti11*tr5+ti12*tr4
              ci5 = ti11*ti5+ti12*ti4
              cr4 = ti12*tr5-ti11*tr4
              ci4 = ti12*ti5-ti11*ti4
              dr3 = cr3-ci4
              dr4 = cr3+ci4
              di3 = ci3+cr4
              di4 = ci3-cr4
              dr5 = cr2+ci5
              dr2 = cr2-ci5
              di5 = ci2-cr5
              di2 = ci2+cr5
              ch(m+ik2) = wa1w1*dr2+wa1w*di2
              ch(m+1+ik2) = wa1w1*di2-wa1w*dr2
              ch(m+ik3) = wa2w1*dr3+wa2w*di3
              ch(m+1+ik3) = wa2w1*di3-wa2w*dr3
              ch(m+ik4) = wa3w1*dr4+wa3w*di4
              ch(m+1+ik4) = wa3w1*di4-wa3w*dr4
              ch(m+ik5) = wa4w1*dr5+wa4w*di5
              ch(m+1+ik5) = wa4w1*di5-wa4w*dr5
            enddo
          enddo
        enddo
      endif
c
      end
c======================================================================

      subroutine vpassf (nac,mi,mf,ms,ido,ip,l1,idl1,cc,c1,c2,ch,ch2,
     &                   mdimc,wa)
c
      implicit real*8 (a-h,o-z)
      dimension  ch(2,mdimc,ido,l1,ip),cc(2,mdimc,ido,ip,l1),
     1           c1(2,mdimc,ido,l1,ip),c2(2,mdimc,idl1,ip),
     2           ch2(2,mdimc,idl1,ip),wa(1)
c
      ido2=ido+ido
      idot = ido
      ipp2 = ip+2
      ipph = (ip+1)/2
      idp = ip*ido2
c
      if (ido .ge. l1) then
        do j=2,ipph
          jc = ipp2-j
          do k=1,l1
            do i=1,ido
              do m=mi,mf,ms
                ch(1,m,i,k,j)  = cc(1,m,i,j,k) + cc(1,m,i,jc,k)
                ch(2,m,i,k,j)  = cc(2,m,i,j,k) + cc(2,m,i,jc,k)
                ch(1,m,i,k,jc) = cc(1,m,i,j,k) - cc(1,m,i,jc,k)
                ch(2,m,i,k,jc) = cc(2,m,i,j,k) - cc(2,m,i,jc,k)
              enddo
            enddo
          enddo
        enddo
        do k=1,l1
          do i=1,ido
            do m=mi,mf,ms
              ch(1,m,i,k,1) = cc(1,m,i,1,k)
              ch(2,m,i,k,1) = cc(2,m,i,1,k)
            enddo
          enddo
        enddo
      else
        do j=2,ipph
          jc = ipp2-j
          do i=1,ido
            do k=1,l1
              do m=mi,mf,ms
                ch(1,m,i,k,j)  = cc(1,m,i,j,k) + cc(1,m,i,jc,k)
                ch(2,m,i,k,j)  = cc(2,m,i,j,k) + cc(2,m,i,jc,k)
                ch(1,m,i,k,jc) = cc(1,m,i,j,k) - cc(1,m,i,jc,k)
                ch(2,m,i,k,jc) = cc(2,m,i,j,k) - cc(2,m,i,jc,k)
              enddo
            enddo
          enddo
        enddo
        do i=1,ido
          do k=1,l1
            do m=mi,mf,ms
              ch(1,m,i,k,1) = cc(1,m,i,1,k)
              ch(2,m,i,k,1) = cc(2,m,i,1,k)
            enddo
          enddo
        enddo
      endif
c
      idl = 2-ido2
      inc = 0
      do l=2,ipph
        lc = ipp2-l
        idl = idl+ido2
        waidl=wa(idl)
        waidl1=wa(idl-1)
        do ik=1,idl1
          do m=mi,mf,ms
            c2(1,m,ik,l)  = ch2(1,m,ik,1) + waidl1 * ch2(1,m,ik,2)
            c2(2,m,ik,l)  = ch2(2,m,ik,1) + waidl1 * ch2(2,m,ik,2)
            c2(1,m,ik,lc) =               - waidl   * ch2(1,m,ik,ip)
            c2(2,m,ik,lc) =               - waidl   * ch2(2,m,ik,ip)
          enddo
        enddo
        idlj = idl
        inc = inc+ido2
        do j=3,ipph
          jc = ipp2-j
          idlj = idlj+inc
          if (idlj .gt. idp) idlj = idlj-idp
          war = wa(idlj-1)
          wai = wa(idlj)
          do ik=1,idl1
            do m=mi,mf,ms
              c2(1,m,ik,l)  = c2(1,m,ik,l)  + war * ch2(1,m,ik,j)
              c2(2,m,ik,l)  = c2(2,m,ik,l)  + war * ch2(2,m,ik,j)
              c2(1,m,ik,lc) = c2(1,m,ik,lc) - wai * ch2(1,m,ik,jc)
              c2(2,m,ik,lc) = c2(2,m,ik,lc) - wai * ch2(2,m,ik,jc)
            enddo
          enddo
        enddo
      enddo
      do j=2,ipph
        do ik=1,idl1
          do m=mi,mf,ms
            ch2(1,m,ik,1) = ch2(1,m,ik,1) + ch2(1,m,ik,j)
            ch2(2,m,ik,1) = ch2(2,m,ik,1) + ch2(2,m,ik,j)
          enddo
        enddo
      enddo
      do j=2,ipph
        jc = ipp2-j
        do ik=1,idl1
          do m=mi,mf,ms
            ch2(1,m,ik,j)  = c2(1,m,ik,j) - c2(2,m,ik,jc)
            ch2(1,m,ik,jc) = c2(1,m,ik,j) + c2(2,m,ik,jc)
            ch2(2,m,ik,j)  = c2(2,m,ik,j) + c2(1,m,ik,jc)
            ch2(2,m,ik,jc) = c2(2,m,ik,j) - c2(1,m,ik,jc)
          enddo
        enddo
      enddo
c
      nac = 1
      if (ido .ne. 1) then
        nac = 0
        do ik=1,idl1
          do m=mi,mf,ms
          c2(1,m,ik,1) = ch2(1,m,ik,1)
          c2(2,m,ik,1) = ch2(2,m,ik,1)
          enddo
        enddo
        do j=2,ip
          do k=1,l1
            do m=mi,mf,ms
              c1(1,m,1,k,j) = ch(1,m,1,k,j)
              c1(2,m,1,k,j) = ch(2,m,1,k,j)
            enddo
          enddo
        enddo
        if (idot .le. l1) then
          idij = 0
          do j=2,ip
            idij = idij+2
            do i=2,ido
              idij = idij+2
              waidij=wa(idij)
              waidij1=wa(idij-1)
              do k=1,l1
                do m=mi,mf,ms
                  c1(1,m,i,k,j) = waidij1 * ch(1,m,i,k,j)
     &                           +waidij   * ch(2,m,i,k,j)
                  c1(2,m,i,k,j) = waidij1 * ch(2,m,i,k,j)
     &                           -waidij   * ch(1,m,i,k,j)
                enddo
              enddo
            enddo
          enddo
          else
          idj = 2-ido2
          do j=2,ip
            idj = idj+ido2
            do k=1,l1
              idij = idj
              do i=2,ido
                idij = idij+2
                waidij=wa(idij)
                waidij1=wa(idij-1)
                do m=mi,mf,ms
                  c1(1,m,i,k,j) = waidij1 * ch(1,m,i,k,j)
     &                           +waidij   * ch(2,m,i,k,j)
                  c1(2,m,i,k,j) = waidij1 * ch(2,m,i,k,j)
     &                           -waidij   * ch(1,m,i,k,j)
                enddo
              enddo
            enddo
          enddo
        endif
      endif
c
      end
