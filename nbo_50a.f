C***********************************************************************
C NBO 5.G -- Natural Bond Orbital Analysis Programs
C (c) Copyright 1996-2008 Board of Regents of the University of Wisconsin System
C     on behalf of the Theoretical Chemistry Institute.  All Rights Reserved.
C***********************************************************************
C
C
C
C                  N  B  O     P  R  O  G  R  A  M
C
C                   (SYSTEM INDEPENDENT ROUTINES)
C
C
C
C              LAST PROGRAM MODIFICATION: SEPTEMBER 8, 2008
C
C
C***********************************************************************
C
C  MAIN SUBROUTINE:
C
C      SUBROUTINE NBO(CORE,NBOOPT,MEMORY)
C
C  JOB INITIALIZATION ROUTINES: (CALLED BY SR NBO)
C
C      SUBROUTINE NBOSET(NBOOPT)
C      SUBROUTINE JOBOPT(NBOOPT)
C      SUBROUTINE JOBOPT1(NBOOPT,CKEY,IFOUND,INBERR,NEXTWD,
C     +  LENG,END,KEYWD)
C      SUBROUTINE JOBOPT2(NBOOPT,CKEY,IFOUND,INBERR,NEXTWD,
C     +  LENG,END,KEYWD)
C      SUBROUTINE JOBOPT3(NBOOPT,CKEY,IFOUND,INBERR,NEXTWD,
C     +  LENG,END,KEYWD)
C      SUBROUTINE NBCVRT(KEYWD,LENG,CKEYWD)
C      SUBROUTINE RDELEM(LFN)
C      SUBROUTINE RDELM2(LFN)
C      SUBROUTINE NBODIM(MEMORY)
C
C  NAO/NBO/NLMO FORMATION ROUTINES: (CALLED BY SR NBO)
C
C      SUBROUTINE NAODRV(DM,T,A)
C      SUBROUTINE NAOSIM(DM,T,A)
C      SUBROUTINE DMNAO(DM,T,A)
C      SUBROUTINE DMSIM(DM,T,A)
C      SUBROUTINE NBODRV(DM,T,A,MEMORY)
C
C  ROUTINES CALLED BY THE NAO DRIVERS:
C
C      SUBROUTINE SIMTRM(A,S,V,NDIM,N,IWMULP,IWCUBF)
C      SUBROUTINE MULANA(BS,VMAYER,BMAYER,IWMULP,IWCUBF)
C      SUBROUTINE DFGORB(DM,T,RENORM,TPAO)
C      SUBROUTINE NAO(T,S,OCC,BLK,SBLK,EVAL,C,EVECT,SCR,LISTAO,NBLOCK)
C      SUBROUTINE NAOANL(DM,SPNAO,BINDEX,BINDT,BMO,OVPOP,F,ENAO,SCR)
C      SUBROUTINE FRMTMO(T,TMO,C,SCR,INDEX,IFLG)
C
C  ROUTINES CALLED BY SR NAO:
C
C      SUBROUTINE LOADAV(LISTAO,NL,M,S,NDIM,A,B,MXAOLM)
C      SUBROUTINE ATDIAG(N,DM,S,EVAL,T,SCR,MAP,NK,L,IAT,IATNO)
C      SUBROUTINE SETBAS(LSTOCC,LSTEMT,NOCC,NEMT,IAT,L,NL,NF,NDIM)
C      SUBROUTINE DISCRD(T,S,BLK,EVAL,S1,S2,S3,OCC,NDIM,NBAS,NNAO,
C     +       NAOCTR,NAOL,LSTOCC,NOCC,LSTEMT,NEMT,LIST,IATNO,NATOMS)
C      SUBROUTINE NEWWTS(S,T,WT)
C      SUBROUTINE WORTH(S,T,BLK,LIST,NDIM,NBAS,N,OCC,EVAL,BIGBLK)
C      SUBROUTINE SHMDT(T,S,NDIM,NBAS,NOCC,LSTOCC,NEMT,LSTEMT,SBLK)
C      SUBROUTINE NEWRYD(T,S,TPNAO,DMBLK,SBLK,EVECT,OCC,EVAL,EVAL2,
C     +                       LIST,IRPNAO)
C      SUBROUTINE RYDIAG(T,S,TPNAO,DMBLK,SBLK,OCC,EVAL,EVECT,EVAL2,
C     +                    IORB,NC,NM,NSTART,NRYDC,LARC,LIST,IRPNAO)
C      SUBROUTINE RYDSEL(LSTEMT,NEMT,NSEL1,LIST1,NSEL2,LIST2,WT)
C      SUBROUTINE REDIAG(DM,T,TPNAO,EVAL,BLK,C,IRANK,IRPNAO)
C      SUBROUTINE REDBLK(T,TPNAO,IL,DM,BLK,EVAL,C,NF,IORB,NC,IRANK,IRPNAO)
C
C  ROUTINES CALLED BY THE NBO/NLMO DRIVERS:
C
C      SUBROUTINE NATHYB(DM,T,GUIDE,BNDOCC,POL,Q,V,BLK,C,EVAL,BORB,
C     +                                       P,TA,HYB,VA,VB,TOPO)
C      SUBROUTINE CHSDRV(DM,T,GUIDE,BNDOCC,POL,Q,V,BLK,C,EVAL,BORB,
C     +                                       P,TA,HYB,VA,VB,TOPO)
C      SUBROUTINE NBCHSE(DM,T,GUIDE,BNDOCC,POL,Q,V,BLK,C,EVAL,BORB,
C     +                                  P,TA,HYB,VA,VB,TOPO,IFLG)
C      SUBROUTINE SRTNBO(T,BNDOCC)
C      SUBROUTINE XCITED(DM,T,HYB,THYB,S,OCC,SCR,ISCR)
C      SUBROUTINE ANLYZE(T,BNDOCC,HYB,HYCOEF,THYB)
C      SUBROUTINE HTYPE(HYB,LTYP,MXAO,NH,COEF,PCT,NL,ISGN)
C      SUBROUTINE FRMHYB(HYB,THYB,COEF,HYCOEF,KL,KU,NHYB)
C      SUBROUTINE HYBDIR(BNDOCC,ATCOOR,THYB,TBND,SCR)
C      SUBROUTINE HYBCMP(PCMP,PPCT,DCMP,DPCT,IHYB,JCTR,HYB)
C      SUBROUTINE NHOANG(THYB,ATCRD,NATOMS,NBAS,NDIM,LFNPR)
C      SUBROUTINE FNDMOL(IATOMS)
C      SUBROUTINE NBOCLA(BNDOCC,ACCTHR)
C      SUBROUTINE FNBOAN(BNDOCC,F,MOLNBO)
C      SUBROUTINE NBOSUM(F,BNDOCC,LIST,LISTA,SCR)
C      SUBROUTINE GETDEL(IBO,OCC,THR1,THR2,NL,LIST,DEL,DELOC,IFLG)
C      SUBROUTINE DLCSTR(IBO,IL,NL,LIST,ML,ISTR)
C      SUBROUTINE NLMO(N,A,EVAL,EVEC,PRM,TSYM,RESON,NOCC,IALARM)
C      SUBROUTINE LMOANL(T,S,RESON,OCC,TS,BORDER,OWBORD,ATLMO,SIAB,NOCC,NAB)
C      SUBROUTINE DIPANL(DM,T,C,TNBO,DX,DY,DZ,SCR,INDEX)
C      SUBROUTINE DIPELE(DXYZ,C,T,SCR,ETA,NOCC,INDEX)
C      SUBROUTINE DIPNUC(DX,DY,DZ,ATCOOR,ETA,NOCC)
C
C  ROUTINES CALLED BY SR NATHYB, SR NBCHSE:
C
C      SUBROUTINE NBCORE(DM,T,BORB,POL,Q,HYB,BNDOCC,IBD,DETAIL,LFNPR)
C      FUNCTION IWPRJ(NCTR)
C      SUBROUTINE DEPLET(DM,T,Q,POL,BORB,BNDOCC,NBD)
C      SUBROUTINE LOAD(DM,IAT1,IAT2,IAT3,BLK,NB)
C      SUBROUTINE PRJEXP(BORB,IAT1,IAT2,IAT3,Q,P,PK,HYB,VA,VB,HYBEXP)
C      SUBROUTINE STASH(BORB,IBD,IAT1,IAT2,IAT3,POL,Q,HYB)
C      SUBROUTINE ORTHYB(Q,S,TA,EVAL,C,IALARM,IFLG)
C      SUBROUTINE NBFPRJ(P,IA,Q,NK,PK,VK,PI)
C      SUBROUTINE AUGMNT(P,BLK,C,EVAL,DM,TA,BORB,V,LARC,IA,NOCC,NORB)
C      SUBROUTINE REPOL(DM,Q,POL,BLK,EVAL,C,NBD)
C      SUBROUTINE FORMT(T,Q,POL)
C      SUBROUTINE CYCLES(ITER,THRESH,GUIDE,BNDOCC,TOPO,ICONT)
C
C  ROUTINES CALLED BY SR NLMO:
C
C      SUBROUTINE SYMUNI(TSYM,A,COS,SIN,OVLP,BLK,EVAL,NROT,
C     +           NIUNIQ,NJUNIQ,ILIST,JLIST,NOFF,IOFF,JOFF,NDIM)
C      SUBROUTINE SYMORT(S,T,BLK,NDIM,N,EVAL,IERR,IPFLG)
C
C  NBO ENERGETIC ANALYSIS ROUTINES:
C
C      SUBROUTINE NBOEAN(A,MEMORY,NBOOPT,IDONE)
C      SUBROUTINE NBODEL(A,MEMORY,IDONE,ISET)
C      SUBROUTINE NBDELE(F,TRF,NDIM,IDEL,LEN,DONE,ISPIN,ISET)
C      SUBROUTINE NEWDM(DM,U,EIG,OCC,SCR,NDIM,ISPIN,ISET)
C      SUBROUTINE RNKEIG(RANK,EIG,N,NDIM,ARCRNK)
C
C  NBO DIRECT ACCESS FILE (DAF) ROUTINES:
C
C      SUBROUTINE NBFILE(NEW,ERROR)
C      SUBROUTINE NBOPEN(NEW,ERROR)
C      SUBROUTINE NBWRIT(IX,NX,IDAR)
C      SUBROUTINE NBREAD(IX,NX,IDAR)
C      SUBROUTINE NBCLOS(DEL)
C      SUBROUTINE NBINQR(IDAR)
C
C      SUBROUTINE FETITL(TITLE)
C      SUBROUTINE FEE0(EDEL,ETOT)
C      SUBROUTINE SVE0(EDEL)
C      SUBROUTINE FECOOR(ATCOOR)
C      SUBROUTINE FESRAW(S)
C      SUBROUTINE SVDRAW(DM)
C      SUBROUTINE FEDRAW(DM,SCR)
C      SUBROUTINE FEFAO(F,IWFOCK)
C      SUBROUTINE FEAOMO(T,IT)
C      SUBROUTINE FEDXYZ(DXYZ,I)
C      SUBROUTINE FEKAO(T,IT)
C      SUBROUTINE FEVAO(V,IV)
C      SUBROUTINE SVCHK(T,IS)
C      SUBROUTINE FECHK(T,IS,IT)
C      SUBROUTINE SVNBO(T,OCC,ISCR)
C      SUBROUTINE FENBO(T,OCC,ISCR)
C      SUBROUTINE FETNBO(T)
C      SUBROUTINE SVPNAO(T)
C      SUBROUTINE FEPNAO(T)
C      SUBROUTINE SVSNAO(S)
C      SUBROUTINE FESNAO(S)
C      SUBROUTINE SVTNAB(T)
C      SUBROUTINE FETNAB(T)
C      SUBROUTINE SVTLMO(T)
C      SUBROUTINE FETLMO(T)
C      SUBROUTINE SVTNHO(T)
C      SUBROUTINE FETNHO(T)
C      SUBROUTINE SVTPAO(T)
C      SUBROUTINE FETPAO(T)
C      SUBROUTINE SVPPAO(DM)
C      SUBROUTINE FEPPAO(DM)
C      SUBROUTINE SVTNAO(T)
C      SUBROUTINE FETNAO(T)
C      SUBROUTINE SVNLMO(T)
C      SUBROUTINE FENLMO(T,ISCR)
C      SUBROUTINE SVDNAO(DM)
C      SUBROUTINE FEDNAO(DM)
C      SUBROUTINE SVFNBO(F)
C      SUBROUTINE FEFNBO(F)
C      SUBROUTINE SVNEWD(DM)
C      SUBROUTINE FENEWD(DM)
C      SUBROUTINE FEINFO(ICORE,ISWEAN)
C      SUBROUTINE FEBAS(NSHELL,NEXP,ISCR)
C      SUBROUTINE FENBLB(ISCR)
C      SUBROUTINE FESPIN(DM,SCR)
C      SUBROUTINE SVLBLS
C      SUBROUTINE FELBLS
C      SUBROUTINE SVNNAO(ICORE,NNAO)
C
C  FREE FORMAT INPUT ROUTINES:
C
C      SUBROUTINE STRTIN(LFNIN)
C      SUBROUTINE NXTCRD
C      SUBROUTINE IFLD(INTGR,ERROR)
C      SUBROUTINE RFLD(REAL,ERROR)
C      SUBROUTINE HFLD(KEYWD,LENG,ENDD)
C      SUBROUTINE FNDFLD
C      SUBROUTINE RTNFLD
C      FUNCTION EQUAL(IA,IB,L)
C
C  OTHER SYSTEM-INDEPENDENT I/O ROUTINES:
C
C      SUBROUTINE GENINP(NEWDAF)
C      SUBROUTINE NBOINP(NBOOPT,IDONE)
C      SUBROUTINE CORINP(IESS,ICOR)
C      SUBROUTINE CHSINP(IESS,ICHS)
C      SUBROUTINE DELINP(NBOOPT,IDONE)
C
C      SUBROUTINE RDCORE(JCORE)
C      SUBROUTINE WRPPNA(T,OCC,IFLG)
C      SUBROUTINE RDPPNA(T,OCC,IFLG)
C      SUBROUTINE WRTNAO(T,IFLG)
C      SUBROUTINE RDTNAO(DM,T,SCR,IFLG)
C      SUBROUTINE WRTNAB(T,IFLG)
C      SUBROUTINE RDTNAB(T,DM,BNDOCC,SCR,IFLG)
C      SUBROUTINE WRTNBO(T,BNDOCC,IFLG)
C      SUBROUTINE WRNLMO(T,DM,IFLG)
C      SUBROUTINE WRBAS(SCR,ISCR,LFN)
C      SUBROUTINE WRARC(SCR,ISCR,LFN)
C      SUBROUTINE WRLBL(LFNLBL)
C      SUBROUTINE WRSP(F,T,LFN)
C
C      SUBROUTINE AOUT(A,MR,NR,NC,TITLE,INDEX,IFLG)
C      SUBROUTINE APRINT(A,MR,NR,NC,TITLE,INDEX,MCOL)
C      SUBROUTINE AWRITE(A,MR,NR,NC,TITLE,LFN)
C      SUBROUTINE AREAD(A,MR,NR,NC,JOB,LFN,ERROR)
C      SUBROUTINE ALTOUT(A,MR,MC,NR,NC)
C      SUBROUTINE KEYPAR(STRING,LEN,IFLG,ICHKPT,LFN,READ,ERROR)
C      FUNCTION IOINQR(IFLG)
C      SUBROUTINE LBLAO
C      SUBROUTINE LBLNAO
C      SUBROUTINE LBLNBO
C      SUBROUTINE LBLNHO(INHO,INBO,ICTR,NCTR)
C      SUBROUTINE LBLPAO
C
C  GENERAL UTILITY ROUTINES:
C
C      SUBROUTINE ANGLES(X,Y,Z,THETA,PHI)
C      FUNCTION BDFIND(IAT,JAT)
C      SUBROUTINE CHEM(NAT,NATOMS,LISTA,NL,ISTR)
C      SUBROUTINE CONSOL(AUT,ALT,NDIM,N)
C      SUBROUTINE CONVIN(IJ,LEN,IK,ERROR)
C      SUBROUTINE CONVRT2N(N,NC1,NC2)
C      SUBROUTINE CONVRT3(N,NC1,NC2,NC3)
C      SUBROUTINE CONVRT3S(N,S1,S2,S3)
C      SUBROUTINE COPY(A,B,NDIM,NR,NC)
C      SUBROUTINE CORTBL(IAT,ICORE,IECP)
C      SUBROUTINE DALIST(VAL,ID,IA,IATD,IATA,IUND,IUNA)
C      SUBROUTINE IDIGIT(KINT,IK,ND,MAXD)
C      FUNCTION IHTYP(IBO,JBO)
C      SUBROUTINE NBJACOBI(N,A,EIVU,EIVR,NDIM,NVDIM,ICONTR)
C      SUBROUTINE KEYERR(WORD)
C      SUBROUTINE LIMTRN(T,M,A,B,NDIM,NBAS,NCDIM,NC,IOPT)
C      SUBROUTINE MATMLT(A,B,V,NDIM,N)
C      SUBROUTINE MATML1(A,B,V,ND1,ND2,ND3,NR,N,NC)
C      SUBROUTINE MATML2(A,B,V,NDIM,N)
C      SUBROUTINE MATML3(A,B,V,ND1,ND2,ND3,NR,N)
C      FUNCTION NAMEAT(IZ)
C      SUBROUTINE NBHALT(WORD)
C      SUBROUTINE NORMLZ(A,S,M,N,NC)
C      SUBROUTINE NBORDR(RANK,LIST,N,NDIM,ARCRNK)
C      SUBROUTINE PACK(T,NDIM,NBAS,NTRI)
C      SUBROUTINE RANK(EIG,N,NDIM,ARCRNK)
C      SUBROUTINE SCNVRT(IVEC,STR,NL,IERR)
C      SUBROUTINE SIMTRS(A,S,V,NDIM,N)
C      SUBROUTINE SIMTR1(A,S,V,ND,NA,NR,NC)
C      SUBROUTINE NBTRSP(A,NDIM,N)
C      SUBROUTINE UNPACK(T,NDIM,NBAS)
C      SUBROUTINE VALTBL(IAT,IVAL,IFLG)
C      FUNCTION VECLEN(X,N,NDIM)
C
C  NRT ROUTINES:
C
C      SUBROUTINE NRTDRV(DM,T,WIBERG,RHOSTR,KPAR,NRES,IRESET,A,MAXRES,
C     +                  MAXREF,NLOW,NAO,LEN,NELEC,MEMORY,IVALSP)
C
C  SECONDARY NRT ROUTINES:
C
C      SUBROUTINE VALDM(DM,GAMMA,SCR,V,U,IOCC,NVAL,LVAL)
C      SUBROUTINE NRTSTR(NRES,IDXRES,MAXRES,MAXREF,LSTRES,LEN,NELEC)
C      SUBROUTINE LEWIS(DM,WIBERG,NRES,IDXRES,MAXRES,MAXREF,LSTRES,
C     +                 LEN,IVALSP)
C      SUBROUTINE LEWATM(IAT,JAT,KDX,LEFTBD,ICNT,NATOMS)
C      SUBROUTINE LEWBDS(IAT,JAT,IDX,JDX,WIBERG,LEFTBD,NATOMS,
C     +                  THR1,THR2,THR3,IALARM)
C      SUBROUTINE LEWDIS(ICH,N,IATNO,NATOMS,IERR,INIT)
C      SUBROUTINE LEWTOP(JAT,JDX,KDX,LEFTBD,ICNT,NATOMS)
C      SUBROUTINE NBORES(NRES,IDXRES,MAXRES,MAXREF,LSTRES,LEN,ISCR,
C     +                  IVALSP)
C      SUBROUTINE KEKULE(ILIST,IDXRES,IRESET,MAXRES,NREF,MAXREF,LSTRES,
C     +                  LEN)
C      SUBROUTINE PARENT(IREF,RHOST,RHOT,DM,T,WIBERG,BNDOCC,POL,Q,V,BLK,
C     +                  C,EVAL,BORB,P,TA,HYB,VA,VB,TOPO,SCR,IDON,IACC,
C     +                  IDXRES,KPAR,MAXRES,MAXREF,IBDRES,ISRCH,NRTCTL)
C      SUBROUTINE SHREWD(DM,T,BNDOCC,POL,Q,V,BLK,C,EVAL,BORB,P,TA,HYB,
C     +                  VA,VB,IREF,IDON,IACC,IFLG)
C      SUBROUTINE NBSLCT(RHOSTR,NRES,IRESET,KPTR,IDXRES,MAXRES,NREF,
C     +                  MAXREF,NRTCTL)
C      SUBROUTINE REFRS(IREF,T,BNDOCC,OCCR,TR,SCR1,SCR2,SCR3,GAMMA,
C     +                 GAMMAW,IST,IOCC,NREF,NAO,IVALSP)
C      SUBROUTINE EXPECT(IRES,T,BNDOCC,OCC,OCCR,TR,SCR,IPTR,MAXRES,IREF,
C     +                  NREF,NELEC)
C      SUBROUTINE IONIC(IRES,T,XION,NLOW,MAXRES,IREF,NREF)
C      SUBROUTINE NBPREP(DM,TNBO,HYB,T,THYB,SCR)
C      SUBROUTINE ARROWS(DM,T,DELOC,SCR,NRES,IRESET,IDON,IACC,IDXRES,
C     +                  MAXRES,IREF,NREF,LSTRES,LEN,IAT1,IAT2,IDXCOV,
C     +                  IIONC,NRTCTL)
C      SUBROUTINE NEWLBL
C      SUBROUTINE IONTST(IRES,IREF,IAT1,IAT2,IDXRES,MAXRES,NREF,LSTRES,
C     +                  LEN,IDEL)
C      SUBROUTINE CONDNS(IREF,XION,KPAR,NRES,IRESET,IDXRES,MAXRES,NREF,
C     +                  NLOW,IAT1,IAT2,IDXCOV,IIONC)
C      SUBROUTINE SECRES(IRES,DM,T,RHOSTR,BNDOCC,TNBO,SCR,IDON,IACC,
C     +                  IDXRES,LSTRES,MAXRES,IREF,NREF,LEN)
C      SUBROUTINE SETAPP(NUMRES,NRES,ILIST,IDXRES,MAXRES,IREF,NREF)
C      SUBROUTINE APPEND(IRES,DM,T,RHOSTR,DELOC,BNDOCC,TNBO,SCR,ICTR,
C     +                  IMAKE,IBRAK,IDN,QDN,IAC,QAC,IPAR,IHYB,IDON,
C     +                  IACC,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
C      SUBROUTINE HBRES(NRES,IDXRES,MAXRES,MAXREF,LSTRES,LEN,NRTCTL)
C      SUBROUTINE INITWT(ERRREF,ERR,RHOSTR,OCC,WGT,Q,IST,IRANK,NRES,IRESET,
C     +                  MAXRES,NREF)
C      SUBROUTINE WGTOPT(ERRREF,ERR,RHOSTR,OCC,WGT,T,SCR1,SCR2,SCR3,SCR4,
C     +                  SCR5,SCR6,SCR7,SCR8,SCR9,Q,IST,IPTR,KPAR,NRES,
C     +                  IRESET,MAXRES,NREF,NRTCTL)
C      SUBROUTINE HESSIN(RHOSTR,OCC,WGT,Q,T,HESS,EVEC,EVAL,DER,G,IST,
C     +                  IPTR,NRES,MAXRES,IREF,NREF,IND)
C      SUBROUTINE SUPPL(FW,WGT,WGTM,MAP,WGTP,IDXRES,KPAR,NRES,IRESET,
C     +                 IPTR,MAXRES,ICNT,NREF,MAXREF,NRTCTL,IVALSP)
C      SUBROUTINE RESWGT(RHOSTR,WGT,WGTP,WGTM,ISCR,MAP,IRANK,NRES,IRESET,
C     +                  IDXRES,MAXRES,ICNT,NREF)
C      SUBROUTINE SYMWGT(RHOSTR,WGTP,WGTM,MAP,NRES,IRESET,IDXRES,MAXRES,
C     +                  ICNT,NREF,NRTCTL)
C      SUBROUTINE NRTOUT(RHOSTR,OCC,WGT,WGTP,SCR,WGTM,Q,MAP,IST,NRES,
C     +                  IRESET,IDXRES,LSTRES,MAXRES,ICNT,NREF,LEN)
C      SUBROUTINE NBDORD(BORDER,VALENZ,TOPO,WGT,XION,WGTP,NRES,IRESET,
C     +                  IDXRES,MAXRES,NREF,LSTRES,LEN,NLOW)
C      SUBROUTINE NRTLST(MAP,WGTM,ICNT,NRES,IRESET,IDXRES,MAXRES,NREF,
C     +                  LSTRES,LEN)
C
C  NRT OPTIMIZATION ROUTINES:
C
C      SUBROUTINE SETOPT(RHOSTR,WGT,T,IPTR,NRES,MAXRES,IREF,NREF,NVAR)
C      SUBROUTINE BFGS(FRET,FREF,OCC,WGT,Q,P,HESS,XT,XIT,G,DG,HDG,DF,W,
C     +                SCR,IPTR,IST,NRES,MAXRES,IREF,NREF,NVAR,ITER)
C      SUBROUTINE NBPWLL(FRET,FREF,OCC,WGT,Q,P,XI,PT,XIT,PTT,W,WP,IPTR,
C     +                  IST,NRES,MAXRES,IREF,NREF,NVAR,ITER)
C      SUBROUTINE NLINMN(FRET,OCC,WGT,Q,XT,P,XIT,IPTR,IST,NRES,MAXRES,IREF,
C     +                  NREF,NVAR)
C      SUBROUTINE DLINMN(FRET,OCC,WGT,Q,XT,P,XIT,DF,SCR,IPTR,IST,NRES,
C     +                  MAXRES,IREF,NREF,NVAR)
C      SUBROUTINE NBMNBK(AX,BX,CX,FA,FB,FC,OCC,WGT,Q,XT,P,XIT,IPTR,IST,
C     +                  NRES,MAXRES,IREF,NREF,NVAR)
C      SUBROUTINE NBRENT(FRET,AX,BX,CX,FB,TOL,XMIN,OCC,WGT,Q,XT,PT,XIT,IPTR,
C     +                 IST,NRES,MAXRES,IREF,NREF,NVAR)
C      SUBROUTINE DBRENT(FRET,AX,BX,CX,FB,TOL,XMIN,OCC,WGT,Q,XT,P,XIT,DF,
C     +                  SCR,IPTR,IST,NRES,MAXRES,IREF,NREF,NVAR)
C      SUBROUTINE NBFDIM(FX,X,OCC,WGT,Q,XT,P,XIT,IPTR,IST,NRES,MAXRES,IREF,
C     +                 NREF,NVAR)
C      SUBROUTINE DF1DIM(DX,X,OCC,WGT,Q,XT,P,XIT,DF,SCR,IPTR,IST,NRES,
C     +                  MAXRES,IREF,NREF,NVAR)
C      SUBROUTINE NBPHI(FT,T,OCC,WGT,Q,IPTR,IST,NRES,MAXRES,IREF,NREF,NVAR)
C      SUBROUTINE NBDPHI(DER,T,OCC,WGT,Q,SCR,IPTR,IST,NRES,MAXRES,IREF,
C     +                  NREF,NVAR)
C
C  SIMULATED ANNEALING ROUTINES:
C
C      SUBROUTINE ANNEAL(XLAM,YLAM,ERRREF,ERR,RHOSTR,OCC,WGT,T,SCR,Q,
C     +                  IPTR,IST,NRES,MAXRES,IREF,NREF,ISEED,NVAR,ITT)
C      SUBROUTINE SETANN(RHOSTR,WGT,T,IPTR,NRES,MAXRES,IREF,NREF,NVAR)
C      SUBROUTINE ADJUST(T,IT,NVAR,SSIZE,STEP,ISEED)
C      SUBROUTINE METROP(NSUC,FW2,FW1,FT,ISEED)
C      SUBROUTINE RESTOR(T,IT,NVAR,SSIZE)
C
C  NRT BRANCHING ROUTINES:
C
C      SUBROUTINE IDCTRL(IREF)
C      SUBROUTINE IDINIT(ICNT,NC,NH,NUM)
C      SUBROUTINE IDINCR(ICNT,NC,NH,NUM)
C      FUNCTION IDTEST(JDXT,IC,NUM)
C      SUBROUTINE IDCLR
C      SUBROUTINE IDCOPY
C      SUBROUTINE IDREST
C
C  NRT UTILITY ROUTINES:
C
C      SUBROUTINE ATMORD(WIBERG,NRT)
C      CHARACTER*2 FUNCTION CHARAT(IZ)
C      SUBROUTINE CMPFW(FW,XLAM,YLAM,ERRREF,ERR,T,OCC,WGT,Q,IPTR,IST,NRES,
C     +                 MAXRES,IREF,NREF)
C      SUBROUTINE EXPWGT(RHOW,RHOSTR,WGT,IRANK,NRES,MAXRES,IREF,NREF,N)
C      SUBROUTINE FETREF(T,LABEL,IBXM,IREF)
C      SUBROUTINE FORMQ(Q,OCC,IST,NRES,MAXRES,IREF,NREF,ICTRL)
C      SUBROUTINE GETDM(T,DM,TR,SCR1,SCR2,SCR3,IST,IOCC,NVAL,IERR)
C      SUBROUTINE GETDW(DW,GAMMAW,WGT,LVAL,NREF,NVAL)
C      SUBROUTINE GETERR(ERROR,WGT,Q,NRES,MAXRES,IREF,NREF)
C      SUBROUTINE GETFDM(DM,DELOC,TNAO,TBO,SCR)
C      SUBROUTINE GETGRD(DER,T,WGT,Q,OCC,G,IST,IPTR,NRES,MAXRES,IREF,NREF,
C     +                  NVAR)
C      SUBROUTINE GETHES(HESS,DER,T,WGT,Q,OCC,G,IST,IPTR,NRES,MAXRES,
C     +                  IREF,NREF,NVAR,IFLG)
C      SUBROUTINE GETREL(IBO,IBOP,IUNIT1,IUNIT2,IREL,IA,IB,IC,ID)
C      FUNCTION INTRN(ILLIM,IULIM,ISEED)
C      SUBROUTINE MULTI(FW,GAMMAW,WGT,SCR,IRESET,LVAL,NREF,NVAL)
C      SUBROUTINE NRTINP(IESS,INRT)
C      SUBROUTINE PRTWGT(IRES,IR,NUM,WGT,II,IAT,JJ,JAT,IFLG)
C      FUNCTION RANNB(IDUM)
C      FUNCTION REALRN(XLLIM,XULIM,ISEED)
C      SUBROUTINE SVTREF(T,LABEL,IBXM,IREF)
C      SUBROUTINE TOPCMP(IDUP,IRES,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
C      SUBROUTINE TOPGET(IRES,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
C      SUBROUTINE TOPOUT
C      SUBROUTINE TOPSTR(IRES,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
C      SUBROUTINE TOPZER(NATOMS)
C      SUBROUTINE WGTOUT(WGT,NRES,MAXRES,IREF,NREF)
C      SUBROUTINE WGTPR(WGTM,MAP,NWGT)
C      SUBROUTINE WNORM(WGT,IRESET,IW,IP,SKIP)
C
C  NBBP MODULE ROUTINES:
C
C      SUBROUTINE NBBP(T,TMO,BBP,SCR,LFN)
C      SUBROUTINE FNDFIL(LFNFIL,ERROR)
C      SUBROUTINE NBPARS(STR,NV,IVAL)
C      FUNCTION NBINTV(STR)
C      FUNCTION LENNB(STRING)
C
C  NBSTER (STERIC) MODULE ROUTINES:
C
C      SUBROUTINE NBSTER(T,S,FNLMO,SCR,MOLNBO,LFNSTR)
C      SUBROUTINE WORTUN(FO,S,W,FP,IERR)
C
C  NEDA ROUTINES:
C
C      SUBROUTINE NBOEDA(T,DM,SCR1,SCR2)
C      SUBROUTINE EDAOUT(ETOT,E,SNRG,FENRG,FPNRG,FSNRG,EDEF,ECP,EFLD,
C     +                  EDFF,DEF,LISTA)
C      SUBROUTINE SVNEWT(T)
C      SUBROUTINE FENEWT(T)
C      SUBROUTINE SVTEDA(T)
C      SUBROUTINE FETEDA(T)
C      SUBROUTINE SVEIG(U)
C      SUBROUTINE FEEIG(U)
C      SUBROUTINE SVDDEF(SCR,NFRG)
C      SUBROUTINE FEDDEF(SCR,NFRG)
C      SUBROUTINE SVDFLD(SCR,NFRG)
C      SUBROUTINE FEDFLD(SCR,NFRG)
C      SUBROUTINE SVDCP(SCR,NFRG)
C      SUBROUTINE FEDCP(SCR,NFRG)
C      SUBROUTINE SVVNUC(SCR,NFRG)
C      SUBROUTINE FEVNUC(SCR,NFRG)
C
C  CHECKPOINTING ROUTINES:
C
C      SUBROUTINE SRTCHK(DM,T,S,SCR,IRNK)
C      SUBROUTINE RDPERM(T,S,IRNK,IARC,ITMP,IORG,LIST)
C      SUBROUTINE RDPRM2(TA,TB)
C      SUBROUTINE FILFLD(LFN,STR,LENGTH,IAMNEW,END)
C
C  ANALYSIS OF CANONICAL MOLECULAR ORBITALS:
C
C      SUBROUTINE CMOANL(TMO,TMP,SCR,IFLG)
C
C  NATURAL NMR CHEMCIAL SHIELDING TENSOR ANALYSIS
C  LFN 26-31 ARE USED BY NCS AS SCRATCH FILES
C      SUBROUTINE NMRWR(D,IX,JY,KZ,IFI,NCF)
C      SUBROUTINE FEH01(IAT,IY,H01I,NBAS,IERR)
C      SUBROUTINE FEH11(IAT,IX,JY,H11I,NBAS,IERR)
C      SUBROUTINE NCSATM(IAT,A,B,D,T,C,C10X,C10Y,C10Z,NBAS,NOCC,LFNU,
C     +           LFNI,SCR1,SCR2,SCR3,SCR4,H01J,IWCMO)
C      SUBROUTINE NCSUAJ(IAT,JY,A,B,D,C,NBAS,NOCC,LFNU,H11XJ,H11YJ,
C     +           H11ZJ,SCRA,IWCMO)
C      SUBROUTINE NCSIAJ(IAT,JY,A,B,T,C,C10X,C10Y,C10Z,NBAS,NOCC,LFNI,
C     +           H01JY,SCRX,SCRY,SCRZ,SCR,IWCMO)
C      FUNCTION TRCNCS(A,B,NDIM)
C      SUBROUTINE NCSXYZ(IAT,NBAS,NOCC,SIGXL,SIGYL,SIGZL,LFNU,LFNI,
C     +           LFNPR,LFNISO,IWXYZ,IWCSA,IWD,IWP,IZ,R,IORDER,IWCMO)
C      SUBROUTINE NCSCSA(IAT,SIGTOT,LFNX,LFNY,LFNZ,LFNPR,
C     +           IWCSA,IZ,ITYP,R,IORDER,IWCMO)
C      SUBROUTINE NCSISO(NOCC,NATM,NUC,SIGISO,LFNISO,LFNPR,IWCMO)
C
C  FIX DENSITY MATRIX (FIXDM) ROUTINES:
C
C      SUBROUTINE FIXDM(DM,S,V,EV,SCR,V1,V2,NDIM,NBAS,LFNPR)
C      SUBROUTINE AXWBX(NDIM,N,A,B,W,IWMATX,X,V1,V2,IERR,LFNPR)
C      SUBROUTINE REBAKA(NDIM,N,B,DL,Z)
C      SUBROUTINE REDUC1(NDIM,N,A,B,DL,IERR,LFNPR)
C      SUBROUTINE TQLRAT(N,D,EZ,IERR)
C      SUBROUTINE NBTQL2(NDIM,N,D,E,Z,IERR)
C      SUBROUTINE TRED1(NDIM,N,A,D,E,E2)
C      SUBROUTINE TRED2(NDIM,N,A,D,E,Z)
C
C  3-CENTER, 4-ELECTRON HYPERBOND (3CHB) SEARCH:
C
C      SUBROUTINE NB3CHB(DM,LFNPR)
C
C  NATURAL J-COUPLING ROUTINES (LFN 91, 92 USED AS SCRATCH)
C
C      SUBROUTINE NJC(TBL,FCG,FCB,FCL,TBLA,TBLB,FCBA,FCBB,FCLA,FCLB,
C                 DJI_NL,DI_L,DPJI_NL,DPI_L,SCR1,SCR2,V1,V2,V3,V4,LFNPR)
C      SUBROUTINE NJCANL(IATNP,TBLA,TBLB,FCBA,FCBB,FCLA,FCLB,
C     +           DJI_NL,DI_L,DPJI_NL,DPI_L,SCR1,SCR2,V1,V2,V3,V4,LFNPR)
C      SUBROUTINE NJCTAB(IATN,IATNP,DJI_NL,DI_L,DELOC,REPOL,
C     +           SUMBI,SUMBJ,DM,T,LFNPR)
C      SUBROUTINE NJCATM(IAT)
C      SUBROUTINE NJCLNK(IA,IB,LINKS,NLINKS,IERR)
C      SUBROUTINE NJCLAB(IATN,IATNP,LINKS,NLINKS,MOLLOC,TITLE)
C      SUBROUTINE FNDHYBS(INBO,IH1,IH2,IH3)
C      SUBROUTINE CONSTFC(CGYRO,IZ1,IZ2,IPR,LFNPR)
C      SUBROUTINE RMBLNK(STR,NS)
C      FUNCTION IPHTYP(IBO,JBO)
C      SUBROUTINE FCAOEL(FCAO,SCR,ISCR,NBAS,NDIM,NATOMS)
C      SUBROUTINE NBRSTR(FVAL,STR,NS)
C      SUBROUTINE NBISTR(INT0,STR,NS)
C      SUBROUTINE INTVAL(STR)
C      SUBROUTINE AOVAL2(AOAMP,R,ORIGIN)
C      FUNCTION AOAFAC(R,ITYPE)
C      SUBROUTINE ITYPERR(ITYPE)
C      SUBROUTINE STRUCF(ITYPE,NKAL,CAL,NXAL,NYAL,NZAL)
C      SUBROUTINE BNORM
C      FUNCTION AONORM(ITYPE,ZETA1,ZETA2)
C      FUNCTION ATMFAC(R,N)
C      FUNCTION OLAPCG(N1,ZETA1,C1,N2,ZETA2,C2)
C      FUNCTION OLAP1D(NX1,ZETA1,X1,NX2,ZETA2,X2,ALFA)
C
C***********************************************************************
      SUBROUTINE NBO(CORE,MEMORY,NBOOPT)
C***********************************************************************
C 30-Dec-97  FAW  Re-format for MAXATM < 999, MAXBAS < 9999 (set to 200, 2000)
C 13-Nov-96  FAW  Add error messages for MAXBAS, MAXATM overruns
C 22-Dec-93  EDG  Call to NBCLOS returned from RUNNBO to NBO
C 28-Sep-93  FAW  Eliminate $PERM keylist; use <PERM> bracket input
C 10-May-93  JKB  Close of NBODAF moved to SR RUNNBO to avoid deleting
C                     NBO DAF before deletion occurs in Gaussian version
C 15-Feb-93  FAW  Add RDPERM to permute checkpoint matrices from $PERM list
C 10-Feb-93  EDG  Close NBODAF according to NBOOPT(7)
C-----------------------------------------------------------------------
C
C  Input:
C     CORE       Core memory to be dynamically allocated for storage needs.
C     MEMORY     The number of REAL*8 words available in `CORE'.
C     NBOOPT(10) List of NBO options as summarized below:
C
C     NBOOPT(1)  = -2       Do nothing
C                = -1       Natural Population Analysis (NPA) only
C                =  0       Perform NPA/NBO/NLMO analyses
C                =  1       Perform NPA/NBO/NLMO analyses, don't read keywords
C                =  2       Perform one Fock matrix deletion, forming new DM
C                =  3       Evaluate and print the energy change from deletion
C
C     NBOOPT(2)  =  0       SCF density
C                =  1       MP first order density
C                =  3       MP2 density
C                =  4       MP3 density
C                =  5       MP4 density
C                =  6       CI one-particle density
C                =  7       CI density
C                =  8       QCI/CC density
C                =  9       Density correct to second order
C
C     NBOOPT(3)  =  1       Transform dipole moment matrices to NBO/NLMO bases
C
C     NBOOPT(4)  =  1       Allow strongly resonant Lewis Structures
C                           (Force the RESONANCE keyword)
C
C     NBOOPT(5)  =  1       Spin-annihilated UHF (AUHF) wavefunction
C
C     NBOOPT(6)             Unused
C
C     NBOOPT(7)  =  0       Delete the NBO direct access file
C                =  1       Save the NBO direct access file
C
C     NBOOPT(8)  =  N       File unit number containing density matrix
C                               (Gaussian version)
C
C     NBOOPT(9)  =  I       Ith excited state CI density (Gaussian version)
C
C     NBOOPT(10) =  0       General version of the NBO program (GENNBO)
C                =  1       AMPAC version
C                =  2       NWChem version
C                =  6       GAMESS version
C                =  7       HONDO version
C                =  8x      Gaussian 8x version
C                =  9x      Gaussian 9x version
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL NEWDAF,ERROR
      LOGICAL DEL
C
C  NBO COMMON BLOCKS:
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBPRMC/LFNPRM
C
      DIMENSION CORE(MEMORY),NBOOPT(10)
C
C  IF NBOOPT(1).EQ.-2, THEN NO NBO ANALYSIS WAS REQUESTED:
C
      IF(NBOOPT(1).EQ.-2) RETURN
C
C  SET DEFAULT OPTIONS:
C
      CALL NBOSET(NBOOPT)
C
C  IF THIS IS THE GENERAL VERSION OF THE PROGRAM, READ THE $GENNBO KEYLIST:
C
      IF(NBOOPT(10).EQ.0) THEN
        CALL GENINP(NEWDAF)
      ELSE
        NEWDAF = .TRUE.
      END IF
C
C  SEARCH THE INPUT FILE FOR THE $NBO KEYLIST:
C
      CALL NBOINP(NBOOPT,IDONE)
      IF(IDONE.EQ.1) RETURN
C
C  READ IN JOB OPTIONS FROM THE $NBO KEYLIST:
C
      CALL JOBOPT(NBOOPT)
C
C  CHECK FILENAME AND OPEN SEQUENTIAL FILES:
C
      CALL NBFILE(NEWDAF,ERROR)
      IF(ERROR) RETURN
C
C  OPEN THE NBO DIRECT ACCESS FILE:
C
      CALL NBOPEN(NEWDAF,ERROR)
      IF(ERROR) THEN
        WRITE(LFNPR,900)
        RETURN
      END IF
C
C  FETCH ATOMS, BASIS, AND WAVE FUNCTION INFORMATION:
C
      CALL FEAOIN(CORE,CORE,MEMORY,NBOOPT)
      IF(NBAS.GT.MAXBAS) THEN
        ERROR = .TRUE.
        WRITE(LFNPR,930) NBAS,MAXBAS
        RETURN
      ELSE IF(NATOMS.GT.MAXATM) THEN
        ERROR = .TRUE.
        WRITE(LFNPR,940) NATOMS,MAXATM
        RETURN
      END IF
      IF(COMPLX) RETURN
C
C  WRITE THE JOB TITLE TO THE OUTPUT FILE:
C
      CALL FETITL(CORE)
      WRITE(LFNPR,910) (CORE(I),I=1,8)
C
C  SET UP DIMENSIONING INFORMATION AND DETERMINE IF ENOUGH SPACE IS AVAILABLE:
C
      CALL NBODIM(MEMORY)
C
C  SET UP BASIC STORAGE:
C
C  CORE(NDM) :  NDIM BY NDIM MATRIX TO STORE DENSITY MATRIX
C  CORE(NT)  :  NDIM BY NDIM MATRIX TO HOLD OVERLAP OR TRANSFORMATION MATRICES
C  CORE(NSCR):  SCRATCH STORAGE, DYNAMICALLY ALLOCATED ACCORDING TO NEEDS
C
      N2   = NDIM*NDIM
      NDM  = 1
      NT   = NDM + N2
      NSCR = NT  + N2
      MEM  = MEMORY - NSCR + 1
C
C  READ IN INPUT OVERLAP AND DENSITY MATRICES, AO BASIS:
C
      ALPHA = .FALSE.
      BETA  = .FALSE.
      ISPIN = 0
      CALL FEDRAW(CORE(NDM),CORE(NSCR))
C
C  SIMULATE THE NATURAL POPULATION ANALYSIS IF THE INPUT BASIS IS ORTHOGONAL:
C
      IF(ORTHO) THEN
        CALL NAOSIM(CORE(NDM),CORE(NT),CORE(NSCR))
C
C  LOAD THE OVERLAP MATRIX INTO CORE(NT) AND PERFORM THE NATURAL POPULATION
C  ANALYSIS:
C
      ELSE
        CALL FESRAW(CORE(NT))
        CALL NAODRV(CORE(NDM),CORE(NT),CORE(NSCR))
      END IF
C
C  NOTE: CORE(NDM) NOW CONTAINS THE TOTAL DENSITY MATRIX IN THE NAO BASIS
C        AND CORE(NT) CONTAINS THE AO TO NAO TRANSFORMATION
C
C  PERFORM CLOSED SHELL NBO ANALYSIS (ALSO FOR MSPNBO):
C
      IF(.NOT.OPEN.OR.(IWMSP.EQ.1)) THEN
        IF(IWMSP.EQ.1) WRITE(LFNPR,920)
        CALL NBODRV(CORE(NDM),CORE(NT),CORE(NSCR),MEM)
      ELSE
C
C  PERFORM OPEN SHELL NBO ANALYSIS:
C
C  FIRST, ANALYZE ALPHA DENSITY MATRIX:
C
        ALPHA = .TRUE.
        BETA  = .FALSE.
        ISPIN = 2
        IF(ORTHO) THEN
          CALL DMSIM(CORE(NDM),CORE(NT),CORE(NSCR))
        ELSE
          CALL DMNAO(CORE(NDM),CORE(NT),CORE(NSCR))
        END IF
        CALL NBODRV(CORE(NDM),CORE(NT),CORE(NSCR),MEM)
C
C  NOW, ANALYZE BETA DENSITY MATRIX:
C
        ALPHA = .FALSE.
        BETA  = .TRUE.
        ISPIN = -2
        IF(ORTHO) THEN
          CALL DMSIM(CORE(NDM),CORE(NT),CORE(NSCR))
        ELSE
          CALL DMNAO(CORE(NDM),CORE(NT),CORE(NSCR))
        END IF
        CALL NBODRV(CORE(NDM),CORE(NT),CORE(NSCR),MEM)
      END IF
C
C  SORT THE CHECKPOINT MATRICES:
C
      NDM  = 1
      NT   = NDM  + N2
      NS   = NT   + N2
      NSCR = NS   + N2
      NRNK = NSCR + NDIM
      NARC = NRNK + NDIM
      NTMP = NARC + NDIM
      NORG = NTMP + NDIM
      NLST = NORG + NDIM
      IF(JPRINT(63).LT.0) THEN
        CALL SRTCHK(CORE(NDM),CORE(NT),CORE(NS),CORE(NSCR),CORE(NRNK))
      END IF
C
C  REORDER THE CHECKPOINT MATRICES FROM <PERM> LIST IN LFNPRM?
C
      IF(JPRINT(63).GT.0.AND.LFNPRM.NE.0) THEN
        CALL RDPERM(CORE(NT),CORE(NS),CORE(NRNK),CORE(NARC),CORE(NTMP),
     +              CORE(NORG),CORE(NLST))
      END IF
C
C  CHECKPOINT TRANSFORMATIONS:
C
      IF(JPRINT(63).NE.0) CALL CHKNBO(CORE)
C
C  CLOSE THE DAF AND DELETE IT ACCORDING TO NBOOPT(7,10):
C
      DEL = .FALSE.
      IF(NBOOPT( 7).EQ.0) DEL = .TRUE.
      IF(NBOOPT(10).LT.0) DEL = .TRUE.
      CALL NBCLOS(DEL)
      RETURN
C
  900 FORMAT(/1X,'NBO direct access file could not be opened.  NBO ',
     + 'program aborted.')
  910 FORMAT(/1X,'Job title: ',8A8)
  920 FORMAT(/1X,'Performing analysis with maximum spin-paired NBOs')
  930 FORMAT(/1X,'No. of basis functions (',I5,') exceeds allowed',
     +' maximum (',I4,');',/,1X,'NBO program aborted.')
  940 FORMAT(/1X,'No. of atoms (',I5,') exceeds allowed',
     +' maximum (',I3,');',/,1X,'NBO program aborted.')
      END
C***********************************************************************
C NBO 5.G -- Natural Bond Orbital Analysis Programs
C (c) Copyright 1996-2008 Board of Regents of the University of Wisconsin System
C     on behalf of the Theoretical Chemistry Institute.  All Rights Reserved.
C***********************************************************************
C
C  JOB INITIALIZATION ROUTINES: (CALLED BY SR NBO)
C
C      SUBROUTINE NBOSET(NBOOPT)
C      SUBROUTINE JOBOPT(NBOOPT)
C      SUBROUTINE JOBOPT1(NBOOPT,CKEY,IFOUND,INBERR,NEXTWD,
C     +  LENG,END,KEYWD)
C      SUBROUTINE JOBOPT2(NBOOPT,CKEY,IFOUND,INBERR,NEXTWD,
C     +  LENG,END,KEYWD)
C      SUBROUTINE JOBOPT3(NBOOPT,CKEY,IFOUND,INBERR,NEXTWD,
C     +  LENG,END,KEYWD)
C      SUBROUTINE NBCVRT(KEYWD,LENG,CKEYWD)
C      SUBROUTINE RDELEM(LFN)
C      SUBROUTINE RDELM2(LFN)
C      SUBROUTINE NBODIM(MEMORY)
C
C***********************************************************************
      SUBROUTINE NBOSET(NBOOPT)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION NBOOPT(10)
C
      PARAMETER(MAXBAS = 2000)
      PARAMETER(MAXFIL = 40)
C
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBTHR/THRSET,PRJSET,ACCTHR,CRTSET,E2THR,ATHR,PTHR,ETHR,
     +             DTHR,DLTHR,CHSTHR,REFTHR,STTHR,PRTHR,THRNCS,THRNJC
      COMMON/NBLBL/NLEW,NVAL,LBL(10,MAXBAS,5)
      COMMON/NBNAME/FILENM,NFILE,IFILE(MAXFIL)
      COMMON/IOCWAR/IOCWAR
      CHARACTER*256 FILENM
C
      SAVE TENTH,HALF
      DATA TENTH,HALF/0.1D0,0.5D0/
C
C  SET DEFAULT JOB OPTIONS:  (MODIFICATIONS TO THESE DEFAULTS
C  SHOULD NOT BE MADE HERE BUT LATER IN THIS SUBROUTINE)
C
C  USE THE BOND-ORDER MATRIX, NOT THE OCCUPATION MATRIX (EXPECTATION
C  VALUES OF THE DENSITY OPERATOR)
C
      IWDM   =  1
      IW3C   =  0
      IWAPOL =  0
      IWHYBS =  0
      IWPNAO =  0
      IWTNAO =  0
      IWTNAB =  0
      IWTNBO =  0
      IWNBBP =  0
      IWMSP  =  0
      IWFIXDM = 0
      IW3CHB  = 0
      IWNJC   = 0
C
C  USE THE FOCK MATRIX, IF THERE IS ONE:
C
      IWFOCK =  1
C
C  SET TO THE DESIRED PRINT LEVEL + 10:
C
      IPRINT = 12
      IPSEUD =  0
      IWDETL =  0
      IWMULP =  0
      ICHOOS =  0
      JCORE  =  0
      IWCUBF =  0
      OPEN   = .FALSE.
      ORTHO  = .FALSE.
      UHF    = .FALSE.
      AUHF   = .FALSE.
      ROHF   = .FALSE.
      CI     = .FALSE.
      MCSCF  = .FALSE.
      COMPLX = .FALSE.
      DO 10 I = 1,100
        JPRINT(I) = 0
   10 CONTINUE
      JPRINT(14) = -1
      JPRINT(56) = -20
      JPRINT(80) = -1
C
      LFNAO  =  31
      LFNPNA =  32
      LFNNAO =  33
      LFNPNH =  34
      LFNNHO =  35
      LFNPNB =  36
      LFNNBO =  37
      LFNPNL =  38
      LFNNLM =  39
      LFNMO  =  40
      LFNDM  =  41
      LFNNAB =  42
      LFNPPA =  43
      LFNLBL =  46
      LFNARC =  47
C
C  SET POSITIVE IN ROUTINE JOBOPT IF CHOSEN BY THE USER:
C
      LFNDAF = -48
      LFNDEF =  49
C
C  INITIALIZE THE LFNBRK (BRACKET ENTRY) ARRAY
C
      DO K = 1,100
        LFNBRK(K) = 0
      ENDDO
C
C  SETTING NVAL NEGATIVE INDICATES THAT THIS VARIABLE HAS NOT
C  BEEN DETERMINED YET:
C
      NVAL   = -1
C
C  SET OCCUPANCY ERROR COUNTER
C
      IOCWAR = 0
C
C  INITIALIZE THE CHARACTER STRING USED TO CREATE FILENAMES:
C
      FILENM(1:4) = 'FILE'
      DO 50 I = 5,256
        FILENM(I:I) = CHAR(32)
   50 CONTINUE
C
C  THAT SOME THRESHOLDS ARE .LT.0 INDICATES THAT THESE VARIABLES HAVE NOT
C  BEEN SET BY THE USER:
C
      THRSET =  -1.9D0
      PRJSET =  -0.2D0
      ACCTHR =  -TENTH
      CRTSET =   1.999D0
      E2THR  =  -HALF
      ATHR   =  -1.000D0
      PTHR   = -25.000D0
      ETHR   =  -0.100D0
      DTHR   =  -0.020D0
      DLTHR  =  -1.000D0
      CHSTHR =  -0.100D0
      REFTHR =  -0.350D0
      STTHR  =  -HALF
      PRTHR  =  -1.000D0
C
C  SET JOB OPTIONS ACCORDING TO NBOOPT:
C
C  SKIP THE COMPUTATION OF THE NBOS?
C
      IF(NBOOPT(1).EQ.-1) JPRINT(1) = 1
C
C  TURN OFF $CHOOSE AND $CORE KEYLISTS IF $NBO KEYLIST IS NOT TO
C  BE READ:
C
      IF(NBOOPT(1).EQ.1) ICHOOS = -1
      IF(NBOOPT(1).EQ.1) JCORE  = -1
C
C  FORCE DIPOLE ANALYSIS?
C
      IF(NBOOPT(3).NE.0) THEN
        JPRINT(46) = 1
      END IF
C
C  FORCE RESONANCE KEYWORD?
C
      IF(NBOOPT(4).NE.0) JPRINT(14) = 1
C
C  PROGRAM VERSION:
C
      JPRINT(2) = NBOOPT(10)
C
      RETURN
      END
C***********************************************************************
      SUBROUTINE JOBOPT(NBOOPT)
C***********************************************************************
C 15-Jun-01  CMM  Call 3CHB automatically when NRT is requested.
C 23-Feb-01  FAW  Add LFNBRK(100) and user-specified <matrix elements> IO
C 20-Dec-00  FAW  Add 3CHB keyword [IW3CHB]
C 27-Nov-00  FAW  Add FIXDM keyword [IWFIXDM]
C 27-Nov-00  FAW  Break up JOBOPT into JOBOPT1, JOBOPT2, JOBOPT3
C 15-Nov-00  JAB  Add NCS keyword [JPRINT(86)]
C 27-May-98  EDG  Add SVEC [JPRINT(85)] and SPARTAN [JPRINT(84)] keywords
C 23-Jul-97  FAW  Add CMO keyword [JPRINT(82)].
C 22-Aug-96  EDG  Add DMPNAO keyword [JPRINT(83)]
C  2-Jul-95  EDG  Add DIST keyword [JPRINT(81)].  Automatically activate with
C                 BNDIDX or NRT for GENNBO
C 25-Jun-95  EDG  Modified PLOT option to prevent multiple OPENs of FILE.46
C 17-Feb-94  FAW  Added final copyright message
C  1-Feb-94  JKB  Add NRTCHG keyword [JPRINT(80)], grouped NRT keywords
C 25-Jan-94  FAW  Add MSPNBO keyword [IWMSP]
C 11-Dec-93  EDG  Add FPNHO and FPNBO keywords [JPRINT(78),JPRINT(79)]
C  3-Dec-93  EDG  Add NRTFDM keyword [JPRINT(77)]
C  2-Dec-93  EDG  Punch $NRTSTR according to NRTLST
C 11-Nov-93  FAW  Added AMPAC bypasses and 'unrecognizable keyword' fix
C 29-Sep-93  FAW  Added STERIC keyword [JPRINT(76)]
C 28-Sep-93  FAW  File-input bracket input (instead of $PERM keylist)
C                 for checkpoint permutation info.  Add COMMON/NBPRMC/
C 19-Jul-93  EDG  Add NRTWGT keyword (threshold wgt for multi-ref)
C                 and REFTHR to /NBTHR/
C  3-Mar-93  EDG  Save DAF if FILE keyword appears in $NBO keylist
C 25-Jan-93  JKB  Added KAO, KNAO, KNHO, KNBO, KNLMO, KMO, and
C                 corresponding VAO, etc. keywords [JPRINT(64-75)]
C 18-Jan-93  EDG  Checkpointing [JPRINT(63)]
C 14-Jan-93  EDG  Added FMO [JPRINT(60)], DMMO [JPRINT(61)], and DIMO
C                 [JPRINT(62)] keywords
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL END,EQUAL,NEXTWD
      DIMENSION NBOOPT(10),INTTMP(256)
C
      PARAMETER(KEYLEN = 9)
      PARAMETER(MAXFIL = 40)
C
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBTHR/THRSET,PRJSET,ACCTHR,CRTSET,E2THR,ATHR,PTHR,ETHR,
     +             DTHR,DLTHR,CHSTHR,REFTHR,STTHR,PRTHR,THRNCS,THRNJC
      COMMON/NBNAME/FILENM,NFILE,IFILE(MAXFIL)
      COMMON/NBPRMC/LFNPRM
      CHARACTER*256 FILENM
      CHARACTER BLANK*1,CKEYWD*9
C
      DIMENSION KEYWD(KEYLEN)
C
      DIMENSION KALT(4)
      DATA KALT/1H$,1HE,1HN,1HD/
C
      SAVE ZERO,HUNDRD
      SAVE IFULL,IVAL,ILEW,IPRNT,IWRIT,IREAD,ICHK,IB,IP,BLANK
      DATA ZERO,HUNDRD/0.0D0,1.0D2/
      DATA IFULL,IVAL,ILEW/4HFULL,3HVAL,3HLEW/
      DATA IPRNT,IWRIT,IREAD,ICHK/4HPRNT,4HWRIT,4HREAD,3HCHK/
      DATA IB,IP/1HB,1HP/
      DATA BLANK/' '/
C
C  READ IN JOB OPTIONS, IN A KEYWORD DIRECTED MANNER:
C
      INBERR = 0
      NUMOPT = 0
      LENNM  = 0
      IF(NBOOPT(1).EQ.1) GOTO 4500
C
C  BEGIN LOOP TO IDENTIFY KEYWORD "KEYWD":
C
      NEXTWD = .TRUE.
  100 LENG = KEYLEN
      IF(NEXTWD) CALL HFLD(KEYWD,LENG,END)
      NEXTWD = .TRUE.
      IF((LENG.EQ.0).OR.END) GO TO 4500
      IF(EQUAL(KEYWD,KALT,4)) GO TO 4500
      NUMOPT = NUMOPT + 1
C Convert Hollerith to character
      CALL NBCVRT(KEYWD,LENG,CKEYWD)
      NC=LENNB(CKEYWD)
      CALL JOBOPT1(NBOOPT,CKEYWD(1:NC),IFOUND,INBERR,NEXTWD,
     +  LENG,END,KEYWD)
      IF(IFOUND.EQ.1) GOTO 100
      CALL JOBOPT2(NBOOPT,CKEYWD(1:NC),IFOUND,INBERR,NEXTWD,
     +  LENG,END,KEYWD)
      IF(IFOUND.EQ.1) GOTO 100
      CALL JOBOPT3(NBOOPT,CKEYWD(1:NC),IFOUND,INBERR,NEXTWD,
     +  LENG,END,KEYWD)
      IF(IFOUND.EQ.1) GOTO 100
C  KEYWORD: FILE -- SELECT ALTERNATE FILENAME
      IF(CKEYWD.EQ.'FILE') THEN
        LENG = 80
        CALL HFLD(INTTMP,LENG,END)
        IF(.NOT.END) LENNM = LENG
        GO TO 100
      ENDIF
C  UNRECOGNIZABLE KEYWORD
      IF(INBERR.EQ.0) THEN
        INBERR=1
        WRITE(LFNPR,5000)
      END IF
 5000 FORMAT(/1X,35('*'),' NBO 5.G ',35('*')/)
      WRITE(LFNPR,5010) (CKEYWD(I:I),I=1,NC)
 5010 FORMAT(1X,'Unrecognizable $NBO keyword: ',6A1)
      GO TO 100
C-----------------------------------------------------------------------
 4500 CONTINUE
C
C  IF OPTION `FILE' WAS SELECTED, EXTRACT THE FILENAME FROM HOLLERITH
C  ARRAY INTTMP:
C
      IF(LENNM.NE.0) THEN
        DO 4510 I = 1,LENNM
          WRITE(FILENM(I:I),'(A1)') INTTMP(I)
 4510   CONTINUE
        DO 4520 I = LENNM+1,256
          FILENM(I:I) = BLANK
 4520   CONTINUE
      END IF
C-----------------------------------------------------------------------
C
C  IF THE PRINT LEVEL IS SET TO ZERO AND NO OTHER OPTIONS WERE ENTERED,
C  COMPLETELY SHUT OFF PROGRAM PRINTING:
C
      IF(NUMOPT.EQ.1.AND.IPRINT.EQ.0) IPRINT = -1
C
C  CHECK FOR JOB OPTIONS THAT ARE CURRENTLY INCOMPATABLE:
C
      IF((IWDM.EQ.0).AND.(IWMULP.NE.0)) THEN
        WRITE(LFNPR,5040)
 5040 FORMAT(1X,'The NBO program must stop because the options /MULAT/',
     + ' and /MULORB/',/1X,'currently require the AO bond order matrix',
     + ', rather than the AO density',/1X,'matrix.  The program could ',
     + 'be modified to permit this.')
        CALL NBHALT('Option MULAT/MULORB incompatible with DM.')
      END IF
C
C  CHECK FOR JOB OPTIONS THAT ARE STRICTLY INCOMPATIBLE:
C
      IF(ORTHO) THEN
        IWTNAO     = 0
        JPRINT(9)  = 0
        JPRINT(11) = 0
        JPRINT(18) = 0
        JPRINT(19) = 0
        JPRINT(20) = 0
        JPRINT(21) = 0
        JPRINT(25) = 0
        JPRINT(30) = 0
        JPRINT(31) = 0
        JPRINT(33) = 0
        JPRINT(35) = 0
        JPRINT(39) = 0
        JPRINT(44) = 0
        JPRINT(48) = 0
        JPRINT(49) = 0
        JPRINT(51) = 0
        JPRINT(65) = 0
        JPRINT(71) = 0
      END IF
C
C  CHECKPOINT OPTION:
C
      IF(ABS(JPRINT(63)).EQ.1)  JPRINT(59) = ICHK
      IF(ABS(JPRINT(63)).EQ.2)  JPRINT(44) = ICHK
      IF(ABS(JPRINT(63)).EQ.3)  IWTNAO     = ICHK
      IF(ABS(JPRINT(63)).EQ.4)  JPRINT(30) = ICHK
      IF(ABS(JPRINT(63)).EQ.5)  JPRINT(28) = ICHK
      IF(ABS(JPRINT(63)).EQ.6)  JPRINT(25) = ICHK
      IF(ABS(JPRINT(63)).EQ.7)  IWTNBO     = ICHK
      IF(ABS(JPRINT(63)).EQ.8)  JPRINT(49) = ICHK
      IF(ABS(JPRINT(63)).EQ.9)  JPRINT(23) = ICHK
C
C-----------------------------------------------------------------------
C
C  START PRINTING NBO OUTPUT:
C
      IF(IPRINT.GE.0) THEN
        WRITE(LFNPR,6000)
        WRITE(LFNPR,6005)
        IF(NUMOPT.GT.0) WRITE(LFNPR,6010)
C-----------------------------------------------------------------------
 6000 FORMAT(/1X,35('*'),' NBO 5.G ',35('*')/,13X,
     * 'N A T U R A L   A T O M I C   O R B I T A L   A N D'/,
     * 10X,'N A T U R A L   B O N D   O R B I T A L   ',
     *    'A N A L Y S I S',/1X,79('*'))
 6005 FORMAT(2X,'(c) Copyright 1996-2008 Board of Regents of the ',
     * 'University of Wisconsin System',/6X,'on behalf of the ',
     * 'Theoretical Chemistry Institute.  All Rights Reserved.',
     + //10X,'Cite this program as:',//10X,
     + 'NBO 5.G.  E. D. Glendening, J. K. Badenhoop, A. E. Reed,',
     + /10X,'J. E. Carpenter, J. A. Bohmann, C. M. Morales, and ',
     + 'F. Weinhold',
     + /10X,
     + '(Theoretical Chemistry Institute, University of Wisconsin,',
     + /10X,'Madison, WI, 2004); http://www.chem.wisc.edu/~nbo5')
 6010 FORMAT(1X)
C-----------------------------------------------------------------------
C
C  JOB CONTROL KEYWORDS:
C
        IF(JPRINT(4).NE.0) WRITE(LFNPR,6020)
        IF(JPRINT(5).NE.0) WRITE(LFNPR,6030)
        IF(JPRINT(6).NE.0) WRITE(LFNPR,6040)
        IF(JPRINT(10).NE.0) WRITE(LFNPR,6060)
        IF(IW3C.NE.0) WRITE(LFNPR,6070)
        IF(IWMSP.NE.0) WRITE(LFNPR,6075)
        IF(JPRINT(1).NE.0) WRITE(LFNPR,6080)
        IF(JPRINT(8).NE.0) WRITE(LFNPR,6090)
        IF(JPRINT(32).NE.0) WRITE(LFNPR,6100)
        IF(JPRINT(55).EQ.IB) THEN
          WRITE(LFNPR,6110)
        ELSE IF(JPRINT(55).EQ.IP) THEN
          WRITE(LFNPR,6111)
        ELSE IF(JPRINT(55).LT.0) THEN
          WRITE(LFNPR,6112)
        ELSE IF(JPRINT(55).GT.0) THEN
          WRITE(LFNPR,6113)
        END IF
        IF(JPRINT(56).GT.0) WRITE(LFNPR,6120) JPRINT(56)
        IF(JPRINT(80).GE.0) WRITE(LFNPR,6130) JPRINT(80)
        IF(REFTHR.GE.ZERO) WRITE(LFNPR,6150) REFTHR*HUNDRD
        IF(DLTHR.GE.ZERO) WRITE(LFNPR,6160) DLTHR
        IF(PRTHR.GE.ZERO) WRITE(LFNPR,6180) PRTHR*HUNDRD
        IF(JPRINT(57).NE.0) WRITE(LFNPR,6170)
        IF(JPRINT(77).NE.0) WRITE(LFNPR,6190)
        IF(JPRINT(86).GE.1) WRITE(LFNPR,6200)
        IF(JPRINT(86).GT.1) THEN
          WRITE(LFNPR,6210)
          IF(THRNCS.NE.0.5D0) WRITE(LFNPR,6220) THRNCS
        ENDIF
        IF(IWFIXDM.NE.0) WRITE(LFNPR,6230)
        IF(IW3CHB.NE.0) THEN
          WRITE(LFNPR,6240)
        ELSE
C  Turn on 3CHB search when NRT is requested  -CMM
        IF(JPRINT(32).EQ.1) IW3CHB = 1
        ENDIF
        IF(IWNJC.NE.0) THEN
          WRITE(LFNPR,6250)
C  Turn on the NLMO option for NJC
          JPRINT(8) = 1
        ENDIF
C-----------------------------------------------------------------------
 6020 FORMAT(1X,'      /NPA    / : Natural Population Analysis')
 6030 FORMAT(1X,'      /NBO    / : Natural Bond Orbital Analysis')
 6040 FORMAT(1X,'      /NBOSUM / : Print summary of the NBO analysis')
 6060 FORMAT(1X,'      /NOBOND / : No two-center NBO search')
 6070 FORMAT(1X,'      /3CBOND / : Search for 3-center bonds')
 6075 FORMAT(1X,'      /MSPNBO / : Maximum Spin-Paired NBOs')
 6080 FORMAT(1X,'      /SKIPBO / : Skip NBO transformation step')
 6090 FORMAT(1X,'      /NLMO   / : Form Natural Localized Molecular',
     *  ' Orbitals')
 6100 FORMAT(1X,'      /NRT    / : Natural Resonance Theory Analysis')
 6110 FORMAT(1X,'      /NRTOPT / : Optimize resonance weights with ',
     * 'BFGS method')
 6111 FORMAT(1X,'      /NRTOPT / : Optimize resonance weights with ',
     * 'POWELL method')
 6112 FORMAT(1X,'      /NRTOPT / : Optimize resonance weights with ',
     * 'ANNEAL method')
 6113 FORMAT(1X,'      /NRTOPT / : Optimize resonance weights with ',
     * 'ANNEAL method + penalty')
 6120 FORMAT(1X,'      /NRTMEM / : NRT memory set to ',I3)
 6130 FORMAT(1X,'      /NRTCHG / : Maximum formal charge allowed on ',
     * 'candidate',/23X,'LEWIS structures set to',I3)
 6150 FORMAT(1X,'      /NRTWGT / : Set to ',F5.1,'%')
 6160 FORMAT(1X,'      /NRTTHR / : Set to ',F5.2,' kcal/mol')
 6170 FORMAT(1X,'      /NRTDTL / : Detailed NRT output')
 6180 FORMAT(1X,'      /NRTLST / : Set to ',F5.1,'%')
 6190 FORMAT(1X,'      /NRTFDM / : Use full NAO density matrix for ',
     * 'multi-ref NRT')
C-----------------------------------------------------------------------
 6200 FORMAT(1X,'      /NCS    / : Natural Chemical Shielding Analysis')
 6210 FORMAT(1X,'                  with user-selected options ')
 6220 FORMAT(1X,'                  Print threshold reset to ',F5.2,
     * ' ppm')
C-----------------------------------------------------------------------
 6230 FORMAT(1X,'      /FIXDM  / : Correct input density matrix for',
     *' unphysical',/,19X,'negative or Pauli-violating occupancies')
C-----------------------------------------------------------------------
 6240 FORMAT(1X,'      /3CHB   / : Search for 3-c, 4-e hyperbonds')
C-----------------------------------------------------------------------
 6250 FORMAT(1X,'      /NJC    / : Natural J-Coupling Analysis')
C
C  JOB THRESHOLD KEYWORDS:
C
        IF(JPRINT(36).NE.0) WRITE(LFNPR,6500)
        IF(ATHR.GE.ZERO.OR.PTHR.GE.ZERO.OR.ETHR.GE.ZERO)
     +             WRITE(LFNPR,6510) ABS(ATHR),ABS(PTHR),ABS(ETHR)
        IF(JPRINT(3).NE.0) WRITE(LFNPR,6520)
        IF(E2THR.GT.ZERO) WRITE(LFNPR,6530) E2THR
        IF(JPRINT(46).NE.0) WRITE(LFNPR,6540)
        IF(DTHR.GE.ZERO) WRITE(LFNPR,6550) ABS(DTHR)
        IF(THRSET.GT.ZERO) WRITE(LFNPR,6560) THRSET
        IF(PRJSET.GT.ZERO) WRITE(LFNPR,6570) PRJSET
        IF(CHSTHR.GT.ZERO) WRITE(LFNPR,6580) CHSTHR
C-----------------------------------------------------------------------
 6500 FORMAT(1X,'      /BEND   / : Print NHO directionality table')
 6510 FORMAT(1X,'                  Print thresholds set to (',F4.1,
     *   ',',F5.1,',',F5.2,')')
 6520 FORMAT(1X,'      /E2PERT / : Analyze NBO Fock matrix')
 6530 FORMAT(1X,'                  Print threshold set to ',F5.2)
 6540 FORMAT(1X,'      /DIPOLE / : Print NBO/NLMO dipole moment ',
     *   'analysis')
 6550 FORMAT(1X,'                  Print threshold set to ',F5.2)
 6560 FORMAT(1X,'      /THRESH / : Set to ',F5.2)
 6570 FORMAT(1X,'      /PRJTHR / : Set to ',F5.2)
 6580 FORMAT(1X,'      /CHSTHR / : Set to ',F5.2)
C-----------------------------------------------------------------------
C
C  MATRIX OUTPUT KEYWORDS:
C
        IF(JPRINT(81).EQ.1) WRITE(LFNPR,6980)
        IF(JPRINT(59).EQ.IFULL) THEN
          WRITE(LFNPR,6990)
        ELSE IF(IOINQR(JPRINT(59)).EQ.IPRNT) THEN
          WRITE(LFNPR,6992) JPRINT(59)
        ELSE IF(IOINQR(JPRINT(59)).EQ.IWRIT) THEN
          WRITE(LFNPR,6994) ABS(JPRINT(59))
        ELSE IF(JPRINT(63).EQ.1) THEN
          WRITE(LFNPR,6996)
        ELSE IF(JPRINT(63).EQ.-1) THEN
          WRITE(LFNPR,6998)
        END IF
        IF(JPRINT(44).EQ.IFULL) THEN
          WRITE(LFNPR,7000)
        ELSE IF(IOINQR(JPRINT(44)).EQ.IPRNT) THEN
          WRITE(LFNPR,7002) JPRINT(44)
        ELSE IF(IOINQR(JPRINT(44)).EQ.IWRIT) THEN
          WRITE(LFNPR,7004) ABS(JPRINT(44))
        ELSE IF(JPRINT(63).EQ.2) THEN
          WRITE(LFNPR,7006)
        ELSE IF(JPRINT(63).EQ.-2) THEN
          WRITE(LFNPR,7008)
        END IF
        IF(IWTNAO.EQ.IFULL) THEN
          WRITE(LFNPR,7010)
        ELSE IF(IOINQR(IWTNAO).EQ.IPRNT) THEN
          WRITE(LFNPR,7012) IWTNAO
        ELSE IF(IOINQR(IWTNAO).EQ.IWRIT) THEN
          WRITE(LFNPR,7014) ABS(IWTNAO)
        ELSE IF(IOINQR(IWTNAO).EQ.IREAD) THEN
          WRITE(LFNPR,7016) ABS(IWTNAO/1000)
        ELSE IF(JPRINT(63).EQ.3) THEN
          WRITE(LFNPR,7018)
        ELSE IF(JPRINT(63).EQ.-3) THEN
          WRITE(LFNPR,7019)
        END IF
        IF(JPRINT(30).EQ.IFULL) THEN
          WRITE(LFNPR,7020)
        ELSE IF(IOINQR(JPRINT(30)).EQ.IPRNT) THEN
          WRITE(LFNPR,7022) JPRINT(30)
        ELSE IF(IOINQR(JPRINT(30)).EQ.IWRIT) THEN
          WRITE(LFNPR,7024) ABS(JPRINT(30))
        ELSE IF(JPRINT(63).EQ.4) THEN
          WRITE(LFNPR,7026)
        ELSE IF(JPRINT(63).EQ.-4) THEN
          WRITE(LFNPR,7028)
        END IF
        IF(JPRINT(28).EQ.IFULL) THEN
          WRITE(LFNPR,7030)
        ELSE IF(IOINQR(JPRINT(28)).EQ.IPRNT) THEN
          WRITE(LFNPR,7032) JPRINT(28)
        ELSE IF(IOINQR(JPRINT(28)).EQ.IWRIT) THEN
          WRITE(LFNPR,7034) ABS(JPRINT(28))
        ELSE IF(JPRINT(63).EQ.5) THEN
          WRITE(LFNPR,7036)
        ELSE IF(JPRINT(63).EQ.-5) THEN
          WRITE(LFNPR,7038)
        END IF
        IF(JPRINT(25).EQ.IFULL) THEN
          WRITE(LFNPR,7040)
        ELSE IF(JPRINT(25).EQ.ILEW) THEN
          WRITE(LFNPR,7042)
        ELSE IF(IOINQR(JPRINT(25)).EQ.IPRNT) THEN
          WRITE(LFNPR,7044) JPRINT(25)
        ELSE IF(IOINQR(JPRINT(25)).EQ.IWRIT) THEN
          WRITE(LFNPR,7046) ABS(JPRINT(25))
        ELSE IF(JPRINT(63).EQ.6) THEN
          WRITE(LFNPR,7048)
        ELSE IF(JPRINT(63).EQ.-6) THEN
          WRITE(LFNPR,7049)
        END IF
        IF(IWTNBO.EQ.IFULL) THEN
          WRITE(LFNPR,7050)
        ELSE IF(IWTNBO.EQ.ILEW) THEN
          WRITE(LFNPR,7052)
        ELSE IF(IOINQR(IWTNBO).EQ.IPRNT) THEN
          WRITE(LFNPR,7054) IWTNBO
        ELSE IF(IOINQR(IWTNBO).EQ.IWRIT) THEN
          WRITE(LFNPR,7056) ABS(IWTNBO)
        ELSE IF(JPRINT(63).EQ.7) THEN
          WRITE(LFNPR,7058)
        ELSE IF(JPRINT(63).EQ.-7) THEN
          WRITE(LFNPR,7059)
        END IF
        IF(JPRINT(49).EQ.IFULL) THEN
          WRITE(LFNPR,7060)
        ELSE IF(JPRINT(49).EQ.ILEW) THEN
          WRITE(LFNPR,7062)
        ELSE IF(IOINQR(JPRINT(49)).EQ.IPRNT) THEN
          WRITE(LFNPR,7064) JPRINT(49)
        ELSE IF(IOINQR(JPRINT(49)).EQ.IWRIT) THEN
          WRITE(LFNPR,7066) ABS(JPRINT(49))
        ELSE IF(JPRINT(63).EQ.8) THEN
          WRITE(LFNPR,7068)
        ELSE IF(JPRINT(63).EQ.-8) THEN
          WRITE(LFNPR,7069)
        END IF
        IF(JPRINT(23).EQ.IFULL) THEN
          WRITE(LFNPR,7070)
        ELSE IF(JPRINT(23).EQ.ILEW) THEN
          WRITE(LFNPR,7072)
        ELSE IF(IOINQR(JPRINT(23)).EQ.IPRNT) THEN
          WRITE(LFNPR,7074) JPRINT(23)
        ELSE IF(IOINQR(JPRINT(23)).EQ.IWRIT) THEN
          WRITE(LFNPR,7076) ABS(JPRINT(23))
        ELSE IF(JPRINT(63).EQ.9) THEN
          WRITE(LFNPR,7078)
        ELSE IF(JPRINT(63).EQ.-9) THEN
          WRITE(LFNPR,7079)
        END IF
        IF(JPRINT(26).EQ.IFULL) THEN
          WRITE(LFNPR,7080)
        ELSE IF(JPRINT(26).EQ.IVAL) THEN
          WRITE(LFNPR,7082)
        ELSE IF(JPRINT(26).EQ.ILEW) THEN
          WRITE(LFNPR,7084)
        ELSE IF(IOINQR(JPRINT(26)).EQ.IPRNT) THEN
          WRITE(LFNPR,7086) JPRINT(26)
        ELSE IF(IOINQR(JPRINT(26)).EQ.IWRIT) THEN
          WRITE(LFNPR,7088) ABS(JPRINT(26))
        ELSE IF(JPRINT(63).EQ.10) THEN
          WRITE(LFNPR,7087)
        ELSE IF(JPRINT(63).EQ.-10) THEN
          WRITE(LFNPR,7089)
        END IF
        IF(JPRINT(63).GT.0.AND.LFNPRM.GT.0) WRITE(LFNPR,7091)
        IF(IWPNAO.EQ.IFULL) THEN
          WRITE(LFNPR,7090)
        ELSE IF(IOINQR(IWPNAO).EQ.IPRNT) THEN
          WRITE(LFNPR,7092) IWPNAO
        ELSE IF(IOINQR(IWPNAO).EQ.IWRIT) THEN
          WRITE(LFNPR,7094) ABS(IWPNAO)
        ELSE IF(IOINQR(IWPNAO).EQ.IREAD) THEN
          WRITE(LFNPR,7096) ABS(IWPNAO/1000)
        END IF
        IF(JPRINT(33).EQ.IFULL) THEN
          WRITE(LFNPR,7100)
        ELSE IF(IOINQR(JPRINT(33)).EQ.IPRNT) THEN
          WRITE(LFNPR,7102) JPRINT(33)
        ELSE IF(IOINQR(JPRINT(33)).EQ.IWRIT) THEN
          WRITE(LFNPR,7104) ABS(JPRINT(33))
        END IF
        IF(IWTNAB.EQ.IFULL) THEN
          WRITE(LFNPR,7110)
        ELSE IF(IWTNAB.EQ.ILEW) THEN
          WRITE(LFNPR,7112)
        ELSE IF(IOINQR(IWTNAB).EQ.IPRNT) THEN
          WRITE(LFNPR,7114) IWTNAB
        ELSE IF(IOINQR(IWTNAB).EQ.IWRIT) THEN
          WRITE(LFNPR,7116) ABS(IWTNAB)
        ELSE IF(IOINQR(IWTNAB).EQ.IREAD) THEN
          WRITE(LFNPR,7118) ABS(IWTNAB/1000)
        END IF
        IF(JPRINT(18).EQ.IFULL) THEN
          WRITE(LFNPR,7120)
        ELSE IF(JPRINT(18).EQ.ILEW) THEN
          WRITE(LFNPR,7122)
        ELSE IF(IOINQR(JPRINT(18)).EQ.IPRNT) THEN
          WRITE(LFNPR,7124) JPRINT(18)
        ELSE IF(IOINQR(JPRINT(18)).EQ.IWRIT) THEN
          WRITE(LFNPR,7126) ABS(JPRINT(18))
        END IF
        IF(JPRINT(9).EQ.IFULL) THEN
          WRITE(LFNPR,7130)
        ELSE IF(JPRINT(9).EQ.IVAL) THEN
          WRITE(LFNPR,7132)
        ELSE IF(JPRINT(9).EQ.ILEW) THEN
          WRITE(LFNPR,7134)
        ELSE IF(IOINQR(JPRINT(9)).EQ.IPRNT) THEN
          WRITE(LFNPR,7136) JPRINT(9)
        ELSE IF(IOINQR(JPRINT(9)).EQ.IWRIT) THEN
          WRITE(LFNPR,7138) ABS(JPRINT(9))
        END IF
        IF(JPRINT(41).EQ.IFULL) THEN
          WRITE(LFNPR,7140)
        ELSE IF(JPRINT(41).EQ.ILEW) THEN
          WRITE(LFNPR,7142)
        ELSE IF(IOINQR(JPRINT(41)).EQ.IPRNT) THEN
          WRITE(LFNPR,7144) JPRINT(41)
        ELSE IF(IOINQR(JPRINT(41)).EQ.IWRIT) THEN
          WRITE(LFNPR,7146) ABS(JPRINT(41))
        END IF
        IF(JPRINT(24).EQ.IFULL) THEN
          WRITE(LFNPR,7150)
        ELSE IF(JPRINT(24).EQ.ILEW) THEN
          WRITE(LFNPR,7152)
        ELSE IF(IOINQR(JPRINT(24)).EQ.IPRNT) THEN
          WRITE(LFNPR,7154) JPRINT(24)
        ELSE IF(IOINQR(JPRINT(24)).EQ.IWRIT) THEN
          WRITE(LFNPR,7156) ABS(JPRINT(24))
        END IF
        IF(JPRINT(38).EQ.IFULL) THEN
          WRITE(LFNPR,7160)
        ELSE IF(JPRINT(38).EQ.IVAL) THEN
          WRITE(LFNPR,7162)
        ELSE IF(JPRINT(38).EQ.ILEW) THEN
          WRITE(LFNPR,7164)
        ELSE IF(IOINQR(JPRINT(38)).EQ.IPRNT) THEN
          WRITE(LFNPR,7166) JPRINT(38)
        ELSE IF(IOINQR(JPRINT(38)).EQ.IWRIT) THEN
          WRITE(LFNPR,7168) ABS(JPRINT(38))
        END IF
        IF(JPRINT(47).EQ.IFULL) THEN
          WRITE(LFNPR,7170)
        ELSE IF(JPRINT(47).EQ.ILEW) THEN
          WRITE(LFNPR,7172)
        ELSE IF(IOINQR(JPRINT(47)).EQ.IPRNT) THEN
          WRITE(LFNPR,7174) JPRINT(47)
        ELSE IF(IOINQR(JPRINT(47)).EQ.IWRIT) THEN
          WRITE(LFNPR,7176) ABS(JPRINT(47))
        END IF
        IF(JPRINT(45).EQ.IFULL) THEN
          WRITE(LFNPR,7180)
        ELSE IF(JPRINT(45).EQ.IVAL) THEN
          WRITE(LFNPR,7182)
        ELSE IF(JPRINT(45).EQ.ILEW) THEN
          WRITE(LFNPR,7184)
        ELSE IF(IOINQR(JPRINT(45)).EQ.IPRNT) THEN
          WRITE(LFNPR,7186) JPRINT(45)
        ELSE IF(IOINQR(JPRINT(45)).EQ.IWRIT) THEN
          WRITE(LFNPR,7188) ABS(JPRINT(45))
        END IF
        IF(JPRINT(13).EQ.IFULL) THEN
          WRITE(LFNPR,7190)
        ELSE IF(JPRINT(13).EQ.IVAL) THEN
          WRITE(LFNPR,7192)
        ELSE IF(JPRINT(13).EQ.ILEW) THEN
          WRITE(LFNPR,7194)
        ELSE IF(IOINQR(JPRINT(13)).EQ.IPRNT) THEN
          WRITE(LFNPR,7196) JPRINT(13)
        ELSE IF(IOINQR(JPRINT(13)).EQ.IWRIT) THEN
          WRITE(LFNPR,7198) ABS(JPRINT(13))
        END IF
        IF(JPRINT(42).EQ.IFULL) THEN
          WRITE(LFNPR,7200)
        ELSE IF(IOINQR(JPRINT(42)).EQ.IPRNT) THEN
          WRITE(LFNPR,7202) JPRINT(42)
        ELSE IF(IOINQR(JPRINT(42)).EQ.IWRIT) THEN
          WRITE(LFNPR,7204) ABS(JPRINT(42))
        END IF
        IF(JPRINT(27).EQ.IFULL) THEN
          WRITE(LFNPR,7210)
          IF(LFNBRK(27).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(27)).EQ.IPRNT) THEN
          WRITE(LFNPR,7212) JPRINT(27)
        ELSE IF(IOINQR(JPRINT(27)).EQ.IWRIT) THEN
          WRITE(LFNPR,7214) ABS(JPRINT(27))
        END IF
        IF(JPRINT(83).EQ.IFULL) THEN
          WRITE(LFNPR,7215)
          IF(LFNBRK(83).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(83)).EQ.IPRNT) THEN
          WRITE(LFNPR,7216) JPRINT(83)
        ELSE IF(IOINQR(JPRINT(83)).EQ.IWRIT) THEN
          WRITE(LFNPR,7217) ABS(JPRINT(83))
        END IF
        IF(JPRINT(35).EQ.IFULL) THEN
          WRITE(LFNPR,7220)
          IF(LFNBRK(35).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(35)).EQ.IPRNT) THEN
          WRITE(LFNPR,7222) JPRINT(35)
        ELSE IF(IOINQR(JPRINT(35)).EQ.IWRIT) THEN
          WRITE(LFNPR,7224) ABS(JPRINT(35))
        END IF
        IF(JPRINT(34).EQ.IFULL) THEN
          WRITE(LFNPR,7230)
          IF(LFNBRK(34).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(34)).EQ.IPRNT) THEN
          WRITE(LFNPR,7232) JPRINT(34)
        ELSE IF(IOINQR(JPRINT(34)).EQ.IWRIT) THEN
          WRITE(LFNPR,7234) ABS(JPRINT(34))
        END IF
        IF(JPRINT(16).EQ.IFULL) THEN
          WRITE(LFNPR,7240)
          IF(LFNBRK(16).GT.0) WRITE(LFNPR,6985)
        ELSE IF(JPRINT(16).EQ.ILEW) THEN
          WRITE(LFNPR,7242)
        ELSE IF(IOINQR(JPRINT(16)).EQ.IPRNT) THEN
          WRITE(LFNPR,7244) JPRINT(16)
        ELSE IF(IOINQR(JPRINT(16)).EQ.IWRIT) THEN
          WRITE(LFNPR,7246) ABS(JPRINT(16))
        END IF
        IF(JPRINT(17).EQ.IFULL) THEN
          WRITE(LFNPR,7250)
          IF(LFNBRK(17).GT.0) WRITE(LFNPR,6985)
        ELSE IF(JPRINT(17).EQ.ILEW) THEN
          WRITE(LFNPR,7252)
        ELSE IF(IOINQR(JPRINT(17)).EQ.IPRNT) THEN
          WRITE(LFNPR,7254) JPRINT(17)
        ELSE IF(IOINQR(JPRINT(17)).EQ.IWRIT) THEN
          WRITE(LFNPR,7256) ABS(JPRINT(17))
        END IF
        IF(JPRINT(61).EQ.IFULL) THEN
          WRITE(LFNPR,7257)
          IF(LFNBRK(61).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(61)).EQ.IPRNT) THEN
          WRITE(LFNPR,7258) JPRINT(61)
        ELSE IF(IOINQR(JPRINT(61)).EQ.IWRIT) THEN
          WRITE(LFNPR,7259) ABS(JPRINT(61))
        END IF
        IF(JPRINT(40).EQ.IFULL) THEN
          WRITE(LFNPR,7260)
          IF(LFNBRK(40).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(40)).EQ.IPRNT) THEN
          WRITE(LFNPR,7262) JPRINT(40)
        ELSE IF(IOINQR(JPRINT(40)).EQ.IWRIT) THEN
          WRITE(LFNPR,7264) ABS(JPRINT(40))
        END IF
        IF(JPRINT(31).EQ.IFULL) THEN
          WRITE(LFNPR,7270)
          IF(LFNBRK(31).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(31)).EQ.IPRNT) THEN
          WRITE(LFNPR,7272) JPRINT(31)
        ELSE IF(IOINQR(JPRINT(31)).EQ.IWRIT) THEN
          WRITE(LFNPR,7274) ABS(JPRINT(31))
        END IF
        IF(JPRINT(78).EQ.IFULL) THEN
          WRITE(LFNPR,7276)
          IF(LFNBRK(78).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(78)).EQ.IPRNT) THEN
          WRITE(LFNPR,7277) JPRINT(78)
        ELSE IF(IOINQR(JPRINT(78)).EQ.IWRIT) THEN
          WRITE(LFNPR,7278) ABS(JPRINT(78))
        END IF
        IF(JPRINT(29).EQ.IFULL) THEN
          WRITE(LFNPR,7280)
          IF(LFNBRK(29).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(29)).EQ.IPRNT) THEN
          WRITE(LFNPR,7282) JPRINT(29)
        ELSE IF(IOINQR(JPRINT(29)).EQ.IWRIT) THEN
          WRITE(LFNPR,7284) ABS(JPRINT(29))
        END IF
        IF(JPRINT(79).EQ.IFULL) THEN
          WRITE(LFNPR,7286)
          IF(LFNBRK(79).GT.0) WRITE(LFNPR,6985)
        ELSE IF(JPRINT(79).EQ.ILEW) THEN
          WRITE(LFNPR,7287)
        ELSE IF(IOINQR(JPRINT(79)).EQ.IPRNT) THEN
          WRITE(LFNPR,7288) JPRINT(79)
        ELSE IF(IOINQR(JPRINT(79)).EQ.IWRIT) THEN
          WRITE(LFNPR,7289) ABS(JPRINT(79))
        END IF
        IF(JPRINT(37).EQ.IFULL) THEN
          WRITE(LFNPR,7290)
          IF(LFNBRK(37).GT.0) WRITE(LFNPR,6985)
        ELSE IF(JPRINT(37).EQ.ILEW) THEN
          WRITE(LFNPR,7292)
        ELSE IF(IOINQR(JPRINT(37)).EQ.IPRNT) THEN
          WRITE(LFNPR,7294) JPRINT(37)
        ELSE IF(IOINQR(JPRINT(37)).EQ.IWRIT) THEN
          WRITE(LFNPR,7296) ABS(JPRINT(37))
        END IF
        IF(JPRINT(15).EQ.IFULL) THEN
          WRITE(LFNPR,7300)
          IF(LFNBRK(15).GT.0) WRITE(LFNPR,6985)
        ELSE IF(JPRINT(15).EQ.ILEW) THEN
          WRITE(LFNPR,7302)
        ELSE IF(IOINQR(JPRINT(15)).EQ.IPRNT) THEN
          WRITE(LFNPR,7304) JPRINT(15)
        ELSE IF(IOINQR(JPRINT(15)).EQ.IWRIT) THEN
          WRITE(LFNPR,7306) ABS(JPRINT(15))
        END IF
        IF(JPRINT(60).EQ.IFULL) THEN
          WRITE(LFNPR,7307)
          IF(LFNBRK(60).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(60)).EQ.IPRNT) THEN
          WRITE(LFNPR,7308) JPRINT(60)
        ELSE IF(IOINQR(JPRINT(60)).EQ.IWRIT) THEN
          WRITE(LFNPR,7309) ABS(JPRINT(60))
        END IF
        IF(JPRINT(50).EQ.IFULL) THEN
          WRITE(LFNPR,7310)
          IF(LFNBRK(50).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(50)).EQ.IPRNT) THEN
          WRITE(LFNPR,7312) JPRINT(50)
        ELSE IF(IOINQR(JPRINT(50)).EQ.IWRIT) THEN
          WRITE(LFNPR,7314) ABS(JPRINT(50))
        END IF
        IF(JPRINT(51).EQ.IFULL) THEN
          WRITE(LFNPR,7320)
          IF(LFNBRK(51).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(51)).EQ.IPRNT) THEN
          WRITE(LFNPR,7322) JPRINT(51)
        ELSE IF(IOINQR(JPRINT(51)).EQ.IWRIT) THEN
          WRITE(LFNPR,7324) ABS(JPRINT(51))
        END IF
        IF(JPRINT(52).EQ.IFULL) THEN
          WRITE(LFNPR,7330)
          IF(LFNBRK(52).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(52)).EQ.IPRNT) THEN
          WRITE(LFNPR,7332) JPRINT(52)
        ELSE IF(IOINQR(JPRINT(52)).EQ.IWRIT) THEN
          WRITE(LFNPR,7334) ABS(JPRINT(52))
        END IF
        IF(JPRINT(53).EQ.IFULL) THEN
          WRITE(LFNPR,7340)
          IF(LFNBRK(53).GT.0) WRITE(LFNPR,6985)
        ELSE IF(JPRINT(53).EQ.ILEW) THEN
          WRITE(LFNPR,7342)
        ELSE IF(IOINQR(JPRINT(53)).EQ.IPRNT) THEN
          WRITE(LFNPR,7344) JPRINT(53)
        ELSE IF(IOINQR(JPRINT(53)).EQ.IWRIT) THEN
          WRITE(LFNPR,7346) ABS(JPRINT(53))
        END IF
        IF(JPRINT(54).EQ.IFULL) THEN
          WRITE(LFNPR,7350)
          IF(LFNBRK(54).GT.0) WRITE(LFNPR,6985)
        ELSE IF(JPRINT(54).EQ.ILEW) THEN
          WRITE(LFNPR,7352)
        ELSE IF(IOINQR(JPRINT(54)).EQ.IPRNT) THEN
          WRITE(LFNPR,7354) JPRINT(54)
        ELSE IF(IOINQR(JPRINT(54)).EQ.IWRIT) THEN
          WRITE(LFNPR,7356) ABS(JPRINT(54))
        END IF
        IF(JPRINT(62).EQ.IFULL) THEN
          WRITE(LFNPR,7357)
          IF(LFNBRK(62).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(62)).EQ.IPRNT) THEN
          WRITE(LFNPR,7358) JPRINT(62)
        ELSE IF(IOINQR(JPRINT(62)).EQ.IWRIT) THEN
          WRITE(LFNPR,7359) ABS(JPRINT(62))
        END IF
        IF(JPRINT(64).EQ.IFULL) THEN
          WRITE(LFNPR,7430)
          IF(LFNBRK(64).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(64)).EQ.IPRNT) THEN
          WRITE(LFNPR,7432) JPRINT(63)
        ELSE IF(IOINQR(JPRINT(64)).EQ.IWRIT) THEN
          WRITE(LFNPR,7434) ABS(JPRINT(64))
        END IF
        IF(JPRINT(65).EQ.IFULL) THEN
          WRITE(LFNPR,7440)
          IF(LFNBRK(65).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(65)).EQ.IPRNT) THEN
          WRITE(LFNPR,7442) JPRINT(65)
        ELSE IF(IOINQR(JPRINT(65)).EQ.IWRIT) THEN
          WRITE(LFNPR,7444) ABS(JPRINT(65))
        END IF
        IF(JPRINT(66).EQ.IFULL) THEN
          WRITE(LFNPR,7450)
          IF(LFNBRK(66).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(66)).EQ.IPRNT) THEN
          WRITE(LFNPR,7452) JPRINT(66)
        ELSE IF(IOINQR(JPRINT(66)).EQ.IWRIT) THEN
          WRITE(LFNPR,7454) ABS(JPRINT(66))
        END IF
        IF(JPRINT(67).EQ.IFULL) THEN
          WRITE(LFNPR,7460)
          IF(LFNBRK(67).GT.0) WRITE(LFNPR,6985)
        ELSE IF(JPRINT(67).EQ.ILEW) THEN
          WRITE(LFNPR,7462)
        ELSE IF(IOINQR(JPRINT(67)).EQ.IPRNT) THEN
          WRITE(LFNPR,7464) JPRINT(67)
        ELSE IF(IOINQR(JPRINT(67)).EQ.IWRIT) THEN
          WRITE(LFNPR,7466) ABS(JPRINT(67))
        END IF
        IF(JPRINT(68).EQ.IFULL) THEN
          WRITE(LFNPR,7470)
          IF(LFNBRK(68).GT.0) WRITE(LFNPR,6985)
        ELSE IF(JPRINT(68).EQ.ILEW) THEN
          WRITE(LFNPR,7472)
        ELSE IF(IOINQR(JPRINT(68)).EQ.IPRNT) THEN
          WRITE(LFNPR,7474) JPRINT(68)
        ELSE IF(IOINQR(JPRINT(68)).EQ.IWRIT) THEN
          WRITE(LFNPR,7476) ABS(JPRINT(68))
        END IF
        IF(JPRINT(69).EQ.IFULL) THEN
          WRITE(LFNPR,7480)
          IF(LFNBRK(69).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(69)).EQ.IPRNT) THEN
          WRITE(LFNPR,7482) JPRINT(69)
        ELSE IF(IOINQR(JPRINT(69)).EQ.IWRIT) THEN
          WRITE(LFNPR,7484) ABS(JPRINT(69))
        END IF
        IF(JPRINT(70).EQ.IFULL) THEN
          WRITE(LFNPR,7490)
          IF(LFNBRK(70).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(70)).EQ.IPRNT) THEN
          WRITE(LFNPR,7492) JPRINT(70)
        ELSE IF(IOINQR(JPRINT(70)).EQ.IWRIT) THEN
          WRITE(LFNPR,7494) ABS(JPRINT(70))
        END IF
        IF(JPRINT(71).EQ.IFULL) THEN
          WRITE(LFNPR,7500)
          IF(LFNBRK(71).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(71)).EQ.IPRNT) THEN
          WRITE(LFNPR,7502) JPRINT(71)
        ELSE IF(IOINQR(JPRINT(71)).EQ.IWRIT) THEN
          WRITE(LFNPR,7504) ABS(JPRINT(71))
        END IF
        IF(JPRINT(72).EQ.IFULL) THEN
          WRITE(LFNPR,7510)
          IF(LFNBRK(72).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(72)).EQ.IPRNT) THEN
          WRITE(LFNPR,7512) JPRINT(72)
        ELSE IF(IOINQR(JPRINT(72)).EQ.IWRIT) THEN
          WRITE(LFNPR,7514) ABS(JPRINT(72))
        END IF
        IF(JPRINT(73).EQ.IFULL) THEN
          WRITE(LFNPR,7520)
          IF(LFNBRK(73).GT.0) WRITE(LFNPR,6985)
        ELSE IF(JPRINT(73).EQ.ILEW) THEN
          WRITE(LFNPR,7522)
        ELSE IF(IOINQR(JPRINT(73)).EQ.IPRNT) THEN
          WRITE(LFNPR,7524) JPRINT(73)
        ELSE IF(IOINQR(JPRINT(73)).EQ.IWRIT) THEN
          WRITE(LFNPR,7526) ABS(JPRINT(73))
        END IF
        IF(JPRINT(74).EQ.IFULL) THEN
          WRITE(LFNPR,7530)
          IF(LFNBRK(74).GT.0) WRITE(LFNPR,6985)
        ELSE IF(JPRINT(74).EQ.ILEW) THEN
          WRITE(LFNPR,7532)
        ELSE IF(IOINQR(JPRINT(74)).EQ.IPRNT) THEN
          WRITE(LFNPR,7534) JPRINT(74)
        ELSE IF(IOINQR(JPRINT(74)).EQ.IWRIT) THEN
          WRITE(LFNPR,7536) ABS(JPRINT(74))
        END IF
        IF(JPRINT(75).EQ.IFULL) THEN
          WRITE(LFNPR,7540)
          IF(LFNBRK(75).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(75)).EQ.IPRNT) THEN
          WRITE(LFNPR,7542) JPRINT(75)
        ELSE IF(IOINQR(JPRINT(75)).EQ.IWRIT) THEN
          WRITE(LFNPR,7544) ABS(JPRINT(75))
        END IF
        IF(JPRINT(39).EQ.IFULL) THEN
          WRITE(LFNPR,7360)
          IF(LFNBRK(39).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(39)).EQ.IPRNT) THEN
          WRITE(LFNPR,7362) JPRINT(39)
        ELSE IF(IOINQR(JPRINT(39)).EQ.IWRIT) THEN
          WRITE(LFNPR,7364) ABS(JPRINT(39))
        END IF
        IF(JPRINT(58).EQ.IFULL) THEN
          WRITE(LFNPR,7366)
          IF(LFNBRK(58).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(58)).EQ.IPRNT) THEN
          WRITE(LFNPR,7367) JPRINT(58)
        ELSE IF(IOINQR(JPRINT(58)).EQ.IWRIT) THEN
          WRITE(LFNPR,7368) ABS(JPRINT(58))
        END IF
        IF(JPRINT(19).EQ.IFULL) THEN
          WRITE(LFNPR,7370)
          IF(LFNBRK(19).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(19)).EQ.IPRNT) THEN
          WRITE(LFNPR,7372) JPRINT(19)
        ELSE IF(IOINQR(JPRINT(19)).EQ.IWRIT) THEN
          WRITE(LFNPR,7374) ABS(JPRINT(19))
        END IF
        IF(JPRINT(20).EQ.IFULL) THEN
          WRITE(LFNPR,7380)
          IF(LFNBRK(20).GT.0) WRITE(LFNPR,6985)
        ELSE IF(IOINQR(JPRINT(20)).EQ.IPRNT) THEN
          WRITE(LFNPR,7382) JPRINT(20)
        ELSE IF(IOINQR(JPRINT(20)).EQ.IWRIT) THEN
          WRITE(LFNPR,7384) ABS(JPRINT(20))
        END IF
        IF(JPRINT(21).EQ.IFULL) THEN
          WRITE(LFNPR,7390)
          IF(LFNBRK(21).GT.0) WRITE(LFNPR,6985)
        ELSE IF(JPRINT(21).EQ.ILEW) THEN
          WRITE(LFNPR,7392)
        ELSE IF(IOINQR(JPRINT(21)).EQ.IPRNT) THEN
          WRITE(LFNPR,7394) JPRINT(21)
        ELSE IF(IOINQR(JPRINT(21)).EQ.IWRIT) THEN
          WRITE(LFNPR,7396) ABS(JPRINT(21))
        END IF
        IF(JPRINT(48).EQ.IFULL) THEN
          WRITE(LFNPR,7400)
          IF(LFNBRK(48).GT.0) WRITE(LFNPR,6985)
        ELSE IF(JPRINT(48).EQ.ILEW) THEN
          WRITE(LFNPR,7402)
        ELSE IF(IOINQR(JPRINT(48)).EQ.IPRNT) THEN
          WRITE(LFNPR,7404) JPRINT(48)
        ELSE IF(IOINQR(JPRINT(48)).EQ.IWRIT) THEN
          WRITE(LFNPR,7406) ABS(JPRINT(48))
        END IF
C SVEC
        IF(JPRINT(85).EQ.IFULL) THEN
          WRITE(LFNPR,7407)
        ELSE IF(IOINQR(JPRINT(85)).EQ.IPRNT) THEN
          WRITE(LFNPR,7408) JPRINT(85)
        ELSE IF(IOINQR(JPRINT(85)).EQ.IWRIT) THEN
          WRITE(LFNPR,7409) ABS(JPRINT(85))
        END IF
C NBBP
        IF(IWNBBP.EQ.IFULL) THEN
          WRITE(LFNPR,7410)
        ELSE IF(IOINQR(IWNBBP).EQ.IREAD) THEN
          WRITE(LFNPR,7415)
        END IF
C SPARTAN
        IF(JPRINT(84).GT.0) THEN
          WRITE(LFNPR,7420) JPRINT(84)
        ELSE IF(JPRINT(84).LT.0) THEN
          WRITE(LFNPR,7425) ABS(JPRINT(84))
        END IF
C STERIC
        IF(JPRINT(76).GE.1) WRITE(LFNPR,7546)
        IF(JPRINT(76).GT.1) WRITE(LFNPR,7550)
        IF(STTHR.GE.0.0D0) WRITE(LFNPR,7548) STTHR
C CMO
        IF(JPRINT(82).EQ.IFULL) THEN
          WRITE(LFNPR,7552)
        ELSE IF(JPRINT(82).EQ.IVAL) THEN
          WRITE(LFNPR,7554)
        ELSE IF(JPRINT(82).EQ.ILEW) THEN
          WRITE(LFNPR,7556)
        ELSE IF(JPRINT(82).NE.0) THEN
          WRITE(LFNPR,7558) ABS(JPRINT(82))
        END IF
C-----------------------------------------------------------------------
 6980 FORMAT(1X,'      /DIST   / : Print atom distance table')
 6985 FORMAT(1X,'                  for user-requested matrix elements')
 6990 FORMAT(1X,'      /AOPAO  / : Print the AO to PAO transformation')
 6992 FORMAT(1X,'      /AOPAO  / : Print ',I3,' columns of the AO to ',
     *   'PAO transformation')
 6994 FORMAT(1X,'      /AOPAO  / : Write the AO to PAO transformation',
     *   ' to LFN',I3)
 6996 FORMAT(1X,'      /AOPAO  / : Checkpoint the AO to PAO ',
     *   'transformation')
 6998 FORMAT(1X,'      /AOPAO  / : Checkpoint the sorted AO to PAO ',
     *   'transformation')
 7000 FORMAT(1X,'      /AOPNAO / : Print the AO to PNAO transformation')
 7002 FORMAT(1X,'      /AOPNAO / : Print ',I3,' columns of the AO to ',
     *   'PNAO transformation')
 7004 FORMAT(1X,'      /AOPNAO / : Write the AO to PNAO transformation',
     *   ' to LFN',I3)
 7006 FORMAT(1X,'      /AOPNAO / : Checkpoint the AO to PNAO ',
     *   'transformation')
 7008 FORMAT(1X,'      /AOPNAO / : Checkpoint the sorted AO to PNAO ',
     *   'transformation')
 7010 FORMAT(1X,'      /AONAO  / : Print the AO to NAO transformation')
 7012 FORMAT(1X,'      /AONAO  / : Print ',I3,' columns of the AO ',
     *   'to NAO transformation')
 7014 FORMAT(1X,'      /AONAO  / : Write the AO to NAO transformation ',
     *   'to LFN',I3)
 7016 FORMAT(1X,'      /AONAO  / : Read AO to NAO transformation from ',
     *          'LFN',I3)
 7018 FORMAT(1X,'      /AONAO  / : Checkpoint the AO to NAO ',
     *   'transformation')
 7019 FORMAT(1X,'      /AONAO  / : Checkpoint the sorted AO to NAO ',
     *   'transformation')
 7020 FORMAT(1X,'      /AOPNHO / : Print the AO to PNHO ',
     *   'transformation')
 7022 FORMAT(1X,'      /AOPNHO / : Print ',I3,' columns of the AO to ',
     *   'PNHO transformation')
 7024 FORMAT(1X,'      /AOPNHO / : Write the AO to PNHO transformation',
     *   ' to LFN',I3)
 7026 FORMAT(1X,'      /AOPNHO / : Checkpoint the AO to PNHO ',
     *   'transformation')
 7028 FORMAT(1X,'      /AOPNHO / : Checkpoint the sorted AO to PNHO ',
     *   'transformation')
 7030 FORMAT(1X,'      /AONHO  / : Print the AO to NHO transformation')
 7032 FORMAT(1X,'      /AONHO  / : Print ',I3,' columns of the AO to ',
     *   'NHO transformation')
 7034 FORMAT(1X,'      /AONHO  / : Write the AO to NHO transformation ',
     *   'to LFN',I3)
 7036 FORMAT(1X,'      /AONHO  / : Checkpoint the AO to NHO ',
     *   'transformation')
 7038 FORMAT(1X,'      /AONHO  / : Checkpoint the sorted AO to NHO ',
     *   'transformation')
 7040 FORMAT(1X,'      /AOPNBO / : Print the AO to PNBO ',
     *   'transformation')
 7042 FORMAT(1X,'      /AOPNBO / : Print the occupied PNBOs in the AO ',
     *   'basis')
 7044 FORMAT(1X,'      /AOPNBO / : Print ',I3,' columns of the AO to ',
     *   'PNBO transformation')
 7046 FORMAT(1X,'      /AOPNBO / : Write the AO to PNBO transformation',
     *   ' to LFN',I3)
 7048 FORMAT(1X,'      /AOPNBO / : Checkpoint the AO to PNBO ',
     *   'transformation')
 7049 FORMAT(1X,'      /AOPNBO / : Checkpoint the sorted AO to PNBO ',
     *   'transformation')
 7050 FORMAT(1X,'      /AONBO  / : Print the AO to NBO transformation')
 7052 FORMAT(1X,'      /AONBO  / : Print the occupied NBOs in the AO ',
     *   'basis')
 7054 FORMAT(1X,'      /AONBO  / : Print ',I3,' columns of the AO ',
     *   'to NBO transformation')
 7056 FORMAT(1X,'      /AONBO  / : Write the AO to NBO transformation ',
     *   'to LFN',I3)
 7058 FORMAT(1X,'      /AONBO  / : Checkpoint the AO to NBO ',
     *   'transformation')
 7059 FORMAT(1X,'      /AONBO  / : Checkpoint the sorted AO to NBO ',
     *   'transformation')
 7060 FORMAT(1X,'      /AOPNLMO/ : Print the AO to PNLMO ',
     *   'transformation')
 7062 FORMAT(1X,'      /AOPNLMO/ : Print the occupied PNLMOs in the AO',
     *   ' basis')
 7064 FORMAT(1X,'      /AOPNLMO/ : Print ',I3,' columns of the AO to ',
     *   'PNLMO transformation')
 7066 FORMAT(1X,'      /AOPNLMO/ : Write the AO to PNLMO transformatio',
     *   'n to LFN',I3)
 7068 FORMAT(1X,'      /AOPNLMO/ : Checkpoint the AO to PNLMO ',
     *   'transformation')
 7069 FORMAT(1X,'      /AOPNLMO/ : Checkpoint the sorted AO to PNLMO ',
     *   'transformation')
 7070 FORMAT(1X,'      /AONLMO / : Print the AO to NLMO ',
     *   'transformation')
 7072 FORMAT(1X,'      /AONLMO / : Print the occupied NLMOs in the AO ',
     *   'basis')
 7074 FORMAT(1X,'      /AONLMO / : Print ',I3,' columns of the AO to ',
     *   'NLMO transformation')
 7076 FORMAT(1X,'      /AONLMO / : Write the AO to NLMO transformation',
     *   ' to LFN',I3)
 7078 FORMAT(1X,'      /AONLMO / : Checkpoint the AO to NLMO ',
     *   'transformation')
 7079 FORMAT(1X,'      /AONLMO / : Checkpoint the sorted AO to NLMO ',
     *   'transformation')
 7080 FORMAT(1X,'      /AOMO   / : Print the MOs in the AO basis')
 7082 FORMAT(1X,'      /AOMO   / : Print core and valence MOs in ',
     *   'the AO basis')
 7084 FORMAT(1X,'      /AOMO   / : Print the occupied MOs in the AO ',
     *   'basis')
 7086 FORMAT(1X,'      /AOMO   / : Print ',I3,' lowest energy MOs ',
     *   'in the AO basis')
 7088 FORMAT(1X,'      /AOMO   / : Write the AO to MO transformation ',
     *   'to LFN',I3)
 7087 FORMAT(1X,'      /AOMO   / : Checkpoint the AO to MO ',
     *   'transformation')
 7089 FORMAT(1X,'      /AOMO   / : Checkpoint the sorted AO to MO ',
     *   'transformation')
 7090 FORMAT(1X,'      /PAOPNAO/ : Print the PAO to PNAO ',
     *   'transformation')
 7091 FORMAT(1X,'                  with user-requested <permutation>')
 7092 FORMAT(1X,'      /PAOPNAO/ : Print ',I3,' columns of the PAO ',
     *   'to PNAO transformation')
 7094 FORMAT(1X,'      /PAOPNAO/ : Write the PAO to PNAO ',
     *   'transformation to LFN',I3)
 7096 FORMAT(1X,'      /PAOPNAO/ : Read PAO to PNAO transformation ',
     *          'from LFN',I3)
 7100 FORMAT(1X,'      /NAONHO / : Print the NAO to NHO transformation')
 7102 FORMAT(1X,'      /NAONHO / : Print ',I3,' columns of the NAO ',
     *   'to NHO transformation')
 7104 FORMAT(1X,'      /NAONHO / : Write the NAO to NHO transformation',
     *   ' to LFN',I3)
 7110 FORMAT(1X,'      /NAONBO / : Print the NAO to NBO transformation')
 7112 FORMAT(1X,'      /NAONBO / : Print the occupied NBOs in the NAO ',
     *   'basis')
 7114 FORMAT(1X,'      /NAONBO / : Print ',I3,' columns of the NAO ',
     *   'to NBO transformation')
 7116 FORMAT(1X,'      /NAONBO / : Write the NAO to NBO transformation',
     *   ' to LFN',I3)
 7118 FORMAT(1X,'      /NAONBO / : Read NAO to NBO transformation from',
     *          ' LFN',I3)
 7120 FORMAT(1X,'      /NAONLMO/ : Print the NAO to NLMO ',
     *   'transformation')
 7122 FORMAT(1X,'      /NAONLMO/ : Print the occupied NLMOs in the NAO',
     *   ' basis')
 7124 FORMAT(1X,'      /NAONLMO/ : Print ',I3,' columns of the NAO ',
     *   'to NLMO transformation')
 7126 FORMAT(1X,'      /NAONLMO/ : Write the NAO to NLMO ',
     *   'transformation to LFN',I3)
 7130 FORMAT(1X,'      /NAOMO  / : Print the MOs in the NAO basis')
 7132 FORMAT(1X,'      /NAOMO  / : Print core and valence MOs in ',
     *   'the NAO basis')
 7134 FORMAT(1X,'      /NAOMO  / : Print the occupied MOs in the NAO ',
     *   'basis')
 7136 FORMAT(1X,'      /NAOMO  / : Print ',I3,' lowest energy MOs ',
     *   'in the NAO basis')
 7138 FORMAT(1X,'      /NAOMO  / : Write the NAO to MO transformation ',
     *   'to LFN',I3)
 7140 FORMAT(1X,'      /NHONBO / : Print the NHO to NBO transformation')
 7142 FORMAT(1X,'      /NHONBO / : Print the occupied NBOs in the NHO ',
     *   'basis')
 7144 FORMAT(1X,'      /NHONBO / : Print ',I3,' columns of the NHO ',
     *   'to NBO transformation')
 7146 FORMAT(1X,'      /NHONBO / : Write the NHO to NBO transformation',
     *   ' to LFN',I3)
 7150 FORMAT(1X,'      /NHONLMO/ : Print the NHO to NLMO ',
     *   'transformation')
 7152 FORMAT(1X,'      /NHONLMO/ : Print the occupied NLMOs in the NHO',
     *   ' basis')
 7154 FORMAT(1X,'      /NHONLMO/ : Print ',I3,' columns of the NHO ',
     *   'to NLMO transformation')
 7156 FORMAT(1X,'      /NHONLMO/ : Write the NHO to NLMO ',
     *   'transformation to LFN',I3)
 7160 FORMAT(1X,'      /NHOMO  / : Print the MOs in the NHO basis')
 7162 FORMAT(1X,'      /NHOMO  / : Print core and valence MOs in ',
     *   'the NHO basis')
 7164 FORMAT(1X,'      /NHOMO  / : Print the occupied MOs in the NHO ',
     *   'basis')
 7166 FORMAT(1X,'      /NHOMO  / : Print ',I3,' lowest energy MOs ',
     *   'in the NHO basis')
 7168 FORMAT(1X,'      /NHOMO  / : Write the NHO to MO transformation ',
     *   'to LFN',I3)
 7170 FORMAT(1X,'      /NBONLMO/ : Print the NBO to NLMO ',
     *   'transformation')
 7172 FORMAT(1X,'      /NBONLMO/ : Print the occupied NLMOs in the NBO',
     *   ' basis')
 7174 FORMAT(1X,'      /NBONLMO/ : Print ',I3,' columns of the NBO ',
     *   'to NLMO transformation')
 7176 FORMAT(1X,'      /NBONLMO/ : Write the NBO to NLMO ',
     *   'transformation to LFN',I3)
 7180 FORMAT(1X,'      /NBOMO  / : Print the MOs in the NBO basis')
 7182 FORMAT(1X,'      /NBOMO  / : Print core and valence MOs in ',
     *   'the NBO basis')
 7184 FORMAT(1X,'      /NBOMO  / : Print the occupied MOs in the NBO ',
     *   'basis')
 7186 FORMAT(1X,'      /NBOMO  / : Print ',I3,' lowest energy MOs ',
     *   'in the NBO basis')
 7188 FORMAT(1X,'      /NBOMO  / : Write the NBO to MO transformation ',
     *   'to LFN',I3)
 7190 FORMAT(1X,'      /NLMOMO / : Print the MOs in the NLMO basis')
 7192 FORMAT(1X,'      /NLMOMO / : Print core and valence MOs in ',
     *   'the NLMO basis')
 7194 FORMAT(1X,'      /NLMOMO / : Print the occupied MOs in the NLMO ',
     *   'basis')
 7196 FORMAT(1X,'      /NLMOMO / : Print ',I3,' lowest energy MOs ',
     *   'in the NLMO basis')
 7198 FORMAT(1X,'      /NLMOMO / : Write the NLMO to MO transformation',
     *   ' to LFN',I3)
 7200 FORMAT(1X,'      /BOAO   / : Print the AO bond-order matrix')
 7202 FORMAT(1X,'      /BOAO   / : Print ',I3,' columns of the AO ',
     *   'bond-order matrix')
 7204 FORMAT(1X,'      /BOAO   / : Write the AO bond-order matrix to ',
     *   'LFN',I3)
 7210 FORMAT(1X,'      /DMAO   / : Print the AO density matrix')
 7212 FORMAT(1X,'      /DMAO   / : Print ',I3,' columns of the AO ',
     *   'density matrix')
 7214 FORMAT(1X,'      /DMAO   / : Write the AO density matrix to ',
     *   'LFN',I3)
 7215 FORMAT(1X,'      /DMPNAO / : Print the PNAO density matrix')
 7216 FORMAT(1X,'      /DMPNAO / : Print ',I3,' columns of the PNAO ',
     *   'density matrix')
 7217 FORMAT(1X,'      /DMPNAO / : Write the PNAO density matrix to ',
     *   'LFN',I3)
 7220 FORMAT(1X,'      /DMNAO  / : Print the NAO density matrix')
 7222 FORMAT(1X,'      /DMNAO  / : Print ',I3,' columns of the NAO ',
     *   'density matrix')
 7224 FORMAT(1X,'      /DMNAO  / : Write the NAO density matrix to ',
     *   'LFN',I3)
 7230 FORMAT(1X,'      /DMNHO  / : Print the NHO density matrix')
 7232 FORMAT(1X,'      /DMNHO  / : Print ',I3,' columns of the NHO ',
     *   'density matrix')
 7234 FORMAT(1X,'      /DMNHO  / : Write the NHO density matrix to ',
     *   'LFN',I3)
 7240 FORMAT(1X,'      /DMNBO  / : Print the NBO density matrix')
 7242 FORMAT(1X,'      /DMNBO  / : Print the density matrix elements ',
     *   'of the occupied NBOs')
 7244 FORMAT(1X,'      /DMNBO  / : Print ',I3,' columns of the NBO ',
     *   'density matrix')
 7246 FORMAT(1X,'      /DMNBO  / : Write the NBO density matrix to ',
     *   'LFN',I3)
 7250 FORMAT(1X,'      /DMNLMO / : Print the NLMO density matrix')
 7252 FORMAT(1X,'      /DMNLMO / : Print the density matrix elements ',
     *   'of the occupied NLMOs')
 7254 FORMAT(1X,'      /DMNLMO / : Print ',I3,' columns of the NLMO ',
     *   'density matrix')
 7256 FORMAT(1X,'      /DMNLMO / : Write the NLMO density matrix to ',
     *   'LFN',I3)
 7257 FORMAT(1X,'      /DMMO   / : Print the MO density matrix')
 7258 FORMAT(1X,'      /DMMO   / : Print ',I3,' columns of the MO ',
     *   'density matrix')
 7259 FORMAT(1X,'      /DMMO   / : Write the MO density matrix to ',
     *   'LFN',I3)
 7260 FORMAT(1X,'      /FAO    / : Print the AO Fock matrix')
 7262 FORMAT(1X,'      /FAO    / : Print ',I3,' columns of the AO ',
     *   'Fock matrix')
 7264 FORMAT(1X,'      /FAO    / : Write the AO Fock matrix to ',
     *   'LFN',I3)
 7270 FORMAT(1X,'      /FNAO   / : Print the NAO Fock matrix')
 7272 FORMAT(1X,'      /FNAO   / : Print ',I3,' columns of the NAO ',
     *   'Fock matrix')
 7274 FORMAT(1X,'      /FNAO   / : Write the NAO Fock matrix to ',
     *   'LFN',I3)
 7276 FORMAT(1X,'      /FPNHO  / : Print the PNHO Fock matrix')
 7277 FORMAT(1X,'      /FPNHO  / : Print ',I3,' columns of the PNHO ',
     *   'Fock matrix')
 7278 FORMAT(1X,'      /FPNHO  / : Write the PNHO Fock matrix to ',
     *   'LFN',I3)
 7280 FORMAT(1X,'      /FNHO   / : Print the NHO Fock matrix')
 7282 FORMAT(1X,'      /FNHO   / : Print ',I3,' columns of the NHO ',
     *   'Fock matrix')
 7284 FORMAT(1X,'      /FNHO   / : Write the NHO Fock matrix to ',
     *   'LFN',I3)
 7286 FORMAT(1X,'      /FPNBO  / : Print the PNBO Fock matrix')
 7287 FORMAT(1X,'      /FPNBO  / : Print the Fock matrix elements of ',
     *   'the occupied PNBOs')
 7288 FORMAT(1X,'      /FPNBO  / : Print ',I3,' columns of the PNBO ',
     *   'Fock matrix')
 7289 FORMAT(1X,'      /FPNBO  / : Write the PNBO Fock matrix to ',
     *   'LFN',I3)
 7290 FORMAT(1X,'      /FNBO   / : Print the NBO Fock matrix')
 7292 FORMAT(1X,'      /FNBO   / : Print the Fock matrix elements of ',
     *   'the occupied NBOs')
 7294 FORMAT(1X,'      /FNBO   / : Print ',I3,' columns of the NBO ',
     *   'Fock matrix')
 7296 FORMAT(1X,'      /FNBO   / : Write the NBO Fock matrix to ',
     *   'LFN',I3)
 7300 FORMAT(1X,'      /FNLMO  / : Print the NLMO Fock matrix')
 7302 FORMAT(1X,'      /FNLMO  / : Print the Fock matrix elements of ',
     *   'the occupied NLMOs')
 7304 FORMAT(1X,'      /FNLMO  / : Print ',I3,' columns of the NLMO ',
     *   'Fock matrix')
 7306 FORMAT(1X,'      /FNLMO  / : Write the NLMO Fock matrix to ',
     *   'LFN',I3)
 7307 FORMAT(1X,'      /FMO    / : Print the MO Fock matrix')
 7308 FORMAT(1X,'      /FMO    / : Print ',I3,' columns of the MO ',
     *   'Fock matrix')
 7309 FORMAT(1X,'      /FMO    / : Write the MO Fock matrix to ',
     *   'LFN',I3)
 7310 FORMAT(1X,'      /DIAO   / : Print the AO dipole integrals')
 7312 FORMAT(1X,'      /DIAO   / : Print ',I3,' columns of the AO ',
     *   'dipole matrices')
 7314 FORMAT(1X,'      /DIAO   / : Write the AO dipole integrals',
     *   ' to LFN',I3)
 7320 FORMAT(1X,'      /DINAO  / : Print the NAO dipole integrals')
 7322 FORMAT(1X,'      /DINAO  / : Print ',I3,' columns of the NAO ',
     *   'dipole matrices')
 7324 FORMAT(1X,'      /DINAO  / : Write the NAO dipole integrals',
     *   ' to LFN',I3)
 7330 FORMAT(1X,'      /DINHO  / : Print the NHO dipole integrals')
 7332 FORMAT(1X,'      /DINHO  / : Print ',I3,' columns of the NHO ',
     *   'dipole matrices')
 7334 FORMAT(1X,'      /DINHO  / : Write the NHO dipole integrals',
     *   ' to LFN',I3)
 7340 FORMAT(1X,'      /DINBO  / : Print the NBO dipole integrals')
 7342 FORMAT(1X,'      /DINBO  / : Print the dipole integrals of ',
     *   'occupied NBOs')
 7344 FORMAT(1X,'      /DINBO  / : Print ',I3,' columns of the NBO ',
     *   'dipole matrices')
 7346 FORMAT(1X,'      /DINBO  / : Write the NBO dipole integrals',
     *   ' to LFN',I3)
 7350 FORMAT(1X,'      /DINLMO / : Print the NLMO dipole integrals')
 7352 FORMAT(1X,'      /DINLMO / : Print the dipole integrals of ',
     *   'occupied NLMOs')
 7354 FORMAT(1X,'      /DINLMO / : Print ',I3,' columns of the NLMO ',
     *   'dipole matrices')
 7356 FORMAT(1X,'      /DINLMO / : Write the NLMO dipole integrals',
     *   ' to LFN',I3)
 7357 FORMAT(1X,'      /DIMO   / : Print the MO dipole integrals')
 7358 FORMAT(1X,'      /DIMO   / : Print ',I3,' columns of the MO ',
     *   'dipole matrices')
 7359 FORMAT(1X,'      /DIMO   / : Write the MO dipole integrals',
     *   ' to LFN',I3)
 7360 FORMAT(1X,'      /SAO    / : Print the AO overlap matrix')
 7362 FORMAT(1X,'      /SAO    / : Print ',I3,' columns of the AO ',
     *   'overlap matrix')
 7364 FORMAT(1X,'      /SAO    / : Write the AO overlap matrix to ',
     *   'LFN',I3)
 7366 FORMAT(1X,'      /SPAO   / : Print the PAO overlap matrix')
 7367 FORMAT(1X,'      /SPAO   / : Print ',I3,' columns of the PAO ',
     *   'overlap matrix')
 7368 FORMAT(1X,'      /SPAO   / : Write the PAO overlap matrix to ',
     *   'LFN',I3)
 7370 FORMAT(1X,'      /SPNAO  / : Print the PNAO overlap matrix')
 7372 FORMAT(1X,'      /SPNAO  / : Print ',I3,' columns of the PNAO ',
     *   'overlap matrix')
 7374 FORMAT(1X,'      /SPNAO  / : Write the PNAO overlap matrix to ',
     *   'LFN',I3)
 7380 FORMAT(1X,'      /SPNHO  / : Print the PNHO overlap matrix')
 7382 FORMAT(1X,'      /SPNHO  / : Print ',I3,' columns of the PNHO ',
     *   'overlap matrix')
 7384 FORMAT(1X,'      /SPNHO  / : Write the PNHO overlap matrix to ',
     *   'LFN',I3)
 7390 FORMAT(1X,'      /SPNBO  / : Print the PNBO overlap matrix')
 7392 FORMAT(1X,'      /SPNBO  / : Print the overlap matrix elements ',
     *   'of the occupied PNBOs')
 7394 FORMAT(1X,'      /SPNBO  / : Print ',I3,' columns of the PNBO ',
     *   'overlap matrix')
 7396 FORMAT(1X,'      /SPNBO  / : Write the PNBO overlap matrix to ',
     *   'LFN',I3)
 7400 FORMAT(1X,'      /SPNLMO / : Print the PNLMO overlap matrix')
 7402 FORMAT(1X,'      /SPNLMO / : Print the overlap matrix elements ',
     *   'of the occupied PNLMOs')
 7404 FORMAT(1X,'      /SPNLMO / : Print ',I3,' columns of the PNLMO ',
     *   'overlap matrix')
 7406 FORMAT(1X,'      /SPNLMO / : Write the PNLMO overlap matrix to ',
     *   'LFN',I3)
 7407 FORMAT(1X,'      /SVEC   / : Print the eigenvectors of the AO ',
     *   'overlap matrix')
 7408 FORMAT(1X,'      /SVEC   / : Print ',I3,' eigenvectors of the ',
     +   'AO overlap matrix')
 7409 FORMAT(1X,'      /SVEC   / : Write the eigenvectors of the AO ',
     +   'overlap matrix to LFN',I3)
 7410 FORMAT(1X,'      /NBBP   / : Print the NBO bond-bond ',
     *   'polarizability matrix')
 7415 FORMAT(1X,'      /NBBP   / : Bond-bond polarizability, ',
     *   'user-requested <NHO indices>')
 7420 FORMAT(1X,'      /SPARTAN/ : Write NBOs in Spartan archive',
     *   ' format to LFN',I3)
 7425 FORMAT(1X,'      /SPARTAN/ : Write NLMOs in Spartan archive',
     *   ' format to LFN',I3)
 7430 FORMAT(1X,'      /KAO    / : Print the AO kinetic energy ',
     *   'matrix')
 7432 FORMAT(1X,'      /KAO    / : Print ',I3,' columns of the AO ',
     *   'kinetic energy matrix')
 7434 FORMAT(1X,'      /KAO    / : Write the AO kinetic energy ',
     *   'matrix to LFN',I3)
 7440 FORMAT(1X,'      /KNAO   / : Print the NAO kinetic energy ',
     *   'matrix')
 7442 FORMAT(1X,'      /KNAO   / : Print ',I3,' columns of the NAO ',
     *   'kinetic energy matrix')
 7444 FORMAT(1X,'      /KNAO   / : Write the NAO kinetic energy',
     *   ' matrix to ','LFN',I3)
 7450 FORMAT(1X,'      /KNHO   / : Print the NHO kinetic energy',
     *   ' matrix')
 7452 FORMAT(1X,'      /KNHO   / : Print ',I3,' columns of the NHO ',
     *   'kinetic energy matrix')
 7454 FORMAT(1X,'      /KNHO   / : Write the NHO kinetic energy',
     *   ' matrix to LFN',I3)
 7460 FORMAT(1X,'      /KNBO   / : Print the NBO kinetic energy',
     *   ' matrix')
 7462 FORMAT(1X,'      /KNBO   / : Print the kinetic energy matrix',
     *   ' elements of the occupied NBOs')
 7464 FORMAT(1X,'      /KNBO   / : Print ',I3,' columns of the NBO ',
     *   'kinetic energy matrix')
 7466 FORMAT(1X,'      /KNBO   / : Write the NBO kinetic energy',
     *   ' matrix to LFN',I3)
 7470 FORMAT(1X,'      /KNLMO  / : Print the NLMO kinetic energy',
     *   ' matrix')
 7472 FORMAT(1X,'      /KNLMO  / : Print the kinetic energy matrix',
     *   ' elements of the occupied NLMOs')
 7474 FORMAT(1X,'      /KNLMO  / : Print ',I3,' columns of the NLMO ',
     *   'kinetic energy matrix')
 7476 FORMAT(1X,'      /KNLMO  / : Write the NLMO kinetic energy ',
     *   'matrix to LFN',I3)
 7480 FORMAT(1X,'      /KMO    / : Print the MO kinetic energy ',
     *   'matrix')
 7482 FORMAT(1X,'      /KMO    / : Print ',I3,' columns of the MO ',
     *   'kinetic energy matrix')
 7484 FORMAT(1X,'      /KMO    / : Write the MO kinetic energy ',
     *   'matrix to LFN',I3)
 7490 FORMAT(1X,'      /VAO    / : Print the AO 1-e potential',
     *   ' energy matrix')
 7492 FORMAT(1X,'      /VAO    / : Print ',I3,' columns of the AO ',
     *   '1-e potential energy matrix')
 7494 FORMAT(1X,'      /VAO    / : Write the AO 1-e potential',
     *   ' energy matrix to LFN',I3)
 7500 FORMAT(1X,'      /VNAO   / : Print the NAO 1-e potential',
     *   ' energy matrix')
 7502 FORMAT(1X,'      /VNAO   / : Print ',I3,' columns of the NAO ',
     *   '1-e potential energy matrix')
 7504 FORMAT(1X,'      /VNAO   / : Write the NAO 1-e potential',
     *   ' energy matrix to LFN',I3)
 7510 FORMAT(1X,'      /VNHO   / : Print the NHO 1-e potential',
     *   ' energy matrix')
 7512 FORMAT(1X,'      /VNHO   / : Print ',I3,' columns of the NHO ',
     *   '1-e potential energy matrix')
 7514 FORMAT(1X,'      /VNHO   / : Write the NHO 1-e potential',
     *   ' energy matrix to LFN',I3)
 7520 FORMAT(1X,'      /VNBO   / : Print the NBO 1-e potential',
     *   ' energy matrix')
 7522 FORMAT(1X,'      /VNBO   / : Print the 1-e potential energy',
     *   ' matrix elements of the occupied NBOs')
 7524 FORMAT(1X,'      /VNBO   / : Print ',I3,' columns of the NBO ',
     *   '1-e potential energy matrix')
 7526 FORMAT(1X,'      /VNBO   / : Write the NBO 1-e potential',
     *   ' energy matrix to LFN',I3)
 7530 FORMAT(1X,'      /VNLMO  / : Print the NLMO 1-e potential',
     *   ' energy matrix')
 7532 FORMAT(1X,'      /VNLMO  / : Print the 1-e potential energy',
     *   ' matrix elements of the occupied NLMOs')
 7534 FORMAT(1X,'      /VNLMO  / : Print ',I3,' columns of the NLMO ',
     *   '1-e potential energy matrix')
 7536 FORMAT(1X,'      /VNLMO  / : Write the NLMO 1-e potential',
     *   ' energy matrix to LFN',I3)
 7540 FORMAT(1X,'      /VMO    / : Print the MO 1-e potential',
     *   ' energy matrix')
 7542 FORMAT(1X,'      /VMO    / : Print ',I3,' columns of the MO ',
     *   '1-e potential energy matrix')
 7544 FORMAT(1X,'      /VMO    / : Write the MO 1-e potential',
     *   ' energy matrix to LFN',I3)
 7546 FORMAT(1X,'      /STERIC / : Print NBO/NLMO steric analysis')
 7548 FORMAT(1X,'                  Print threshold set to ',F5.2)
 7550 FORMAT(1X,'                  with user-requested <NBO indices>')
 7552 FORMAT(1X,'      /CMO    / : Print analysis of canonical MOs')
 7554 FORMAT(1X,'      /CMO    / : Print analysis of canonical MOs',
     *   ' (valence MOs only)')
 7556 FORMAT(1X,'      /CMO    / : Print analysis of canonical MOs',
     *   ' (occupied MOs only)')
 7558 FORMAT(1X,'      /CMO    / : Print analysis of canonical MOs',
     *   ' (first',i4,' MOs only)')
C-----------------------------------------------------------------------
C
C  OTHER OUTPUT CONTROL KEYWORDS:
C
        IF(LFNPR.NE.6) WRITE(LFNPR,8000) LFNPR
        IF(JPRINT(43).NE.0) WRITE(LFNPR,8010)
        IF(IWDETL.NE.0) WRITE(LFNPR,8020)
        IF(JPRINT(7).NE.0) WRITE(LFNPR,8030) JPRINT(7)
        IF(JPRINT(12).NE.0) WRITE(LFNPR,8040)
        IF(LFNDAF.GE.0) WRITE(LFNPR,8050) LFNDAF
        IF(JPRINT(22).NE.0) WRITE(LFNPR,8060) JPRINT(22)
        IF(IWMULP.EQ.1) WRITE(LFNPR,8070)
        IF(IWMULP.EQ.2) WRITE(LFNPR,8080)
        IF(IWAPOL.NE.0) WRITE(LFNPR,8090)
        IF(JPRINT(11).NE.0) WRITE(LFNPR,8100)
        IF(LENNM.NE.0) WRITE(LFNPR,8110) (FILENM(I:I),I=1,52)
C
        IF(IPRINT.LT.10) THEN
          WRITE(LFNPR,8500) IPRINT
        ELSE
          IPRINT = IPRINT - 10
        END IF
C-----------------------------------------------------------------------
 8000 FORMAT(1X,'      /LFNPR  / : set to',I3)
 8010 FORMAT(1X,'      /PLOT   / : Write information for the orbital',
     *   ' plotter')
 8020 FORMAT(1X,'      /DETAIL / : Write out details of NBO search')
 8030 FORMAT(1X,'      /ARCHIVE/ : Write the archive file to LFN',I3)
 8040 FORMAT(1X,'      /BNDIDX / : Print bond indices based on ',
     *  'the NAO density matrix')
 8050 FORMAT(1X,'      /NBODAF / : NBO direct access file written on',
     *   ' LFN',I3)
 8060 FORMAT(1X,'      /AOINFO / : Write AO information to LFN',I3)
 8070 FORMAT(1X,'      /MULAT  / : Print Mulliken populations',
     *                ' by atom')
 8080 FORMAT(1X,'      /MULORB / : Print Mulliken populations',
     *                ' by orbital and atom')
 8090 FORMAT(1X,'      /APOLAR / : Enforce apolar NBOs')
 8100 FORMAT(1X,'      /RPNAO  / : Revise TPNAO with TRYD and TRED')
 8110 FORMAT(1X,'      /FILE   / : Set to ',52A1)
 8500 FORMAT(1X,'      /PRINT  / : Print level set to',I3)
C-----------------------------------------------------------------------
      END IF
C
C  SET PRINT LEVEL OPTIONS:
C
      IF(IPRINT.GT.0) THEN
        JPRINT(4)  =  1
        JPRINT(5)  =  1
      END IF
C
      IF(IPRINT.GT.1) THEN
        JPRINT(3)  =  1
        JPRINT(6)  =  1
        IF(JPRINT(36).EQ.0) JPRINT(36) =  1
      END IF
C
      IF(IPRINT.GT.2) THEN
        JPRINT(8)  =  1
        JPRINT(12) =  1
        JPRINT(46) =  1
      END IF
C
C  HIGHEST PRINT LEVEL (=4).  NOTE THAT THE AO DENSITY MATRIX AND
C  AO-XXX TRANSFORMATIONS ARE ACTIVATED BY JPRINT(43), THE PLOT
C  OPTION:
C
      IF(IPRINT.GT.3) THEN
        IF(JPRINT(7).EQ.0)  JPRINT(7)  = LFNARC
        IF(JPRINT(9).EQ.0)  JPRINT(9)  = IFULL
        IF(JPRINT(13).EQ.0) JPRINT(13) = IFULL
                            JPRINT(14) = 1
        IF(JPRINT(15).EQ.0) JPRINT(15) = IFULL
        IF(JPRINT(16).EQ.0) JPRINT(16) = IFULL
        IF(JPRINT(17).EQ.0) JPRINT(17) = IFULL
        IF(JPRINT(18).EQ.0) JPRINT(18) = IFULL
        IF(JPRINT(19).EQ.0) JPRINT(19) = IFULL
        IF(JPRINT(20).EQ.0) JPRINT(20) = IFULL
        IF(JPRINT(21).EQ.0) JPRINT(21) = IFULL
        IF(JPRINT(24).EQ.0) JPRINT(24) = IFULL
        IF(JPRINT(29).EQ.0) JPRINT(29) = IFULL
        IF(JPRINT(31).EQ.0) JPRINT(31) = IFULL
        IF(JPRINT(32).EQ.0) JPRINT(32) = 1
        IF(JPRINT(33).EQ.0) JPRINT(33) = IFULL
        IF(JPRINT(34).EQ.0) JPRINT(34) = IFULL
        IF(JPRINT(35).EQ.0) JPRINT(35) = IFULL
        IF(JPRINT(37).EQ.0) JPRINT(37) = IFULL
        IF(JPRINT(38).EQ.0) JPRINT(38) = IFULL
        IF(JPRINT(39).EQ.0) JPRINT(39) = IFULL
        IF(JPRINT(40).EQ.0) JPRINT(40) = IFULL
        IF(JPRINT(41).EQ.0) JPRINT(41) = IFULL
        IF(JPRINT(42).EQ.0) JPRINT(42) = IFULL
                            JPRINT(43) = LFNLBL
        IF(JPRINT(45).EQ.0) JPRINT(45) = IFULL
        IF(JPRINT(47).EQ.0) JPRINT(47) = IFULL
        IF(JPRINT(48).EQ.0) JPRINT(48) = IFULL
        IF(JPRINT(50).EQ.0) JPRINT(50) = IFULL
        IF(JPRINT(51).EQ.0) JPRINT(51) = IFULL
        IF(JPRINT(52).EQ.0) JPRINT(52) = IFULL
        IF(JPRINT(53).EQ.0) JPRINT(53) = IFULL
        IF(JPRINT(54).EQ.0) JPRINT(54) = IFULL
        IF(JPRINT(55).EQ.0) JPRINT(55) = 1
        IF(JPRINT(58).EQ.0) JPRINT(58) = IFULL
        IF(JPRINT(59).EQ.0) JPRINT(59) = IFULL
        IF(JPRINT(60).EQ.0) JPRINT(60) = IFULL
        IF(JPRINT(61).EQ.0) JPRINT(61) = IFULL
        IF(JPRINT(64).EQ.0) JPRINT(64) = IFULL
        IF(JPRINT(65).EQ.0) JPRINT(65) = IFULL
        IF(JPRINT(66).EQ.0) JPRINT(66) = IFULL
        IF(JPRINT(67).EQ.0) JPRINT(67) = IFULL
        IF(JPRINT(68).EQ.0) JPRINT(68) = IFULL
        IF(JPRINT(69).EQ.0) JPRINT(69) = IFULL
        IF(JPRINT(70).EQ.0) JPRINT(70) = IFULL
        IF(JPRINT(71).EQ.0) JPRINT(71) = IFULL
        IF(JPRINT(72).EQ.0) JPRINT(72) = IFULL
        IF(JPRINT(73).EQ.0) JPRINT(73) = IFULL
        IF(JPRINT(74).EQ.0) JPRINT(74) = IFULL
        IF(JPRINT(75).EQ.0) JPRINT(75) = IFULL
        IF(JPRINT(76).EQ.0) JPRINT(76) = IFULL
        IF(JPRINT(78).EQ.0) JPRINT(78) = IFULL
        IF(JPRINT(79).EQ.0) JPRINT(79) = IFULL
        IF(JPRINT(81).EQ.0) JPRINT(81) = 1
        IF(JPRINT(82).EQ.0) JPRINT(82) = IFULL
        IF(IWTNAB.EQ.0)     IWTNAB     = IFULL
                            IWDETL     = 1
        IF(IWNBBP.EQ.0)     IWNBBP     = IFULL
        IF(IWDM.NE.0)       IWMULP     = 2
      END IF
C
C  TURN ON THE NLMO ANALYSIS IF REQUIRED:
C
      IF(JPRINT(13).NE.0) JPRINT(8) = 1
      IF(JPRINT(15).NE.0) JPRINT(8) = 1
      IF(JPRINT(17).NE.0) JPRINT(8) = 1
      IF(JPRINT(18).NE.0) JPRINT(8) = 1
      IF(JPRINT(23).NE.0) JPRINT(8) = 1
      IF(JPRINT(46).NE.0) JPRINT(8) = 1
      IF(JPRINT(47).NE.0) JPRINT(8) = 1
      IF(JPRINT(48).NE.0) JPRINT(8) = 1
      IF(JPRINT(49).NE.0) JPRINT(8) = 1
      IF(JPRINT(54).NE.0) JPRINT(8) = 1
      IF(JPRINT(68).NE.0) JPRINT(8) = 1
      IF(JPRINT(74).NE.0) JPRINT(8) = 1
      IF(JPRINT(86).NE.0) JPRINT(8) = 1
C
C  PRINT ATOM DISTANCE TABLE WITH 'NRT' AND 'BNDIDX' FOR GENNBO:
C
      IF(NBOOPT(10).EQ.0) THEN
        IF(JPRINT(12).NE.0.OR.JPRINT(32).NE.0) JPRINT(81) = 1
      END IF
C
C  TAKE CARE OF THE PLOT OPTION:
C
      IF(JPRINT(43).NE.0) THEN
                            JPRINT(8)  =  1
        IF(JPRINT(22).EQ.0) JPRINT(22) =  LFNAO
        IF(IWTNAO.EQ.0)     IWTNAO     = -LFNNAO
        IF(JPRINT(28).EQ.0) JPRINT(28) = -LFNNHO
        IF(IWTNBO.EQ.0)     IWTNBO     = -LFNNBO
        IF(JPRINT(23).EQ.0) JPRINT(23) = -LFNNLM
        IF(JPRINT(26).EQ.0) JPRINT(26) = -LFNMO
        IF(JPRINT(27).EQ.0) JPRINT(27) = -LFNDM
        IF(JPRINT(44).EQ.0) JPRINT(44) = -LFNPNA
        IF(JPRINT(30).EQ.0) JPRINT(30) = -LFNPNH
        IF(JPRINT(25).EQ.0) JPRINT(25) = -LFNPNB
        IF(JPRINT(49).EQ.0) JPRINT(49) = -LFNPNL
      END IF
C
C  PRINT HYBRIDS IF THE NBO OUTPUT IS REQUESTED:
C
      IWHYBS = JPRINT(5)
      RETURN
      END
C***********************************************************************
      SUBROUTINE JOBOPT1(NBOOPT,CKEY,IFOUND,INBERR,NEXTWD,
     +  LENG,END,KEYWD)
C***********************************************************************
C 27-Nov-00  FAW  Break up JOBOPT into JOBOPT1, JOBOPT2, JOBOPT3
C 23-Feb-01  FAW  Add LFNBRK(100) and user-specified <matrix elements> IO
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER CKEY*(*)
      LOGICAL ERROR,END,NEXTWD,READ,AMPAC
      PARAMETER(KEYLEN = 9)
      DIMENSION NBOOPT(10),KEYWD(KEYLEN)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBTHR/THRSET,PRJSET,ACCTHR,CRTSET,E2THR,ATHR,PTHR,ETHR,
     +             DTHR,DLTHR,CHSTHR,REFTHR,STTHR,PRTHR,THRNCS,THRNJC
      COMMON/NBPRMC/LFNPRM
      SAVE IFULL,IVAL,ILEW
      DATA IFULL,IVAL,ILEW/4HFULL,3HVAL,3HLEW/
      IFOUND = 0
      NC=LENNB(CKEY)
C
C  IS THIS AN AMPAC VERSION?
C
      IF(NBOOPT(10).EQ.1) THEN
        AMPAC = .TRUE.
      ELSE
        AMPAC = .FALSE.
      END IF
C Search for 500-700 keywords
C  KEYWORD: 3CBOND -- SEARCH FOR THREE-CENTER BONDS
C   (DEFAULT IS TO SEARCH ONLY FOR ONE- AND TWO-CENTER NBOS)
      IF(CKEY.EQ.'3CBOND') THEN
        IW3C = 1
C  KEYWORD: LFNPR -- SPECIFY OUTPUT LFN
      ELSE IF(CKEY.EQ.'LFNPR') THEN
      CALL IFLD(IDUM,ERROR)
        IF(ERROR) THEN
          CALL KEYERR('LFNPR')
        ELSE
          LFNPR=IDUM
        ENDIF
C  KEYWORD: THRESH -- SPECIFY FIXED OCCUPANCY THRESHOLD FOR NBO SEARCH
      ELSE IF(CKEY.EQ.'THRESH') THEN
      CALL RFLD(RDUM,ERROR)
        IF(ERROR) THEN
          CALL KEYERR('THRESH')
        ELSE
          THRSET=RDUM
        ENDIF
C  KEYWORD: DETAIL -- PRINT DETAILS OF NBO SEARCH PROCEDURE
      ELSE IF(CKEY.EQ.'DETAIL') THEN
        IWDETL = 1
C  KEYWORD: MULAT -- PRINT MULLIKEN POPULATIONS BY ATOM
      ELSE IF(CKEY.EQ.'MULAT') THEN
        IWMULP = 1
C  KEYWORD: MULORB -- PRINT MULLIKEN POPULATIONS BY ORBITAL AND ATOM
      ELSE IF(CKEY.EQ.'MULORB') THEN
        IWMULP = 2
C  KEYWORD: PRJTHR -- USER SETS VALUE OF PROJECTION THRESHOLD FOR NBO SEARCH
C           FOR REJECTING LINEARLY DEPENDENT HYBRIDS
      ELSE IF(CKEY.EQ.'PRJTHR') THEN
      CALL RFLD(RDUM,ERROR)
        IF(ERROR) THEN
          CALL KEYERR('PRJTHR')
        ELSE
          PRJSET=RDUM
        ENDIF
C  KEYWORD: FNBO -- PRINT NBO FOCK MATRIX
      ELSE IF(CKEY.EQ.'FNBO') THEN
        JPRINT(37) = IFULL
        JPR = 37
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(37),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(37).EQ.IVAL) JPRINT(37) = IFULL
        END IF
C  KEYWORD: AOPNAO -- OUTPUT RAW AO TO PNAO TRANSFORMATION
      ELSE IF(CKEY.EQ.'AOPNAO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(44) = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(44),ICHKPT,LFNPNA,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(44).EQ.IVAL) JPRINT(44) = IFULL
          IF(JPRINT(44).EQ.ILEW) JPRINT(44) = IFULL
          IF(ICHKPT.NE.0) JPRINT(63) = ICHKPT * 2
          IF(ICHKPT.EQ.1) THEN
            CALL FNDFLD
            CALL FNDFIL(LFNPRM,ERROR)
            IF(ERROR) LFNPRM=0
          END IF
        END IF
C  KEYWORD: NLMOMO -- COMPUTE AND PRINT NLMO TO MO TRANSF.
      ELSE IF(CKEY.EQ.'NLMOMO') THEN
        JPRINT(13) = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(13),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
        END IF
C  KEYWORD: NLMO -- COMPUTE AND PRINT NLMOS
      ELSE IF(CKEY.EQ.'NLMO') THEN
        JPRINT(8) = 1
C  KEYWORD: NAOMO -- COMPUTE AND PRINT NAO TO MO TRANSF.
      ELSE IF(CKEY.EQ.'NAOMO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(9) = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(9),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
        END IF
C  KEYWORD: NBOMO -- COMPUTE AND PRINT NBO TO MO TRANSF.
      ELSE IF(CKEY.EQ.'NBOMO') THEN
        JPRINT(45) = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(45),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
        END IF
C  KEYWORD: NOBOND -- COMPUTE ONLY ONE-CENTER NBOS
      ELSE IF(CKEY.EQ.'NOBOND') THEN
        JPRINT(10) = 1
C  KEYWORD: SKIPBO -- SKIP NBO PROCEDURE
      ELSE IF(CKEY.EQ.'SKIPBO') THEN
        JPRINT(1) = 1
C  KEYWORD: RPNAO -- COMPUTE REVISED PURE AO TO PNAO TRANSF.
      ELSE IF(CKEY.EQ.'RPNAO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(11) = 1
C  KEYWORD: BNDIDX -- PRINT BOND INDICES
      ELSE IF(CKEY.EQ.'BNDIDX') THEN
        JPRINT(12) = 1
C  KEYWORD: RESONANCE -- ALLOW STRONGLY "NON-LEWIS" NBO OCCUPANCIES
C   (OVERRIDES AUTOMATIC SHUTDOWN OF NBO PROCEDURE IN STRONGLY
C    DELOCALIZED CASES)
      ELSE IF(CKEY.EQ.'RESON') THEN
        JPRINT(14) = 1
C  KEYWORD: PAOPNAO -- I/O WITH PAO TO PNAO TRANSFORMATION
      ELSE IF(CKEY.EQ.'PAOPNAO') THEN
        IF(AMPAC) GO TO 2000
        IWPNAO = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .TRUE.
          CALL KEYPAR(KEYWD,LENG,IWPNAO,ICHKPT,LFNPPA,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(IWPNAO.EQ.IVAL) IWPNAO = IFULL
          IF(IWPNAO.EQ.ILEW) IWPNAO = IFULL
        END IF
C  KEYWORD: AONAO -- I/O WITH AO TO NAO TRANSFORMATION
      ELSE IF(CKEY.EQ.'AONAO') THEN
        IF(AMPAC) GO TO 2000
        IWTNAO = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .TRUE.
          CALL KEYPAR(KEYWD,LENG,IWTNAO,ICHKPT,LFNNAO,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(IWTNAO.EQ.IVAL) IWTNAO = IFULL
          IF(IWTNAO.EQ.ILEW) IWTNAO = IFULL
          IF(ICHKPT.NE.0) JPRINT(63) = ICHKPT * 3
          IF(AMPAC.AND.ICHKPT.EQ.1) THEN
            JPRINT(63) = 0
            GO TO 2010
          END IF
          IF(ICHKPT.EQ.1) THEN
            CALL FNDFLD
            CALL FNDFIL(LFNPRM,ERROR)
            IF(ERROR) LFNPRM=0
          END IF
        END IF
C  KEYWORD: NAONBO -- I/O WITH NAO TO NBO TRANSFORMATION
      ELSE IF(CKEY.EQ.'NAONBO') THEN
        IF(AMPAC) GO TO 2000
        IWTNAB = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .TRUE.
          CALL KEYPAR(KEYWD,LENG,IWTNAB,ICHKPT,LFNNAB,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(IWTNAB.EQ.IVAL) IWTNAB = IFULL
        END IF
C  KEYWORD: AONBO -- OUTPUT AO TO NBO TRANSFORMATION
      ELSE IF(CKEY.EQ.'AONBO') THEN
        IWTNBO = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,IWTNBO,ICHKPT,LFNNBO,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(IWTNBO.EQ.IVAL) IWTNBO = IFULL
          IF(ICHKPT.NE.0) JPRINT(63) = ICHKPT * 7
          IF(AMPAC.AND.ICHKPT.EQ.1) THEN
            JPRINT(63) = 0
            GO TO 2010
          END IF
          IF(ICHKPT.EQ.1) THEN
            CALL FNDFLD
            CALL FNDFIL(LFNPRM,ERROR)
            IF(ERROR) LFNPRM=0
          END IF
        END IF
C  KEYWORD: FNLMO -- PRINT NLMO FOCK MATRIX
      ELSE IF(CKEY.EQ.'FNLMO') THEN
        JPRINT(15) = IFULL
        JPR = 15
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(15),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(15).EQ.IVAL) JPRINT(15) = IFULL
        END IF
C  KEYWORD: DMNBO -- PRINT NBO DENSITY MATRIX
      ELSE IF(CKEY.EQ.'DMNBO') THEN
        JPRINT(16) = IFULL
        JPR = 16
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(16),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(16).EQ.IVAL) JPRINT(16) = IFULL
        END IF
C  KEYWORD: DMNLMO -- PRINT NLMO DENSITY MATRIX
      ELSE IF(CKEY.EQ.'DMNLMO') THEN
        JPRINT(17) = IFULL
        JPR = 17
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(17),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(17).EQ.IVAL) JPRINT(17) = IFULL
        END IF
C  KEYWORD: AONLMO -- COMPUTE AND OUTPUT AO TO NLMO TRANSF.
      ELSE IF(CKEY.EQ.'AONLMO') THEN
        JPRINT(23) = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(23),ICHKPT,LFNNLM,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(23).EQ.IVAL) JPRINT(23) = IFULL
          IF(ICHKPT.NE.0) JPRINT(63) = ICHKPT * 9
          IF(AMPAC.AND.ICHKPT.EQ.1) THEN
            JPRINT(63) = 0
            GO TO 2010
          END IF
          IF(ICHKPT.EQ.1) THEN
            CALL FNDFLD
            CALL FNDFIL(LFNPRM,ERROR)
            IF(ERROR) LFNPRM=0
          END IF
        END IF
C  KEYWORD: PRINT -- READ IN PRINT OPTION LEVEL "IPRINT"
      ELSE IF(CKEY.EQ.'PRINT') THEN
        CALL IFLD(IDUM,ERROR)
        IF(ERROR) THEN
          CALL KEYERR('PRINT')
        ELSE
          IPRINT=IDUM
        ENDIF
C  KEYWORD: NAONLMO -- PRINT NAO TO NLMO TRANSFORMATION MATRIX
      ELSE IF(CKEY.EQ.'NAONLMO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(18) = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(18),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(18).EQ.IVAL) JPRINT(18) = IFULL
        END IF
C  KEYWORD: SPNAO -- PRINT S-PNAO OVERLAP MATRIX
      ELSE IF(CKEY.EQ.'SPNAO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(19) = IFULL
        JPR = 19
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(19),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(19).EQ.IVAL) JPRINT(19) = IFULL
          IF(JPRINT(19).EQ.ILEW) JPRINT(19) = IFULL
        END IF
C  KEYWORD: SPNHO -- PRINT S-PNHO OVERLAP MATRIX
      ELSE IF(CKEY.EQ.'SPNHO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(20) = IFULL
        JPR = 20
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(20),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(20).EQ.IVAL) JPRINT(20) = IFULL
          IF(JPRINT(20).EQ.ILEW) JPRINT(20) = IFULL
        END IF
C  KEYWORD: NHONLMO -- OUTPUT THE NHO TO NLMO TRANSFORMATION
      ELSE IF(CKEY.EQ.'NHONLMO') THEN
        JPRINT(24) = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(24),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(24).EQ.IVAL) JPRINT(24) = IFULL
        END IF
C  KEYWORD: SPNBO -- PRINT S-PNBO OVERLAP MATRIX
      ELSE IF(CKEY.EQ.'SPNBO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(21) = IFULL
        JPR = 21
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(21),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(21).EQ.IVAL) JPRINT(21) = IFULL
        END IF
C  KEYWORD: AOINFO -- WRITE BASIS SET INFO
      ELSE IF(CKEY.EQ.'AOINFO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(22) = LFNAO
        CALL IFLD(ITEMP,ERROR)
        IF(.NOT.ERROR) JPRINT(22) = ABS(ITEMP)
      ELSE
        IFOUND = 0
        RETURN
      ENDIF
      IFOUND = 1
      RETURN
C  INACTIVE KEYWORD FOR AM1/MOPAC VERSION
 2000 CONTINUE
      IF(INBERR.EQ.0) THEN
        INBERR=1
        WRITE(LFNPR,5000)
 5000   FORMAT(/1X,35('*'),' NBO 5.G ',35('*')/)
      END IF
      WRITE(LFNPR,5020) (CKEY(I:I),I=1,NC)
 5020 FORMAT(1X,'Inactive $NBO keyword for AM1/Mopac version: ',6A1)
      IFOUND = 1
      RETURN
C  CHECKPOINTING NOT SUPPORTED FOR AM1/MOPAC VERSION
 2010 CONTINUE
      IF(INBERR.EQ.0) THEN
        INBERR=1
        WRITE(LFNPR,5000)
      END IF
      WRITE(LFNPR,5030) (CKEY(I:I),I=1,NC)
 5030 FORMAT(1X,'Checkpointing not supported in AM1/Mopac ',
     +           'version: ',6A1)
      IFOUND = 1
      RETURN
      END
C***********************************************************************
      SUBROUTINE JOBOPT2(NBOOPT,CKEY,IFOUND,INBERR,NEXTWD,
     +  LENG,END,KEYWD)
C***********************************************************************
C 27-Nov-00  FAW  Break up JOBOPT into JOBOPT1, JOBOPT2, JOBOPT3
C 23-Feb-01  FAW  Add LFNBRK(100) and user-specified <matrix elements> IO
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER CKEY*(*)
      LOGICAL ERROR,END,NEXTWD,READ,AMPAC
      PARAMETER(KEYLEN = 9)
      DIMENSION NBOOPT(10),KEYWD(KEYLEN)
C
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBTHR/THRSET,PRJSET,ACCTHR,CRTSET,E2THR,ATHR,PTHR,ETHR,
     +             DTHR,DLTHR,CHSTHR,REFTHR,STTHR,PRTHR,THRNCS,THRNJC
      COMMON/NBPRMC/LFNPRM
      SAVE IFULL,IVAL,ILEW
      DATA IFULL,IVAL,ILEW/4HFULL,3HVAL,3HLEW/
      DATA ONE/1.0D0/
      IFOUND = 0
      NC=LENNB(CKEY)
C
C  IS THIS AN AMPAC VERSION?
C
      IF(NBOOPT(10).EQ.1) THEN
        AMPAC = .TRUE.
      ELSE
        AMPAC = .FALSE.
      END IF
C Search for 900-1100 keywords
C  KEYWORD: AOPNBO -- WRITE AO TO PNBO TRANSFORMATION
      IF(CKEY.EQ.'AOPNBO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(25) = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(25),ICHKPT,LFNPNB,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(25).EQ.IVAL) JPRINT(25) = IFULL
          IF(ICHKPT.NE.0) JPRINT(63) = ICHKPT * 6
          IF(ICHKPT.EQ.1) THEN
            CALL FNDFLD
            CALL FNDFIL(LFNPRM,ERROR)
            IF(ERROR) LFNPRM=0
            LFNBRK(25) = LFNPRM
          END IF
        END IF
C  KEYWORD: AOMO -- WRITE AO TO MO TRANSFORMATION
      ELSE IF(CKEY.EQ.'AOMO') THEN
        JPRINT(26) = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(26),ICHKPT,LFNMO,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
        END IF
C  KEYWORD: DMAO -- WRITE AO DENSITY MATRIX
      ELSE IF(CKEY.EQ.'DMAO') THEN
        JPRINT(27) = IFULL
        JPR = 27
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(27),ICHKPT,LFNDM,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(27).EQ.IVAL) JPRINT(27) = IFULL
          IF(JPRINT(27).EQ.ILEW) JPRINT(27) = IFULL
        END IF
C  KEYWORD: AONHO -- WRITE AO TO NHO TRANSFORMATION
      ELSE IF(CKEY.EQ.'AONHO') THEN
        JPRINT(28) = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(28),ICHKPT,LFNNHO,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(28).EQ.IVAL) JPRINT(28) = IFULL
          IF(JPRINT(28).EQ.ILEW) JPRINT(28) = IFULL
          IF(ICHKPT.NE.0) JPRINT(63) = ICHKPT * 5
          IF(AMPAC.AND.ICHKPT.EQ.1) THEN
            JPRINT(63) = 0
            GO TO 2010
          END IF
          IF(ICHKPT.EQ.1) THEN
            CALL FNDFLD
            CALL FNDFIL(LFNPRM,ERROR)
            IF(ERROR) LFNPRM=0
          END IF
        END IF
C  KEYWORD: FNHO -- PRINT NHO FOCK MATRIX
      ELSE IF(CKEY.EQ.'FNHO') THEN
        JPRINT(29) = IFULL
        JPR = 29
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(29),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(29).EQ.IVAL) JPRINT(29) = IFULL
          IF(JPRINT(29).EQ.ILEW) JPRINT(29) = IFULL
        END IF
C  KEYWORD: AOPNHO -- WRITE AO TO PNHO TRANSFORMATION
      ELSE IF(CKEY.EQ.'AOPNHO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(30) = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(30),ICHKPT,LFNPNH,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(30).EQ.IVAL) JPRINT(30) = IFULL
          IF(JPRINT(30).EQ.ILEW) JPRINT(30) = IFULL
          IF(ICHKPT.NE.0) JPRINT(63) = ICHKPT * 4
          IF(ICHKPT.EQ.1) THEN
            CALL FNDFLD
            CALL FNDFIL(LFNPRM,ERROR)
            IF(ERROR) LFNPRM=0
          END IF
        END IF
C  KEYWORD: FNAO -- PRINT NAO FOCK MATRIX
      ELSE IF(CKEY.EQ.'FNAO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(31) = IFULL
        JPR = 31
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(31),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(31).EQ.IVAL) JPRINT(31) = IFULL
          IF(JPRINT(31).EQ.ILEW) JPRINT(31) = IFULL
        END IF
C  KEYWORD: NAONHO -- OUTPUT THE NAO TO NHO TRANSFORMATION
      ELSE IF(CKEY.EQ.'NAONHO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(33) = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(33),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(33).EQ.IVAL) JPRINT(33) = IFULL
          IF(JPRINT(33).EQ.ILEW) JPRINT(33) = IFULL
        END IF
C  KEYWORD: DMNHO -- PRINT NHO DENSITY MATRIX
      ELSE IF(CKEY.EQ.'DMNHO') THEN
        JPRINT(34) = IFULL
        JPR = 34
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(34),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(34).EQ.IVAL) JPRINT(34) = IFULL
          IF(JPRINT(34).EQ.ILEW) JPRINT(34) = IFULL
        END IF
C  KEYWORD: DMNAO -- PRINT NAO DENSITY MATRIX
      ELSE IF(CKEY.EQ.'DMNAO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(35) = IFULL
        JPR = 35
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(35),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(35).EQ.IVAL) JPRINT(35) = IFULL
          IF(JPRINT(35).EQ.ILEW) JPRINT(35) = IFULL
        END IF
C  KEYWORD: BEND -- PRINT NHO DIRECTIONALITY AND BOND BENDING INFO
      ELSE IF(CKEY.EQ.'BEND') THEN
        JPRINT(36) = 2
        CALL RFLD(TEMP,ERROR)
        IF(ERROR) GO TO 100
        ATHR = ABS(TEMP)
        CALL RFLD(TEMP,ERROR)
        IF(ERROR) GO TO 100
        PTHR = ABS(TEMP)
        IF(PTHR.LT.ONE) PTHR = ONE
        CALL RFLD(TEMP,ERROR)
        IF(ERROR) GO TO 100
        ETHR = ABS(TEMP)
C  KEYWORD: NHOMO -- COMPUTE AND PRINT NHO TO MO TRANSF.
      ELSE IF(CKEY.EQ.'NHOMO') THEN
        JPRINT(38) = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(38),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
        END IF
C  KEYWORD: SAO -- PRINT AO OVERLAP MATRIX
      ELSE IF(CKEY.EQ.'SAO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(39) = IFULL
        JPR = 39
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(39),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(39).EQ.IVAL) JPRINT(39) = IFULL
          IF(JPRINT(39).EQ.ILEW) JPRINT(39) = IFULL
        END IF
C  KEYWORD: FAO -- PRINT AO FOCK MATRIX
      ELSE IF(CKEY.EQ.'FAO') THEN
        JPRINT(40) = IFULL
        JPR = 40
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(40),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(40).EQ.IVAL) JPRINT(40) = IFULL
          IF(JPRINT(40).EQ.ILEW) JPRINT(40) = IFULL
        END IF
C  KEYWORD: NHONBO -- OUTPUT NHO TO NBO TRANSFORMATION
      ELSE IF(CKEY.EQ.'NHONBO') THEN
        JPRINT(41) = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(41),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(41).EQ.IVAL) JPRINT(41) = IFULL
        END IF
C  KEYWORD: BOAO -- PRINT AO BOND-ORDER MATRIX
      ELSE IF(CKEY.EQ.'BOAO') THEN
        JPRINT(42) = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(42),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(42).EQ.IVAL) JPRINT(42) = IFULL
          IF(JPRINT(42).EQ.ILEW) JPRINT(42) = IFULL
        END IF
C  KEYWORD: E2PERT -- 2ND-ORDER PERTURBATIVE ANALYSIS OF THE NBO FOCK MATRIX
      ELSE IF(CKEY.EQ.'E2PERT') THEN
        JPRINT(3) = 1
        CALL RFLD(TEMP,ERROR)
        IF(ERROR) GO TO 100
        E2THR = ABS(TEMP)
C  KEYWORD: PLOT -- WRITE AO BASIS, DENSITY, AND TRANSFORMS FOR PLOTTING
      ELSE IF(CKEY.EQ.'PLOT') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(43) = LFNLBL
        CALL IFLD(ITEMP,ERROR)
        IF(.NOT.ERROR) JPRINT(43) = ABS(ITEMP)
C  KEYWORD: NPA -- PRINT THE NATURAL POPULATION ANALYSIS
      ELSE IF(CKEY.EQ.'NPA') THEN
        JPRINT(4) = 1
C  KEYWORD: NBOSUM -- PRINT THE NBO SUMMARY
      ELSE IF(CKEY.EQ.'NBOSUM') THEN
        JPRINT(6) = 1
C  KEYWORD: NBO -- PRINT THE NBO ANALYSIS
      ELSE IF(CKEY.EQ.'NBO') THEN
        JPRINT(5) = 1
C  KEYWORD: DIPOLE -- PRINT NBO/NLMO DIPOLE ANALYSIS:
      ELSE IF(CKEY.EQ.'DIPOLE') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(46) = 1
        JPR = 46
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        CALL RFLD(TEMP,ERROR)
        IF(ERROR) GO TO 100
        DTHR = ABS(TEMP)
C  KEYWORD: NBONLMO -- PRINT NBO TO NLMO TRANSFORMATION MATRIX
      ELSE IF(CKEY.EQ.'NBONLMO') THEN
        JPRINT(47) = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(47),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(47).EQ.IVAL) JPRINT(47) = IFULL
        END IF
C  KEYWORD: SPNLMO -- OUTPUT THE PNLMO OVERLAP MATRIX
      ELSE IF(CKEY.EQ.'SPNLMO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(48) = IFULL
        JPR = 48
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(48),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(48).EQ.IVAL) JPRINT(48) = IFULL
        END IF
C  KEYWORD: AOPNLMO -- OUTPUT THE AO-PNLMO TRANSFORMATION MATRIX
      ELSE IF(CKEY.EQ.'AOPNLMO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(49) = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(49),ICHKPT,LFNPNL,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(49).EQ.IVAL) JPRINT(49) = IFULL
          IF(ICHKPT.NE.0) JPRINT(63) = ICHKPT * 8
          IF(ICHKPT.EQ.1) THEN
            CALL FNDFLD
            CALL FNDFIL(LFNPRM,ERROR)
            IF(ERROR) LFNPRM=0
          END IF
        END IF
C  KEYWORD: DIAO -- OUTPUT THE AO DIPOLE INTEGRALS
      ELSE IF(CKEY.EQ.'DIAO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(50) = IFULL
        JPR = 50
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(50),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(50).EQ.IVAL) JPRINT(50) = IFULL
          IF(JPRINT(50).EQ.ILEW) JPRINT(50) = IFULL
        END IF
C  KEYWORD: DINAO -- OUTPUT THE NAO DIPOLE INTEGRALS
      ELSE IF(CKEY.EQ.'DINAO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(51) = IFULL
        JPR = 51
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(51),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(51).EQ.IVAL) JPRINT(51) = IFULL
          IF(JPRINT(51).EQ.ILEW) JPRINT(51) = IFULL
        END IF
C  KEYWORD: DINHO -- OUTPUT THE NHO DIPOLE INTEGRALS
      ELSE IF(CKEY.EQ.'DINHO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(52) = IFULL
        JPR = 52
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(52),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(52).EQ.IVAL) JPRINT(52) = IFULL
          IF(JPRINT(52).EQ.ILEW) JPRINT(52) = IFULL
        END IF
C  KEYWORD: DINBO -- OUTPUT THE NBO DIPOLE INTEGRALS
      ELSE IF(CKEY.EQ.'DINBO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(53) = IFULL
        JPR = 53
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(53),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(53).EQ.IVAL) JPRINT(53) = IFULL
        END IF
C  KEYWORD: DINLMO -- OUTPUT THE NLMO DIPOLE INTEGRALS
      ELSE IF(CKEY.EQ.'DINLMO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(54) = IFULL
        JPR = 54
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(54),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(54).EQ.IVAL) JPRINT(54) = IFULL
        END IF
C  KEYWORD: NBODAF -- CHOOSE AN ALTERNATE DAF
      ELSE IF(CKEY.EQ.'NBODAF') THEN
        LFNDAF = ABS(LFNDAF)
        CALL IFLD(ITEMP,ERROR)
        IF(.NOT.ERROR) LFNDAF = ABS(ITEMP)
C  KEYWORD: ARCHIVE -- WRITE THE ARCHIVE FILE
      ELSE IF(CKEY.EQ.'ARCHIVE') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(7) = LFNARC
        CALL IFLD(ITEMP,ERROR)
        IF(.NOT.ERROR) JPRINT(7) = ABS(ITEMP)
C  KEYWORD: APOLAR -- ENFORCE APOLAR BONDS:
      ELSE IF(CKEY.EQ.'APOLAR') THEN
        IWAPOL = 1
C  KEYWORD: CHSTHR -- SET THE OCCUPANCY THRESHOLD IN NBCHSE
      ELSE IF(CKEY.EQ.'CHSTHR') THEN
        CHSTHR = ABS(CHSTHR)
        CALL RFLD(TEMP,ERROR)
        IF(ERROR) GO TO 100
        CHSTHR = ABS(TEMP)
      ELSE
        IFOUND = 0
        RETURN
      ENDIF
  100 IFOUND = 1
      RETURN
C  INACTIVE KEYWORD FOR AM1/MOPAC VERSION
 2000 CONTINUE
      IF(INBERR.EQ.0) THEN
        INBERR=1
        WRITE(LFNPR,5000)
 5000   FORMAT(/1X,35('*'),' NBO 5.G ',35('*')/)
      END IF
      WRITE(LFNPR,5020) (CKEY(I:I),I=1,NC)
 5020 FORMAT(1X,'Inactive $NBO keyword for AM1/Mopac version: ',6A1)
      IFOUND=1
      RETURN
C  CHECKPOINTING NOT SUPPORTED FOR AM1/MOPAC VERSION
 2010 CONTINUE
      IF(INBERR.EQ.0) THEN
        INBERR=1
        WRITE(LFNPR,5000)
      END IF
      WRITE(LFNPR,5030) (CKEY(I:I),I=1,NC)
 5030 FORMAT(1X,'Checkpointing not supported in AM1/Mopac ',
     +           'version: ',6A1)
      IFOUND = 1
      RETURN
      END
C***********************************************************************
      SUBROUTINE JOBOPT3(NBOOPT,CKEY,IFOUND,INBERR,NEXTWD,
     +  LENG,END,KEYWD)
C***********************************************************************
C 27-Nov-00  FAW  Break up JOBOPT into JOBOPT1, JOBOPT2, JOBOPT3
C 23-Feb-01  FAW  Add LFNBRK(100) and user-specified <matrix elements> IO
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER CKEY*(*),CKEY1*10
      LOGICAL ERROR,END,EQUAL,NEXTWD,READ,AMPAC
      PARAMETER(KEYLEN = 9)
      DIMENSION NBOOPT(10),KEYWD(KEYLEN)
C
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBTHR/THRSET,PRJSET,ACCTHR,CRTSET,E2THR,ATHR,PTHR,ETHR,
     +             DTHR,DLTHR,CHSTHR,REFTHR,STTHR,PRTHR,THRNCS,THRNJC
      COMMON/NBPRMC/LFNPRM
      DIMENSION KBFGS(4),KPOWEL(6),KSAP(3)
      DATA KBFGS/1HB,1HF,1HG,1HS/,
     + KPOWEL/1HP,1HO,1HW,1HE,1HL,1HL/,KSAP/1HS,1HA,1HP/
      DATA IB,IP/1HB,1HP/HUNDRD/100.0D0/
      DATA IFULL,IVAL,ILEW/4HFULL,3HVAL,3HLEW/
      SAVE IFULL,IVAL,ILEW,IB,IP,HUNDRD
      IFOUND = 0
      NC = LENNB(CKEY)
C
C  IS THIS AN AMPAC VERSION?
C
      IF(NBOOPT(10).EQ.1) THEN
        AMPAC = .TRUE.
      ELSE
        AMPAC = .FALSE.
      END IF
C *** NRT KEYWORDS ***
C  KEYWORD: NRTOPT -- OPTIMIZE NRT WEIGHTS:
      IF(CKEY.EQ.'NRTOPT') THEN
        IF(JPRINT(32).EQ.0) JPRINT(32) = 1
        JPRINT(55) = IB
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          IF(EQUAL(KEYWD,KBFGS,4)) THEN
            JPRINT(55) = IB
          ELSE IF(EQUAL(KEYWD,KPOWEL,6)) THEN
            JPRINT(55) = IP
          ELSE IF(EQUAL(KEYWD,KSAP,3)) THEN
            JPRINT(55) = 1234567
            IF(LENG.GT.3) CALL CONVIN(KEYWD(4),LENG-3,JPRINT(55),ERROR)
            IF(ERROR) THEN
              CALL KEYERR('NRTOPT')
              JPRINT(55) = 1234567
            ENDIF
            JPRINT(55) = ABS(JPRINT(55))
          ELSE IF(EQUAL(KEYWD,KSAP,2)) THEN
            JPRINT(55) = -1234567
            IF(LENG.GT.2) CALL CONVIN(KEYWD(3),LENG-2,JPRINT(55),ERROR)
            IF(ERROR) THEN
              CALL KEYERR('NRTOPT')
              JPRINT(55)= -1234567
            ENDIF
            JPRINT(55) = -ABS(JPRINT(55))
          ELSE
            NEXTWD = .FALSE.
          END IF
        END IF
C  KEYWORD: NRTMEM -- NUMBER OF REFERENCE STRUCTURES IN NRT ANALYSIS
      ELSE IF(CKEY.EQ.'NRTMEM') THEN
        IF(JPRINT(32).EQ.0) JPRINT(32) = 1
        CALL IFLD(ITEMP,ERROR)
        IF(ERROR) GO TO 100
        JPRINT(56) = MAX(1,ABS(ITEMP))
C  KEYWORD: NRTDTL -- DETAIL NRT ANALYSIS
      ELSE IF(CKEY.EQ.'NRTDTL') THEN
        IF(JPRINT(32).EQ.0) JPRINT(32) = 1
        JPRINT(57) = 1
C  KEYWORD: NRTTHR -- SET THRESHOLD FOR DELOCALIZATION LIST
      ELSE IF(CKEY.EQ.'NRTTHR') THEN
        IF(JPRINT(32).EQ.0) JPRINT(32) = 1
        DLTHR = ABS(DLTHR)
        CALL RFLD(TEMP,ERROR)
        IF(ERROR) GO TO 100
        DLTHR = ABS(TEMP)
C  KEYWORD: NRTWGT -- THRESHOLD WGT FOR MULTI-REF NRT
      ELSE IF(CKEY.EQ.'NRTWGT') THEN
        IF(JPRINT(32).EQ.0) JPRINT(32) = 1
        REFTHR = ABS(REFTHR)
        CALL RFLD(TEMP,ERROR)
        IF(ERROR) GO TO 100
        REFTHR = ABS(TEMP)/HUNDRD
C  KEYWORD: NRTLST -- SET THRESHOLD FOR $NRTSTR LISTING
      ELSE IF(CKEY.EQ.'NRTLST') THEN
        IF(JPRINT(32).EQ.0) JPRINT(32) = 1
        CALL RFLD(TEMP,ERROR)
        IF(ERROR) GO TO 100
        PRTHR = ABS(TEMP)/HUNDRD
C  KEYWORD: NRTFDM -- USE FULL NAO DENSITY FOR MULTI-REF NRT
      ELSE IF(CKEY.EQ.'NRTFDM') THEN
        IF(JPRINT(32).EQ.0) JPRINT(32) = 1
        JPRINT(77) = 1
C  KEYWORD: NRTCHG -- MAXIMUM FORMAL CHARGE ALLOWED IN SR LEWIS
      ELSE IF(CKEY.EQ.'NRTCHG') THEN
        IF(JPRINT(32).EQ.0) JPRINT(32) = 1
        JPRINT(80) = 1
        CALL IFLD(ITEMP,ERROR)
        IF(ERROR) GO TO 100
        JPRINT(80) = ITEMP
C  KEYWORD: NRT -- PERFORM NATURAL RESONANCE THEORY ANALYSIS:
C  (NOTE THAT WE SHOULD CHECK THIS KEYWORD AFTER WE CHECK THE OTHER
C  `NRT' KEYWORDS, LIKE `NRTOPT'.  OTHERWISE, KEYWORD CONFLICTS CAN
C  OCCUR.)
      ELSE IF(CKEY.EQ.'NRT') THEN
        JPRINT(32) = 1
        CALL IFLD(ITEMP,ERROR)
        IF(.NOT.ERROR) JPRINT(32) = ITEMP
C***** END OF NRT KEYWORDS *****
C  KEYWORD: AOPAO -- OUTPUT AO TO PURE AO TRANSF.
      ELSE IF(CKEY.EQ.'AOPAO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(59) = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(59),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(59).EQ.IVAL) JPRINT(59) = IFULL
          IF(JPRINT(59).EQ.ILEW) JPRINT(59) = IFULL
          IF(ICHKPT.NE.0) JPRINT(63) = ICHKPT
          IF(AMPAC.AND.ICHKPT.EQ.1) THEN
            JPRINT(63) = 0
            GO TO 2010
          END IF
          IF(ICHKPT.EQ.1) THEN
            CALL FNDFLD
            CALL FNDFIL(LFNPRM,ERROR)
            IF(ERROR) LFNPRM=0
          END IF
        END IF
C  KEYWORD: SPAO -- OUTPUT PAO OVERLAP MATRIX
      ELSE IF(CKEY.EQ.'SPAO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(58) = IFULL
        JPR = 58
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(58),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(58).EQ.IVAL) JPRINT(58) = IFULL
          IF(JPRINT(58).EQ.ILEW) JPRINT(58) = IFULL
        END IF
C  KEYWORD: NBBP -- OUTPUT BOND-BOND POLARIZABILITY MATRIX AND SUPPLEMENTARY
C                   ELEMENTS FROM <.../.../...> INPUT LIST
      ELSE IF(CKEY.EQ.'NBBP') THEN
        IWNBBP = IFULL
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNTRY,ERROR)
        IF(LFNTRY.GT.0) IWNBBP = -1000*LFNTRY
        IF(ERROR) NEXTWD = .FALSE.
C  KEYWORD: STERIC --OUTPUT NBO STERIC ANALYSIS AND SUPPLEMENTARY ELEMENTS
C                    FROM <.../...> INPUT LIST
      ELSE IF(CKEY.EQ.'STERIC') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(76) = 1
        JPRINT(8) = 1
        CALL RFLD(TEMP,ERROR)
        IF(.NOT.ERROR) THEN
          STTHR = ABS(TEMP)
          LENG = KEYLEN
          CALL HFLD(KEYWD,LENG,END)
        END IF
        CALL FNDFIL(LFNTRY,ERROR)
        IF(LFNTRY.GT.0) JPRINT(76) = LFNTRY
        IF(ERROR) NEXTWD = .FALSE.
C  KEYWORD: FMO -- PRINT MO FOCK MATRIX
      ELSE IF(CKEY.EQ.'FMO') THEN
        JPRINT(60) = IFULL
        JPR = 60
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(60),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(60).EQ.IVAL) JPRINT(60) = IFULL
          IF(JPRINT(60).EQ.ILEW) JPRINT(60) = IFULL
        END IF
C  KEYWORD: DMMO -- PRINT MO DENSITY MATRIX
      ELSE IF(CKEY.EQ.'DMMO') THEN
        JPRINT(61) = IFULL
        JPR = 61
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(61),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(61).EQ.IVAL) JPRINT(61) = IFULL
          IF(JPRINT(61).EQ.ILEW) JPRINT(61) = IFULL
        END IF
C  KEYWORD: DIMO -- PRINT MO DIPOLE MATRICES
      ELSE IF(CKEY.EQ.'DIMO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(62) = IFULL
        JPR = 62
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(62),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(62).EQ.IVAL) JPRINT(62) = IFULL
          IF(JPRINT(62).EQ.ILEW) JPRINT(62) = IFULL
        END IF
C  KEYWORD: KAO -- PRINT AO KINETIC ENERGY MATRIX
      ELSE IF(CKEY.EQ.'KAO') THEN
        JPRINT(64) = IFULL
        JPR = 64
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(64),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(64).EQ.IVAL) JPRINT(64) = IFULL
          IF(JPRINT(64).EQ.ILEW) JPRINT(64) = IFULL
        END IF
C  KEYWORD: KNAO -- PRINT NAO KINETIC ENERGY MATRIX
      ELSE IF(CKEY.EQ.'KNAO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(65) = IFULL
        JPR = 65
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(65),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(65).EQ.IVAL) JPRINT(65) = IFULL
          IF(JPRINT(65).EQ.ILEW) JPRINT(65) = IFULL
        END IF
C  KEYWORD: KNHO -- PRINT NHO KINETIC ENERGY MATRIX
      ELSE IF(CKEY.EQ.'KNHO') THEN
        JPRINT(66) = IFULL
        JPR = 66
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(66),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(66).EQ.IVAL) JPRINT(66) = IFULL
          IF(JPRINT(66).EQ.ILEW) JPRINT(66) = IFULL
        END IF
C  KEYWORD: KNBO -- PRINT NBO KINETIC ENERGY MATRIX
      ELSE IF(CKEY.EQ.'KNBO') THEN
        JPRINT(67) = IFULL
        JPR = 67
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(67),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(67).EQ.IVAL) JPRINT(67) = IFULL
          IF(JPRINT(67).EQ.ILEW) JPRINT(67) = IFULL
        END IF
C  KEYWORD: KNLMO -- PRINT NLMO KINETIC ENERGY MATRIX
      ELSE IF(CKEY.EQ.'KNLMO') THEN
        JPRINT(68) = IFULL
        JPR = 68
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(68),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(68).EQ.IVAL) JPRINT(68) = IFULL
          IF(JPRINT(68).EQ.ILEW) JPRINT(68) = IFULL
        END IF
C  KEYWORD: KMO -- PRINT MO KINETIC ENERGY MATRIX
      ELSE IF(CKEY.EQ.'KMO') THEN
        JPRINT(69) = IFULL
        JPR = 69
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(69),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(69).EQ.IVAL) JPRINT(69) = IFULL
          IF(JPRINT(69).EQ.ILEW) JPRINT(69) = IFULL
        END IF
C  KEYWORD: VAO -- PRINT AO 1-ELECTRON POTENTIAL ENERGY MATRIX
      ELSE IF(CKEY.EQ.'VAO') THEN
        JPRINT(70) = IFULL
        JPR = 70
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(70),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(70).EQ.IVAL) JPRINT(70) = IFULL
          IF(JPRINT(70).EQ.ILEW) JPRINT(70) = IFULL
        END IF
C  KEYWORD: VNAO -- PRINT NAO 1-ELECTRON POTENTIAL ENERGY MATRIX
      ELSE IF(CKEY.EQ.'VNAO') THEN
        IF(AMPAC) GO TO 2000
        JPRINT(71) = IFULL
        JPR = 71
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(71),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(71).EQ.IVAL) JPRINT(71) = IFULL
          IF(JPRINT(71).EQ.ILEW) JPRINT(71) = IFULL
        END IF
C  KEYWORD: VNHO -- PRINT NHO 1-ELECTRON POTENTIAL ENERGY MATRIX
      ELSE IF(CKEY.EQ.'VNHO') THEN
        JPRINT(72) = IFULL
        JPR = 72
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(72),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(72).EQ.IVAL) JPRINT(72) = IFULL
          IF(JPRINT(72).EQ.ILEW) JPRINT(72) = IFULL
        END IF
C  KEYWORD: VNBO -- PRINT NBO 1-ELECTRON POTENTIAL ENERGY MATRIX
      ELSE IF(CKEY.EQ.'VNBO') THEN
        JPRINT(73) = IFULL
        JPR = 73
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(73),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(73).EQ.IVAL) JPRINT(73) = IFULL
          IF(JPRINT(73).EQ.ILEW) JPRINT(73) = IFULL
        END IF
C  KEYWORD: VNLMO -- PRINT NLMO 1-ELECTRON POTENTIAL ENERGY MATRIX
      ELSE IF(CKEY.EQ.'VNLMO') THEN
        JPRINT(74) = IFULL
        JPR = 74
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(74),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(74).EQ.IVAL) JPRINT(74) = IFULL
          IF(JPRINT(74).EQ.ILEW) JPRINT(74) = IFULL
        END IF
C  KEYWORD: VMO -- PRINT MO 1-ELECTRON POTENTIAL ENERGY MATRIX
      ELSE IF(CKEY.EQ.'VMO') THEN
        JPRINT(75) = IFULL
        JPR = 75
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(75),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(75).EQ.IVAL) JPRINT(75) = IFULL
          IF(JPRINT(75).EQ.ILEW) JPRINT(75) = IFULL
        END IF
C  KEYWORD: FPNHO -- PRINT PNHO FOCK MATRIX:
      ELSE IF(CKEY.EQ.'FPNHO') THEN
        IF(AMPAC) GOTO 2000
        JPRINT(78) = IFULL
        JPR = 78
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(78),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(78).EQ.IVAL) JPRINT(78) = IFULL
          IF(JPRINT(78).EQ.ILEW) JPRINT(78) = IFULL
        END IF
C  KEYWORD: FPNBO -- PRINT PNBO FOCK MATRIX
      ELSE IF(CKEY.EQ.'FPNBO') THEN
        IF(AMPAC) GOTO 2000
        JPRINT(79) = IFULL
        JPR = 79
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(79),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(79).EQ.IVAL) JPRINT(79) = IFULL
        END IF
C  KEYWORD: MSPNBO -- MAXIMUM SPIN-PAIRED NBOS
      ELSE IF(CKEY.EQ.'MSPNBO') THEN
        IWMSP=1
C  KEYWORD: DIST -- PRINT TABLE OF ATOM DISTANCES:
      ELSE IF(CKEY.EQ.'DIST') THEN
        JPRINT(81) = 1
C  KEYWORD: CMO -- PRINT NBO ANALYSIS OF CANONICAL MOLECULAR ORBITALS
      ELSE IF(CKEY.EQ.'CMO') THEN
        JPRINT(82) = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(82),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
        END IF
C  KEYWORD: DMPNAO -- PRINT PNAO DENSITY MATRIX
      ELSE IF(CKEY.EQ.'DMPNAO') THEN
        IF(AMPAC) GOTO 2000
        JPRINT(83) = IFULL
        JPR = 83
        LENG = KEYLEN
        CALL FNDFLD
        CALL FNDFIL(LFNBRK(JPR),ERROR)
        IF(ERROR) LFNBRK(JPR) = 0
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(83),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(83).EQ.IVAL) JPRINT(83) = IFULL
          IF(JPRINT(83).EQ.ILEW) JPRINT(83) = IFULL
        END IF
C  KEYWORD: SVEC -- PRINT THE EIGENVECTORS OF THE OVERLAP MATRIX
      ELSE IF(CKEY.EQ.'SVEC') THEN
        IF(AMPAC) GOTO 2000
        JPRINT(85) = IFULL
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        IF(.NOT.END) THEN
          READ = .FALSE.
          CALL KEYPAR(KEYWD,LENG,JPRINT(85),ICHKPT,LFNDEF,READ,ERROR)
          IF(ERROR) NEXTWD = .FALSE.
          IF(JPRINT(85).EQ.IVAL) JPRINT(85) = IFULL
        END IF
C  KEYWORD: SPARTAN -- WRITE SPARTAN ARCHIVE FILE
      ELSE IF(CKEY.EQ.'SPARTAN') THEN
        IF(AMPAC) GOTO 2000
        LENG = KEYLEN
        CALL HFLD(KEYWD,LENG,END)
        CALL NBCVRT(KEYWD,LENG,CKEY1)
        IF(.NOT.END) THEN
          NC=LENNB(CKEY1)
          IF(CKEY1(1:NC).EQ.'NBO') THEN
            JPRINT(84) =  45
          ELSE IF(CKEY1(1:NC).EQ.'NLMO') THEN
            JPRINT(84) = -45
          ELSE
            JPRINT(84) = 45
            NEXTWD = .FALSE.
          END IF
        END IF
C  KEYWORD: NJC -- OUTPUT NATURAL J-COUPLING ANALYSIS
      ELSE IF(CKEY.EQ.'NJC') THEN
        IF(AMPAC) GOTO 2000
        IWNJC = 1
        THRNJC = 0.1D0
        CALL RFLD(TEMP,ERROR)
        IF(.NOT.ERROR) THRNJC = ABS(TEMP)
C  KEYWORD: NCS -- OUTPUT NMR CHEMICAL SHIFT ANALYSIS WITH OPTIONS
C                    FROM <.../...> INPUT LIST
      ELSE IF(CKEY.EQ.'NCS') THEN
        IF(AMPAC) GO TO 2000
        THRNCS = 0.1D0
        JPRINT(86) = 1
        CALL RFLD(TEMP,ERROR)
        IF(.NOT.ERROR) THEN
          THRNCS = ABS(TEMP)
          LENG=KEYLEN
          CALL HFLD(KEYWD,LENG,END)
        END IF
        CALL FNDFIL(LFNTRY,ERROR)
        IF(LFNTRY.GT.0) JPRINT(86) = LFNTRY
        IF(ERROR) NEXTWD=.FALSE.
C  KEYWORD: FIXDM -- FIX DENSITY MATRIX TO REMOVE NEGATIVE OR
C                    PAULI-VIOLATING OCCUPANCIES
      ELSE IF(CKEY.EQ.'FIXDM') THEN
        IWFIXDM = 1
C  KEYWORD: 3CHB -- 3-CENTER, 4-ELECTRON HYPERBOND SEARCH
      ELSE IF(CKEY.EQ.'3CHB') THEN
        IW3CHB = 1
      ELSE
        IFOUND = 0
        RETURN
      ENDIF
  100 IFOUND = 1
      RETURN
C  INACTIVE KEYWORD FOR AM1/MOPAC VERSION
 2000 CONTINUE
      IF(INBERR.EQ.0) THEN
        INBERR = 1
        WRITE(LFNPR,5000)
 5000   FORMAT(/1X,35('*'),' NBO 5.G ',35('*')/)
      END IF
      WRITE(LFNPR,5020) (CKEY(I:I),I=1,NC)
 5020 FORMAT(1X,'Inactive $NBO keyword for AM1/Mopac version: ',6A1)
      IFOUND = 1
      RETURN
C  CHECKPOINTING NOT SUPPORTED FOR AM1/MOPAC VERSION
 2010 CONTINUE
      IF(INBERR.EQ.0) THEN
        INBERR=1
        WRITE(LFNPR,5000)
      END IF
      WRITE(LFNPR,5030) (CKEY(I:I),I=1,NC)
 5030 FORMAT(1X,'Checkpointing not supported in AM1/Mopac ',
     +           'version: ',6A1)
      IFOUND = 1
      RETURN
      END
C***********************************************************************
      SUBROUTINE NBCVRT(KEYWD,LENG,CKEYWD)
C***********************************************************************
C 27-Jul-06  EDG  Rewritten to avoid use of scratch file
C 27-Nov-00  FAW  New subroutine for JOBOPT character conversion
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      CHARACTER CKEYWD*(*)
      DIMENSION KEYWD(1)
C
C Convert Hollerith KEYWD to Character CKEYWD:
C
      WRITE(CKEYWD,1000) (KEYWD(I),I=1,LENG)
 1000 FORMAT(80A1)
      RETURN
      END
C***********************************************************************
      SUBROUTINE RDELEM(LFN)
C***********************************************************************
C 23-Feb-01  FAW  New subroutine
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      COMMON/NBELEM/IJELEM(2,100),NELEM
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C  No LFN? Close the /NBELEM/ list and return
      NELEM = 0
      IF(LFN.LE.0) RETURN
      REWIND(LFN)
   10 CONTINUE
C  Read the next (I,J) pair
      READ(LFN,*,ERR=20,END=20) I,J
      NELEM = NELEM + 1
      IF(NELEM.GT.100) THEN
        WRITE(LFNPR,1000)
 1000   FORMAT(/,1X,'Too many (>100) user-requested elements; ',
     +  'remainder ignored.',/)
        NELEM = 100
        GOTO 20
      ENDIF
C  Store the pair in COMMON/NBELEM/
      IJELEM(1,NELEM) = I
      IJELEM(2,NELEM) = J
      GOTO 10
   20 RETURN
      END
C***********************************************************************
      SUBROUTINE RDELM2(LFN)
C***********************************************************************
C 24-Feb-01  FAW  New subroutine to read spin-permutations for AOPNBO
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER LINE*80,C*1
      COMMON/NBELEM/IJELEM(2,100),NELEM
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C  Read the spin-labelled entries (ai,bj) of the bracket-list
C  No LFN? Close the /NBELEM/ list and return
      NELEM = 0
      IF(LFN.LE.0) RETURN
      REWIND(LFN)
   10 CONTINUE
C  Read the next (I,J) pair
      READ(LFN,1100,ERR=90,END=90) LINE
 1100 FORMAT(A80)
C  Read the J index
      NL=LENNB(LINE)
      NL0 = NL
      K = NL + 1
   20 K = K - 1
      C = LINE(K:K)
      IF(C.EQ.'b'.OR.C.EQ.'B') THEN
        JT = NBINTV(LINE(K+1:NL))
        J = -JT
        NL = K
      ELSE IF(C.EQ.'a'.OR.C.EQ.'A') THEN
        JT = NBINTV(LINE(K+1:NL))
        J = JT
        NL = K
      ELSE IF(K.GT.4) THEN
        GOTO 20
      ELSE
        WRITE(LFNPR,1200) (LINE(IL:IL),IL=1,NL0)
 1200   FORMAT(/,'Illegal bracket-list entries: ',80A1)
        RETURN
      ENDIF
C  Skip to next non-blank (or non-comma) character
   30 K = K -1
      C = LINE(K:K)
      IF(C.EQ.' '.OR.C.EQ.',') THEN
        NL = K
        IF(K.GT.2) GOTO 30
        WRITE(LFNPR,1200) (LINE(IL:IL),IL=1,NL0)
        RETURN
      ENDIF
C  Read the I index
   40 K = K - 1
      C = LINE(K:K)
      IF(C.EQ.'b'.OR.C.EQ.'B') THEN
        IT = NBINTV(LINE(K+1:NL))
        I = -IT
      ELSE IF(C.EQ.'a'.OR.C.EQ.'A') THEN
        IT = NBINTV(LINE(K+1:NL))
        I = IT
      ELSE IF(K.GT.0) THEN
        GOTO 40
      ELSE
        WRITE(LFNPR,1200) (LINE(IL:IL),IL=1,NL0)
        RETURN
      ENDIF
      NELEM = NELEM + 1
      IF(NELEM.GT.100) THEN
        WRITE(LFNPR,1000)
 1000   FORMAT(/,1X,'Too many (>100) user-requested elements; ',
     +  'remainder ignored.',/)
        NELEM = 100
        GOTO 90
      ENDIF
C  Store the pair in COMMON/NBELEM/
      IJELEM(1,NELEM) = I
      IJELEM(2,NELEM) = J
      GOTO 10
   90 RETURN
      END
C***********************************************************************
      SUBROUTINE NBODIM(MEMORY)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      DIMENSION NSPDFG(5,2)
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBBAS/LABEL(MAXBAS,6),LVAL(MAXBAS),IMVAL(MAXBAS),
     +       LSTOCC(MAXBAS),LSTEMT(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBAO/LCTR(MAXBAS),LANG(MAXBAS)
C
      SAVE IREAD
      DATA IREAD/4HREAD/
C
C  NBODIM:  SET UP DIMENSIONING INFORMATION, LISTS IN COMMON/NBATOM/,
C           AND COMPARE STORAGE NEEDS WITH AMOUNT OF STORAGE AVAILABLE
C
C  FIND:
C     MXAOLM, THE MAXIMUM NUMBER OF ATOMIC ORBITALS OF THE SAME SYMMETRY
C              ON A SINGLE ATOM
C     MXAO, THE MAXIMUM NUMBER OF ATOMIC ORBITALS PER ATOM
C     MXBO, THE MAXIMUM NUMBER OF ATOMIC ORBITALS PER TWO-CENTER OR
C              THREE-CENTER BOND
C
      DO 300 I = 1,NBAS
        LM = LANG(I)
        LVAL(I) = LM/100
        IM = LM - LVAL(I)*100
        IF(IM.GT.50) IM = IM - 50
        IMVAL(I) = IM
  300 CONTINUE
C
      MXAO   = 0
      MXAO2  = 0
      MXAO3  = 0
      MXAOLM = 0
      LLU = 0
      DO 500 I = 1,NATOMS
        N = 0
        DO 400 IL = 1,5
          DO 400 ITYP = 1,2
  400       NSPDFG(IL,ITYP) = 0
        DO 410 J = 1,NBAS
          IF(LCTR(J).NE.I) GO TO 410
          LM = LANG(J)
          L = LM/100
          IM = LM - L*100
C
C  IF IM.NE.1 (THAT IS, IF THIS IS NOT THE FIRST COMPONENT OF THE
C  ANG. MOM. L FUNCTIONS ON THE ATOM), DON'T COUNT IT IN NSPDFG:
C
          IF(IM.NE.1) GO TO 410
C
C  ITYP=1 FOR CARTESIAN FUNCTION, =2 FOR TRUE SPHERICAL HARMONIC:
C
          ITYP = 1
          IF(IM.GT.50) ITYP = 2
          IL = L + 1
          NSPDFG(IL,ITYP) = NSPDFG(IL,ITYP)+1
  410     IF(LCTR(J).EQ.I) N = N + 1
C
C  NUMBER OF S ORBITALS= NO. S ORBS INPUT + NO. CARTESIAN D AND G ORBS:
C
        NSPDFG(1,1) = NSPDFG(1,1) + NSPDFG(1,2) + NSPDFG(3,1) +
     +                NSPDFG(5,1)
C
C  NUMBER OF P ORBITALS= NO. P ORBS INPUT + NO. CARTESIAN F ORBS:
C
        NSPDFG(2,1) = NSPDFG(2,1) + NSPDFG(2,2) + NSPDFG(4,1)
C
C  NUMBER OF D ORBITALS= NO. D ORBS INPUT + NO. CARTESIAN G ORBS:
C
        NSPDFG(3,1) = NSPDFG(3,1) + NSPDFG(3,2) + NSPDFG(5,1)
C
C  NUMBER OF F ORBITALS:
C
        NSPDFG(4,1) = NSPDFG(4,1) + NSPDFG(4,2)
C
C  NUMBER OF G ORBITALS:
C
        NSPDFG(5,1) = NSPDFG(5,1) + NSPDFG(5,2)
C
        DO 430 IL = 1,5
          IF(NSPDFG(IL,1).LE.MXAOLM) GO TO 430
          MXAOLM = NSPDFG(IL,1)
  430   CONTINUE
C
        NORBS(I) = N
        LL(I) = LLU + 1
        LU(I) = LL(I) + N - 1
        LLU = LU(I)
        IF(N.LE.MXAO) GO TO 460
        MXAO3 = MXAO2
        MXAO2 = MXAO
        MXAO = N
        GO TO 500
  460   IF(N.LE.MXAO2) GO TO 480
        MXAO3 = MXAO2
        MXAO2 = N
        GO TO 500
  480   IF(N.LE.MXAO3) GO TO 500
        MXAO3 = N
  500 CONTINUE
      MXBO = MXAO + MXAO2 + MXAO3
C
C  COMPUTE STORAGE REQUIREMENTS AND COMPARE WITH AVAILABLE CORE SPACE:
C
C  STORAGE FOR DENSITY MATRIX (DM) AND TRANSFORMATIONS (T):
C
      NEED0 = 2*NDIM*NDIM
C
C  COMPUTE STORAGE FOR NATURAL POPULATION ANALYSIS:
C
      NEED1 = 0
      IO = IOINQR(IWTNAO)
      IF(IO.NE.IREAD.AND..NOT.ORTHO) THEN
        NEED  = NDIM + NDIM + NDIM*NDIM + MXAOLM*MXAOLM + NDIM +
     +          MXAOLM*MXAOLM + MXAOLM*MXAOLM + NDIM*NDIM + NDIM*NDIM +
     +          NDIM + 9*MXAOLM
        NEED1 = MAX(NEED1,NEED)
      END IF
C
      NEED  = NATOMS*NATOMS + NATOMS + NATOMS*NATOMS + NATOMS*NATOMS +
     +        NDIM*NDIM + 2*NDIM
      NEED1 = MAX(NEED1,NEED)
C
      NEED  = NATOMS*NATOMS + NDIM*NDIM + NDIM
      NEED1 = MAX(NEED1,NEED)
C
      IF(JPRINT(9).NE.0) THEN
        NEED  = NATOMS*NATOMS + NDIM*NDIM + NDIM*NDIM + NDIM*(NDIM+5)
        NEED1 = MAX(NEED1,NEED)
      END IF
C
      NEED1 = NEED1 + NEED0
C
C  COMPUTE STORAGE FOR NATURAL BOND ORBITAL ANALYSIS:
C
      NEED2 = 0
      IF(JPRINT(1).EQ.0) THEN
        IF(IOINQR(IWTNAB).NE.IREAD) THEN
          NEED  = NATOMS*NATOMS + NDIM + 3*NDIM + MXAO*NDIM + NDIM
     +          + MXBO*MXBO + MXBO*MXBO + MXBO + MXBO + MXAO*MXAO
     +          + MXAO*MXAO + MXAO + MXAO + MXAO + NATOMS*NATOMS
        ELSE
          NEED  = NATOMS*NATOMS + NDIM + 3*NDIM
        END IF
        NEED2 = MAX(NEED2,NEED)
C
        IF(.NOT.ORTHO) THEN
          NEED  = NATOMS*NATOMS + 4*NDIM*NDIM + MXAO + 3*NDIM
          NEED2 = MAX(NEED2,NEED)
        END IF
C
        NEED  = NATOMS*NATOMS + NDIM + MXAO + NDIM*NDIM + NDIM*NDIM
     +        + NDIM + NDIM
        NEED2 = MAX(NEED2,NEED)
C
        NEED  = NATOMS*NATOMS + NDIM + NDIM + NDIM + NDIM*NDIM
        NEED2 = MAX(NEED2,NEED)
C
        IF(JPRINT(36).NE.0) THEN
          NEED  = NATOMS*NATOMS + NDIM + 3*NATOMS + NDIM*NDIM
     +          + NDIM*NDIM + NDIM
          NEED2 = MAX(NEED2,NEED)
        END IF
C
        NEED  = NATOMS*NATOMS + NDIM + NDIM*NDIM + NDIM*NDIM
     +        + NDIM*(NDIM+5)
        NEED2 = MAX(NEED2,NEED)
C
        IF(JPRINT(6).NE.0) THEN
          NEED  = NATOMS*NATOMS + NDIM + NDIM*NDIM + NDIM + NATOMS
     +          + NDIM
          NEED2 = MAX(NEED2,NEED)
        END IF
C
C  COMPUTE STORAGE FOR NATURAL LOCALIZED MOLECULAR ORBITAL ANALYSIS:
C
        NEED3 = 0
        IF(JPRINT(8).NE.0) THEN
          NEED  = NATOMS*NATOMS + NDIM + NDIM + NDIM*NDIM + NDIM*NDIM
          NEED3 = MAX(NEED3,NEED)
C
          NEED  = NDIM + NDIM + NDIM + NATOMS*NATOMS + 2*NATOMS*NATOMS
     +          + NDIM*NATOMS + NDIM*NATOMS*(NATOMS-1)/2 + NDIM*NDIM
          NEED3 = MAX(NEED3,NEED)
C
          NEED  = NATOMS*NATOMS + NDIM*NDIM + NDIM*NDIM + NDIM*(NDIM+5)
          NEED3 = MAX(NEED3,NEED)
C
          IF(JPRINT(46).NE.0) THEN
            NEED  = NDIM*NDIM + NDIM*NDIM + NDIM*NDIM + NDIM*NDIM
     +            + NDIM*NDIM + NDIM*NDIM + NDIM + NATOMS*NATOMS
            NEED3 = MAX(NEED3,NEED)
          END IF
          NEED3 = NEED3 + NDIM*NDIM
        END IF
      END IF
C
C  PRINT SCRATCH STORAGE REQUIREMENTS:
C
      IF(IPRINT.GE.0) THEN
        IF(JPRINT(1).EQ.0) THEN
          IF(JPRINT(8).NE.0) THEN
            WRITE(LFNPR,3300) NEED1,NEED2,NEED3,MEMORY
          ELSE
            NEED3 = 0
            WRITE(LFNPR,3200) NEED1,NEED2,MEMORY
          END IF
        ELSE
          NEED2 = 0
          NEED3 = 0
          WRITE(LFNPR,3100) NEED1,MEMORY
        END IF
      END IF
      IF(NEED1.GT.MEMORY.OR.NEED2.GT.MEMORY.OR.NEED3.GT.MEMORY) GOTO 990
      RETURN
C
  990 CALL NBHALT('NBODIM: Not enough core storage available.')
C
 3100 FORMAT(/1X,'Storage needed:',I12,' in NPA (',I12,' available)')
 3200 FORMAT(/1X,'Storage needed:',I12,' in NPA,',I12,' in NBO (',I12,
     + ' available)')
 3300 FORMAT(/1X,'Storage needed:',I12,' in NPA,',I12,' in NBO,',
     +   /,16X,I12,' in NLMO (',I12,' available)')
      END
C***********************************************************************
C NBO 5.G -- Natural Bond Orbital Analysis Programs
C (c) Copyright 1996-2008 Board of Regents of the University of Wisconsin System
C     on behalf of the Theoretical Chemistry Institute.  All Rights Reserved.
C***********************************************************************
C
C  NAO/NBO/NLMO FORMATION ROUTINES: (CALLED BY SR NBO)
C
C      SUBROUTINE NAODRV(DM,T,A)
C      SUBROUTINE NAOSIM(DM,T,A)
C      SUBROUTINE DMNAO(DM,T,A)
C      SUBROUTINE DMSIM(DM,T,A)
C      SUBROUTINE NBODRV(DM,T,A,MEMORY)
C
C***********************************************************************
      SUBROUTINE NAODRV(DM,T,A)
C***********************************************************************
C 24-Feb-01  FAW  Modified for LFNBRK user-requested bracket list
C  5-May-98  EDG  Print eigenvectors of the AO overlap matrix (SVEC)
C  2-Jul-95  EDG  Print atom distance table
C  2-Feb-93  JKB  Matrix output ordered T, S, BO, (DM, F,) K, V, DI
C                     ( ) closed shell only
C 31-Jan-93  JKB  Added support for KAO, KMO, KNAO, VAO, VMO, VNAO
C 14-Jan-93  EDG  Added support for FMO, DMMO, and DIMO
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL UNPACK
C
C  DRIVER SUBROUTINE TO CALCULATE NATURAL ATOMIC ORBITALS (NAOS)
C  GIVEN 1-PARTICLE DENSITY MATRIX IN AN ARBITRARY ATOM-CENTERED
C  ATOMIC ORBITAL BASIS SET.
C
C        T = OVERLAP MATRIX FOR THE PRIMITIVE AO BASIS
C             (ON RETURN, THIS IS THE AO TO NAO TRANSFORMATION MATRIX)
C       DM = DENSITY MATRIX IN THE PRIMITIVE AO BASIS
C               (OR BOND-ORDER MATRIX, IF IWDM = 1)
C
C   THE SPIN NATURE OF DM IS INDICATED BY:
C    ISPIN =  0: SPINLESS  (CLOSED SHELL)
C    ISPIN = +2: ALPHA SPIN
C    ISPIN = -2: SPIN
C   (ISPIN IS THE RECIPROCAL OF THE S(Z) QUANTUM NO.)
C
C-----------------------------------------------------------------------
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),LSTEMT(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBAO/LCTR(MAXBAS),LANG(MAXBAS)
C
      DIMENSION T(NDIM,NDIM),DM(NDIM,NDIM),A(*)
      DIMENSION ATCRD(3,MAXATM),VEC(3)
      CHARACTER*80 TITLE
C
      SAVE IPRNT,IWRIT,IREAD,ICHK
      SAVE ZERO
      DATA IPRNT,IWRIT,IREAD,ICHK/4HPRNT,4HWRIT,4HREAD,3HCHK/
      DATA ZERO/0.0D0/
C
C  FORM LABELS FOR THE RAW AO BASIS SET:
C
      CALL LBLAO
C
C  COPY THE AO CENTERS AND LABELS FROM /NBAO/ TO /NBBAS/:
C
      DO 5 I = 1,NBAS
        LBL(I) = LCTR(I)
        LORBC(I) = LANG(I)
    5 CONTINUE
C
C  WRITE OUT THE AO BASIS SET INFORMATION:
C
      IF(JPRINT(22).GT.0) THEN
        CALL WRBAS(A,A,JPRINT(22))
      END IF
C
C  WRITE OUT THE ARCHIVE FILE:
C
      IF(JPRINT(7).NE.0) THEN
        CALL WRARC(A,A,JPRINT(7))
      END IF
C
C  PRINT THE ATOM DISTANCE TABLE:
C
      IF(JPRINT(81).NE.0) THEN
        CALL FECOOR(ATCRD)
        I = 0
        DO 7 IAT = 1,NATOMS
          DO 6 JAT = 1,IAT
            I = I + 1
            IF(IAT.EQ.JAT) THEN
              A(I) = ZERO
            ELSE
              VEC(1) = ATCRD(1,IAT) - ATCRD(1,JAT)
              VEC(2) = ATCRD(2,IAT) - ATCRD(2,JAT)
              VEC(3) = ATCRD(3,IAT) - ATCRD(3,JAT)
              A(I) = VECLEN(VEC,3,3)
            END IF
    6     CONTINUE
    7   CONTINUE
        CALL UNPACK(A,NATOMS,NATOMS)
        TITLE = 'Atom distance matrix: (Angstroms)'
        CALL AOUT(A,NATOMS,NATOMS,NATOMS,TITLE,0,NATOMS)
      END IF
C
C  OUTPUT THE AO-MO TRANSFORMATION MATRIX:
C
      IO = IOINQR(JPRINT(26))
      IF(.NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL FEAOMO(A,IT)
        IF(IT.NE.0) THEN
          CALL RDELEM(LFNBRK(26))
          TITLE = 'MOs in the AO basis:'
          CALL AOUT(A,NDIM,NBAS,NBAS,TITLE,1,JPRINT(26))
        END IF
      ELSE IF(.NOT.OPEN.AND.IO.EQ.ICHK) THEN
        CALL FEAOMO(A,IT)
        IF(IT.NE.0) CALL SVCHK(A,0)
      END IF
C
C  OUTPUT THE AO OVERLAP MATRIX:
C
      IO = IOINQR(JPRINT(39))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL RDELEM(LFNBRK(39))
        TITLE = 'AO overlap matrix:'
        CALL AOUT(T,NDIM,-NBAS,NBAS,TITLE,1,JPRINT(39))
      END IF
C
C  CALCULATE AND OUTPUT THE EIGENVECTORS/EIGENVALUES OF THE OVERLAP MATRIX:
C
      IO = IOINQR(JPRINT(85))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        I0 = 1
        I1 = I0 + NBAS*NBAS
        I2 = I1 + NBAS
C       IEND = I2 + NBAS*NBAS
        CALL COPY(T,A(I0),NDIM,NBAS,NBAS)
        CALL NBJACOBI(NBAS,A(I0),A(I1),A(I2),NBAS,NDIM,1)
        TITLE = 'Eigenvectors of the AO overlap matrix:'
        CALL AOUT(A(I2),NDIM,NBAS,NBAS,TITLE,1,JPRINT(85))
        TITLE = 'Eigenvalues of the AO overlap matrix:'
        CALL AOUT(A(I1),1,1,NBAS,TITLE,-2,JPRINT(85))
      END IF
C
C  OUTPUT THE AO BOND-ORDER MATRIX:
C
      IO = IOINQR(JPRINT(42))
      IF(IWDM.EQ.1.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        TITLE = 'Spinless AO bond-order matrix:'
        CALL AOUT(DM,NDIM,-NBAS,NBAS,TITLE,1,JPRINT(42))
      END IF
C
C  CONVERT THE BOND-ORDER MATRIX TO THE DENSITY MATRIX:
C
      IF(IWDM.NE.0) CALL SIMTRM(DM,T,A,NDIM,NBAS,IWMULP,IWCUBF)
C
C  OUTPUT THE AO DENSITY MATRIX:
C
      IO = IOINQR(JPRINT(27))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL RDELEM(LFNBRK(27))
        TITLE = 'Spinless AO density matrix:'
        CALL AOUT(DM,NDIM,-NBAS,NBAS,TITLE,1,JPRINT(27))
      END IF
C
C  OUTPUT THE AO FOCK MATRIX:
C
      IO = IOINQR(JPRINT(40))
      IF(.NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL FEFAO(A,IWFOCK)
        IF(IWFOCK.NE.0) THEN
          CALL RDELEM(LFNBRK(40))
          TITLE = 'AO Fock matrix:'
          CALL AOUT(A,NDIM,-NBAS,NBAS,TITLE,1,JPRINT(40))
        ELSE
          TITLE = 'AO Fock matrix.'
          NT = LENNB(TITLE)
          WRITE(LFNPR,2300) (TITLE(K:K),K=1,NT)
        END IF
      END IF
C
C  OUTPUT THE AO KINETIC ENERGY MATRIX:
C
      IO = IOINQR(JPRINT(64))
      IF(.NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL FEKAO(A,IWKIN)
        IF(IWKIN.NE.0) THEN
          CALL RDELEM(LFNBRK(64))
          TITLE = 'AO kinetic energy matrix:'
          CALL AOUT(A,NDIM,-NBAS,NBAS,TITLE,1,JPRINT(64))
        END IF
      END IF
C
C  OUTPUT THE AO 1-e POTENTIAL ENERGY MATRIX:
C
      IO = IOINQR(JPRINT(70))
      IF(.NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL FEVAO(A,IWV1)
        IF(IWV1.NE.0) THEN
          CALL RDELEM(LFNBRK(70))
          TITLE = 'AO 1-e potential energy matrix:'
          CALL AOUT(A,NDIM,-NBAS,NBAS,TITLE,1,JPRINT(70))
        END IF
      END IF
C
C  OUTPUT THE AO DIPOLE MATRICES:
C
      IO = IOINQR(JPRINT(50))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        IX = 1
        CALL FEDXYZ(A,IX)
        IF(IX.NE.0) THEN
          CALL RDELEM(LFNBRK(50))
          TITLE = 'AO x dipole integrals:'
          CALL AOUT(A,NDIM,-NBAS,NBAS,TITLE,1,JPRINT(50))
        END IF
        IX = 2
        CALL FEDXYZ(A,IX)
        IF(IX.NE.0) THEN
          CALL RDELEM(LFNBRK(50))
          TITLE = 'AO y dipole integrals:'
          CALL AOUT(A,NDIM,-NBAS,NBAS,TITLE,1,JPRINT(50))
        END IF
        IX = 3
        CALL FEDXYZ(A,IX)
        IF(IX.NE.0) THEN
          CALL RDELEM(LFNBRK(50))
          TITLE = 'AO z dipole integrals:'
          CALL AOUT(A,NDIM,-NBAS,NBAS,TITLE,1,JPRINT(50))
        END IF
      END IF
C
C  REORGANIZE THE SCRATCH VECTOR
C
      I1 = 1
      I2 = I1 + NDIM * NDIM
      I3 = I2 + NDIM * NDIM
C     IEND = I3 + NDIM
C
C  OUTPUT THE MO DENSITY MATRIX:
C
      CALL FEAOMO(A(I1),IT)
      IO = IOINQR(JPRINT(61))
      IF(IT.NE.0.AND..NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL COPY(DM,A(I2),NDIM,NBAS,NBAS)
        CALL SIMTRS(A(I2),A(I1),A(I3),NDIM,NBAS)
        CALL RDELEM(LFNBRK(61))
        TITLE = 'MO density matrix:'
        CALL AOUT(A(I2),NDIM,-NBAS,NBAS,TITLE,-1,JPRINT(61))
      END IF
C
C  OUTPUT THE MO FOCK MATRIX:
C
      CALL FEAOMO(A(I1),IT)
      IO = IOINQR(JPRINT(60))
      IF(IT.NE.0.AND..NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL FEFAO(A(I2),IWFOCK)
        IF(IWFOCK.NE.0) THEN
          CALL SIMTRS(A(I2),A(I1),A(I3),NDIM,NBAS)
          CALL RDELEM(LFNBRK(60))
          TITLE = 'MO Fock matrix:'
          CALL AOUT(A(I2),NDIM,-NBAS,NBAS,TITLE,-1,JPRINT(60))
        ELSE
          TITLE = 'MO Fock matrix.'
          NT = LENNB(TITLE)
          WRITE(LFNPR,2300) (TITLE(K:K),K=1,NT)
        END IF
      END IF
C
C  OUTPUT THE MO KINETIC ENERGY MATRIX:
C
      CALL FEAOMO(A(I1),IT)
      IO = IOINQR(JPRINT(69))
      IF(IT.NE.0.AND..NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL FEKAO(A(I2),IWKIN)
        IF(IWKIN.NE.0) THEN
          CALL SIMTRS(A(I2),A(I1),A(I3),NDIM,NBAS)
          CALL RDELEM(LFNBRK(69))
          TITLE = 'MO kinetic energy matrix:'
          CALL AOUT(A(I2),NDIM,-NBAS,NBAS,TITLE,-1,JPRINT(69))
        END IF
      END IF
C
C  OUTPUT THE MO 1-e POTENTIAL ENERGY MATRIX:
C
      CALL FEAOMO(A(I1),IT)
      IO = IOINQR(JPRINT(75))
      IF(IT.NE.0.AND..NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL FEVAO(A(I2),IWV1)
        IF(IWV1.NE.0) THEN
          CALL SIMTRS(A(I2),A(I1),A(I3),NDIM,NBAS)
          CALL RDELEM(LFNBRK(75))
          TITLE = 'MO 1-e potential energy matrix:'
          CALL AOUT(A(I2),NDIM,-NBAS,NBAS,TITLE,-1,JPRINT(75))
        END IF
      END IF
C
C  OUTPUT THE MO DIPOLE MATRICES:
C
      IO = IOINQR(JPRINT(62))
      IF(IT.NE.0.AND..NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        IX = 1
        CALL FEDXYZ(A(I2),IX)
        IF(IX.NE.0) THEN
          CALL SIMTRS(A(I2),A(I1),A(I3),NDIM,NBAS)
          CALL RDELEM(LFNBRK(62))
          TITLE = 'MO x dipole integrals:'
          CALL AOUT(A(I2),NDIM,-NBAS,NBAS,TITLE,-1,JPRINT(62))
        END IF
        IX = 2
        CALL FEDXYZ(A(I2),IX)
        IF(IX.NE.0) THEN
          CALL SIMTRS(A(I2),A(I1),A(I3),NDIM,NBAS)
          CALL RDELEM(LFNBRK(62))
          TITLE = 'MO y dipole integrals:'
          CALL AOUT(A(I2),NDIM,-NBAS,NBAS,TITLE,-1,JPRINT(62))
        END IF
        IX = 3
        CALL FEDXYZ(A(I2),IX)
        IF(IX.NE.0) THEN
          CALL SIMTRS(A(I2),A(I1),A(I3),NDIM,NBAS)
          CALL RDELEM(LFNBRK(62))
          TITLE = 'MO z dipole integrals:'
          CALL AOUT(A(I2),NDIM,-NBAS,NBAS,TITLE,-1,JPRINT(62))
        END IF
      END IF
C
C  ALLOCATE SCRATCH COMMON FOR NAO ROUTINES:
C
C  A(I1) = V(NDIM)  (ALSO USED FOR GUIDE(NATOMS,NATOMS))
C  A(I2) = RENORM(NDIM),SCR(NDIM)
C  A(I3) = BLK(NDIM,NDIM),TPAO(NDIM,NDIM)
C  A(I4) = SBLK(MXAOLM,MXAOLM)
C  A(I5) = EVAL(NDIM)
C  A(I6) = C(MXAOLM,MXAOLM)
C  A(I7) = EVECT(MXAOLM,MXAOLM)
C  A(I8) = EVAL2(NDIM),SCR(NDIM,NDIM)
C  A(I9) = SCR(NDIM,NDIM)
C  A(I10) = SCR(NDIM)
C  LEAVE THIS LAST IN THE LIST SINCE THESE ARE INTEGERS:
C  A(I11) = LISTAO(MXAOLM,9)
C
      NBLOCK = MXAOLM*MXAOLM
      I1   = 1
      I2   = I1 + NDIM
      I3   = I2 + NDIM
      I4   = I3 + NDIM*NDIM
      I5   = I4 + NBLOCK
      I6   = I5 + NDIM
      I7   = I6 + NBLOCK
      I8   = I7 + NBLOCK
      I9   = I8 + NDIM*NDIM
      I10  = I9 + NDIM*NDIM
      I11  = I10 + NDIM
C     IEND = I11 + 9*MXAOLM
C
C  READ IN T-NAO, NAO LABELS, THE PNAO OVERLAP MATRIX, AND COMPUTE THE
C  NAO DENSITY MATRIX: (NOTE THAT T CONTAINS THE PNAO OVERLAP MATRIX
C  AFTER RDTNAO IS CALLED)
C
      IF(IOINQR(IWTNAO).EQ.IREAD) THEN
        CALL RDTNAO(DM,T,A(I1),IWTNAO)
      ELSE
C
C  TRANSFORM ALL SETS OF CARTESIAN D,F,G ORBITALS (FORMING THE AO-PAO
C  TRANSFORMATION MATRIX IN A(I3)) AND RELABEL ALL ORBITALS:
C
        CALL DFGORB(DM,T,A(I2),A(I3))
        CALL SVTPAO(A(I3))
C
C  STORE PURE AO (PAO) DENSITY MATRIX:
C
        CALL SVPPAO(DM)
C
C  CONSOLIDATE DENSITY MATRIX AND OVERLAP MATRIX IN DM:
C
        CALL CONSOL(DM,T,NDIM,NBAS)
C
C  FIND NATURAL ATOMIC ORBITAL BASIS SET TRANSFORMATION T FROM DM:
C  (UPON RETURN, DM CONTAINS THE FULL NAO DENSITY MATRIX)
C
        CALL NAO(T,DM,A(I1),A(I3),A(I4),A(I5),A(I6),A(I7),A(I8),A(I9),
     +           A(I10),A(I11),NBLOCK)
C
C  T CONTAINS THE PAO-NAO TRANSFORM.  FORM THE AO-NAO TRANSFORM IN T:
C
        CALL COPY(T,A(I3),NDIM,NBAS,NNAO)
        CALL FETPAO(T)
        CALL MATML1(T,A(I3),A(I2),NDIM,NDIM,NDIM,NBAS,NBAS,NNAO)
        CALL SVTNAO(T)
C
C  FORM AO-PNAO TRANSFORMATION:
C
        CALL FETPAO(T)
        CALL FEPNAO(A(I3))
        CALL MATML1(T,A(I3),A(I2),NDIM,NDIM,NDIM,NBAS,NBAS,NNAO)
        CALL SVPNAO(T)
C
C  COMPUTE NON-ORTHOGONAL NAO OVERLAP MATRIX, SPNAO:
C
        CALL FESRAW(A(I3))
        CALL SIMTR1(A(I3),T,A(I2),NDIM,NBAS,NBAS,NNAO)
        CALL SVSNAO(A(I3))
C
C  WRITE T-NAO, NAO LABELS, AND THE PNAO OVERLAP MATRIX:
C
        IF(IOINQR(IWTNAO).EQ.IWRIT) CALL WRTNAO(T,IWTNAO)
      END IF
C
C  FIX THE AO DENSITY, IF NECESSARY:
C
      IF(IWFIXDM.EQ.1.OR.NNAO.NE.NBAS) THEN
        CALL FETNAO(T)
        ALPHA = OPEN
        CALL FEDRAW(DM,A(I3))
        IF(IWDM.EQ.1) THEN
          CALL FESRAW(A(I3))
          CALL SIMTRS(DM,A(I3),A(I5),NDIM,NBAS)
        END IF
        CALL FIXDM(DM,T,A(I3),A(I8),A(I1),A(I2),A(I5),A(I9),NDIM,NBAS,
     +             NNAO,LFNPR,IFIX)
        IF(IFIX.EQ.1) CALL SVDRAW(DM)
        IF(OPEN) THEN
          ALPHA = .FALSE.
          BETA  = .TRUE.
          CALL FEDRAW(DM,A(I3))
          IF(IWDM.EQ.1) THEN
            CALL FESRAW(A(I3))
            CALL SIMTRS(DM,A(I3),A(I5),NDIM,NBAS)
          END IF
          CALL FIXDM(DM,T,A(I3),A(I8),A(I1),A(I2),A(I5),A(I9),NDIM,NBAS,
     +               NNAO,LFNPR,IFIX)
          IF(IFIX.EQ.1) CALL SVDRAW(DM)
          BETA = .FALSE.
        END IF
        CALL FEDRAW(DM,A(I3))
        IF(IWDM.EQ.1) THEN
          CALL FESRAW(A(I3))
          CALL SIMTRS(DM,A(I3),A(I5),NDIM,NBAS)
        END IF
        CALL SIMTR1(DM,T,A(I3),NDIM,NBAS,NBAS,NNAO)
      END IF
C
C  DM IS NOW THE DENSITY MATRIX IN THE NAO BASIS:
C
      I1   = 1
      I2   = I1 + NATOMS*NATOMS
      I3   = I2 + NATOMS
      I4   = I3 + NATOMS*NATOMS
      I5   = I4 + NATOMS*NATOMS
      I6   = I5 + NDIM*NDIM
      I7   = I6 + NDIM
C     IEND = I7 + NDIM
      CALL NAOANL(DM,T,A(I1),A(I2),A(I3),A(I4),A(I5),A(I6),A(I7))
C
C  DO NOT DESTROY THE MATRIX AT A(I1).  THIS HOLDS THE WIBERG BOND
C  INDEX WHICH NEEDS TO BE PASSED TO THE NBO ROUTINES.
C
C  SAVE THE NAO DENSITY MATRIX:
C
      CALL SVDNAO(DM)
C
C  FORM THE NAO LABELS:
C
      CALL LBLNAO
C
C  REORGANIZE THE SCRATCH VECTOR:
C
      I1   = 1
      I2   = I1 + NATOMS*NATOMS
      I3   = I2 + NDIM*NDIM
C     IEND = I3 + NDIM*NDIM
C
C  OUTPUT THE AO-PNAO TRANSFORMATION MATRIX:
C
      IO = IOINQR(JPRINT(44))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL FEPNAO(T)
        CALL RDELEM(LFNBRK(44))
        TITLE = 'PNAOs in the AO basis:'
        CALL AOUT(T,NDIM,NBAS,NNAO,TITLE,1,JPRINT(44))
      ELSE IF(IO.EQ.ICHK) THEN
        CALL SVCHK(T,0)
        IF(OPEN) CALL SVCHK(T,-2)
      END IF
C
C  OUTPUT THE PNAO OVERLAP MATRIX:
C
      IO = IOINQR(JPRINT(19))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL FESNAO(A(I2))
        CALL RDELEM(LFNBRK(19))
        TITLE = 'PNAO overlap matrix:'
        CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,2,JPRINT(19))
      END IF
C
C  OUTPUT THE PNAO DENSITY MATRIX:
C
      IO = IOINQR(JPRINT(83))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL FEDRAW(A(I2),A(I3))
        IF(IWDM.EQ.1) THEN
          CALL FESRAW(T)
          CALL SIMTRS(A(I2),T,A(I3),NDIM,NBAS)
        END IF
        CALL FEPNAO(T)
        CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
        CALL RDELEM(LFNBRK(83))
        TITLE = 'PNAO density matrix:'
        CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,2,JPRINT(83))
      END IF
C
C  FETCH THE AO-NAO TRANSFORMATION FROM THE NBO DAF:
C
      CALL FETNAO(T)
C
C  PRINT THE AO-NAO TRANSFORMATION MATRIX:
C
      IF(IOINQR(IWTNAO).EQ.IPRNT) THEN
        TITLE = 'NAOs in the AO basis:'
        CALL AOUT(T,NDIM,NBAS,NNAO,TITLE,1,IWTNAO)
      ELSE IF(IOINQR(IWTNAO).EQ.ICHK) THEN
        CALL SVCHK(T,0)
        IF(OPEN) CALL SVCHK(T,-2)
      END IF
C
C  IF THIS IS A CLOSED SHELL WAVEFUNCTION, NAOMO DMNAO FNAO MATRIX OUTPUT:
C
      IF(.NOT.OPEN) THEN
C
C  OUTPUT THE NAO-MO TRANSFORMATION MATRIX:
C
      IO = IOINQR(JPRINT(9))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        I1   = 1
        I2   = I1 + NATOMS*NATOMS
        I3   = I2 + NDIM*NDIM
        I4   = I3 + NDIM*NDIM
C       IEND = I4 + NDIM*(NDIM+5)
        CALL FRMTMO(T,A(I2),A(I3),A(I4),2,JPRINT(9))
      END IF
C
C  REORGANIZE THE SCRATCH VECTOR:
C
      I1   = 1
      I2   = I1 + NATOMS*NATOMS
      I3   = I2 + NDIM*NDIM
C     IEND = I3 + NDIM
C
C  OUTPUT THE NAO DENSITY MATRIX:
C
      IO = IOINQR(JPRINT(35))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL RDELEM(LFNBRK(35))
        TITLE = 'NAO density matrix:'
        CALL AOUT(DM,NDIM,-NNAO,NNAO,TITLE,2,JPRINT(35))
      END IF
C
C  OUTPUT THE NAO FOCK MATRIX:
C
      IO = IOINQR(JPRINT(31))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL FEFAO(A(I2),IWFOCK)
        IF(IWFOCK.NE.0) THEN
          CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
          CALL RDELEM(LFNBRK(31))
          TITLE = 'NAO Fock matrix:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,2,JPRINT(31))
        ELSE
          TITLE = 'NAO Fock matrix.'
          NT = LENNB(TITLE)
          WRITE(LFNPR,2300) (TITLE(K:K),K=1,NT)
        END IF
      END IF
C  End closed shell-only section
      ENDIF
C
C  OUTPUT THE NAO KINETIC ENERGY MATRIX:
C
      IO = IOINQR(JPRINT(65))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL FEKAO(A(I2),IWKIN)
        IF(IWKIN.NE.0) THEN
          CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
          CALL RDELEM(LFNBRK(65))
          TITLE = 'NAO kinetic energy matrix:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,2,JPRINT(65))
        END IF
      END IF
C
C  OUTPUT THE NAO 1-e POTENTIAL ENERGY MATRIX:
C
      IO = IOINQR(JPRINT(71))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL FEVAO(A(I2),IWV1)
        IF(IWV1.NE.0) THEN
          CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
          CALL RDELEM(LFNBRK(71))
          TITLE = 'NAO 1-e potential energy matrix:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,2,JPRINT(71))
        END IF
      END IF
C
C  OUTPUT THE NAO DIPOLE MATRICES:
C
      IO = IOINQR(JPRINT(51))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        IX = 1
        CALL FEDXYZ(A(I2),IX)
        IF(IX.NE.0) THEN
          CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
          CALL RDELEM(LFNBRK(51))
          TITLE = 'NAO x dipole integrals:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,2,JPRINT(51))
        END IF
        IX = 2
        CALL FEDXYZ(A(I2),IX)
        IF(IX.NE.0) THEN
          CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
          CALL RDELEM(LFNBRK(51))
          TITLE = 'NAO y dipole integrals:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,2,JPRINT(51))
        END IF
        IX = 3
        CALL FEDXYZ(A(I2),IX)
        IF(IX.NE.0) THEN
          CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
          CALL RDELEM(LFNBRK(51))
          TITLE = 'NAO z dipole integrals:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,2,JPRINT(51))
        END IF
      END IF
      RETURN
 2300 FORMAT(/1X,'Fock matrix unavailable for this wavefunction;',
     * ' can''t print ',80A1)
      END
C***********************************************************************
      SUBROUTINE NAOSIM(DM,T,A)
C***********************************************************************
C  2-Jul-95  EDG  Print atom distance table
C  1-Feb-93  JKB  Added support for KAO, KMO, VAO, VMO
C 19-Jan-93  EDG  Checkpoint the AO-MO transformation matrix
C 14-Jan-93  EDG  Added support for FMO, DMMO, and DIMO
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL UNPACK
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),LSTEMT(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBAO/LCTR(MAXBAS),LANG(MAXBAS)
C
      DIMENSION DM(NDIM,NDIM),T(NDIM,NDIM),A(*)
      DIMENSION ATCRD(3,MAXATM),VEC(3)
      CHARACTER*80 TITLE
C
      SAVE ZERO,ONE,IPRNT,IWRIT,ICHK
      DATA ZERO,ONE/0.0D0,1.0D0/
      DATA IPRNT,IWRIT,ICHK/4HPRNT,4HWRIT,3HCHK/
C
C  THIS ROUTINE SIMULATES THE ACTION OF THE NAO SUBPROGRAM:
C
C  FORM LABELS FOR THE RAW AO BASIS SET:
C
      CALL LBLAO
C
C  COPY THE AO CENTERS AND LABELS FROM /NBAO/ TO /NBBAS/:
C
      DO 5 I = 1,NBAS
        LBL(I) = LCTR(I)
        LORBC(I) = LANG(I)
    5 CONTINUE
C
C  WRITE OUT THE AO BASIS SET INFORMATION:
C
      IF(JPRINT(22).GT.0) THEN
        CALL WRBAS(A,A,JPRINT(22))
      END IF
C
C  WRITE OUT THE ARCHIVE FILE:
C
      IF(JPRINT(7).NE.0) THEN
        CALL WRARC(A,A,JPRINT(7))
      END IF
C
C  PRINT THE ATOM DISTANCE TABLE:
C
      IF(JPRINT(81).NE.0) THEN
        CALL FECOOR(ATCRD)
        I = 0
        DO 7 IAT = 1,NATOMS
          DO 6 JAT = 1,IAT
            I = I + 1
            IF(IAT.EQ.JAT) THEN
              A(I) = ZERO
            ELSE
              VEC(1) = ATCRD(1,IAT) - ATCRD(1,JAT)
              VEC(2) = ATCRD(2,IAT) - ATCRD(2,JAT)
              VEC(3) = ATCRD(3,IAT) - ATCRD(3,JAT)
              A(I) = VECLEN(VEC,3,3)
            END IF
    6     CONTINUE
    7   CONTINUE
        CALL UNPACK(A,NATOMS,NATOMS)
        TITLE = 'Atom distance matrix: (Angstroms)'
        CALL AOUT(A,NATOMS,NATOMS,NATOMS,TITLE,0,NATOMS)
      END IF
C
C  OUTPUT THE AO-MO TRANSFORMATION MATRIX:
C
      IO = IOINQR(JPRINT(26))
      IF(.NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL FEAOMO(A,IT)
        IF(IT.NE.0) THEN
          TITLE = 'MOs in the AO basis:'
          CALL AOUT(A,NDIM,NBAS,NBAS,TITLE,1,JPRINT(26))
        END IF
      ELSE IF(.NOT.OPEN.AND.IO.EQ.ICHK) THEN
        CALL FEAOMO(A,IT)
        IF(IT.NE.0) CALL SVCHK(A,0)
      END IF
C
C  OUTPUT THE AO DENSITY MATRIX:
C
      IO = IOINQR(JPRINT(27))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        TITLE = 'Spinless AO density matrix:'
        CALL AOUT(DM,NDIM,-NBAS,NBAS,TITLE,1,JPRINT(27))
      END IF
C
C  OUTPUT THE AO FOCK MATRIX:
C
      IO = IOINQR(JPRINT(40))
      IF(.NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL FEFAO(A,IWFOCK)
        IF(IWFOCK.NE.0) THEN
          TITLE = 'AO Fock matrix:'
          CALL AOUT(A,NDIM,-NBAS,NBAS,TITLE,1,JPRINT(40))
        ELSE
          TITLE = 'AO Fock matrix.'
          NT = LENNB(TITLE)
          WRITE(LFNPR,2300) (TITLE(K:K),K=1,NT)
        END IF
      END IF
C
C  OUTPUT THE AO KINETIC ENERGY MATRIX:
C
      IO = IOINQR(JPRINT(64))
      IF(.NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL FEKAO(A,IWKIN)
        IF(IWKIN.NE.0) THEN
          TITLE = 'AO kinetic energy matrix:'
          CALL AOUT(A,NDIM,-NBAS,NBAS,TITLE,1,JPRINT(64))
        END IF
      END IF
C
C  OUTPUT THE AO 1-e POTENTIAL ENERGY MATRIX:
C
      IO = IOINQR(JPRINT(70))
      IF(.NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL FEVAO(A,IWV1)
        IF(IWV1.NE.0) THEN
          TITLE = 'AO 1-e potential energy matrix:'
          CALL AOUT(A,NDIM,-NBAS,NBAS,TITLE,1,JPRINT(70))
        END IF
      END IF
C
C  OUTPUT THE AO DIPOLE MATRICES:
C
      IO = IOINQR(JPRINT(50))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        IX = 1
        CALL FEDXYZ(A,IX)
        IF(IX.NE.0) THEN
          TITLE = 'AO x dipole integrals:'
          CALL AOUT(A,NDIM,-NBAS,NBAS,TITLE,1,JPRINT(50))
        END IF
        IX = 2
        CALL FEDXYZ(A,IX)
        IF(IX.NE.0) THEN
          TITLE = 'AO y dipole integrals:'
          CALL AOUT(A,NDIM,-NBAS,NBAS,TITLE,1,JPRINT(50))
        END IF
        IX = 3
        CALL FEDXYZ(A,IX)
        IF(IX.NE.0) THEN
          TITLE = 'AO z dipole integrals:'
          CALL AOUT(A,NDIM,-NBAS,NBAS,TITLE,1,JPRINT(50))
        END IF
      END IF
C
C  REORGANIZE THE SCRATCH VECTOR:
C
      I1 = 1
      I2 = I1 + NDIM * NDIM
      I3 = I2 + NDIM * NDIM
C     IEND = I3 + NDIM
C
C  OUTPUT THE MO DENSITY MATRIX:
C
      CALL FEAOMO(A(I1),IT)
      IO = IOINQR(JPRINT(61))
      IF(IT.NE.0.AND..NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL COPY(DM,A(I2),NDIM,NBAS,NBAS)
        CALL SIMTRS(A(I2),A(I1),A(I3),NDIM,NBAS)
        TITLE = 'MO density matrix:'
        CALL AOUT(A(I2),NDIM,-NBAS,NBAS,TITLE,-1,JPRINT(61))
      END IF
C
C  OUTPUT THE MO FOCK MATRIX:
C
      CALL FEAOMO(A(I1),IT)
      IO = IOINQR(JPRINT(60))
      IF(IT.NE.0.AND..NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL FEFAO(A(I2),IWFOCK)
        IF(IWFOCK.NE.0) THEN
          CALL SIMTRS(A(I2),A(I1),A(I3),NDIM,NBAS)
          TITLE = 'MO Fock matrix:'
          CALL AOUT(A(I2),NDIM,-NBAS,NBAS,TITLE,-1,JPRINT(60))
        ELSE
          TITLE = 'MO Fock matrix.'
          NT = LENNB(TITLE)
          WRITE(LFNPR,2300) (TITLE(K:K),K=1,NT)
        END IF
      END IF
C
C  OUTPUT THE MO KINETIC ENERGY MATRIX:
C
      CALL FEAOMO(A(I1),IT)
      IO = IOINQR(JPRINT(69))
      IF(IT.NE.0.AND..NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL FEKAO(A(I2),IWKIN)
        IF(IWKIN.NE.0) THEN
          CALL SIMTRS(A(I2),A(I1),A(I3),NDIM,NBAS)
          TITLE = 'MO kinetic energy matrix:'
          CALL AOUT(A(I2),NDIM,-NBAS,NBAS,TITLE,-1,JPRINT(69))
        END IF
      END IF
C
C  OUTPUT THE MO 1-e POTENTIAL ENERGY MATRIX:
C
      CALL FEAOMO(A(I1),IT)
      IO = IOINQR(JPRINT(75))
      IF(IT.NE.0.AND..NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL FEVAO(A(I2),IWV1)
        IF(IWV1.NE.0) THEN
          CALL SIMTRS(A(I2),A(I1),A(I3),NDIM,NBAS)
          TITLE = 'MO 1-e potential energy matrix:'
          CALL AOUT(A(I2),NDIM,-NBAS,NBAS,TITLE,-1,JPRINT(75))
        END IF
      END IF
C
C  OUTPUT THE MO DIPOLE MATRICES:
C
      IO = IOINQR(JPRINT(62))
      IF(IT.NE.0.AND..NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        IX = 1
        CALL FEDXYZ(A(I2),IX)
        IF(IX.NE.0) THEN
          CALL SIMTRS(A(I2),A(I1),A(I3),NDIM,NBAS)
          TITLE = 'MO x dipole integrals:'
          CALL AOUT(A(I2),NDIM,-NBAS,NBAS,TITLE,-1,JPRINT(62))
        END IF
        IX = 2
        CALL FEDXYZ(A(I2),IX)
        IF(IX.NE.0) THEN
          CALL SIMTRS(A(I2),A(I1),A(I3),NDIM,NBAS)
          TITLE = 'MO y dipole integrals:'
          CALL AOUT(A(I2),NDIM,-NBAS,NBAS,TITLE,-1,JPRINT(62))
        END IF
        IX = 3
        CALL FEDXYZ(A(I2),IX)
        IF(IX.NE.0) THEN
          CALL SIMTRS(A(I2),A(I1),A(I3),NDIM,NBAS)
          TITLE = 'MO z dipole integrals:'
          CALL AOUT(A(I2),NDIM,-NBAS,NBAS,TITLE,-1,JPRINT(62))
        END IF
      END IF
C
C  INITIALIZE THE AO TO NAO TRANSFORMATION MATRIX (UNIT MATRIX):
C
      DO 20 J = 1,NBAS
        DO 10 I = 1,NBAS
          T(I,J) = ZERO
   10   CONTINUE
        T(J,J) = ONE
   20 CONTINUE
C
C  SAVE TNAO FOR LATER USE:
C
      CALL SVTNAO(T)
C
C  FILL ATOMIC ORBITAL INFORMATION LISTS:
C
      DO 30 I = 1,NBAS
        NAOCTR(I) = LCTR(I)
        NAOL(I)   = LANG(I)
        IF(MOD(NAOL(I),100).LT.50) NAOL(I) = NAOL(I) + 50
        LSTOCC(I) = 1
   30 CONTINUE
C
C  PERFORM THE NATURAL POPULATION ANALYSIS: (NOTE THAT ROUTINE NAOANL
C  EXPECTS TO FIND THE OVERLAP MATRIX IN T, WHICH IS THE UNIT MATRIX
C  FOR ORTHOGONAL BASIS SETS. UPON RETURN FROM NAOANL, T IS THE AO TO
C  NAO TRANSFORMATION, WHICH IS STILL A UNIT MATRIX):
C
      I1   = 1
      I2   = I1 + NATOMS*NATOMS
      I3   = I2 + NATOMS
      I4   = I3 + NATOMS*NATOMS
      I5   = I4 + NATOMS*NATOMS
      I6   = I5 + NDIM*NDIM
      I7   = I6 + NDIM
C     IEND = I7 + NDIM
      CALL NAOANL(DM,T,A(I1),A(I2),A(I3),A(I4),A(I5),A(I6),A(I7))
C
C  DO NOT DESTROY THE MATRIX AT A(I1).  THIS HOLDS THE WIBERG BOND
C  INDEX WHICH NEEDS TO BE PASSED TO THE NBO ROUTINES.
C
C  SAVE THE NAO DENSITY MATRIX:
C
      CALL SVDNAO(DM)
C
C  FORM THE NAO LABELS:
C
      CALL LBLNAO
C
      RETURN
 2300 FORMAT(/1X,'Fock matrix unavailable for this wavefunction;',
     * ' can''t print ',80A1)
      END
C***********************************************************************
      SUBROUTINE DMNAO(DM,T,A)
C***********************************************************************
C  2-Feb-93  JKB  Matrix output ordered DM, F
C  1-Feb-93  JKB  Added support for KMO, VMO
C 19-Jan-93  EDG  Checkpoint the AO-MO transformation matrix
C 14-Jan-93  EDG  Added support for FMO, DMMO, and DIMO
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),LSTEMT(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBAO/LCTR(MAXBAS),LANG(MAXBAS)
      COMMON/NBNAO/NAOC(MAXBAS),NAOA(MAXBAS),LTYP(MAXBAS),IPRIN(MAXBAS)
C
      DIMENSION DM(NDIM,NDIM),T(NDIM,NDIM),A(*)
      CHARACTER*80 TITLE
C
      SAVE IPRNT,IWRIT,ICHK
      DATA IPRNT,IWRIT,ICHK/4HPRNT,4HWRIT,3HCHK/
C
C  PLACE ALPHA OR BETA OCCUPATION MATRIX IN DM AND TRANSFORM FROM THE AO
C  TO NAO BASIS:
C
      IF(ALPHA) THEN
        IF(JPRINT(4).NE.0) WRITE(LFNPR,2100)
      ELSE
        DO 70 I = 1,NNAO
          NAOCTR(I) = NAOC(I)
          NAOL(I) = NAOA(I)
          LBL(I) = LCTR(I)
          LORBC(I) = LANG(I)
   70   CONTINUE
        CALL FETNAO(T)
        IF(JPRINT(4).NE.0) WRITE(LFNPR,2200)
      END IF
C
C  OUTPUT THE AO-MO TRANSFORMATION MATRIX:
C
      IO = IOINQR(JPRINT(26))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL FEAOMO(A,IT)
        IF(IT.NE.0) THEN
          TITLE = 'MOs in the AO basis:'
          CALL AOUT(A,NDIM,NBAS,NNAO,TITLE,1,JPRINT(26))
        END IF
      ELSE IF(IO.EQ.ICHK) THEN
        CALL FEAOMO(A,IT)
        IF(IT.NE.0) CALL SVCHK(A,ISPIN)
      END IF
C
C  FETCH ALPHA OR BETA DM (ACCORDING TO WHETHER ALPHA OR BETA IS TRUE):
C
      CALL FEDRAW(DM,A)
C
C  OUTPUT THE AO BOND-ORDER MATRIX:
C
      IO = IOINQR(JPRINT(42))
      IF(IWDM.NE.0.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        TITLE = 'AO bond-order matrix:'
        CALL AOUT(DM,NDIM,-NBAS,NBAS,TITLE,1,JPRINT(42))
      END IF
C
C  CONVERT THE BOND-ORDER MATRIX TO THE DENSITY MATRIX:
C
      IF(IWDM.NE.0) THEN
        I1   = 1
        I2   = I1 + NDIM*NDIM
C       IEND = I2 + NDIM*NDIM
        CALL FESRAW(A(I1))
        CALL SIMTRM(DM,A(I1),A(I2),NDIM,NBAS,IWMULP,IWCUBF)
      END IF
C
C  OUTPUT THE AO DENSITY MATRIX:
C
      IO = IOINQR(JPRINT(27))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        TITLE = 'AO density matrix:'
        CALL AOUT(DM,NDIM,-NBAS,NBAS,TITLE,1,JPRINT(27))
      END IF
C
C  OUTPUT THE AO FOCK MATRIX:
C
      IO = IOINQR(JPRINT(40))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL FEFAO(A,IWFOCK)
        IF(IWFOCK.NE.0) THEN
          TITLE = 'AO Fock matrix:'
          CALL AOUT(A,NDIM,-NBAS,NBAS,TITLE,1,JPRINT(40))
        ELSE
          TITLE = 'AO Fock matrix.'
          NT = LENNB(TITLE)
          WRITE(LFNPR,2300) (TITLE(K:K),K=1,NT)
        END IF
      END IF
C
C  REORGANIZE THE SCRATCH VECTOR
C
      I1 = 1
      I2 = I1 + NDIM * NDIM
      I3 = I2 + NDIM * NDIM
C     IEND = I3 + NDIM
C
C  OUTPUT THE MO DENSITY MATRIX:
C
      CALL FEAOMO(A(I1),IT)
      IO = IOINQR(JPRINT(61))
      IF(IT.NE.0.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL COPY(DM,A(I2),NDIM,NBAS,NBAS)
        CALL SIMTR1(A(I2),A(I1),A(I3),NDIM,NBAS,NBAS,NNAO)
        TITLE = 'MO density matrix:'
        CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,-1,JPRINT(61))
      END IF
C
C  OUTPUT THE MO FOCK MATRIX:
C
      CALL FEAOMO(A(I1),IT)
      IO = IOINQR(JPRINT(60))
      IF(IT.NE.0.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL FEFAO(A(I2),IWFOCK)
        IF(IWFOCK.NE.0) THEN
          CALL SIMTR1(A(I2),A(I1),A(I3),NDIM,NBAS,NBAS,NNAO)
          TITLE = 'MO Fock matrix:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,-1,JPRINT(60))
        ELSE
          TITLE = 'MO Fock matrix.'
          NT = LENNB(TITLE)
          WRITE(LFNPR,2300) (TITLE(K:K),K=1,NT)
        END IF
      END IF
C
C  OUTPUT THE MO KINETIC ENERGY MATRIX:
C
      CALL FEAOMO(A(I1),IT)
      IO = IOINQR(JPRINT(69))
      IF(IT.NE.0.AND..NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL FEKAO(A(I2),IWKIN)
        IF(IWKIN.NE.0) THEN
          CALL SIMTR1(A(I2),A(I1),A(I3),NDIM,NBAS,NBAS,NNAO)
          TITLE = 'MO kinetic energy matrix:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,-1,JPRINT(69))
        END IF
      END IF
C
C  OUTPUT THE MO 1-e POTENTIAL ENERGY MATRIX:
C
      CALL FEAOMO(A(I1),IT)
      IO = IOINQR(JPRINT(75))
      IF(IT.NE.0.AND..NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL FEVAO(A(I2),IWV1)
        IF(IWV1.NE.0) THEN
          CALL SIMTR1(A(I2),A(I1),A(I3),NDIM,NBAS,NBAS,NNAO)
          TITLE = 'MO 1-e potential energy matrix:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,-1,JPRINT(75))
        END IF
      END IF
C
C  OUTPUT THE MO DIPOLE MATRICES:
C
      IO = IOINQR(JPRINT(62))
      IF(IT.NE.0.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        IX = 1
        CALL FEDXYZ(A(I2),IX)
        IF(IX.NE.0) THEN
          CALL SIMTR1(A(I2),A(I1),A(I3),NDIM,NBAS,NBAS,NNAO)
          TITLE = 'MO x dipole integrals:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,-1,JPRINT(62))
        END IF
        IX = 2
        CALL FEDXYZ(A(I2),IX)
        IF(IX.NE.0) THEN
          CALL SIMTR1(A(I2),A(I1),A(I3),NDIM,NBAS,NBAS,NNAO)
          TITLE = 'MO y dipole integrals:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,-1,JPRINT(62))
        END IF
        IX = 3
        CALL FEDXYZ(A(I2),IX)
        IF(IX.NE.0) THEN
          CALL SIMTR1(A(I2),A(I1),A(I3),NDIM,NBAS,NAS,NNAO)
          TITLE = 'MO z dipole integrals:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,-1,JPRINT(62))
        END IF
      END IF
C
C  TRANSFORM DM TO THE NAO BASIS:
C
      CALL SIMTR1(DM,T,A,NDIM,NBAS,NBAS,NNAO)
C
C  SAVE THE NAO DENSITY MATRIX IN SCRATCH STORAGE:
C
      CALL SVDNAO(DM)
C
C  PRINT THE NATURAL POPULATION ANALYSIS FOR THIS SPIN CASE:
C
      I1   = 1
      I2   = I1 + NATOMS*NATOMS
      I3   = I2 + NATOMS
      I4   = I3 + NATOMS*NATOMS
      I5   = I4 + NATOMS*NATOMS
      I6   = I5 + NDIM*NDIM
      I7   = I6 + NDIM
C     IEND = I7 + NDIM
      CALL FESNAO(T)
      CALL NAOANL(DM,T,A(I1),A(I2),A(I3),A(I4),A(I5),A(I6),A(I7))
C
C  NOTE: DO NOT DESTROY THE WIBERG BOND INDEX WHICH IS STORED IN THE FIRST
C  NATOMS*NATOMS ELEMENTS OF THE SCRATCH VECTOR A.  THIS IS MATRIX IS
C  REQUIRED FOR THE NBO ANALYSIS:
C
C  NOTE THAT T IS NOW T-AO-NAO:
C
C  FORM THE NAO LABELS:
C
      CALL LBLNAO
C
C  OUTPUT THE NAO-MO TRANSFORMATION MATRIX:
C
      IO = IOINQR(JPRINT(9))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        I1   = 1
        I2   = I1 + NATOMS*NATOMS
        I3   = I2 + NDIM*NDIM
        I4   = I3 + NDIM*NDIM
C       IEND = I4 + NDIM*(NDIM+5)
        CALL FRMTMO(T,A(I2),A(I3),A(I4),2,JPRINT(9))
      END IF
C
C  REORGANIZE THE SCRATCH VECTOR:
C
      I1   = 1
      I2   = I1 + NATOMS*NATOMS
      I3   = I2 + NDIM*NDIM
C     IEND = I3 + NDIM
C
C  OUTPUT THE NAO DENSITY MATRIX:
C
      IO = IOINQR(JPRINT(35))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        TITLE = 'NAO density matrix:'
        CALL AOUT(DM,NDIM,-NNAO,NNAO,TITLE,2,JPRINT(35))
      END IF
C
C  OUTPUT THE NAO FOCK MATRIX:
C
      IO = IOINQR(JPRINT(31))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL FEFAO(A(I2),IWFOCK)
        IF(IWFOCK.NE.0) THEN
          CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
          TITLE = 'NAO Fock matrix:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,2,JPRINT(31))
        ELSE
          TITLE = 'NAO Fock matrix.'
          NT = LENNB(TITLE)
          WRITE(LFNPR,2300) (TITLE(K:K),K=1,NT)
        END IF
      END IF
C
 2100 FORMAT(//1X,
     * '***************************************************',/1X,
     * '*******         Alpha spin orbitals         *******',/1X,
     * '***************************************************')
 2200 FORMAT(//1X,
     * '***************************************************',/1X,
     * '*******         Beta  spin orbitals         *******',/1X,
     * '***************************************************')
 2300 FORMAT(/1X,'Fock matrix unavailable for this wavefunction;',
     * ' can''t print ',80A1)
      RETURN
      END
C***********************************************************************
      SUBROUTINE DMSIM(DM,T,A)
C***********************************************************************
C  1-Feb-93  JKB  Added support for KMO, VMO
C 19-Jan-93  EDG  Checkpoint the AO-MO transformation and added support for
C                 FMO, DMMO, and DIMO
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),LSTEMT(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBAO/LCTR(MAXBAS),LANG(MAXBAS)
      COMMON/NBNAO/NAOC(MAXBAS),NAOA(MAXBAS),LTYP(MAXBAS),IPRIN(MAXBAS)
C
      DIMENSION DM(NDIM,NDIM),T(NDIM,NDIM),A(*)
      CHARACTER*80 TITLE
C
      SAVE IPRNT,IWRIT,ICHK
      DATA IPRNT,IWRIT,ICHK/4HPRNT,4HWRIT,3HCHK/
C
C  SIMULATE THE ALPHA/BETA NAO SUBPROGRAM:
C
      IF(ALPHA) THEN
        IF(JPRINT(4).NE.0) WRITE(LFNPR,2100)
      ELSE
        DO 70 I = 1,NBAS
          NAOCTR(I) = NAOC(I)
          NAOL(I) = NAOA(I)
          LBL(I) = LCTR(I)
          LORBC(I) = LANG(I)
   70   CONTINUE
        CALL FETNAO(T)
        IF(JPRINT(4).NE.0) WRITE(LFNPR,2200)
      END IF
C
C  OUTPUT THE AO-MO TRANSFORMATION MATRIX:
C
      IO = IOINQR(JPRINT(26))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL FEAOMO(A,IT)
        IF(IT.NE.0) THEN
          TITLE = 'MOs in the AO basis:'
          CALL AOUT(A,NDIM,NBAS,NBAS,TITLE,1,JPRINT(26))
        END IF
      ELSE IF(IO.EQ.ICHK) THEN
        CALL FEAOMO(A,IT)
        IF(IT.NE.0) CALL SVCHK(A,ISPIN)
      END IF
C
C  FETCH ALPHA OR BETA DM (ACCORDING TO WHETHER ALPHA OR BETA IS TRUE):
C
      CALL FEDRAW(DM,A)
C
C  OUTPUT THE AO DENSITY MATRIX:
C
      IO = IOINQR(JPRINT(27))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        TITLE = 'AO density matrix:'
        CALL AOUT(DM,NDIM,-NBAS,NBAS,TITLE,1,JPRINT(27))
      END IF
C
C  OUTPUT THE AO FOCK MATRIX:
C
      IO = IOINQR(JPRINT(40))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL FEFAO(A,IWFOCK)
        IF(IWFOCK.NE.0) THEN
          TITLE = 'AO Fock matrix:'
          CALL AOUT(A,NDIM,-NBAS,NBAS,TITLE,1,JPRINT(40))
        ELSE
          TITLE = 'AO Fock matrix.'
          NT = LENNB(TITLE)
          WRITE(LFNPR,2300) (TITLE(K:K),K=1,NT)
        END IF
      END IF
C
C  REORGANIZE THE SCRATCH VECTOR
C
      I1 = 1
      I2 = I1 + NDIM * NDIM
      I3 = I2 + NDIM * NDIM
C     IEND = I3 + NDIM
C
C  OUTPUT THE MO DENSITY MATRIX:
C
      CALL FEAOMO(A(I1),IT)
      IO = IOINQR(JPRINT(61))
      IF(IT.NE.0.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL COPY(DM,A(I2),NDIM,NBAS,NBAS)
        CALL SIMTRS(A(I2),A(I1),A(I3),NDIM,NBAS)
        TITLE = 'MO density matrix:'
        CALL AOUT(A(I2),NDIM,-NBAS,NBAS,TITLE,-1,JPRINT(61))
      END IF
C
C  OUTPUT THE MO FOCK MATRIX:
C
      CALL FEAOMO(A(I1),IT)
      IO = IOINQR(JPRINT(60))
      IF(IT.NE.0.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL FEFAO(A(I2),IWFOCK)
        IF(IWFOCK.NE.0) THEN
          CALL SIMTRS(A(I2),A(I1),A(I3),NDIM,NBAS)
          TITLE = 'MO Fock matrix:'
          CALL AOUT(A(I2),NDIM,-NBAS,NBAS,TITLE,-1,JPRINT(60))
        ELSE
          TITLE = 'MO Fock matrix.'
          NT = LENNB(TITLE)
          WRITE(LFNPR,2300) (TITLE(K:K),K=1,NT)
        END IF
      END IF
C
C  OUTPUT THE MO KINETIC ENERGY MATRIX:
C
      CALL FEAOMO(A(I1),IT)
      IO = IOINQR(JPRINT(69))
      IF(IT.NE.0.AND..NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL FEKAO(A(I2),IWKIN)
        IF(IWKIN.NE.0) THEN
          CALL SIMTRS(A(I2),A(I1),A(I3),NDIM,NBAS)
          TITLE = 'MO kinetic energy matrix:'
          CALL AOUT(A(I2),NDIM,-NBAS,NBAS,TITLE,-1,JPRINT(69))
        END IF
      END IF
C
C  OUTPUT THE MO 1-e POTENTIAL ENERGY MATRIX:
C
      CALL FEAOMO(A(I1),IT)
      IO = IOINQR(JPRINT(75))
      IF(IT.NE.0.AND..NOT.OPEN.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        CALL FEVAO(A(I2),IWV1)
        IF(IWV1.NE.0) THEN
          CALL SIMTRS(A(I2),A(I1),A(I3),NDIM,NBAS)
          TITLE = 'MO 1-e potential energy matrix:'
          CALL AOUT(A(I2),NDIM,-NBAS,NBAS,TITLE,-1,JPRINT(75))
        END IF
      END IF
C
C  OUTPUT THE MO DIPOLE MATRICES:
C
      IO = IOINQR(JPRINT(62))
      IF(IT.NE.0.AND.(IO.EQ.IPRNT.OR.IO.EQ.IWRIT)) THEN
        IX = 1
        CALL FEDXYZ(A(I2),IX)
        IF(IX.NE.0) THEN
          CALL SIMTRS(A(I2),A(I1),A(I3),NDIM,NBAS)
          TITLE = 'MO x dipole integrals:'
          CALL AOUT(A(I2),NDIM,-NBAS,NBAS,TITLE,-1,JPRINT(62))
        END IF
        IX = 2
        CALL FEDXYZ(A(I2),IX)
        IF(IX.NE.0) THEN
          CALL SIMTRS(A(I2),A(I1),A(I3),NDIM,NBAS)
          TITLE = 'MO y dipole integrals:'
          CALL AOUT(A(I2),NDIM,-NBAS,NBAS,TITLE,-1,JPRINT(62))
        END IF
        IX = 3
        CALL FEDXYZ(A(I2),IX)
        IF(IX.NE.0) THEN
          CALL SIMTRS(A(I2),A(I1),A(I3),NDIM,NBAS)
          TITLE = 'MO z dipole integrals:'
          CALL AOUT(A(I2),NDIM,-NBAS,NBAS,TITLE,-1,JPRINT(62))
        END IF
      END IF
C
C  SAVE THE NAO DENSITY MATRIX IN SCRATCH STORAGE:
C
      CALL SVDNAO(DM)
C
C  PRINT THE NATURAL POPULATION ANALYSIS FOR THIS SPIN CASE:
C
      I1   = 1
      I2   = I1 + NATOMS*NATOMS
      I3   = I2 + NATOMS
      I4   = I3 + NATOMS*NATOMS
      I5   = I4 + NATOMS*NATOMS
      I6   = I5 + NDIM*NDIM
      I7   = I6 + NDIM
C     IEND = I7 + NDIM
      CALL NAOANL(DM,T,A(I1),A(I2),A(I3),A(I4),A(I5),A(I6),A(I7))
C
C  NOTE: DO NOT DESTROY THE WIBERG BOND INDEX WHICH IS STORED IN THE FIRST
C  NATOMS*NATOMS ELEMENTS OF THE SCRATCH VECTOR A.  THIS IS MATRIX IS
C  REQUIRED FOR THE NBO ANALYSIS:
C
C  FORM THE NAO LABELS:
C
      CALL LBLNAO
C
 2100 FORMAT(//1X,
     * '***************************************************',/1X,
     * '*******         Alpha spin orbitals         *******',/1X,
     * '***************************************************')
 2200 FORMAT(//1X,
     * '***************************************************',/1X,
     * '*******         Beta  spin orbitals         *******',/1X,
     * '***************************************************')
 2300 FORMAT(/1X,'Fock matrix unavailable for this wavefunction;',
     * ' can''t print ',80A1)
      RETURN
      END
C***********************************************************************
C NBO 5.G -- Natural Bond Orbital Analysis Programs
C (c) Copyright 1996-2008 Board of Regents of the University of Wisconsin System
C     on behalf of the Theoretical Chemistry Institute.  All Rights Reserved.
C***********************************************************************
      SUBROUTINE NBODRV(DM,T,A,MEMORY)
C***********************************************************************
C 22-Aug-02  EDG  Evaluate MAXRES with reals to avoid integer overflow
C 12-May-02  FAW  Add MEMORY message for NRT
C  4-Mar-01  FAW  Add NLMO restart with relaxed DONE, EPS
C 20-Dec-00  FAW  Add 3CHB hyperbond search
C 15-Nov-00  JAB  Add NCS Analysis, initially for G98
C 31-Oct-00  FAW  Altered CALL NBSTER argument list to repair STERIC
C  6-Jan-00  FAW  Repaired NAONLMO output (per Steve Wilkens)
C 27-May-98  EDG  Write NBOs and NLMOS in Spartan Archive Format
C 28-Jan-94  JKB  Add jump back to 70 if NRT valence space error occurred
C 24-Jan-94  JKB  Print a message if Fock matrix keywords used when IFOCK=0
C 11-Dec-93  EDG  Add printing of PNHO and PNBO Fock matrices
C 15-Oct-93  JKB  Added NBSTER call
C  1-Feb-93  JKB  Added support for KNHO, KNBO, KNLMO, VNHO, VNBO, VNLMO
C 19-Jan-93  EDG  Checkpoint the PNHOs, NHOs, PNBOs, NBOs, PNLMOs, and NLMOs
C-----------------------------------------------------------------------
C
C  DRIVER SUBROUTINE TO CALCULATE NATURAL HYBRID ORBITALS (NHOS) AND
C  NATURAL BOND ORBITALS (NBOS) FROM THE DENSITY MATRIX IN THE NAO BASIS
C
C        T = SCRATCH STORAGE
C       DM = NAO DENSITY MATRIX
C            THE SPIN NATURE OF DM IS INDICATED BY:
C            ISPIN =  0: SPINLESS  (CLOSED SHELL)
C            ISPIN = +2: ALPHA SPIN
C            ISPIN = -2: SPIN
C            (ISPIN IS THE RECIPROCAL OF THE S(Z) QUANTUM NO.)
C
C        A = SCRATCH STORAGE FROM THE MAIN PROGRAM.  THE LOCATION OF A(*)
C               IS IN THE COMMON BLOCK /SCM/ IN THE MAIN PROGRAM,
C               AFTER THE STORAGE FOR THE MATRICES 'S','DM'
C             ('A' IS THE VECTOR WHICH IS PARTITIONED
C                   ACCORDING TO THE STORAGE NEEDS OF EACH PROGRAM RUN)
C     ATOM, BASIS, OPTION, NBINFO: COMMON BLOCKS WITH DATA TRANSFERED FROM
C        FROM THE INPUT PROGRAMS.
C
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER*80 TITLE
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBNAO/NAOC(MAXBAS),NAOA(MAXBAS),LTYP(MAXBAS),IPRIN(MAXBAS)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBTHR/THRSET,PRJSET,ACCTHR,CRTSET,E2THR,ATHR,PTHR,ETHR,
     +             DTHR,DLTHR,CHSTHR,REFTHR,STTHR,PRTHR,THRNCS,THRNJC
      COMMON/IOCWAR/IOCWAR
C
      DIMENSION T(NDIM,NDIM),DM(NDIM,NDIM),A(*)
C
      SAVE ZERO,IPRNT,IWRIT,IREAD,ICHK,IVAL
      DATA IPRNT,IWRIT,IREAD,ICHK/4HPRNT,4HWRIT,4HREAD,3HCHK/
      DATA ZERO/0.0D0/
      DATA IVAL/3HVal/
C
C  SKIP NBO TRANSFORMATION IF REQUESTED (OR IF MCSCF WITHOUT MSPNBO):
C
      IF(JPRINT(1).GT.0) THEN
        IF(MCSCF) THEN
          IF(OPEN) THEN
            IF(IWMSP.NE.1) THEN
              WRITE(LFNPR,2010)
              RETURN
            END IF
          END IF
        ELSE
          WRITE(LFNPR,2000)
          RETURN
        END IF
      END IF
C
C  ORGANIZE SCRATCH STORAGE VECTOR A.  WARNING:  THIS IS REDEFINED
C  SEVERAL TIMES AFTER THE NBOS ARE FORMED
C
C  A(I0)  = GUIDE(NATOMS,NATOMS)
C  A(I1)  = BNDOCC(NDIM)
C  A(I2)  = POL(NDIM,3)
C  A(I3)  = Q(MXAO,NDIM)
C  A(I4)  = V(NDIM)
C  A(I5)  = BLK(MXBO,MXBO)
C  A(I6)  = C(MXBO,MXBO)
C  A(I7)  = EVAL(MXBO)
C  A(I8)  = BORB(MXBO)
C  A(I9)  = P(MXAO,MXAO)
C  A(I10) = PK(MXAO,MXAO)
C  A(I11) = HYB(MXAO)
C  A(I12) = VA(MXAO)
C  A(I13) = VB(MXAO)
C
      I0   = 1
      I1   = I0  + NATOMS*NATOMS
      I2   = I1  + NDIM
      I3   = I2  + 3*NDIM
      I4   = I3  + MXAO*NDIM
      I5   = I4  + NDIM
      I6   = I5  + MXBO*MXBO
      I7   = I6  + MXBO*MXBO
      I8   = I7  + MXBO
      I9   = I8  + MXBO
      I10  = I9  + MXAO*MXAO
      I11  = I10 + MXAO*MXAO
      I12  = I11 + MXAO
      I13  = I12 + MXAO
      I14  = I13 + MXAO
C     IEND = I14 + NATOMS*NATOMS
C
      IF(JPRINT(5).NE.0.AND.ISPIN.EQ.0) WRITE(LFNPR,1400)
      IF(JPRINT(5).NE.0.AND.ISPIN.EQ.2) WRITE(LFNPR,1410)
      IF(JPRINT(5).NE.0.AND.ISPIN.EQ.-2) WRITE(LFNPR,1420)
      IF(IOCWAR.EQ.-1) THEN
        IOCWAR = 0
        WRITE(LFNPR,1440)
      END IF
C
C  READ IN T-NAB, LABEL, IBXM, TRANSFORM DM, AND FIND BNDOCC IF IWTNAB=IREAD:
C
      IF(IOINQR(IWTNAB).EQ.IREAD) THEN
        CALL RDTNAB(T,DM,A(I1),A(I2),IWTNAB)
      ELSE
C
C  SEARCH INPUT FILE FOR $CORE INPUT:
C
        IF(.NOT.BETA) THEN
          CALL CORINP(JPRINT(2),JCORE)
          CALL RDCORE(JCORE)
        END IF
C
C  SEARCH INPUT FILE FOR $CHOOSE INPUT:
C
        IF(.NOT.BETA) THEN
          CALL CHSINP(JPRINT(2),ICHOOS)
          IF(OPEN.AND.ICHOOS.EQ.1.AND.JPRINT(32).NE.0) THEN
            WRITE(LFNPR,1390)
            ICHOOS = 0
          END IF
        END IF
C
C  CALCULATE NATURAL HYBRID ORBITALS AND BOND ORBITALS:
C
        IF(ICHOOS.NE.1) CALL NATHYB(DM,T,A(I0),A(I1),A(I2),A(I3),A(I4),
     +                            A(I5),A(I6),A(I7),A(I8),A(I9),A(I10),
     +                            A(I11),A(I12),A(I13),A(I14))
        IF(ICHOOS.EQ.1) CALL CHSDRV(DM,T,A(I0),A(I1),A(I2),A(I3),A(I4),
     +                            A(I5),A(I6),A(I7),A(I8),A(I9),A(I10),
     +                            A(I11),A(I12),A(I13),A(I14))
C
C  IF NBO SEARCH WAS ABANDONED, DON'T TRY TO DO ANYTHING FURTHER:
C
        IF(JPRINT(1).LT.0) RETURN
C
C  SORT THE NBOS BY ATOM:
C
        CALL SRTNBO(T,A(I1))
C
C  FORM THE NBO DENSITY MATRIX:
C
        CALL SIMTRS(DM,T,A(I2),NDIM,NNAO)
C
C  CHECK NHO OVERLAPS TO SEE IF BOND ORBITALS SHOULD BE RELABELLED:
C
        IF(.NOT.ORTHO) THEN
          I0   = 1
          I1   = I0 + NATOMS*NATOMS
          I2   = I1 + NDIM
          I3   = I2 + MXAO
          I4   = I3 + NDIM*NDIM
          I5   = I4 + NDIM*NDIM
          I6   = I5 + NDIM
C         IEND = I6 + NDIM
          CALL XCITED(DM,T,A(I2),A(I3),A(I4),A(I5),A(I6),A(I6))
        END IF
      END IF
C
C  T  NOW CONTAINS THE NAO-NBO TRANSFORMATION MATRIX
C  DM NOW CONTAINS THE NBO DENSITY MATRIX
C  A(I0)  CONTAINS THE WIBERG BOND INDEX MATRIX      ! DON'T DESTROY THIS
C  A(I1)  CONTAINS THE NBO OCCUPANCIES               ! DON'T DESTROY THIS
C  A(I2)  IS SCRATCH SPACE
C
C  SAVE THE NAO-NBO TRANSFORMATION ON THE NBO DAF:
C
      CALL SVTNAB(T)
C
C  FORM THE NBO LABELS:
C
      CALL LBLNBO
C
C  WRITE OUT THE ANALYSIS OF BOND ORBITALS:
C
      I0   = 1
      I1   = I0 + NATOMS*NATOMS
      I2   = I1 + NDIM
      I3   = I2 + NDIM
      I4   = I3 + NDIM
C     IEND = I4 + NDIM*NDIM
      CALL ANLYZE(T,A(I1),A(I2),A(I3),A(I4))
C
C  WRITE OUT HYBRID DIRECTIONALITY AND BOND BENDING INFO:
C
      IF(JPRINT(36).NE.0) THEN
        I0   = 1
        I1   = I0 + NATOMS*NATOMS
        I2   = I1 + NDIM
        I3   = I2 + 3*NATOMS
        I4   = I3 + NDIM*NDIM
        I5   = I4 + NDIM*NDIM
C       IEND = I5 + NDIM
        CALL HYBDIR(A(I1),A(I2),A(I3),A(I4),A(I5))
        IF(JPRINT(36).GT.1)
     +       CALL NHOANG(A(I3),A(I2),NATOMS,NNAO,NDIM,LFNPR)
      END IF
C
C  FIND MOLECULAR UNITS:
C
      CALL FNDMOL(A(I2))
C
C  CLASSIFY ALL THE NBOS ACCORDING TO DONOR/ACCEPTOR TYPE:
C
      CALL NBOCLA(A(I1),ACCTHR)
C
C  OUTPUT TRANSFORMATION MATRICES FOR THE PNHO AND NHO BASIS SETS,
C  AND THE NHO DENSITY MATRIX, NHO FOCK MATRIX, AND NHO DIPOLE MATRICES:
C
C  THE SECTION OF THE CODE MAKES USE OF T AND DM.  THESE MATRICES
C  WILL BE RESTORED LATER:  [NOTE: DO NOT DESTROY INFO ALREADY STORED
C  IN A(I0) AND A(I1)]
C
C  REORGANIZE THE SCRATCH VECTOR:
C
      I0   = 1
      I1   = I0 + NATOMS*NATOMS
      I2   = I1 + NDIM
      I3   = I2 + NDIM*NDIM
      I4   = I3 + NDIM*NDIM
C     IEND = I4 + NDIM*(NDIM+5)
C
C  OUTPUT THE AO-PNHO TRANSFORMATION, PNHO OVERLAP AND FOCK MATRICES:
C
      IO = IOINQR(JPRINT(20))
      JO = IOINQR(JPRINT(30))
      KO = IOINQR(JPRINT(78))
      IF((IO.EQ.IPRNT.OR.IO.EQ.IWRIT).OR.
     +   (JO.EQ.IPRNT.OR.JO.EQ.IWRIT.OR.JO.EQ.ICHK).OR.
     +   (KO.EQ.IPRNT.OR.KO.EQ.IWRIT)) THEN
        CALL FEPNAO(T)
        CALL FETNHO(A(I2))
        CALL MATML1(T,A(I2),A(I3),NDIM,NDIM,NDIM,NBAS,NNAO,NNAO)
        CALL FESRAW(A(I2))
        CALL NORMLZ(T,A(I2),NDIM,NBAS,NNAO)
        IF(JO.EQ.ICHK) CALL SVCHK(T,ISPIN)
        IF(JO.EQ.IPRNT.OR.JO.EQ.IWRIT) THEN
          CALL RDELEM(LFNBRK(30))
          TITLE = 'PNHOs in the AO basis:'
          CALL AOUT(T,NDIM,NBAS,NNAO,TITLE,1,JPRINT(30))
        END IF
        IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
          CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
          CALL RDELEM(LFNBRK(20))
          TITLE = 'PNHO overlap matrix:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,3,JPRINT(20))
        END IF
        IF(KO.EQ.IPRNT.OR.KO.EQ.IWRIT) THEN
          CALL FEFAO(A(I2),IWFOCK)
          IF(IWFOCK.NE.0) THEN
            CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
            CALL RDELEM(LFNBRK(78))
            TITLE = 'PNHO Fock matrix:'
            CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,3,JPRINT(78))
          ELSE
            TITLE = 'PNHO Fock matrix.'
            NT = LENNB(TITLE)
            WRITE(LFNPR,2300) (TITLE(K:K),K=1,NT)
          END IF
        END IF
      ENDIF
C
C  FORM THE AO-NHO TRANSFORMATION MATRIX:
C
      CALL FETNAO(T)
      CALL FETNHO(A(I2))
      CALL MATML1(T,A(I2),A(I3),NDIM,NDIM,NDIM,NBAS,NNAO,NNAO)
C
C  OUTPUT THE AO-NHO TRANSFORMATION MATRIX:
C
      IO = IOINQR(JPRINT(28))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL RDELEM(LFNBRK(28))
        TITLE = 'NHOs in the AO basis:'
        CALL AOUT(T,NDIM,NBAS,NNAO,TITLE,1,JPRINT(28))
      ELSE IF(IO.EQ.ICHK) THEN
        CALL SVCHK(T,ISPIN)
      END IF
C
C  OUTPUT THE NAO-NHO TRANSFORMATION MATRIX:
C
      IO = IOINQR(JPRINT(33))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL FETNHO(A(I2))
        CALL RDELEM(LFNBRK(33))
        TITLE = 'NHOs in the NAO basis:'
        CALL AOUT(A(I2),NDIM,NNAO,NNAO,TITLE,2,JPRINT(33))
      END IF
C
C  OUTPUT THE NHO-MO TRANSFORMATION MATRIX:
C
      IO = IOINQR(JPRINT(38))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL FRMTMO(T,A(I2),A(I3),A(I4),3,JPRINT(38))
      END IF
C
C  OUTPUT THE NHO DENSITY MATRIX:
C
      IO = IOINQR(JPRINT(34))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL FEDRAW(DM,A(I2))
        IF(IWDM.EQ.1) THEN
          CALL FESRAW(A(I2))
          CALL SIMTRS(DM,A(I2),A(I3),NDIM,NBAS)
        END IF
        CALL SIMTR1(DM,T,A(I2),NDIM,NBAS,NBAS,NNAO)
        CALL RDELEM(LFNBRK(34))
        TITLE = 'NHO density matrix:'
        CALL AOUT(DM,NDIM,-NNAO,NNAO,TITLE,3,JPRINT(34))
      END IF
C
C  OUTPUT THE NHO FOCK MATRIX:
C
      IO = IOINQR(JPRINT(29))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL FEFAO(A(I2),IWFOCK)
        IF(IWFOCK.NE.0) THEN
          CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
          CALL RDELEM(LFNBRK(29))
          TITLE = 'NHO Fock matrix:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,3,JPRINT(29))
        ELSE
          TITLE = 'NHO Fock matrix.'
          NT = LENNB(TITLE)
          WRITE(LFNPR,2300) (TITLE(K:K),K=1,NT)
        END IF
      END IF
C
C  OUTPUT THE NHO KINETIC ENERGY MATRIX:
C
      IO = IOINQR(JPRINT(66))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL FEKAO(A(I2),IWKIN)
        IF(IWKIN.NE.0) THEN
          CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
          CALL RDELEM(LFNBRK(66))
          TITLE = 'NHO kinetic energy matrix:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,3,JPRINT(66))
        END IF
      END IF
C
C  OUTPUT THE NHO 1-e POTENTIAL ENERGY MATRIX:
C
      IO = IOINQR(JPRINT(72))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL FEVAO(A(I2),IWV1)
        IF(IWV1.NE.0) THEN
          CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
          CALL RDELEM(LFNBRK(72))
          TITLE = 'NHO 1-e potential energy matrix:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,3,JPRINT(72))
        END IF
      END IF
C
C  OUTPUT THE NHO DIPOLE MATRICES:
C
      IO = IOINQR(JPRINT(52))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        IX = 1
        CALL FEDXYZ(A(I2),IX)
        IF(IX.NE.0) THEN
          CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
          CALL RDELEM(LFNBRK(52))
          TITLE = 'NHO x dipole integrals:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,3,JPRINT(52))
        END IF
        IX = 2
        CALL FEDXYZ(A(I2),IX)
        IF(IX.NE.0) THEN
          CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
          CALL RDELEM(LFNBRK(52))
          TITLE = 'NHO y dipole integrals:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,3,JPRINT(52))
        END IF
        IX = 3
        CALL FEDXYZ(A(I2),IX)
        IF(IX.NE.0) THEN
          CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
          CALL RDELEM(LFNBRK(52))
          TITLE = 'NHO z dipole integrals:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,3,JPRINT(52))
        END IF
      END IF
C
C 3-C, 4-E HYPERBOND SEARCH
C
      IF(IW3CHB.GT.0) THEN
        CALL FEDRAW(DM,A(I2))
        IF(IWDM.EQ.1) THEN
          CALL FESRAW(A(I2))
          CALL SIMTRS(DM,A(I2),A(I3),NDIM,NBAS)
        END IF
        CALL SIMTR1(DM,T,A(I2),NDIM,NBAS,NBAS,NNAO)
        CALL NB3CHB(DM,LFNPR)
      ENDIF
C
C  OUTPUT TRANSFORMATION MATRICES FOR THE PNBO AND NBO BASIS SETS,
C  AND THE NBO DENSITY MATRIX, NBO FOCK MATRIX, AND NBO DIPOLE MATRICES:
C
C  [NOTE: DO NOT DESTROY INFO ALREADY STORED IN A(I0) AND A(I1)]
C
C  REORGANIZE THE SCRATCH VECTOR:
C
      I0   = 1
      I1   = I0 + NATOMS*NATOMS
      I2   = I1 + NDIM
      I3   = I2 + NDIM*NDIM
      I4   = I3 + NDIM*NDIM
      I5   = I4 + NDIM*NDIM
      I6   = I5 + NDIM*NDIM
      I7   = I6 + NDIM*NDIM
C     IEND = I7 + NDIM*(NDIM+3)
C
C  OUTPUT THE AO-PNBO TRANSFORMATION, PNBO OVERLAP AND FOCK MATRICES:
C
      IO = IOINQR(JPRINT(21))
      JO = IOINQR(JPRINT(25))
      KO = IOINQR(JPRINT(79))
      IF((IO.EQ.IPRNT.OR.IO.EQ.IWRIT).OR.
     +   (JO.EQ.IPRNT.OR.JO.EQ.IWRIT.OR.JO.EQ.ICHK).OR.
     +   (KO.EQ.IPRNT.OR.KO.EQ.IWRIT)) THEN
        CALL FEPNAO(T)
        CALL FETNAB(A(I2))
        CALL MATML1(T,A(I2),A(I3),NDIM,NDIM,NDIM,NBAS,NNAO,NNAO)
        CALL FESRAW(A(I2))
        CALL NORMLZ(T,A(I2),NDIM,NBAS,NNAO)
        IF(JO.EQ.ICHK) THEN
          CALL SVCHK(T,ISPIN)
          CALL RDELM2(LFNBRK(25))
          CALL RDPRM2(A(I4),A(I5))
        ENDIF
        IF(JO.EQ.IPRNT.OR.JO.EQ.IWRIT) THEN
          TITLE = 'PNBOs in the AO basis:'
          CALL AOUT(T,NDIM,NBAS,NNAO,TITLE,1,JPRINT(25))
        END IF
        IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
          CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
          CALL RDELEM(LFNBRK(21))
          TITLE = 'PNBO overlap matrix:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,4,JPRINT(21))
        END IF
        IF(KO.EQ.IPRNT.OR.KO.EQ.IWRIT) THEN
          CALL FEFAO(A(I2),IWFOCK)
          IF(IWFOCK.NE.0) THEN
            CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
            CALL RDELEM(LFNBRK(79))
            TITLE = 'PNBO Fock matrix:'
            CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,4,JPRINT(79))
          ELSE
            TITLE = 'PNBO Fock matrix.'
            NT = LENNB(TITLE)
            WRITE(LFNPR,2300) (TITLE(K:K),K=1,NT)
          END IF
        END IF
      END IF
C
C  FORM THE AO-NBO TRANSFORMATION MATRIX:
C
      CALL FETNAO(T)
      CALL FETNAB(A(I2))
      CALL MATML1(T,A(I2),A(I3),NDIM,NDIM,NDIM,NBAS,NNAO,NNAO)
C
C  SAVE THE AO-NBO TRANSFORMATION, NBO OCCS, AND NBO LABELS ON NBO DAF:
C
      CALL SVNBO(T,A(I1),A(I2))
C
C  WRITE THE AO-NBO TRANSFORMATION WITH NBO LABELS AND OCCUPANCIES:
C
      IF(IOINQR(IWTNBO).EQ.IWRIT) CALL WRTNBO(T,A(I1),IWTNBO)
C
C  PRINT THE AO-NBO TRANSFORMATION MATRIX:
C
      IF(IOINQR(IWTNBO).EQ.IPRNT) THEN
        TITLE = 'NBOs in the AO basis:'
        CALL AOUT(T,NDIM,NBAS,NNAO,TITLE,1,IWTNBO)
      ELSE IF(IOINQR(IWTNBO).EQ.ICHK) THEN
        CALL SVCHK(T,ISPIN)
      END IF
C
C  WRITE THE NAO-NBO TRANSFORMATION MATRIX:
C
      IF(IOINQR(IWTNAB).EQ.IWRIT) THEN
        CALL FETNAB(A(I2))
        CALL WRTNAB(A(I2),IWTNAB)
      END IF
C
C  PRINT THE NAO-NBO TRANSFORMATION TO THE OUTPUT FILE:
C
      IF(IOINQR(IWTNAB).EQ.IPRNT) THEN
        CALL FETNAB(A(I2))
        TITLE = 'NBOs in the NAO basis:'
        CALL AOUT(A(I2),NDIM,NNAO,NNAO,TITLE,2,IWTNAB)
      END IF
C
C  OUTPUT THE NHO-NBO TRANSFORMATION MATRIX:
C
      IO = IOINQR(JPRINT(41))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL FETNHO(A(I2))
        CALL NBTRSP(A(I2),NDIM,NNAO)
        CALL FETNAB(A(I3))
        CALL MATMLT(A(I2),A(I3),A(I4),NDIM,NNAO)
        CALL RDELEM(LFNBRK(41))
        TITLE = 'NBOs in the NHO basis:'
        CALL AOUT(A(I2),NDIM,NNAO,NNAO,TITLE,3,JPRINT(41))
      END IF
C
C  OUTPUT THE NBO-MO TRANSFORMATION MATRIX:
C
      IO = IOINQR(JPRINT(45))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL FRMTMO(T,A(I2),A(I3),A(I4),4,JPRINT(45))
      END IF
C
C  PRINT THE NBO ANALYSIS OF CANONICAL MOLECULAR ORBITALS
C
      IF(JPRINT(82).NE.0) THEN
        IF(IWFOCK.NE.0) THEN
          CALL FRMTMO(T,A(I2),A(I3),A(I4),4,0)
          CALL CMOANL(A(I2),A(I3),A(I4),JPRINT(82))
        ELSE
          WRITE(LFNPR,2400)
        END IF
      END IF
C
C  FORM THE NBO DENSITY MATRIX:
C
      CALL FEDRAW(DM,A(I2))
      IF(IWDM.EQ.1.AND..NOT.ORTHO) THEN
        CALL FESRAW(A(I2))
        CALL SIMTRS(DM,A(I2),A(I3),NDIM,NBAS)
      END IF
      CALL SIMTR1(DM,T,A(I2),NDIM,NBAS,NBAS,NNAO)
C
C  OUTPUT THE NBO DENSITY MATRIX:
C
      IO = IOINQR(JPRINT(16))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL RDELEM(LFNBRK(16))
        TITLE = 'NBO density matrix:'
        CALL AOUT(DM,NDIM,-NNAO,NNAO,TITLE,4,JPRINT(16))
      END IF
C
C  COMPUTE AND SAVE THE NBO FOCK MATRIX:
C
      CALL FEFAO(A(I2),IWFOCK)
      IF(IWFOCK.NE.0) THEN
        CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
        CALL SVFNBO(A(I2))
      END IF
C
C  OUTPUT THE NBO FOCK MATRIX:
C
      IO = IOINQR(JPRINT(37))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        IF(IWFOCK.NE.0) THEN
          CALL RDELEM(LFNBRK(37))
          TITLE = 'NBO Fock matrix:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,4,JPRINT(37))
        ELSE
          TITLE = 'NBO Fock matrix.'
          NT = LENNB(TITLE)
          WRITE(LFNPR,2300) (TITLE(K:K),K=1,NT)
        END IF
      END IF
C
C  WRITE NBOS IN SPARTAN ARCHIVE FORMAT:
C
      IF(JPRINT(84).GT.0) CALL WRSP(A(I2),T,JPRINT(84))
C
C  OUTPUT THE NBO KINETIC ENERGY MATRIX:
C
      IO = IOINQR(JPRINT(67))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL FEKAO(A(I2),IWKIN)
        IF(IWKIN.NE.0) THEN
          CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
          CALL RDELEM(LFNBRK(67))
          TITLE = 'NBO kinetic energy matrix:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,4,JPRINT(67))
        END IF
      END IF
C
C  OUTPUT THE NBO 1-e POTENTIAL ENERGY MATRIX:
C
      IO = IOINQR(JPRINT(73))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        CALL FEVAO(A(I2),IWV1)
        IF(IWV1.NE.0) THEN
          CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
          CALL RDELEM(LFNBRK(73))
          TITLE = 'NBO 1-e potential energy matrix:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,4,JPRINT(73))
        END IF
      END IF
C
C  OUTPUT THE NBO DIPOLE MATRICES:
C
      IO = IOINQR(JPRINT(53))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        IX = 1
        CALL FEDXYZ(A(I2),IX)
        IF(IX.NE.0) THEN
          CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
          CALL RDELEM(LFNBRK(53))
          TITLE = 'NBO x dipole integrals:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,4,JPRINT(53))
        END IF
        IX = 2
        CALL FEDXYZ(A(I2),IX)
        IF(IX.NE.0) THEN
          CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
          CALL RDELEM(LFNBRK(53))
          TITLE = 'NBO y dipole integrals:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,4,JPRINT(53))
        END IF
        IX = 3
        CALL FEDXYZ(A(I2),IX)
        IF(IX.NE.0) THEN
          CALL SIMTR1(A(I2),T,A(I3),NDIM,NBAS,NBAS,NNAO)
          CALL RDELEM(LFNBRK(53))
          TITLE = 'NBO z dipole integrals:'
          CALL AOUT(A(I2),NDIM,-NNAO,NNAO,TITLE,4,JPRINT(53))
        END IF
      END IF
C
C  PRINT OUT THE NBBP (BOND-BOND POLARIZABILITY) MATRIX
C
      IF(IOINQR(IWNBBP).EQ.IREAD) THEN
        LFNBBP = ABS(IWNBBP)/1000
        CALL NBBP(A(I2),A(I3),A(I4),A(I5),LFNBBP)
      ELSE IF(IWNBBP.NE.0) THEN
        LFNBBP = 0
        CALL NBBP(A(I2),A(I3),A(I4),A(I5),LFNBBP)
      END IF
C
C  WRITE OUT THE LABEL FILE FOR PLOT KEYWORD
C
      IF(JPRINT(43).NE.0) CALL WRLBL(JPRINT(43))
C
C  PERFORM PERTURBATIVE ANALYSIS OF THE NBO FOCK MATRIX:
C
      IF(JPRINT(3).EQ.1.AND.IWFOCK.NE.0) CALL FNBOAN(A(I1),A(I2),A(I3))
C
C  PRINT THE NBO SUMMARY:
C
      IF(JPRINT(6).EQ.1) THEN
        I0   = 1
        I1   = I0 + NATOMS*NATOMS
        I2   = I1 + NDIM
        I3   = I2 + NDIM*NDIM
        I4   = I3 + NDIM
        I5   = I4 + NATOMS
C       IEND = I5 + NDIM
        CALL NBOSUM(A(I2),A(I1),A(I3),A(I4),A(I5))
      END IF
C
C  CONTINUE WITH THE CONSTRUCTION OF THE NLMOS:
C
      IF(JPRINT(8).NE.0) THEN
C
C  STORE IN A(I0) THE VECTOR RESON(NDIM), THE SQUARES OF THE DIAGONAL
C  ELEMENTS OF THE NBO TO NLMO TRANSFORMATION MATRIX.  IALARM SOUNDS
C  THE ALARM THAT THE NLMO STEP IS TO BE SKIPPED:
C
C   DM   : NBO DENSITY         ! TRANSFORMED TO NLMO BASIS ON RETURN
C   A(I0): RESON(NDIM)         ! PERCENTAGES OF PARENT NBO
C   A(I1): LMOOCC(NDIM)        ! NLMO OCCUPANCIES
C   A(I2): TNLMO(NDIM,NDIM)    ! NBO-NLMO TRANSFORM
C   A(I3): TSYM                ! SCRATCH
C   A(I4): PRM                 ! PERMUTATION MATRIX
C
C  (DO NOT DESTROY THE WIBERG BOND INDEX!)
C
        I0   = 1 + NATOMS*NATOMS
        I1   = I0 + NDIM
        I2   = I1 + NDIM
        I3   = I2 + NDIM*NDIM
        I4   = I3 + NDIM*NDIM
        I5   = I4 + NDIM*NDIM
C       IEND = I5 + NDIM*NDIM
        CALL COPY(DM,A(I5),NDIM,NNAO,NNAO)
        ITRY = 0
        IALARM = 0
   10   CALL NLMO(DM,A(I1),A(I2),A(I4),A(I3),A(I0),NOCC,IALARM)
        IF(IALARM.NE.0) THEN
          ITRY = ITRY + 1
          IF(ITRY.EQ.1) THEN
C  RE-LOAD THE UNTAINTED NBO DENSITY MATRIX AND TRY AGAIN
            CALL COPY(A(I5),DM,NDIM,NNAO,NNAO)
            GOTO 10
          ENDIF
          IF(ITRY.GT.1.AND.IALARM.EQ.1) THEN
            WRITE(LFNPR,1430)
            GO TO 20
          ENDIF
        END IF
C
C  SAVE THE NBO TO NLMO TRANSFORMATION MATRIX ON THE NBO DAF:
C
        CALL SVTLMO(A(I2))
C
C  FORM THE NAO TO NLMO TRANSFORMATION IN T:
C
        CALL FETNAB(T)
        CALL MATMLT(T,A(I2),A(I3),NDIM,NNAO)
C
C  SET UP STORAGE FOR LMOANL:
C
C   A(I0): RESON(NDIM)
C   A(I1): LMOOCC(NDIM)
C   A(I2): TS(NDIM)
C   A(I3): BORDER(NATOMS,NATOMS)
C   A(I4): OWBORD(NATOMS,NATOMS)
C   A(I5): ATLMO(NOCC,NATOMS)
C   A(I6): SIAB(NOCC,NAB)
C
C  (DO NOT DESTROY THE WIBERG BOND INDEX!)
C
        NAB = NATOMS*(NATOMS-1)/2
        IF(NATOMS.EQ.1) NAB = 1
        I0   = 1 + NATOMS*NATOMS
        I1   = I0 + NDIM
        I2   = I1 + NDIM
        I3   = I2 + NDIM
        I4   = I3 + NATOMS*NATOMS
        I5   = I4 + NATOMS*NATOMS
        I6   = I5 + NOCC*NATOMS
        I7   = I6 + NOCC*NAB
C       IEND = I7 + NDIM*NDIM
        CALL COPY(DM,A(I7),NDIM,NNAO,NNAO)
        CALL LMOANL(T,A(I7),A(I0),A(I1),A(I2),A(I3),A(I4),A(I5),
     +              A(I6),NOCC,NAB)
C
C  OUTPUT TRANSFORMATION MATRICES FOR THE PNLMO AND NLMO BASIS SETS,
C  AND THE NLMO DENSITY MATRIX, NLMO FOCK MATRIX, AND NLMO DIPOLE MATRICES:
C
C  REORGANIZE THE SCRATCH VECTOR:
C
C  (DO NOT DESTROY THE WIBERG BOND INDEX!)
C
        I0   = 1 + NATOMS*NATOMS
        I1   = I0 + NDIM*NDIM
        I2   = I1 + NDIM*NDIM
C       IEND = I2 + NDIM*(NDIM+5)
C
C  OUTPUT THE AO-PNLMO TRANSFORMATION AND THE PNLMO OVERLAP MATRIX:
C
        IO = IOINQR(JPRINT(48))
        JO = IOINQR(JPRINT(49))
        IF((IO.EQ.IPRNT.OR.IO.EQ.IWRIT).OR.
     +     (JO.EQ.IPRNT.OR.JO.EQ.IWRIT.OR.JO.EQ.ICHK)) THEN
          CALL FEPNAO(T)
          CALL FETNAB(A(I0))
          CALL MATML1(T,A(I0),A(I1),NDIM,NDIM,NDIM,NBAS,NNAO,NNAO)
          CALL FETLMO(A(I0))
          CALL MATML1(T,A(I0),A(I1),NDIM,NDIM,NDIM,NBAS,NNAO,NNAO)
          CALL FESRAW(A(I0))
          CALL NORMLZ(T,A(I0),NDIM,NBAS,NNAO)
          IF(JO.EQ.ICHK) CALL SVCHK(T,ISPIN)
          IF(JO.EQ.IPRNT.OR.JO.EQ.IWRIT) THEN
            CALL RDELEM(LFNBRK(49))
            TITLE = 'PNLMOs in the AO basis:'
            CALL AOUT(T,NDIM,NBAS,NNAO,TITLE,1,JPRINT(49))
          END IF
          IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
            CALL SIMTR1(A(I0),T,A(I1),NDIM,NBAS,NBAS,NNAO)
            CALL RDELEM(LFNBRK(48))
            TITLE = 'PNLMO overlap matrix:'
            CALL AOUT(A(I0),NDIM,-NNAO,NNAO,TITLE,5,JPRINT(48))
          END IF
        END IF
C
C  FORM THE AO-NLMO TRANSFORMATION MATRIX:
C
        CALL FETNAO(T)
        CALL FETNAB(A(I0))
        CALL MATML1(T,A(I0),A(I1),NDIM,NDIM,NDIM,NBAS,NNAO,NNAO)
        CALL FETLMO(A(I0))
        CALL MATML1(T,A(I0),A(I1),NDIM,NDIM,NDIM,NBAS,NNAO,NNAO)
C
C  SAVE THE AO-NLMO TRANSFORMATION ON NBO DAF:
C
        CALL SVNLMO(T)
C
C  WRITE OUT THE AO-NLMO TRANSFORMATION MATRIX:
C
        IO = IOINQR(JPRINT(23))
        IF(IO.EQ.IWRIT) CALL WRNLMO(T,DM,JPRINT(23))
C
C  PRINT THE AO-NLMO TRANSFORMATION MATRIX:
C
        IF(IO.EQ.IPRNT) THEN
          CALL RDELEM(LFNBRK(23))
          TITLE = 'NLMOs in the AO basis:'
          CALL AOUT(T,NDIM,NBAS,NNAO,TITLE,1,JPRINT(23))
        ELSE IF(IO.EQ.ICHK) THEN
          CALL SVCHK(T,ISPIN)
        END IF
C
C  OUTPUT THE NAO-NLMO TRANSFORMATION MATRIX:
C
        IO = IOINQR(JPRINT(18))
        IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
          CALL FETNAB(A(I0))
          CALL FETLMO(A(I1))
          CALL MATMLT(A(I0),A(I1),A(I2),NDIM,NNAO)
          CALL RDELEM(LFNBRK(18))
          TITLE = 'NLMOs in the NAO basis:'
          CALL AOUT(A(I0),NDIM,NNAO,NNAO,TITLE,2,JPRINT(18))
        END IF
C
C  OUTPUT THE NHO-NLMO TRANSFORMATION MATRIX:
C
        IO = IOINQR(JPRINT(24))
        IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
          CALL FETNHO(A(I0))
          CALL NBTRSP(A(I0),NDIM,NNAO)
          CALL FETNAB(A(I1))
          CALL MATMLT(A(I0),A(I1),A(I2),NDIM,NNAO)
          CALL FETLMO(A(I1))
          CALL MATMLT(A(I0),A(I1),A(I2),NDIM,NNAO)
          CALL RDELEM(LFNBRK(24))
          TITLE = 'NLMOs in the NHO basis:'
          CALL AOUT(A(I0),NDIM,NNAO,NNAO,TITLE,3,JPRINT(24))
        END IF
C
C  OUTPUT THE NBO-NLMO TRANSFORMATION MATRIX:
C
        IO = IOINQR(JPRINT(47))
        IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
          CALL FETLMO(A(I0))
          CALL RDELEM(LFNBRK(47))
          TITLE = 'NLMOs in the NBO basis:'
          CALL AOUT(A(I0),NDIM,NNAO,NNAO,TITLE,4,JPRINT(47))
        END IF
C
C  OUTPUT THE NLMO-MO TRANSFORMATION MATRIX:
C
        IO = IOINQR(JPRINT(13))
        IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
          CALL FRMTMO(T,A(I0),A(I1),A(I2),5,JPRINT(13))
        END IF
C
C  OUTPUT THE NLMO DENSITY MATRIX:
C
        IO = IOINQR(JPRINT(17))
        IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
          CALL RDELEM(LFNBRK(17))
          TITLE = 'NLMO density matrix:'
          CALL AOUT(DM,NDIM,-NNAO,NNAO,TITLE,5,JPRINT(17))
        END IF
C
C  OUTPUT THE NLMO FOCK MATRIX:
C
        IO = IOINQR(JPRINT(15))
        IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
          CALL FEFAO(A(I0),IWFOCK)
          IF(IWFOCK.NE.0) THEN
            CALL SIMTR1(A(I0),T,A(I1),NDIM,NBAS,NBAS,NNAO)
            CALL RDELEM(LFNBRK(15))
            TITLE = 'NLMO Fock matrix:'
            CALL AOUT(A(I0),NDIM,-NNAO,NNAO,TITLE,5,JPRINT(15))
          ELSE
            TITLE = 'NLMO Fock matrix.'
            NT = LENNB(TITLE)
            WRITE(LFNPR,2300) (TITLE(K:K),K=1,NT)
          END IF
        END IF
C
C  WRITE NLMOS IN SPARTAN ARCHIVE FORMAT:
C
        IF(JPRINT(84).LT.0) THEN
          CALL FEFAO(A(I0),IWFOCK)
          IF(IWFOCK.NE.0) THEN
            CALL SIMTR1(A(I0),T,A(I1),NDIM,NBAS,NBAS,NNAO)
            CALL WRSP(A(I0),T,JPRINT(84))
          END IF
        END IF
C
C  OUTPUT THE NLMO KINETIC ENERGY MATRIX:
C
        IO = IOINQR(JPRINT(68))
        IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
          CALL FEKAO(A(I0),IWKIN)
          IF(IWKIN.NE.0) THEN
            CALL SIMTR1(A(I0),T,A(I1),NDIM,NBAS,NBAS,NNAO)
            CALL RDELEM(LFNBRK(68))
            TITLE = 'NLMO kinetic energy matrix:'
            CALL AOUT(A(I0),NDIM,-NNAO,NNAO,TITLE,5,JPRINT(68))
          END IF
        END IF
C
C  OUTPUT THE NLMO 1-e POTENTIAL ENERGY MATRIX:
C
        IO = IOINQR(JPRINT(74))
        IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
          CALL FEVAO(A(I0),IWV1)
          IF(IWV1.NE.0) THEN
            CALL SIMTR1(A(I0),T,A(I1),NDIM,NBAS,NBAS,NNAO)
            CALL RDELEM(LFNBRK(74))
            TITLE = 'NLMO 1-e potential energy matrix:'
            CALL AOUT(A(I0),NDIM,-NNAO,NNAO,TITLE,5,JPRINT(74))
          END IF
        END IF
C
C  OUTPUT THE NLMO DIPOLE MATRICES:
C
        IO = IOINQR(JPRINT(54))
        IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
          IX = 1
          CALL FEDXYZ(A(I0),IX)
          IF(IX.NE.0) THEN
            CALL SIMTR1(A(I0),T,A(I1),NDIM,NBAS,NBAS,NNAO)
            CALL RDELEM(LFNBRK(54))
            TITLE = 'NLMO x dipole integrals:'
            CALL AOUT(A(I0),NDIM,-NNAO,NNAO,TITLE,5,JPRINT(54))
          END IF
          IX = 2
          CALL FEDXYZ(A(I0),IX)
          IF(IX.NE.0) THEN
            CALL SIMTR1(A(I0),T,A(I1),NDIM,NBAS,NBAS,NNAO)
            CALL RDELEM(LFNBRK(54))
            TITLE = 'NLMO y dipole integrals:'
            CALL AOUT(A(I0),NDIM,-NNAO,NNAO,TITLE,5,JPRINT(54))
          END IF
          IX = 3
          CALL FEDXYZ(A(I0),IX)
          IF(IX.NE.0) THEN
            CALL SIMTR1(A(I0),T,A(I1),NDIM,NBAS,NBAS,NNAO)
            CALL RDELEM(LFNBRK(54))
            TITLE = 'NLMO z dipole integrals:'
            CALL AOUT(A(I0),NDIM,-NNAO,NNAO,TITLE,5,JPRINT(54))
          END IF
        END IF
C
C  PRINT OUT THE NBO STERIC ANALYSIS
C
C  REORGANIZE THE SCRATCH VECTOR:
C
        I0   = 1
        I1   = I0 + NATOMS*NATOMS
        I2   = I1 + NDIM
        I3   = I2 + NDIM*NDIM
        I4   = I3 + NDIM*NDIM
        I5   = I4 + NDIM*NDIM
        I6   = I5 + NDIM*NDIM
        IF(JPRINT(76).NE.0) THEN
          IF(IWFOCK.NE.0) THEN
            IF(JPRINT(76).EQ.1) THEN
              LFNSTR=0
            ELSE
              LFNSTR=JPRINT(76)
            END IF
            CALL NBSTER(A(I2),A(I3),A(I4),A(I5),A(I6),LFNSTR)
          ELSE
            WRITE(LFNPR,2100)
          ENDIF
        END IF
C
C  PERFORM THE NBO/NLMO DIPOLE MOMENT ANALYSIS:
C
C  DM   :  NLMO DENSITY MATRIX
C  T    :  AO-NLMO TRANSFORMATION MATRIX
C  A(I1):  C(NDIM,NDIM)
C  A(I2):  TNBO(NDIM,NDIM)
C  A(I3):  DX(NDIM,NDIM)
C  A(I4):  DY(NDIM,NDIM)
C  A(I5):  DZ(NDIM,NDIM)
C  A(I6):  SCR(NDIM,NDIM)
C  A(I7):  INDEX(NDIM)
C
C  (DO NOT DESTROY THE WIBERG BOND INDEX!)
C
        IF(JPRINT(46).NE.0) THEN
          I1   = 1 + NATOMS*NATOMS
          I2   = I1 + NDIM*NDIM
          I3   = I2 + NDIM*NDIM
          I4   = I3 + NDIM*NDIM
          I5   = I4 + NDIM*NDIM
          I6   = I5 + NDIM*NDIM
          I7   = I6 + NDIM*NDIM
          I8   = I7 + NATOMS*2
C         IEND = I8 + NDIM
          CALL DIPANL(DM,T,A(I1),A(I2),A(I3),A(I4),A(I5),A(I6),A(I7),
     +                 A(I8))
        END IF
C   Perform the NJC natural J-coupling analysis
        IF(IWNJC.NE.0) THEN
          I2  = 1   + NATOMS*NATOMS     ! TBL(NDIM,NDIM)
          I3  = I2  + NDIM*NDIM         ! FCG(NDIM,NATOMS)
          I4  = I3  + NDIM*NATOMS       ! FCB(NDIM,NATOMS)
          I5  = I4  + NDIM*NATOMS       ! FCL(NDIM,NATOMS)
          I6  = I5  + NDIM*NATOMS       ! TBLA
          I7  = I6  + NDIM*NDIM         ! TBLB
          I8  = I7  + NDIM*NDIM         ! FCBA
          I9  = I8  + NDIM*NATOMS       ! FCBB
          I10 = I9  + NDIM*NATOMS       ! FCLA
          I11 = I10 + NDIM*NATOMS       ! FCLB
          I12 = I11 + NDIM*NATOMS       ! DJI_NL
          I13 = I12 + NDIM*NDIM         ! DI_L
          I14 = I13 + NDIM              ! DPJI_NL
          I15 = I14 + NDIM*NDIM         ! DPI_L
          I16 = I15 + NDIM              ! SCR1
          I17 = I16 + NDIM*NDIM         ! SCR2
          I18 = I17 + NDIM*NDIM         ! V1
          I19 = I18 + NDIM              ! V2
          I20 = I19 + NDIM              ! V3
          I21 = I20 + NDIM              ! V4
C         IEND = I21 + NDIM
          CALL NJC(A(I2),A(I3),A(I4),A(I5),
     +     A(I6),A(I7),A(I8),A(I9),A(I10),A(I11),A(I12),
     +     A(I13),A(I14),A(I15),A(I16),A(I17),A(I18),A(I19),
     +     A(I20),A(I21),LFNPR)
        ENDIF
C
C   Perform the NCS (NLMO/NBO) NMR shielding tensor analysis
C  A(I1):  A(NDIM,NDIM)    =  NBO=>NLMO transformation
C  A(I2):  B(NDIM,NDIM)    =  AO=>NBO   transformation
C  A(I3):  C(NDIM,NDIM)    =  AO=>MO    transformation
C  A(I4):  D(NDIM,NDIM)    =  AO=>NLMO  transformation
C  A(I5):  T(NDIM,NDIM)    =  NLMO=>MO  transformation
C  A(I6):  H01(NDIM,NDIM)  =  scratch placeholder for H01 matrices
C  A(I7):  C10X(NDIM,NOCC) =  1st-order perturbation coefficients (X)
C  A(I8):  C10Y(NDIM,NOCC) =  1st-order perturbation coefficients (Y)
C  A(I9):  C10Z(NDIM,NOCC) =  1st-order perturbation coefficients (Z)
C  A(I10): ENER(NDIM)      =  MO orbital energies
C  A(I11): SCR1(NDIM,NDIM) =  scratch
C  A(I12): SCR2(NDIM,NDIM) =  scratch
C  A(I13): SCR3(NDIM,NDIM) =  scratch
C  A(I14): SCR4(NDIM,NDIM) =  scratch
C  (saves the Wiberg bond index matrix!)
C
C***********************************************************************G03DRV
C  NCS is currently supported also by Gaussian 03 implementation        G03DRV
*       IF(JPRINT(86).NE.0) THEN                                        G03DRV
*         I1   = 1 + NATOMS*NATOMS                                      G03DRV
*         I2   = I1 + NDIM*NDIM                                         G03DRV
*         I3   = I2 + NDIM*NDIM                                         G03DRV
*         I4   = I3 + NDIM*NDIM                                         G03DRV
*         I5   = I4 + NDIM*NDIM                                         G03DRV
*         I6   = I5 + NDIM*NDIM                                         G03DRV
*         I7   = I6 + NDIM*NDIM                                         G03DRV
*         I8   = I7 + NDIM*NOCC                                         G03DRV
*         I9   = I8 + NDIM*NOCC                                         G03DRV
*         I10  = I9 + NDIM*NOCC                                         G03DRV
*         I11  = I10 + NDIM                                             G03DRV
*         I12  = I11 + NDIM*NDIM                                        G03DRV
*         I13  = I12 + NDIM*NDIM                                        G03DRV
*         I14  = I13 + NDIM*NDIM                                        G03DRV
*         IEND = I14 + NDIM*NDIM                                        G03DRV
*         CALL NCSMAT(A(I7),A(IEND),MEMORY-IEND-1,NCANDO)               G03DRV
*         CALL NCSANL(NATOMS,NDIM,NOCC,A(I1),A(I2),A(I3),A(I4),A(I5),   G03DRV
*    +                A(I6),A(I7),A(I8),A(I9),A(I10),LFNPR,             G03DRV
*    +                A(I11),A(I12),A(I13),A(I14),JPRINT(86))           G03DRV
*       END IF                                                          G03DRV
C***********************************************************************G03DRV
C***********************************************************************G98DRV
C  NCS is currently supported only by Gaussian 9X implementation        G98DRV
*       IF(JPRINT(86).NE.0) THEN                                        G98DRV
*         I1   = 1 + NATOMS*NATOMS                                      G98DRV
*         I2   = I1 + NDIM*NDIM                                         G98DRV
*         I3   = I2 + NDIM*NDIM                                         G98DRV
*         I4   = I3 + NDIM*NDIM                                         G98DRV
*         I5   = I4 + NDIM*NDIM                                         G98DRV
*         I6   = I5 + NDIM*NDIM                                         G98DRV
*         I7   = I6 + NDIM*NDIM                                         G98DRV
*         I8   = I7 + NDIM*NOCC                                         G98DRV
*         I9   = I8 + NDIM*NOCC                                         G98DRV
*         I10  = I9 + NDIM*NOCC                                         G98DRV
*         I11  = I10 + NDIM                                             G98DRV
*         I12  = I11 + NDIM*NDIM                                        G98DRV
*         I13  = I12 + NDIM*NDIM                                        G98DRV
*         I14  = I13 + NDIM*NDIM                                        G98DRV
*         IEND = I14 + NDIM*NDIM                                        G98DRV
*         CALL NCSMAT(A(I7),A(IEND),MEMORY-IEND-1)                      G98DRV
*         CALL NCSANL(NATOMS,NDIM,NOCC,A(I1),A(I2),A(I3),A(I4),A(I5),   G98DRV
*    +                A(I6),A(I7),A(I8),A(I9),A(I10),LFNPR,             G98DRV
*    +                A(I11),A(I12),A(I13),A(I14),JPRINT(86))           G98DRV
*       END IF                                                          G98DRV
C***********************************************************************G98DRV
      END IF
C----------------- END OF NLMO ------------------
   20 CONTINUE
C
C  PERFORM NATURAL RESONANCE THEORY ANALYSIS:
C
      IF(JPRINT(32).NE.0) THEN
        IVALSP = 0
C
C  CAREFULLY DETERMINE THE MAXIMUM NUMBER OF RESONANCE STRUCTURES
C  (MAXRES) THAT THE SCRATCH VECTOR CAN ACCOMODATE:
C
   70   NEL = 6
        NLOW = NATOMS * (NATOMS - 1) / 2
        MAXREF = ABS(JPRINT(56))
        TOT = ZERO
        DO 80 IBAS = 1,NNAO
          TOT = TOT + DM(IBAS,IBAS)
   80   CONTINUE
        NELEC = NINT(TOT)
        NVAL  = 0
        DO 90 IBAS = 1,NNAO
          IF(LTYP(IBAS).EQ.IVAL) NVAL = NVAL + 1
   90   CONTINUE
        NAO = NVAL
        IF(JPRINT(77).NE.0) NAO = NNAO
        LNAO = NAO * (NAO + 1) / 2
C
C  ASSUME NDIM IS LARGER THAN MAXRES (NOT USUALLY THE CASE):
C
        IC = 5*NDIM*NDIM + 15*NDIM + MXAO*NDIM + 2*MXBO*MXBO +
     +       2*MXBO + 2*MXAO*MXAO + 3*MXAO + 2*NATOMS*NATOMS +
     +       2*NDIM*MAXREF + 5*MAXREF + LNAO + LNAO*MAXREF - MEMORY
        IB = NDIM*MAXREF + 9*MAXREF + NLOW*MAXREF + 6 +
     +       NATOMS*NEL*MAXREF/2
        IA = 1
        RA = DFLOAT(IA)
        RB = DFLOAT(IB)
        RC = DFLOAT(IC)
        DET = SQRT(RB*RB - 4.0D0*RA*RC)
        MAXRES = INT((-RB+DET) / (2.0D0*RA))
C
C  CHECK THIS ASSUMPTION:
C
        IF(MAXRES.GT.NDIM) THEN
          IC = IC - 2*NDIM*NDIM
          IA = IA + 2
          RA = DFLOAT(IA)
          RC = DFLOAT(IC)
          DET = SQRT(RB*RB - 4.0D0*RA*RC)
          MAXRES = INT((-RB+DET) / (2.0D0*RA))
        END IF
        IF(MAXRES.GT.NDIM*NDIM) THEN
          IC = IC - NDIM*NDIM
          IB = IB + 1
          RB = DFLOAT(IB)
          RC = DFLOAT(IC)
          DET = SQRT(RB*RB - 4.0D0*RA*RC)
          MAXRES = INT((-RB+DET) / (2.0D0*RA))
        END IF
C
C  ASSUME THAT THERE WILL BE ROUGHLY 6(=NEL) ELEMENTS REQUIRED PER ATOM
C  TO STORE THE TOPO MATRICES FOR EACH RESONANCE STRUCTURE: (1 FOR NUMBER
C  OF BONDS, 1 FOR NUMBER OF LONE PAIRS, AND 4 BONDED ATOMS -- SEE SR
C  TOPSTR, THIS IS ONLY AN ESTIMATE OF THE STORAGE REQUIREMENT, BUT IT
C  SHOULD BE SUFFICIENT FOR MOST CASES)
C
        LEN = NEL * NATOMS * MAXRES * MAXREF / 2
C
C  PARTITION THE SCRATCH VECTOR:
C
        I0  = 1
        I1  = I0 + NATOMS*NATOMS
        I2  = I1 + MAXRES*MAXREF
        I3  = I2 + MAXRES*MAXREF
        I4  = I3 + MAXREF
        I5  = I4 + MAXREF
        MEM = MEMORY - I5 + 1
        CALL NRTDRV(DM,T,A(I0),A(I1),A(I2),A(I3),A(I4),A(I5),MAXRES,
     +              MAXREF,NLOW,NAO,LEN,NELEC,MEM,IVALSP)
C
C  REALLOCATE SCRATCH VECTOR AND REPEAT NRT ACCORDING TO IVALSP:
C
        IF(IVALSP.EQ.1.OR.IVALSP.EQ.2.OR.
     +     IVALSP.EQ.4.OR.IVALSP.EQ.5) THEN
          JPRINT(77) = 1
          IVALSP = -1
          GO TO 70
        END IF
      END IF
C
C  END OF TASKS
C
      RETURN
C
 1390 FORMAT(/1X,'WARNING:  The $CHOOSE keylist is incompatible with ',
     + 'the NRT analysis for open',/1X,'          shell NBO analyses.',
     + '  Program execution will continue, ignoring the',/1X,'       ',
     + '   $CHOOSE keylist.')
 1400 FORMAT(//1X,'NATURAL BOND ORBITAL ANALYSIS:')
 1410 FORMAT(//1X,'NATURAL BOND ORBITAL ANALYSIS,',
     * ' alpha spin orbitals:')
 1420 FORMAT(//1X,'NATURAL BOND ORBITAL ANALYSIS,',
     * ' beta spin orbitals:')
 1430 FORMAT(/1X,'NLMO search abandoned.')
 1440 FORMAT(/1X,'WARNING:  Non-physical occupancies were found in ',
     * 'NAO search.',/11X,'NBO will attempt to continue.')
 2000 FORMAT(//1X,'NBO analysis skipped by request.')
 2010 FORMAT(//1X,'Default NBO analysis not performed for open-shell',
     * ' MCSCF;',/4X,'must specify MSPNBO keyword.')
 2100 FORMAT(/1X,'Fock matrix unavailable for this wavefunction;',
     * ' can''t perform steric analysis.')
 2300 FORMAT(/1X,'Fock matrix unavailable for this wavefunction;',
     * ' can''t print ',80A1)
 2400 FORMAT(/1X,'Fock matrix unavailable for this wavefunction;',
     * ' can''t perform analysis of',/,4x,
     * 'canonical molecular orbitals.')
      END
C***********************************************************************
C
C  ROUTINES CALLED BY THE NAO DRIVERS:
C
C      SUBROUTINE SIMTRM(A,S,V,NDIM,N,IWMULP,IWCUBF)
C      SUBROUTINE MULANA(BS,VMAYER,BMAYER,IWMULP,IWCUBF)
C      SUBROUTINE DFGORB(DM,T,RENORM,TPAO)
C      SUBROUTINE NAO(T,S,OCC,BLK,SBLK,EVAL,C,EVECT,SCR,LISTAO,NBLOCK)
C      SUBROUTINE NAOANL(DM,SPNAO,BINDEX,BINDT,BMO,OVPOP,F,ENAO,SCR)
C      SUBROUTINE FRMTMO(T,TMO,C,SCR,INDEX,IFLG)
C
C***********************************************************************
      SUBROUTINE SIMTRM(A,S,V,NDIM,N,IWMULP,IWCUBF)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  SIMILARITY TRANSFORM A ==> S(TRANSPOSE)*A*S, USING SCRATCH VECTOR V.
C   WRITE THE DIAGONAL ELEMENTS OF A*S BY CALLING SUBROUTINE MULANA IF
C          IWMULP.NE.0
C     (THESE ARE THE MULLIKEN POPULATIONS IF S= OVERLAP MATRIX
C                                       AND A= BOND-ORDER MATRIX)
C
      DIMENSION A(NDIM,NDIM),S(NDIM,NDIM),V(*)
      CALL MATMLT(A,S,V,NDIM,N)
      I1=NDIM+1
      IF(IWMULP.NE.0) CALL MULANA(A,V(1),V(I1),IWMULP,IWCUBF)
      CALL MATML2(S,A,V,NDIM,N)
      RETURN
      END
C***********************************************************************
      SUBROUTINE MULANA(BS,VMAYER,BMAYER,IWMULP,IWCUBF)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
C
C  PERFORM MAYER-MULLIKEN BOND ORDER ANALYSIS
C
C  PRINT OUT DIAGONAL ELEMENTS OF BS=B*S, WHERE
C      B= BOND-ORDER MATRIX,   S= OVERLAP MATRIX,   BOTH IN ORIGINAL AO BASIS
C   THIS CONSTITUTES A MULLIKEN POPULATION ANALYSIS.
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),LSTEMT(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      DIMENSION BS(NDIM,NDIM),VMAYER(NATOMS),BMAYER(NATOMS,NATOMS),
     *          IANG(5),ANGL(60),LANG(60),CUBICF(7)
      CHARACTER*80 TITLE
C
      SAVE IANG,LANG,ANGL,CUBICF,ZERO
      DATA IANG/1Hs,1Hp,1Hd,1Hf,1Hg/
      DATA LANG/ 51,151,152,153,251,252,253,254,255,
     *          351,352,353,354,355,356,357,
     *          451,452,453,454,455,456,457,458,459,
     *            1,101,102,103,201,202,203,204,205,206,
     *          301,302,303,304,305,306,307,308,309,310,
     *          401,402,403,404,405,406,407,408,409,410,
     *          411,412,413,414,415/
      DATA ANGL/4H    ,4Hx   ,4Hy   ,4Hz   ,4Hxy  ,4Hxz  ,4Hyz  ,
     *   4Hx2y2,4Hz2  ,4H(0) ,4H(c1),4H(s1),4H(c2),4H(s2),4H(c3),
     *   4H(s3),4H(0) ,4H(c1),4H(s1),4H(c2),4H(s2),4H(c3),4H(s3),
     *   4H(c4),4H(s4),
     *          4H    ,4Hx   ,4Hy   ,4Hz   ,4Hxx  ,4Hxy  ,4Hxz  ,
     *   4Hyy  ,4Hyz  ,4Hzz  ,4Hxxx ,4Hxxy ,4Hxxz ,4Hxyy ,4Hxyz ,
     *   4Hxzz ,4Hyyy ,4Hyyz ,4Hyzz ,4Hzzz ,4Hxxxx,4Hxxxy,4Hxxxz,
     *   4Hxxyy,4Hxxyz,4Hxxzz,4Hxyyy,4Hxyyz,4Hxyzz,4Hxzzz,4Hyyyy,
     *   4Hyyyz,4Hyyzz,4Hyzzz,4Hzzzz/
      DATA CUBICF/4H(d1),4H(d2),4H(d3),4H(b) ,4H(e1),4H(e2),4H(e3)/
      DATA ZERO/0.0D0/
C
      IF(IWCUBF.EQ.0) GO TO 20
C  IF THE F FUNCTIONS ARE A CUBIC SET, INSERT THE PROPER LABELS:
        DO 10 I=1,7
          II=I+9
   10     ANGL(II)=CUBICF(I)
   20 CONTINUE
      IF(IWMULP.EQ.1) WRITE(LFNPR,1000)
      IF(IWMULP.EQ.2) WRITE(LFNPR,1100)
      IF(IWMULP.EQ.2) WRITE(LFNPR,1200)
      SUMT=ZERO
      DO 100 I=1,NATOMS
        VMAYER(I)=ZERO
        DO 100 J=1,NATOMS
  100     BMAYER(I,J)=ZERO
      DO 300 IAT=1,NATOMS
        IZ=IATNO(IAT)
        NAM=NAMEAT(IZ)
        SUMAT=ZERO
        DO 200 I=1,NBAS
          IF(LBL(I).NE.IAT) GO TO 200
          LM=LORBC(I)
          L=LM/100
          IL=IANG(L+1)
          DO 130 ILM=1,60
            IF(LM.EQ.LANG(ILM)) GO TO 140
 130      CONTINUE
C
          CALL NBHALT('Error in SR MULANA')
 140      CONTINUE
          OCC=BS(I,I)
          SUMAT=SUMAT+OCC
        IF(IWMULP.EQ.2) WRITE(LFNPR,1300) I,NAM,IAT,IL,ANGL(ILM),OCC
        DO 180 J=1,NBAS
          JAT=LBL(J)
          IF(JAT.EQ.IAT) GO TO 180
          BMAYER(IAT,JAT)=BMAYER(IAT,JAT)+BS(I,J)*BS(J,I)
  180     CONTINUE
  200   CONTINUE
        IF(IWMULP.EQ.1) WRITE(LFNPR,1800) NAM,IAT,SUMAT
        IF(IWMULP.EQ.2) WRITE(LFNPR,1900) NAM,IAT,SUMAT
  300   SUMT=SUMT+SUMAT
      IF(IWMULP.NE.0) WRITE(LFNPR,1600) SUMT
      TITLE = 'Mayer-Mulliken atom-atom bond order matrix:'
      CALL AOUT(BMAYER,NATOMS,NATOMS,NATOMS,TITLE,0,NATOMS)
      DO 310 I=1,NATOMS
        DO 310 J=1,NATOMS
  310     VMAYER(I)=VMAYER(I)+BMAYER(I,J)
      TITLE = 'Mayer-Mulliken valencies by atom:'
      CALL AOUT(VMAYER,NATOMS,NATOMS,1,TITLE,0,1)
      RETURN
 1000 FORMAT(//1X,'Total gross Mulliken populations by atom:',
     * //4X,'Atom No',6X,'Total')
 1100 FORMAT(//1X,'Input atomic orbitals, gross Mulliken populations:',
     +//1X,' AO',2X,'Atom No',1X,'lang',2X,'Mulliken Population',
     +4X,'Atom No',6X,'Total')
 1200 FORMAT(1X,79('-'))
 1300 FORMAT(I4,3X,A2,I3,2X,A1,A4,F13.7)
 1600 FORMAT(/1X,'Total number of electrons: ',F11.6)
 1800 FORMAT(5X,A2,I3,F15.7)
 1900 FORMAT(44X,A2,I3,F15.7)
      END
C***********************************************************************
      SUBROUTINE DFGORB(DM,T,RENORM,TPAO)
C***********************************************************************
C 19-Jan-93  EDG  Checkpoint the AO-PAO transformation
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL FIRST
      CHARACTER*80 TITLE
C
C  FORM THE AO TO PURE AO TRANSFORMATION MATRIX (IN TPAO) AND TRANSFORM
C  THE DENSITY MATRIX (IN DM) AND OVERLAP MATRIX (IN T) TO THE PAO BASIS:
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LIST(6,MAXBAS),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),LSTEMT(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBAO/LCTR(MAXBAS),LLM(MAXBAS)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION DM(NDIM,NDIM),T(NDIM,NDIM),RENORM(NDIM),TPAO(NDIM,NDIM)
      DIMENSION A(6,6),B(6),M(6)
      DIMENSION LF(3,3),LFCUB(3,3),LFT(3,3),LFCUBT(3,3),LG(3,3),LGT(3,3)
C
      SAVE LF,LFCUB,LFT,LFCUBT,LG,LGT
      SAVE EPS,ZERO,ONE,TWO,THREE,FOUR,FIVE,SIX,SEVEN,EIGHT
      SAVE IWRIT,IPRNT,ICHK
      DATA LF    /301,304,306,302,307,309,303,308,310/
      DATA LFCUB /306,304,301,309,302,307,303,308,310/
      DATA LFT   /151,356,352,152,357,353,153,354,351/
      DATA LFCUBT/151,355,351,152,356,352,153,357,353/
      DATA LG    /402,407,409,403,408,410,405,412,414/
      DATA LGT   /251,455,459,252,452,456,253,453,457/
      DATA EPS,ZERO,ONE,TWO,THREE,FOUR,FIVE,SIX,SEVEN,EIGHT
     *    /1.0D-5,0.0D0,1.0D0,2.0D0,3.0D0,4.0D0,5.0D0,6.0D0,7.0D0,8.0D0/
      DATA IWRIT,IPRNT,ICHK/4HWRIT,4HPRNT,3HCHK/
C
C  INITIALIZE LABELS AND TPAO MATRIX:
C
      DO 10 I = 1,NBAS
        LORB(I) = 0
        DO 5 J = 1,NBAS
          TPAO(J,I) = ZERO
   5    CONTINUE
        TPAO(I,I) = ONE
  10  CONTINUE
C
C  INITIALIZE COUNTERS:
C
      N1 = 0
      N2 = 0
      N3 = 0
      N4 = 0
      N5 = 0
      N6 = 0
C
C  CONSTRUCT ARRAY LIST:
C
      DO 20 IBAS = 1,NBAS
        IF(LORBC(IBAS).EQ.201) THEN
          N1 = N1 + 1
          LIST(1,N1) = IBAS
        ELSE IF(LORBC(IBAS).EQ.204) THEN
          N2 = N2 + 1
          LIST(2,N2) = IBAS
        ELSE IF(LORBC(IBAS).EQ.206) THEN
          N3 = N3 + 1
          LIST(3,N3) = IBAS
        ELSE IF(LORBC(IBAS).EQ.202) THEN
          N4 = N4 + 1
          LORB(IBAS) = 251
        ELSE IF(LORBC(IBAS).EQ.203) THEN
          N5 = N5 + 1
          LORB(IBAS) = 252
        ELSE IF(LORBC(IBAS).EQ.205) THEN
          N6 = N6 + 1
          LORB(IBAS) = 253
        END IF
   20 CONTINUE
C
C  MAKE SURE THERE IS A COMPLETE SET OF D FUNCTIONS:
C
      IF(N1.NE.N2.OR.N1.NE.N3.OR.N1.NE.N4.OR.N1.NE.N5.OR.N1.NE.N6) THEN
        WRITE(LFNPR,900)
        CALL NBHALT('Incorrect number of d functions found.')
      END IF
C
      IDTRAN = N1
      IF(IDTRAN.EQ.0) GO TO 60
C
C  SET UP TRANSFORMATION TO PURE D SET:
C
C  S=R2=X2+Y2+Z2:
C
      A(1,1) =  ONE
      A(2,1) =  ONE
      A(3,1) =  ONE
C
C  D(X2-Y2):
C
      A(1,2) =  ONE
      A(2,2) = -ONE
      A(3,2) =  ZERO
C
C  D(3Z2-R2)=-X2-Y2+2Z2:
C
      A(1,3) = -ONE
      A(2,3) = -ONE
      A(3,3) =  TWO
C
C  LOOP OVER D SETS IN LIST:
C
      DO 50 ID = 1,IDTRAN
        M(1) = LIST(1,ID)
        M(2) = LIST(2,ID)
        M(3) = LIST(3,ID)
C
C  TRANSFORM OVERLAP, DENSITY, AND TRANSFORMATION MATRICES:
C
        CALL LIMTRN(T,M,A,B,NDIM,NBAS,6,3,0)
        CALL LIMTRN(DM,M,A,B,NDIM,NBAS,6,3,0)
        CALL LIMTRN(TPAO,M,A,B,NDIM,NBAS,6,3,1)
C
C  SET THE ORBITAL LABELS FOR THE 3 ORBITALS TRANSFORMED:
C
        LORB(M(1)) =  51
        LORB(M(2)) = 254
        LORB(M(3)) = 255
   50 CONTINUE
   60 CONTINUE
C
C  NOW DO F ORBITALS:
C
      IFTRAN = 0
      DO 120 IFBLK = 1,3
        N1 = 0
        N2 = 0
        N3 = 0
        IF(IWCUBF.EQ.0) THEN
          LF1 = LF(1,IFBLK)
          LF2 = LF(2,IFBLK)
          LF3 = LF(3,IFBLK)
        ELSE
          LF1 = LFCUB(1,IFBLK)
          LF2 = LFCUB(2,IFBLK)
          LF3 = LFCUB(3,IFBLK)
        END IF
C
C  CONSTRUCT THE LIST:
C
        DO 70 IBAS = 1,NBAS
          IF(LORBC(IBAS).EQ.LF1) THEN
            N1 = N1 + 1
            LIST(1,N1) = IBAS
          ELSE IF(LORBC(IBAS).EQ.LF2) THEN
            N2 = N2 + 1
            LIST(2,N2) = IBAS
          ELSE IF(LORBC(IBAS).EQ.LF3) THEN
            N3 = N3 + 1
            LIST(3,N3) = IBAS
          END IF
   70   CONTINUE
C
C  MAKE SURE THERE IS A COMPLETE SET OF F FUNCTIONS:
C
        IF(IFBLK.EQ.1) IFTRAN = N1
        IF(N1.NE.N2.OR.N1.NE.N3.OR.N1.NE.IFTRAN) THEN
          WRITE(LFNPR,910)
          CALL NBHALT('Incorrect number of f functions found.')
        END IF
        IF(IFTRAN.EQ.0) GO TO 140
        IF(IWCUBF.NE.0) THEN
C
C  SET UP TRANSFORMATIONS FOR CUBIC F ORBITALS:
C
C  PX=X*R2, PY=Y*R2, PZ=Z*R2
C
          A(1,1) =  ONE
          A(2,1) =  ONE
          A(3,1) =  ONE
C
C  FX(Z2-Y2), FY(Z2-X2), FZ(X2-Y2)
C
          A(1,2) =  ONE
          A(2,2) = -ONE
          A(3,2) =  ZERO
C
C  FX(5Z2-3R2), FY(5Y2-3R2), FZ(5Z2-3R2)
C
          A(1,3) = -THREE
          A(2,3) = -THREE
          A(3,3) =  TWO
C
C  INCLUDE NORMALIZATION FACTORS FOR CERTAIN COMPONENTS:
C  (THESE ARISE BECAUSE COMPONENTS SUCH AS X^3 AND XY^2 HAVE DIFFERENT
C  NORMALIZATION CONSTANTS)
C
          DO 80 I = 1,3
            A(3,I) = A(3,I) * SQRT(FIVE)
   80     CONTINUE
        ELSE
C
C  SET UP TRANSFORMATION FOR FIRST F BLOCK:
C
          IF(IFBLK.EQ.1) THEN
C
C  PX=X*R2
C
            A(1,1) =  ONE
            A(2,1) =  ONE
            A(3,1) =  ONE
C
C  FX(X2-3Y2)
C
            A(1,2) =  ONE
            A(2,2) = -THREE
            A(3,2) =  ZERO
C
C  FX(5Z2-R2)
C
            A(1,3) = -ONE
            A(2,3) = -ONE
            A(3,3) =  FOUR
C
C  SET UP TRANSFORMATION FOR SECOND F BLOCK:
C
          ELSE IF(IFBLK.EQ.2) THEN
C
C  PY=Y*R2
C
            A(1,1) =  ONE
            A(2,1) =  ONE
            A(3,1) =  ONE
C
C  FY(3X2-Y2)
C
            A(1,2) =  THREE
            A(2,2) = -ONE
            A(3,2) =  ZERO
C
C  FY(5Z2-R2)
C
            A(1,3) = -ONE
            A(2,3) = -ONE
            A(3,3) =  FOUR
C
C  SET UP TRANSFORMATION FOR THIRD F BLOCK:
C
          ELSE IF(IFBLK.EQ.3) THEN
C
C  PZ=Z*R2
C
            A(1,1) =  ONE
            A(2,1) =  ONE
            A(3,1) =  ONE
C
C  FZ(X2-Y2)
C
            A(1,2) =  ONE
            A(2,2) = -ONE
            A(3,2) =  ZERO
C
C  FZ(5Z2-3R2)
C
            A(1,3) = -THREE
            A(2,3) = -THREE
            A(3,3) =  TWO
          ELSE
            CALL NBHALT('IFBLK out of bounds in SR DFGORB')
          END IF
C
C  INCLUDE NORMALIZATION FACTORS:
C
          DO 90 I = 1,3
            A(IFBLK,I) = A(IFBLK,I) * SQRT(FIVE)
   90     CONTINUE
        END IF
C
C  LOOP OVER F SETS IN LIST:
C
        DO 100 IT = 1,IFTRAN
          M(1) = LIST(1,IT)
          M(2) = LIST(2,IT)
          M(3) = LIST(3,IT)
C
C  TRANSFORM OVERLAP, DENSITY, AND TRANSFORMATION MATRICES:
C
          CALL LIMTRN(T,M,A,B,NDIM,NBAS,6,3,0)
          CALL LIMTRN(DM,M,A,B,NDIM,NBAS,6,3,0)
          CALL LIMTRN(TPAO,M,A,B,NDIM,NBAS,6,3,1)
C
C  FIX THE ORBITAL LABELS FOR THE 3 ORBITALS TRANSFORMED:
C
          IF(IWCUBF.EQ.0) THEN
            LORB(M(1)) = LFT(1,IFBLK)
            LORB(M(2)) = LFT(2,IFBLK)
            LORB(M(3)) = LFT(3,IFBLK)
          ELSE
            LORB(M(1)) = LFCUBT(1,IFBLK)
            LORB(M(2)) = LFCUBT(2,IFBLK)
            LORB(M(3)) = LFCUBT(3,IFBLK)
          END IF
  100   CONTINUE
  120 CONTINUE
C
C   SEARCH FOR FXYZ AND RELABEL:
C
      LF1  = 305
      IF(IWCUBF.EQ.0) THEN
        LF1T = 355
      ELSE
        LF1T = 354
      END IF
      N1 = 0
      DO 130 IBAS = 1,NBAS
        IF(LORBC(IBAS).EQ.LF1) THEN
          N1 = N1 + 1
          LORB(IBAS) = LF1T
        END IF
  130 CONTINUE
C
      IF(IFTRAN.NE.N1) THEN
        WRITE(LFNPR,910)
        CALL NBHALT('Incorrect number of f functions found.')
      END IF
  140 CONTINUE
C
C  FINALLY, DO G ORBITALS:
C
      IGTRAN = 0
      DO 190 IGBLK = 1,3
        N1 = 0
        N2 = 0
        N3 = 0
        LG1 = LG(1,IGBLK)
        LG2 = LG(2,IGBLK)
        LG3 = LG(3,IGBLK)
C
C  CONSTRUCT THE LIST:
C
        DO 150 IBAS = 1,NBAS
          LANG = LORBC(IBAS)
          IF(LANG.EQ.LG1) THEN
            N1 = N1 + 1
            LIST(1,N1) = IBAS
          ELSE IF(LANG.EQ.LG2) THEN
            N2 = N2 + 1
            LIST(2,N2) = IBAS
          ELSE IF(LANG.EQ.LG3) THEN
            N3 = N3 + 1
            LIST(3,N3) = IBAS
          END IF
  150   CONTINUE
C
C  MAKE SURE THERE IS A COMPLETE SET OF G FUNCTIONS:
C
        IF(IGBLK.EQ.1) IGTRAN = N1
        IF(N1.NE.N2.OR.N1.NE.N3.OR.N1.NE.IGTRAN) THEN
          WRITE(LFNPR,920)
          CALL NBHALT('Incorrect number of g functions found.')
        END IF
        IF(IGTRAN.EQ.0) GO TO 240
C
C  SET UP TRANSFORMATION FOR FIRST G BLOCK:
C
        IF(IGBLK.EQ.1) THEN
C
C  DXY=XY*R2
C
          A(1,1) =  ONE
          A(2,1) =  ONE
          A(3,1) =  ONE
C
C  G(2S)
C
          A(1,2) =  ONE
          A(2,2) =  ONE
          A(3,2) = -SIX
C
C  G(4S)
C
          A(1,3) =  ONE
          A(2,3) = -ONE
          A(3,3) =  ZERO
C
C  SET UP TRANSFORMATION FOR SECOND G BLOCK:
C
        ELSE IF(IGBLK.EQ.2) THEN
C
C  DXZ=XZ*R2
C
          A(1,1) =  ONE
          A(2,1) =  ONE
          A(3,1) =  ONE
C
C  G(1C)
C
          A(1,2) = -THREE
          A(2,2) = -THREE
          A(3,2) =  FOUR
C
C  G(3C)
C
          A(1,3) =  ONE
          A(2,3) = -THREE
          A(3,3) =  ZERO
C
C  SET UP TRANSFORMATION FOR THIRD G BLOCK:
C
        ELSE IF(IGBLK.EQ.3) THEN
C
C  DYZ=YZ*R2
C
          A(1,1) =  ONE
          A(2,1) =  ONE
          A(3,1) =  ONE
C
C  G(1S)
C
          A(1,2) = -THREE
          A(2,2) = -THREE
          A(3,2) =  FOUR
C
C  G(3S)
C
          A(1,3) =  THREE
          A(2,3) = -ONE
          A(3,3) =  ZERO
        ELSE
          CALL NBHALT('IGBLK out of bounds in SR DFGORB')
        END IF
C
C  NORMALIZATION FACTORS:
C
        J = 3 - IGBLK + 1
        DO 160 I = 1,3
          A(J,I) = A(J,I) / SQRT(FIVE)
  160   CONTINUE
C
C  LOOP OVER G SETS IN LIST:
C
        DO 180 IT = 1,IGTRAN
          M(1) = LIST(1,IT)
          M(2) = LIST(2,IT)
          M(3) = LIST(3,IT)
C
C  TRANSFORM OVERLAP, DENSITY, AND TRANSFORMATION MATRICES:
C
          CALL LIMTRN(T,M,A,B,NDIM,NBAS,6,3,0)
          CALL LIMTRN(DM,M,A,B,NDIM,NBAS,6,3,0)
          CALL LIMTRN(TPAO,M,A,B,NDIM,NBAS,6,3,1)
C
C  FIX THE ORBITAL LABELS FOR THE 3 ORBITALS TRANSFORMED:
C
          LORB(M(1)) = LGT(1,IGBLK)
          LORB(M(2)) = LGT(2,IGBLK)
          LORB(M(3)) = LGT(3,IGBLK)
  180   CONTINUE
  190 CONTINUE
C
C  G ORBITALS --- FOURTH (6X6) BLOCK:
C
      N1 = 0
      N2 = 0
      N3 = 0
      N4 = 0
      N5 = 0
      N6 = 0
C
C  CONSTRUCT THE LIST:
C
      DO 200 IBAS = 1,NBAS
        LANG = LORBC(IBAS)
        IF(LANG.EQ.401) THEN
          N1 = N1 + 1
          LIST(1,N1) = IBAS
        ELSE IF(LANG.EQ.411) THEN
          N2 = N2 + 1
          LIST(2,N2) = IBAS
        ELSE IF(LANG.EQ.415) THEN
          N3 = N3 + 1
          LIST(3,N3) = IBAS
        ELSE IF(LANG.EQ.404) THEN
          N4 = N4 + 1
          LIST(4,N4) = IBAS
        ELSE IF(LANG.EQ.406) THEN
          N5 = N5 + 1
          LIST(5,N5) = IBAS
        ELSE IF(LANG.EQ.413) THEN
          N6 = N6 + 1
          LIST(6,N6) = IBAS
        END IF
  200 CONTINUE
C
C  MAKE SURE THERE IS A COMPLETE SET OF G FUNCTIONS:
C
      IF(N1.NE.N2.OR.N1.NE.N3.OR.N1.NE.N4.OR.N1.NE.N5.OR.N1.NE.N6
     +   .OR.N1.NE.IGTRAN) THEN
        WRITE(LFNPR,920)
        CALL NBHALT('Incorrect number of g functions found.')
      END IF
C
C  SET UP TRANSFORMATION FOR FOURTH G BLOCK:
C
C  S=(R2)2
C
      A(1,1) =  ONE
      A(2,1) =  ONE
      A(3,1) =  ONE
      A(4,1) =  TWO
      A(5,1) =  TWO
      A(6,1) =  TWO
C
C  D(X2-Y2)
C
      A(1,2) =  ONE
      A(2,2) = -ONE
      A(3,2) =  ZERO
      A(4,2) =  ZERO
      A(5,2) =  ONE
      A(6,2) = -ONE
C
C  D(3Z2-R2)
C
      A(1,3) = -ONE
      A(2,3) = -ONE
      A(3,3) =  TWO
      A(4,3) = -TWO
      A(5,3) =  ONE
      A(6,3) =  ONE
C
C  G(0)
C
      A(1,4) =  THREE
      A(2,4) =  THREE
      A(3,4) =  EIGHT
      A(4,4) =  SIX
      A(5,4) = -SIX*FOUR
      A(6,4) = -SIX*FOUR
C
C  G(2C)
C
      A(1,5) =  ONE
      A(2,5) = -ONE
      A(3,5) =  ZERO
      A(4,5) =  ZERO
      A(5,5) = -SIX
      A(6,5) =  SIX
C
C  G(4C)
C
      A(1,6) =  ONE
      A(2,6) =  ONE
      A(3,6) =  ZERO
      A(4,6) = -SIX
      A(5,6) =  ZERO
      A(6,6) =  ZERO
C
C  INCLUDE NORMALIZATION FACTORS:
C
      DO 220 I = 1,6
        DO 210 J = 4,6
          A(J,I) = A(J,I) / SQRT(FIVE * SEVEN / THREE)
  210   CONTINUE
  220 CONTINUE
C
C  LOOP OVER G SETS IN LIST:
C
      DO 230 IT = 1,IGTRAN
        M(1) = LIST(1,IT)
        M(2) = LIST(2,IT)
        M(3) = LIST(3,IT)
        M(4) = LIST(4,IT)
        M(5) = LIST(5,IT)
        M(6) = LIST(6,IT)
C
C  TRANSFORM OVERLAP, DENSITY, AND TRANSFORMATION MATRICES:
C
        CALL LIMTRN(T,M,A,B,NDIM,NBAS,6,6,0)
        CALL LIMTRN(DM,M,A,B,NDIM,NBAS,6,6,0)
        CALL LIMTRN(TPAO,M,A,B,NDIM,NBAS,6,6,1)
C
C  CHANGE THE ORBITAL LABELS FOR THE 3 ORBITALS TRANSFORMED:
C
        LORB(M(1)) = 51
        LORB(M(2)) = 254
        LORB(M(3)) = 255
        LORB(M(4)) = 451
        LORB(M(5)) = 454
        LORB(M(6)) = 458
  230 CONTINUE
  240 CONTINUE
C
C  RENORMALIZATION:
C
      DO 250 I = 1,NBAS
        X = T(I,I)
        IF(X.LT.ZERO) THEN
          CALL NBHALT('Attempt sqrt of negative number in SR DFGORB.')
        END IF
        RENORM(I) = ONE / SQRT(X)
  250 CONTINUE
      DO 270 I = 1,NBAS
        DO 260 J = 1,NBAS
          RIJ = RENORM(I) * RENORM(J)
          T(I,J) = T(I,J) * RIJ
          DM(I,J) = DM(I,J) * RIJ
          TPAO(I,J) = TPAO(I,J) * RENORM(J)
  260   CONTINUE
  270 CONTINUE
C
C  RELABELLING OF NON-TRANSFORMED ORBITALS:
C
      DO 280 I = 1,NBAS
        IF(LORB(I).EQ.0) THEN
          LANG = LORBC(I)
          LORB(I) = LANG
          L = LANG / 100
          IDIF = LANG - L * 100
          IF(IDIF.LT.50) LORB(I) = LORB(I) + 50
        END IF
  280 CONTINUE
C
C  FORM PAO LABELS:
C
      CALL LBLPAO
C
C  OUTPUT THE RAW AO TO PURE AO TRANSFORMATION MATRIX:
C
      IO = IOINQR(JPRINT(59))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        TITLE = 'PAOs in the AO basis:'
        CALL AOUT(TPAO,NDIM,NBAS,NBAS,TITLE,1,JPRINT(59))
      ELSE IF(IO.EQ.ICHK) THEN
        CALL SVCHK(TPAO,0)
        IF(OPEN) CALL SVCHK(TPAO,-2)
      END IF
C
C  OUTPUT THE PURE AO (PAO) OVERLAP MATRIX:
C
      IO = IOINQR(JPRINT(58))
      IF(IO.EQ.IPRNT.OR.IO.EQ.IWRIT) THEN
        TITLE = 'PAO overlap matrix:'
        CALL AOUT(T,NDIM,-NBAS,NBAS,TITLE,6,JPRINT(58))
      END IF
C
C  CHECK OVERLAPS:
C
      FIRST = .TRUE.
      DO 300 I = 1,NBAS-1
        ICTR = LCTR(I)
        DO 290 J = I+1,NBAS
          JCTR = LCTR(J)
          IF(ICTR.EQ.JCTR) THEN
            IF(LORB(I).NE.LORB(J).AND.ABS(T(I,J)).GT.EPS) THEN
              IF(FIRST) WRITE(LFNPR,940)
              WRITE(LFNPR,950) ICTR,I,LORB(I),J,LORB(J),T(I,J)
              FIRST = .FALSE.
            END IF
          END IF
  290   CONTINUE
  300 CONTINUE
      IF(.NOT.FIRST) THEN
        WRITE(LFNPR,960)
        CALL NBHALT('Basis transformation error in SR DFGORB.')
      END IF
      RETURN
C
  900 FORMAT(' Unequal numbers of d function components were',
     +' found in the input.',/,' These cannot be properly transformed-',
     +'-perhaps they were improperly labelled.')
  910 FORMAT(' Unequal numbers of f function components were',
     +' found in the input.',/,' These cannot be properly transformed-',
     +'-perhaps they were improperly labelled.')
  920 FORMAT(' Unequal numbers of g function components were',
     +' found in the input.',/,' These cannot be properly transformed-',
     +'-perhaps they were improperly labelled.')
  940 FORMAT(/1X,'Non-negligible overlap is calculated for PAOs of ',
     + 'differing angular symmetry.',//1X,'  Atom    I    Symm    J',
     + '    Symm       Overlap',/1X,' -----------------------------',
     + '-------------------')
  950 FORMAT(1X,I5,I7,I7,I6,I7,F14.5)
  960 FORMAT(/1X,'The most likely source of this problem is the ',
     + 'transformation of Cartesian',/1X,'basis functions to the',
     + ' pure set (the spherical PAOs) in SR DFGORB.')
      END
C***********************************************************************
      SUBROUTINE NAO(T,S,OCC,BLK,SBLK,EVAL,C,EVECT,S1,S2,S3,LISTAO,
     +               NBLOCK)
C***********************************************************************
C 25-May-05  EDG  Ensure that the basis set has a sufficient number of
C                 shells of symmetry types s, p, d, and f
C  2-May-03  EDG  Fix LL,LU,NORBS arrays for linearly dependent basis
C                 sets involving ghost atoms with no basis functions
C  1-Jun-01  EDG  Treat linearly dependent basis sets
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  MAIN SUBROUTINE 'NAO' FOR NATURAL ATOMIC ORBITAL BASIS SET.
C
C  INPUT REQUIRED:
C        S = OVERLAP MATRIX ELEMENTS IN LOWER TRIANGLE (BELOW DIAGONAL)
C          = DENSITY MATRIX ELEMENTS IN UPPER TRIANGLE (INCLUDING DIAG.)
C               (INPUT AO'S MUST(!) BE NORMALIZED.  ON RETURN, S IS THE
C                FULL DENSITY MATRIX.  OVERLAP MATRIX ELEMENTS ARE LOST.)
C      LBL = LIST OF ATOMIC CENTERS; LBL(I) = N IF ORBITAL I IS ON CENTER N
C     LORB = LIST OF ANGULAR MOMENTUM TYPE FOR EACH ORBITAL;
C            LORB(I) = N IF ORBITAL I IS OF 'TYPE' N.
C            N = ( 51,151,152,153)     = (S,PX,PY,PZ)
C              = (251,252,253,254,255) = (DXY,DXZ,DYZ,D(X2-Y2),D(3Z2-R2))
C              = (351-357 FOR THE 7 TYPES OF F ORBITALS)
C              = (451-459 FOR THE 9 TYPES OF G ORBITALS)
C              = (551-561 FOR THE 11 TYPES OF H ORBITALS)
C              = (651-663 FOR THE 13 TYPES OF I ORBITALS)
C
C  OUTPUT:
C        T = TRANSFORMATION MATRIX FROM INPUT AO'S TO NAO'S (ROWS ARE
C            LABELLED BY PRIMITIVE AO'S, COLUMNS BY NAO'S)
C   NAOCTR = LIST OF ATOMIC CENTERS FOR NAO'S; NAOCTR(I) = N IF NAO # I
C            IS ON CENTER #N.
C     NAOL = LIST OF ANGULAR MOMENTUM TYPE FOR EACH NAO, SAME FORMAT AS "LORB"
C
C  BEFORE RETURN:
C   LSTOCC = LIST OF NATURAL MINIMAL BASIS ('OCCUPIED') ORBITALS;
C            LSTOCC(I)=N (I=1,...,NOCC) MEANS THAT NAO #N BELONGS
C            TO THE NMB SET.
C   LSTEMT = LIST OF NATURAL RYDBERG BASIS ('EMPTY') ORBITALS;
C            LSTEMT(I)=N (I=1,...,NEMT) MEANS THAT NAO #N BELONGS
C            TO THE NRB SET.
C
C  AFTER RETURN:
C   LSTOCC(I) = 1 ONLY IF NAO #I BELONGS TO THE NMB SET.
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),LSTEMT(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION T(NDIM,NDIM),S(NDIM,NDIM),OCC(NDIM),BLK(NDIM,NDIM),
     +          SBLK(MXAOLM,MXAOLM),EVAL(NBAS),S1(NDIM,NDIM),
     +          S2(NDIM),S3(NDIM),LISTAO(MXAOLM,9),C(NBLOCK),
     +          EVECT(MXAOLM,MXAOLM),ICORE(4),IVAL(4)
      CHARACTER*1 STR(4)
      CHARACTER*2 CHARAT
      CHARACTER*80 TITLE
C
      SAVE ZERO,ONE,IPRNT,IWRIT,IREAD,STR
      DATA ZERO,ONE/0.0D0,1.0D0/
      DATA IPRNT,IWRIT,IREAD/4HPRNT,4HWRIT,4HREAD/
      DATA STR/'s','p','d','f'/
C
C  Skip T-PNAO formation if IOINQR(IWPNAO).EQ.IREAD:
C
      IF(IOINQR(IWPNAO).NE.IREAD) THEN
C
C  Initialize arrays:
C
        DO 20 J = 1,NBAS
          LSTOCC(J) = 0
          LSTEMT(J) = 0
          NAOCTR(J) = 0
          NAOL(J)   = 0
          OCC(J)    = ZERO
          DO 10 I = 1,NBAS
            T(I,J) = ZERO
   10     CONTINUE
   20   CONTINUE
C
C  NNAO counts the accumulated PNAOs:
C  NOCC counts the accumulated occupied PNAOs:
C  NEMT counts the accumulated empty PNAOs:
C
        NNAO = 0
        NOCC = 0
        NEMT = 0
C
C  Begin the main loop over PNAOs:
C
        DO 140 ICNTR = 1,NATOMS
C
C  Determine the minimum number of shells expected on this center:
C
          CALL CORTBL(ICNTR,ICORE,0)
          CALL VALTBL(ICNTR,IVAL,0)
C
C  Loop over angular momentum blocks.  NL counts the number of orbitals
c  in each M component of the L block:
C
          DO 130 IL = 1,7
            IF(NNAO.GE.NBAS) GO TO 130
            L = IL - 1
            M = 2 * L + 1
C
C  Gather list of AOs (LISTAO) belonging to the current atom and
C  angular momentum symmetry:
C
            NLP = 0
            DO 40 IM = 1,M
              LANG = 100 * L + IM + 50
              NL = 0
              DO 30 I = 1,NBAS
                IF((LBL(I).EQ.ICNTR).AND.(LORB(I).EQ.LANG)) THEN
                  NL = NL + 1
                  LISTAO(NL,IM) = I
                END IF
   30         CONTINUE
              IF(IM.GT.1.AND.NL.NE.NLP) THEN
                WRITE(LFNPR,900) CHARAT(IATNO(ICNTR)),ICNTR,NLP,
     +                           LANG-1,NL,LANG
                CALL NBHALT(' ')
              END IF
              NLP = NL
   40       CONTINUE
C
C  Ensure that a sufficient number of subshells exists:
C
C  (Exception: La may be missing a valence f subshell.)
C
            IF(IL.LT.5) THEN
              IF(NL.LT.ICORE(IL)+IVAL(IL)) THEN
                IF(IATNO(ICNTR).EQ.57.AND.IL.EQ.4) THEN
                  WRITE(LFNPR,910)
                  CALL VALTBL(ICNTR,IVAL,-4)
                ELSE
                  WRITE(LFNPR,920) CHARAT(IATNO(ICNTR)),
     +                             ICORE(IL)+IVAL(IL),STR(IL),NL
                  CALL NBHALT(' ')
                END IF
              END IF
            END IF
C
C  Load this list of AOs into BLK and SBLK (the density and overlap
C  elements, respectively) and average the density matrix elements
C  over the M components of the L subshell:
C
            IF(NL.NE.0) THEN
              CALL LOADAV(LISTAO,NL,M,S,NDIM,BLK,SBLK,MXAOLM)
C
C  Solve the generalized eigenvalue problem to calculate the PNAOs,
C  discarding subshells of PNAOs are lead to intraatomic linear
C  dependence:
C
              CALL ATDIAG(NL,BLK,SBLK,EVAL,C,S1,LARC,NK,L,ICNTR,
     +                    IATNO(ICNTR))
C
C  Loop over the 2*L+1 components to construct the T-PNAO transform:
C
              DO 125 IM = 1,M
C
C  Partition orbitals into occupied and empty sets:
C
                CALL SETBAS(LSTOCC,LSTEMT,NOCC,NEMT,ICNTR,L,NK,NNAO,
     +                      NDIM)
C
C  Store the eigenvectors of the density in T:
C
                DO 120 J = 1,NK
                  NNAO = NNAO + 1
                  OCC(NNAO) = EVAL(J)
                  IOFF = NL * (J - 1)
                  DO 110 I = 1,NL
                    IAO = LISTAO(I,IM)
                    IJR = IOFF + I
                    T(IAO,NNAO) = C(IJR)
  110             CONTINUE
C
C  Make the NAO labels:
C
                  NAOCTR(NNAO) = ICNTR
                  NAOL(NNAO) = L*100 + IM + 50
  120           CONTINUE
  125         CONTINUE
            END IF
  130     CONTINUE
  140   CONTINUE
C
C  Fill S with the overlap matrix, destroying the density matrix elements:
C
        DO 160 I = 1,NBAS
          DO 150 J = 1,I-1
            S(J,I) = S(I,J)
  150     CONTINUE
          S(I,I) = ONE
  160   CONTINUE
C
C  Search for interatomic linear dependence, discarding additional PNAOs
C  as necessary:
C
        CALL DISCRD(T,S,BLK,EVAL,S1,S2,S3,OCC,NDIM,NBAS,NNAO,NAOCTR,
     +              NAOL,LSTOCC,NOCC,LSTEMT,NEMT,LARC,IATNO,NATOMS)
C
C  Write T-PNAO data, if requested:
C
        IF(IOINQR(IWPNAO).EQ.IWRIT) CALL WRPPNA(T,OCC,IWPNAO)
C
C  Save NNAO on DAF:
C
        CALL SVNNAO(S3,NNAO)
C
C  Read T-PNAO data, if requested:
C
      ELSE
        CALL RDPPNA(T,OCC,IWPNAO)
C
C  Recompute and symmetry-average weights if the input PNAOs are RPNAOs:
C
        IF(OCC(1).LT.ZERO) CALL NEWWTS(S,T,OCC)
        NOCC = 0
        DO 210 I = 1,NNAO
          IF(LSTOCC(I).GT.0) THEN
            NOCC = I
          ELSE
            GOTO 220
          END IF
  210   CONTINUE
  220   NEMT = 0
        DO 250 I = 1,NNAO
          DO 230 J = 1,NOCC
            IF(LSTOCC(J).EQ.I) GOTO 240
  230     CONTINUE
          NEMT = NEMT + 1
          LSTEMT(NEMT) = I
  240     CONTINUE
  250    CONTINUE
      END IF
C
C  Save T-PNAO:
C
      CALL SVPNAO(T)
C
C  Print T-PNAO:
C
      IF(IOINQR(IWPNAO).EQ.IPRNT) THEN
        TITLE = 'PNAOs in the PAO basis:'
        CALL AOUT(T,NDIM,NBAS,NNAO,TITLE,6,IWPNAO)
      END IF
C
C  Begin orthogonalization of PNAOs to generate NAOs:
C
      DO 320 I = 1,NBAS
        DO 310 J = 1,I
          S(J,I) = S(I,J)
  310   CONTINUE
        S(I,I) = ONE
  320 CONTINUE
C
C  Use occupancy-weighted symmetric orthogonalization to
C  orthogonalize the occupied PNAOs:
C
      CALL WORTH(S,T,BLK,S1,S2,S3,LSTOCC,NDIM,NBAS,NOCC,OCC,EVAL)
C
C  Now treat the formally empty PNAOs:
C
      IF(NEMT.NE.0) THEN
C
C  First Schmidt orthogonalize the empties to the occupieds:
C
        CALL SHMDT(T,S,NDIM,NBAS,NOCC,LSTOCC,NEMT,LSTEMT,BLK)
C
C  Calculate new Rydberg functions:
C
        CALL FEPPAO(BLK)
        DO 420 J = 1,NBAS
          DO 410 I = 1,J
            S(I,J) = BLK(I,J)
  410     CONTINUE
  420   CONTINUE
        CALL NEWRYD(T,S,BLK,C,SBLK,EVECT,OCC,EVAL,S2,S1,LISTAO,
     +              JPRINT(11),NOCC)
C
C  Split the set of Rydbergs into those of high occupancy (in LARC) and
C  those of low occupancy (in LISTAO):
C
        CALL RYDSEL(LSTEMT,NEMT,NSEL1,LARC,NSEL2,LISTAO,OCC)
C
C  Use weighted-symmetric orthogonalization to orthogonalize the high
C  occupancy Rydbergs:
C
        IF(NSEL1.GT.0) THEN
          CALL WORTH(S,T,BLK,S1,S2,S3,LARC,NDIM,NBAS,NSEL1,OCC,EVAL)
C
C  Schmidt orthogonalize the low-occupancy Rydbergs:
C
          IF(NSEL2.GT.0) THEN
            CALL SHMDT(T,S,NDIM,NBAS,NSEL1,LARC,NSEL2,LISTAO,BLK)
          END IF
        END IF
C
C  Lowdin-orthogonalize the low-occupancy Rydbergs:
C
        IF(NSEL2.GT.0) THEN
          CALL WORTH(S,T,BLK,S1,S2,S3,LISTAO,NDIM,NBAS,NSEL2,OCC,EVAL)
        END IF
      END IF
C
C  Calculate the NAO density:
C
      CALL FEPPAO(S)
      CALL SIMTR1(S,T,OCC,NDIM,NBAS,NBAS,NNAO)
      CALL REDIAG(S,T,BLK,OCC,SBLK,C,LISTAO,JPRINT(11))
C
C  Reset LSTOCC:
C
      DO 510 I = 1,NNAO
        LSTOCC(I) = 1
  510 CONTINUE
      DO 520 I = 1,NEMT
        LSTOCC(LSTEMT(I)) = 0
  520 CONTINUE
C
C  Reconstruct NORBS, LL, and LU arrays.  Loops 605/606 are required
C  to treat ghost atoms having no basis functions for linearly-dependent
C  basis sets:
C
      IAT = 0
      DO 600 I = 1,NNAO
        IF(NAOCTR(I).NE.IAT) THEN
          IAT = NAOCTR(I)
          LL(IAT) = I
        END IF
  600 CONTINUE
      DO 605 I = IAT+1,NATOMS
        LL(I) = NNAO + 1
  605 CONTINUE
      DO 606 IAT = NATOMS-1,1,-1
        JAT = IAT + 1
        IF(LL(IAT).GT.LL(JAT)) LL(IAT) = LL(JAT)
  606 CONTINUE
      DO 610 IAT = 1,NATOMS-1
        LU(IAT) = LL(IAT+1) - 1
  610 CONTINUE
      LU(NATOMS) = NNAO
      DO 620 IAT = 1,NATOMS
        NORBS(IAT) = LU(IAT) - LL(IAT) + 1
  620 CONTINUE
      RETURN
C
  900 FORMAT(/1X,'Incomplete subshell encountered on ',A2,I3,
     + '; check your input data.',/1X,'NAO finds',I3,' AOs of ',
     + 'angular symmetry ',I3,' and',I3,' of symmetry ',I3,'.')
C  Exception for LANL2DZ basis set
  910 FORMAT(/1X,'La basis set lacks f functions; NPA will ',
     + 'neglect the La valence f subshell.')
  920 FORMAT(/1X,'The ',A2,' basis set should include',I2,' ',A1,
     + '-type subshell(s);',I2,' found.')
      END
C***********************************************************************
      SUBROUTINE NAOANL(DM,SPNAO,BINDEX,BINDT,BMO,OVPOP,F,ENAO,SCR)
C***********************************************************************
C  8-Mar-01  EDG  Print Natural Spin Densities
C 30-Jun-94  JKB  Added check of NAO occupancies against ZEROX, TWOX
C                    If within threshold, reset to 0 or 2 else NBHALT
C 10-Apr-93  EDG  Use orbital energies, if available, to determine
C                 Cor and Val type NAOs
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER*80 TITLE
      LOGICAL FIRST,CORE,ALLZER
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
C
C    Perform the Natural Population Analysis
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBNAO/NAOC(MAXBAS),NAOA(MAXBAS),LTYP(MAXBAS),IPRIN(MAXBAS)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBTHR/THRSET,PRJSET,ACCTHR,CRTSET,E2THR,ATHR,PTHR,ETHR,
     +             DTHR,DLTHR,CHSTHR,REFTHR,STTHR,PRTHR,THRNCS,THRNJC
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),LSTEMT(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBLBL/NLEW,NVAL,LBLS(10,MAXBAS,5)
      COMMON/IOCWAR/IOCWAR
C
      DIMENSION DM(NDIM,NDIM),SPNAO(NDIM,NDIM),BINDEX(NATOMS,NATOMS),
     *     BINDT(NATOMS),OVPOP(NATOMS,NATOMS),F(NDIM,NDIM),ENAO(NDIM),
     *     JPRIN(MAXBAS),ICORE(4),IVAL(4),NWARN(MAXATM),LABEC(20,2),
     *     OCCEC(20),BMO(NATOMS,NATOMS),SCR(NDIM)
      DIMENSION IANG(5),ANGL(25),LANG(25),CUBICF(7)
C
      SAVE IRYD,IANG,LANG
      SAVE ANGL,CUBICF,ZERO,TENTH,ONE,TWO,BIG
      SAVE ZEROP,ZEROX,TWOP,TWOX
      SAVE TEST,TEST2,ALLOW,ALLOW2,ICHCOR,ICHVAL,ICHRYD
C
      DATA IRYD/3HRyd/
      DATA IANG/1Hs,1Hp,1Hd,1Hf,1Hg/
      DATA LANG/ 51,151,152,153,251,252,253,254,255,
     *          351,352,353,354,355,356,357,
     *          451,452,453,454,455,456,457,458,459/
      DATA ANGL/4H    ,4Hx   ,4Hy   ,4Hz   ,4Hxy  ,4Hxz  ,4Hyz  ,
     *   4Hx2y2,4Hz2  ,4H(0) ,4H(c1),4H(s1),4H(c2),4H(s2),4H(c3),
     *   4H(s3),4H(0) ,4H(c1),4H(s1),4H(c2),4H(s2),4H(c3),4H(s3),
     *   4H(c4),4H(s4)/
      DATA CUBICF/4H(d1),4H(d2),4H(d3),4H(b) ,4H(e1),4H(e2),4H(e3)/
      DATA ZERO,TENTH,ONE,TWO,BIG/0.0D0,0.1D0,1.0D0,2.0D0,1.0D6/
C
C  TEST, TEST2, ALLOW, and ALLOW2 are numbers used in determining if the
C  density matrix trace is close to being an integer.  TEST2 (ALLOW2) must
C  be slightly greater than twice TEST (ALLOW):
C
      DATA TEST,TEST2/1.0D-5,2.1D-5/
      DATA ALLOW,ALLOW2/1.0D-2,2.1D-2/
      DATA ZEROP,TWOP,ZEROX,TWOX/1.0D-5,2.0001D0,1.0D-2,2.01D0/
      DATA ICHCOR,ICHVAL,ICHRYD/3HCor,3HVal,3HRyd/
C
C  If the f functions are a cubic set, insert the proper labels:
C
      IF(IWCUBF.EQ.0) GOTO 20
        DO 10 I = 1,7
          II = I+9
   10     ANGL(II) = CUBICF(I)
   20 CONTINUE
C
C  Retrieve the PNAO overlap from the DAF:
C
      CALL FESNAO(SPNAO)
C
C  Update the NAO atom-atom valency matrix:
C
      DO 30 J = 1,NATOMS
        DO 30 I = 1,NATOMS
          OVPOP(I,J) = ZERO
          BMO(I,J) = ZERO
   30     BINDEX(I,J) = ZERO
      DO 50 I = 1,NNAO
        IAT = NAOCTR(I)
        DO 40 J = 1,NNAO
          JAT = NAOCTR(J)
          IF(JAT.NE.IAT) THEN
            SIJ = SPNAO(I,J)
            DMIJ = DM(I,J)
            DMIJ2 = DMIJ*DMIJ
            DMSIJ = DMIJ*SIJ
            BINDEX(JAT,IAT) = BINDEX(JAT,IAT) + DMIJ2
            BMO(JAT,IAT) = BMO(JAT,IAT) + DMIJ
            OVPOP(JAT,IAT) = OVPOP(JAT,IAT) + DMSIJ
          END IF
   40   CONTINUE
   50 CONTINUE
C
C  Determine the NAO orbital energies if a Fock matrix exists.  Use
C  SPNAO to store TNAO:
C
      CALL FETNAO(SPNAO)
      IFOCK = IWFOCK
      IF(OPEN.AND..NOT.(ALPHA.OR.BETA)) IFOCK = 0
      IF(IFOCK.EQ.1) THEN
        CALL FEFAO(F,IWFOCK)
        IF(IWFOCK.NE.0) THEN
          DO 80 I = 1,NNAO
            ENRG = ZERO
            DO 70 J = 1,NBAS
              DO 60 K = 1,NBAS
                ENRG = ENRG + SPNAO(J,I)*F(J,K)*SPNAO(K,I)
   60         CONTINUE
   70       CONTINUE
            ENAO(I) = ENRG
   80     CONTINUE
        END IF
      END IF
C
C  Label NAO's as either 'Cor', 'Val', or 'Ryd':
C
      DO 200 I = 1,NNAO
        LTYP(I) = IRYD
  200 CONTINUE
      IECP = 0
      DO 300 NCTR = 1,NATOMS
        CALL CORTBL(NCTR,ICORE,IECP)
        CALL VALTBL(NCTR,IVAL,0)
C
C  Loop over s,p,d,f orbitals:
C
        DO 290 L = 0,3
          ITYP = IANG(L+1)
          LNUM = 2*L + 1
          IF(ICORE(L+1).LE.0) GOTO 240
C
C  Label core orbitals:
C
          DO 230 M = 1,ICORE(L+1)
            DO 220 LA = 1,LNUM
              MORB = 0
              OCC = -ONE
              ENRG = BIG
              DO 210 N = 1,NNAO
                LM = NAOL(N)
                NORB = LM/100
                IL = IANG(NORB+1)
                NA = MOD(NAOL(N),50)
                IF(NAOCTR(N).EQ.NCTR.AND.IL.EQ.ITYP.AND.
     +             LTYP(N).EQ.IRYD.AND.LA.EQ.NA) THEN
                  IF(IFOCK.NE.0.AND.ENAO(N).LT.ENRG) THEN
                    MORB = N
                    ENRG = ENAO(N)
                  ELSE IF(IFOCK.EQ.0.AND.DM(N,N).GT.OCC) THEN
                    MORB = N
                    OCC = DM(N,N)
                  END IF
                END IF
  210         CONTINUE
              IF(MORB.EQ.0) THEN
                WRITE(LFNPR,2500) ITYP,NAMEAT(IATNO(NCTR)),NCTR,
     +                            (ICORE(I),I=1,4),M,LA
                CALL NBHALT('Missing core orbital in SR NAOANL.')
              END IF
              LTYP(MORB) = ICHCOR
  220       CONTINUE
  230     CONTINUE
  240     CONTINUE
          IF(IVAL(L+1).LE.0) GOTO 280
C
C  Label valence orbitals:
C
          DO 270 M = 1,IVAL(L+1)
            DO 260 LA = 1,LNUM
              MORB = 0
              OCC = -ONE
              ENRG = BIG
              DO 250 N = 1,NNAO
                LM = NAOL(N)
                NORB = LM/100
                IL = IANG(NORB+1)
                NA = MOD(NAOL(N),50)
                IF(NAOCTR(N).EQ.NCTR.AND.IL.EQ.ITYP.AND.
     +             LTYP(N).EQ.IRYD.AND.LA.EQ.NA) THEN
                  IF(IFOCK.NE.0.AND.ENAO(N).LT.ENRG) THEN
                    MORB = N
                    ENRG = ENAO(N)
                  ELSE IF(IFOCK.EQ.0.AND.DM(N,N).GT.OCC) THEN
                    MORB = N
                    OCC = DM(N,N)
                  END IF
                END IF
  250         CONTINUE
              IF(MORB.EQ.0) THEN
                WRITE(LFNPR,2600) ITYP,NAMEAT(IATNO(NCTR)),NCTR,
     +                            (IVAL(I),I=1,4),M,LA
                CALL NBHALT('Missing valence orbital in SR NAOANL.')
              END IF
              LTYP(MORB) = ICHVAL
  260       CONTINUE
  270     CONTINUE
  280     CONTINUE
  290   CONTINUE
  300 CONTINUE
C
C  Assign `principal' quantum numbers using the NAO occupancies:
C
      DO 390 I = 1,NNAO
        IPRIN(I) = 0
  390 CONTINUE
      DO 450 NCTR = 1,NATOMS
        IECP = 1
        CALL CORTBL(NCTR,IVAL,IECP)
        IECP = 0
        CALL CORTBL(NCTR,ICORE,IECP)
        DO 440 L = 0,4
          ITYP = IANG(L+1)
          MMAX = 2*L + 1
          DO 430 M = 1,MMAX
            IF(L.EQ.4) THEN
              N = 4
            ELSE
              N = IVAL(L+1) - ICORE(L+1) + L
            END IF
  400       CONTINUE
              MORB = 0
              OCC = -ONE
              DO 410 J = 1,NNAO
                LM = NAOL(J)
                NORB = LM/100
                IL = IANG(NORB+1)
                NA = MOD(NAOL(J),50)
                  IF(NAOCTR(J).EQ.NCTR.AND.IL.EQ.ITYP.AND.
     +              DM(J,J).GT.OCC.AND.IPRIN(J).EQ.0.AND.
     +                                           M.EQ.NA) THEN
                        MORB = J
                        OCC = DM(J,J)
                  END IF
  410           CONTINUE
              IF(MORB.EQ.0) GOTO 420
              N = N + 1
              IPRIN(MORB) = N
            GOTO 400
  420       CONTINUE
  430     CONTINUE
  440   CONTINUE
  450 CONTINUE
C
C  Assign `principal' quantum numbers using the NAO Fock matrix elements:
C
      IF(IFOCK.EQ.0) GOTO 580
      DO 490 I = 1,NNAO
        JPRIN(I) = 0
  490 CONTINUE
      DO 550 NCTR = 1,NATOMS
        IECP = 1
        CALL CORTBL(NCTR,IVAL,IECP)
        IECP = 0
        CALL CORTBL(NCTR,ICORE,IECP)
        DO 540 L = 0,4
          ITYP = IANG(L+1)
          MMAX = 2*L + 1
          DO 530 M = 1,MMAX
            IF(L.EQ.4) THEN
              N = 4
            ELSE
              N = IVAL(L+1) - ICORE(L+1) + L
            END IF
  500       CONTINUE
              MORB = 0
              ENRG = BIG
              DO 510 J = 1,NNAO
                LM = NAOL(J)
                NORB = LM/100
                IL = IANG(NORB+1)
                NA = MOD(NAOL(J),50)
                  IF(NAOCTR(J).EQ.NCTR.AND.IL.EQ.ITYP.AND.
     +              ENAO(J).LT.ENRG.AND.JPRIN(J).EQ.0.AND.
     +                                           M.EQ.NA) THEN
                        MORB = J
                        ENRG = ENAO(J)
                  END IF
  510           CONTINUE
              IF(MORB.EQ.0) GOTO 520
              N = N + 1
              JPRIN(MORB) = N
            GOTO 500
  520       CONTINUE
  530     CONTINUE
  540   CONTINUE
  550 CONTINUE
  580 CONTINUE
C
C  Count the total number of electrons:
C
      TOT = ZERO
      DO 600 INAO = 1,NNAO
        TOT = TOT + DM(INAO,INAO)
  600 CONTINUE
      NEL = INT(TOT + TENTH)
C
C  Store NEL for use by the output routines:
C
      IF(OPEN) THEN
        NLEW = NEL
      ELSE
        NLEW = NEL/2
      ENDIF
C
C  Check to see if the total number of electrons found is an integer:
C
      IF(TOT.GE.ZERO) THEN
        SUMTT = TOT + TEST
        SUMTI = AINT(SUMTT)
        SUMTF = SUMTT - SUMTI
        IF(SUMTF.GT.TEST2) THEN
          SUMTT = TOT + ALLOW
          SUMTI = AINT(SUMTT)
          SUMTF = SUMTT - SUMTI
          IF(SUMTF.GT.ALLOW2) THEN
            WRITE(LFNPR,1310) TOT
            JPRINT(4) = -1
          ELSE
            WRITE(LFNPR,1315) TOT
          END IF
        END IF
      ELSE
        WRITE(LFNPR,1310) TOT
        JPRINT(4) = -1
      END IF
C
C  Calculated the NAO spin density matrix:
C
      ISPIND = 0
      IF(OPEN.AND..NOT.ALPHA.AND..NOT.BETA) THEN
        ISPIND = 1
        CALL FESPIN(F,SPNAO)
        CALL FESRAW(SPNAO)
        CALL SIMTRS(F,SPNAO,SCR,NDIM,NBAS)
        CALL FETNAO(SPNAO)
        CALL SIMTR1(F,SPNAO,SCR,NDIM,NBAS,NBAS,NNAO)
      END IF
C
C  Natural spin densities evaluated in SCR:
C
      DO 610 I = 1,NATOMS
        SCR(I) = ZERO
  610 CONTINUE
C
C  Write out Natural Population analysis:
C
      IF(JPRINT(4).NE.0) THEN
        IF(IFOCK.EQ.1.AND.ISPIND.EQ.0) THEN
          WRITE(LFNPR,900)
        ELSE IF(IFOCK.EQ.0.AND.ISPIND.EQ.0) THEN
          WRITE(LFNPR,910)
        ELSE IF(IFOCK.EQ.1.AND.ISPIND.EQ.1) THEN
          WRITE(LFNPR,911)
        ELSE IF(IFOCK.EQ.0.AND.ISPIND.EQ.1) THEN
          WRITE(LFNPR,912)
        END IF
        JCTR = 1
        DO 700 I = 1,NNAO
          NCTR = NAOCTR(I)
c          NCTRM = MOD(NCTR,100)
          NCTRM = NCTR
          IF(NCTR.NE.JCTR) THEN
            WRITE(LFNPR,*)
            JCTR = NCTR
          END IF
          IAT = IATNO(NCTR)
          NAM = NAMEAT(IAT)
          LM = NAOL(I)
          L = LM/100
          IL = IANG(L+1)
          DO 680 ILM = 1,25
            IF(LM.EQ.LANG(ILM)) GOTO 690
  680     CONTINUE
  690     CONTINUE
C
C  If occupancy within ZEROP/TWOP, reset to 0 or 2 with no message;
C     if between ZEROP/TWOP and ZEROX/TWOX, reset with warning message;
C     if outside ZEROX/TWOX, print message and orbital label, NBHALT
C
          OCC = DM(I,I)
          IF(OCC.LT.ZERO.AND.OCC.GT.-ZEROP) OCC = ZERO
          IF(OCC.GT.TWO.AND.OCC.LT.TWOP) OCC = TWO
          IF((OCC.LE.-ZEROP.AND.OCC.GT.-ZEROX).OR.
     +       (OCC.GE.TWOP.AND.OCC.LT.TWOX)) THEN
            IOCWAR = -1
            WRITE(LFNPR,1305) OCC,I
          END IF
          IF(OCC.LE.-ZEROX.OR.OCC.GE.TWOX)
     +       WRITE(LFNPR,1300) OCC,I
          IF(IFOCK.EQ.1.AND.ISPIND.EQ.0) THEN
            WRITE(LFNPR,920) I,NAM,NCTRM,IL,ANGL(ILM),LTYP(I),
     +                        JPRIN(I),IL,OCC,ENAO(I)
          ELSE IF(IFOCK.EQ.0.AND.ISPIND.EQ.0) THEN
            WRITE(LFNPR,920) I,NAM,NCTRM,IL,ANGL(ILM),LTYP(I),
     +                        IPRIN(I),IL,OCC
          ELSE IF(IFOCK.EQ.1.AND.ISPIND.EQ.1) THEN
            WRITE(LFNPR,920) I,NAM,NCTRM,IL,ANGL(ILM),LTYP(I),
     +                        JPRIN(I),IL,OCC,ENAO(I),F(I,I)
            SCR(NCTR) = SCR(NCTR) + F(I,I)
          ELSE IF(IFOCK.EQ.0.AND.ISPIND.EQ.1) THEN
            WRITE(LFNPR,925) I,NAM,NCTRM,IL,ANGL(ILM),LTYP(I),
     +                        IPRIN(I),IL,OCC,F(I,I)
            SCR(NCTR) = SCR(NCTR) + F(I,I)
          END IF
          IF(OCC.LE.-ZEROX.OR.OCC.GE.TWOX)
     +        CALL NBHALT('Orbital occupancy outside allowed range.')
  700   CONTINUE
C
C  Add note about effective core potentials if used:
C
        IECP = 0
        DO 710 I = 1,NATOMS
          IECP = IECP + IATNO(I) - IZNUC(I)
  710   CONTINUE
        IF(IPSEUD.NE.0) THEN
          IF(ALPHA.OR.BETA) IECP = IECP/2
          WRITE(LFNPR,930) IECP
        END IF
C
C  Write out warnings for low occupancy core orbitals:
C
        CRTHRS = CRTSET
        IF(ALPHA.OR.BETA) CRTHRS = CRTHRS - 1.0D0
        DO 715 N = 1,NATOMS
          NWARN(N) = 0
  715   CONTINUE
        DO 720 I = 1,NNAO
          ICTR = NAOCTR(I)
          IF(LTYP(I).EQ.ICHCOR.AND.DM(I,I).LT.CRTHRS)
     +       NWARN(ICTR) = NWARN(ICTR) + 1
  720   CONTINUE
        FIRST = .TRUE.
        DO 725 N = 1,NATOMS
          NAM = NAMEAT(IATNO(N))
          IF(NWARN(N).EQ.1) THEN
            IF(FIRST) THEN
              WRITE(LFNPR,*)
              WRITE(LFNPR,932) CRTHRS,NAM,N
              FIRST = .FALSE.
            ELSE
              WRITE(LFNPR,932) CRTHRS,NAM,N
            END IF
          ELSE IF(NWARN(N).GT.1) THEN
            IF(FIRST) THEN
              WRITE(LFNPR,*)
              WRITE(LFNPR,934) NWARN(N),CRTHRS,NAM,N
              FIRST = .FALSE.
            ELSE
              WRITE(LFNPR,934) NWARN(N),CRTHRS,NAM,N
            END IF
          END IF
  725   CONTINUE
C
C  Write out warnings for population inversions:
C
        IF(IFOCK.EQ.1) THEN
          DO 730 N = 1,NATOMS
            NWARN(N) = 0
  730     CONTINUE
          DO 735 I = 1,NNAO
            ICTR = NAOCTR(I)
            IF(IPRIN(I).NE.JPRIN(I)) NWARN(ICTR) = 1
            IPRIN(I) = JPRIN(I)
  735     CONTINUE
          FIRST = .TRUE.
          DO 738 N = 1,NATOMS
            NAM = NAMEAT(IATNO(N))
            IF(NWARN(N).GT.0) THEN
              IF(FIRST) THEN
                WRITE(LFNPR,*)
                WRITE(LFNPR,936) NAM,N
                FIRST = .FALSE.
              ELSE
                WRITE(LFNPR,936) NAM,N
              END IF
            END IF
  738     CONTINUE
        END IF
C
C  Summarize the Natural Population Analysis:
C
        ICond = igetival('icond')
        IF(ISPIND.EQ.0) THEN
          WRITE(LFNPR,938)
          Write(ICond,938)
        ELSE
          WRITE(LFNPR,939)
          Write(ICond,939)
        END IF
        SUMAC = ZERO
        SUMAV = ZERO
        SUMAR = ZERO
        SUMSD = ZERO
        NOMAC = 0
        DO 750 I = 1,NATOMS
          SUMC = ZERO
          SUMV = ZERO
          SUMR = ZERO
          NAM = NAMEAT(IATNO(I))
          DO 740 J = 1,NNAO
            IF(NAOCTR(J).EQ.I) THEN
              OCC = DM(J,J)
              IF(LTYP(J).EQ.ICHCOR) SUMC = SUMC + OCC
              IF(LTYP(J).EQ.ICHVAL) SUMV = SUMV + OCC
              IF(LTYP(J).EQ.ICHRYD) SUMR = SUMR + OCC
              IF(LTYP(J).EQ.ICHCOR) NOMAC = NOMAC + 2
            END IF
  740     CONTINUE
          TOT = SUMC + SUMV + SUMR
          IF(ALPHA.OR.BETA) THEN
            CHG = IZNUC(I)/TWO - TOT
          ELSE
            CHG = IZNUC(I) - TOT
          END IF
          ECP = DFLOAT(IATNO(I) - IZNUC(I))
          IF(ALPHA.OR.BETA) ECP = ECP/TWO
          IF(ISPIND.EQ.0) THEN
            WRITE(LFNPR,940) NAM,I,CHG,SUMC+ECP,SUMV,SUMR,TOT+ECP
            WRITE(ICond,940) NAM,I,CHG,SUMC+ECP,SUMV,SUMR,TOT+ECP
          ELSE
            WRITE(LFNPR,941) NAM,I,CHG,SUMC+ECP,SUMV,SUMR,TOT+ECP,SCR(I)
            WRITE(ICond,941) NAM,I,CHG,SUMC+ECP,SUMV,SUMR,TOT+ECP,SCR(I)
          END IF
          SUMAC = SUMAC + SUMC
          SUMAV = SUMAV + SUMV
          SUMAR = SUMAR + SUMR
          SUMSD = SUMSD + SCR(I)
  750   CONTINUE
        TOT = SUMAC + SUMAV + SUMAR
        CHG = -ONE * TOT
        IF(ALPHA.OR.BETA) THEN
          NOMAC = NOMAC/2
          DO 760 I = 1,NATOMS
            CHG = CHG + IZNUC(I)/TWO
  760     CONTINUE
        ELSE
          DO 770 I = 1,NATOMS
            CHG = CHG + IZNUC(I)
  770     CONTINUE
        END IF
        IF(ISPIND.EQ.0) THEN
          WRITE(LFNPR,950) CHG,SUMAC+DFLOAT(IECP),SUMAV,SUMAR,
     +                     TOT+DFLOAT(IECP)
          WRITE(ICond,950) CHG,SUMAC+DFLOAT(IECP),SUMAV,SUMAR,
     +                     TOT+DFLOAT(IECP)
        ELSE
          WRITE(LFNPR,951) CHG,SUMAC+DFLOAT(IECP),SUMAV,SUMAR,
     +                     TOT+DFLOAT(IECP),SUMSD
          WRITE(ICond,951) CHG,SUMAC+DFLOAT(IECP),SUMAV,SUMAR,
     +                     TOT+DFLOAT(IECP),SUMSD
        END IF
C
C  Write out NMB and NRB populations and percentage occupancies:
C
        WRITE(LFNPR,960)
        WRITE(ICond,960)
        NOMA = NEL
        NOMAV = NOMA - NOMAC
        SUMA = SUMAC + SUMAV
        IF(IPSEUD.NE.0) THEN
          ECP = IECP
          SUMA = SUMA + ECP
          NOMA = NOMA + IECP
          WRITE(LFNPR,970) ECP
          WRITE(ICond,970) ECP
        END IF
        IF(NOMAC.NE.0) THEN
          PCENT = SUMAC/NOMAC * 100.0D0
          WRITE(LFNPR,980) SUMAC,PCENT,NOMAC
          WRITE(ICond,980) SUMAC,PCENT,NOMAC
        ELSE IF(SUMAC.NE.ZERO) THEN
          PCENT = ZERO
          WRITE(LFNPR,980) SUMAC,PCENT,NOMAC
          WRITE(ICond,980) SUMAC,PCENT,NOMAC
        END IF
        IF(NOMAV.NE.0) THEN
          PCENT = SUMAV/NOMAV * 100.0D0
          WRITE(LFNPR,990) SUMAV,PCENT,NOMAV
          WRITE(ICond,990) SUMAV,PCENT,NOMAV
        ELSE IF(SUMAV.NE.ZERO) THEN
          PCENT = ZERO
          WRITE(LFNPR,990) SUMAV,PCENT,NOMAV
          WRITE(ICond,990) SUMAV,PCENT,NOMAV
        END IF
        IF(NOMA.NE.0) THEN
          PCENT = SUMA/NOMA * 100.0D0
        ELSE
          PCENT = ZERO
        END IF
        WRITE(LFNPR,1000) SUMA,PCENT,NOMA
        WRITE(ICond,1000) SUMA,PCENT,NOMA
        IF(NOMA.NE.0) THEN
          PCENT = SUMAR/NOMA * 100.0D0
          WRITE(LFNPR,1010) SUMAR,PCENT,NOMA
          WRITE(ICond,1010) SUMAR,PCENT,NOMA
        ELSE IF(SUMAR.NE.ZERO) THEN
          PCENT = 0
          WRITE(LFNPR,1010) SUMAR,PCENT,NOMA
          WRITE(ICond,1010) SUMAR,PCENT,NOMA
        END IF
C
C  Write out Natural Electron Configuration:
C
        WRITE(LFNPR,1040)
        DO 899 NCTR = 1,NATOMS
          ICT = 0
          IECP = 1
          CALL CORTBL(NCTR,ICORE,IECP)
          DO 870 NPL = 1,8
            DO 860 N = 1,NPL
              L = NPL - N
              IF(L.GE.0.AND.L.LT.N) THEN
                IF(N.GT.ICORE(L+1)+L) THEN
                  ICT = ICT + 1
                  LABEC(ICT,1) = N
                  LABEC(ICT,2) = IANG(L+1)
                  OCCEC(ICT) = ZERO
                END IF
              END IF
  860       CONTINUE
  870     CONTINUE
          DO 890 I = 1,NNAO
            ICTR = NAOCTR(I)
            IF(ICTR.EQ.NCTR.AND.LTYP(I).NE.ICHCOR) THEN
              NORB = NAOL(I)/100
              IL = IANG(NORB+1)
              DO 880 J = 1,ICT
                IF(IPRIN(I).EQ.LABEC(J,1).AND.
     +                   IL.EQ.LABEC(J,2)) THEN
                  OCCEC(J) = OCCEC(J) + DM(I,I)
                  GOTO 890
                END IF
  880         CONTINUE
            END IF
  890     CONTINUE
          IF(LABEC(1,1).NE.1) THEN
            CORE = .TRUE.
          ELSE
            CORE = .FALSE.
          END IF
          THOLD = 5.0D-3
          JMAX = ICT
C
C  Remove low occupancy subshells:
C
          DO 893 JCT = 1,ICT
  891       CONTINUE
            IF(OCCEC(JCT).LT.THOLD) THEN
              ALLZER = .TRUE.
              DO 892 KCT = JCT,ICT-1
                LABEC(KCT,1) = LABEC(KCT+1,1)
                LABEC(KCT,2) = LABEC(KCT+1,2)
                OCCEC(KCT)   = OCCEC(KCT+1)
                IF(OCCEC(KCT).GE.THOLD) ALLZER = .FALSE.
  892         CONTINUE
              OCCEC(ICT) = ZERO
              IF(ALLZER) THEN
                JMAX = JCT - 1
                GOTO 895
              END IF
              GOTO 891
            END IF
  893     CONTINUE
  895     CONTINUE
          NAM = NAMEAT(IATNO(NCTR))
          IF(JMAX.EQ.0) THEN
            IF(.NOT.CORE) THEN
              WRITE(LFNPR,1050) NAM,NCTR
            ELSE
              WRITE(LFNPR,1060) NAM,NCTR
            END IF
          ELSE
            IF(.NOT.CORE) THEN
              WRITE(LFNPR,1050) NAM,NCTR,((LABEC(K,J),J=1,2),OCCEC(K),
     +                          K=1,JMAX)
            ELSE
              WRITE(LFNPR,1060) NAM,NCTR,((LABEC(K,J),J=1,2),OCCEC(K),
     +                          K=1,JMAX)
            END IF
          END IF
  899   CONTINUE
      END IF
      IF(JPRINT(4).LT.0) CALL NBHALT('JPRINT(4) < 0 in SR NAOANL')
C
C  Write out Wiberg Bond Index Matrix if requested:
C
      IF(JPRINT(12).NE.0) THEN
        TITLE = 'Wiberg bond index matrix in the NAO basis:'
        CALL AOUT(BINDEX,NATOMS,NATOMS,NATOMS,TITLE,0,NATOMS)
        DO 3010 IAT = 1,NATOMS
          BINDT(IAT) = ZERO
          DO 3000 JAT = 1,NATOMS
            IF(IAT.EQ.JAT) GOTO 3000
            BINDT(IAT) = BINDT(IAT) + BINDEX(JAT,IAT)
 3000     CONTINUE
 3010   CONTINUE
        TITLE = 'Wiberg bond index, Totals by atom:'
        CALL AOUT(BINDT,NATOMS,NATOMS,1,TITLE,0,1)
C
C  Write out overlap-weighted bond populations:
C
        TITLE = 'Atom-atom overlap-weighted NAO bond order:'
        CALL AOUT(OVPOP,NATOMS,NATOMS,NATOMS,TITLE,0,NATOMS)
        DO 3030 IAT = 1,NATOMS
          BINDT(IAT) = ZERO
          DO 3020 JAT = 1,NATOMS
            IF(IAT.EQ.JAT) GOTO 3020
            BINDT(IAT) = BINDT(IAT) + OVPOP(JAT,IAT)
 3020     CONTINUE
 3030   CONTINUE
        TITLE(1:43)  = 'Atom-atom overlap-weighted NAO bond order, '
        TITLE(44:58) = 'Totals by atom:'
        CALL AOUT(BINDT,NATOMS,NATOMS,1,TITLE,0,1)
C
C  Write out MO bond orders:
C
        TITLE = 'MO bond order:'
        CALL AOUT(BMO,NATOMS,NATOMS,NATOMS,TITLE,0,NATOMS)
        DO 3050 IAT = 1,NATOMS
          BINDT(IAT) = ZERO
          DO 3040 JAT = 1,NATOMS
            IF(IAT.EQ.JAT) GOTO 3040
            BINDT(IAT) = BINDT(IAT) + BMO(JAT,IAT)
 3040     CONTINUE
 3050   CONTINUE
        TITLE  = 'MO atomic valencies:'
        CALL AOUT(BINDT,NATOMS,NATOMS,1,TITLE,0,1)
      END IF
C
C  Save NAO info in COMMON/NBNAO/:
C
      DO 888 I = 1,NNAO
        NAOC(I) = NAOCTR(I)
        NAOA(I) = NAOL(I)
  888 CONTINUE
      RETURN
C
  900 FORMAT(//,1X,
     +'NATURAL POPULATIONS:  Natural atomic orbital occupancies ',/,1X,
     +'                                                         ',/,1X,
     +' NAO Atom No lang   Type(AO)    Occupancy      Energy    ',/,1X,
     +'---------------------------------------------------------')
  910 FORMAT(//,1X,
     +'NATURAL POPULATIONS:  Natural atomic orbital occupancies ',/,1X,
     +'                                                         ',/,1X,
     +' NAO Atom No lang   Type(AO)    Occupancy                ',/,1X,
     +'-------------------------------------------              ')
  911 FORMAT(//,1X,
     +'NATURAL POPULATIONS:  Natural atomic orbital occupancies ',/,1X,
     +'                                                         ',/,1X,
     +' NAO Atom No lang   Type(AO)    Occupancy      Energy    ',
     +'   Spin',/,1X,'------------------------------------------',
     +'---------------------------')
  912 FORMAT(//,1X,
     +'NATURAL POPULATIONS:  Natural atomic orbital occupancies ',/,1X,
     +'                                                         ',/,1X,
     +' NAO Atom No lang   Type(AO)    Occupancy      Spin      ',/,1X,
     +'-------------------------------------------------------  ')
  920 FORMAT(I4,3X,A2,I3,2X,A1,A4,2X,A3,'(',I2,A1,')',
     + F12.5,F14.5,F12.5)
  925 FORMAT(I4,3X,A2,I3,2X,A1,A4,2X,A3,'(',I2,A1,')',
     + F12.5,F12.5)
  930 FORMAT(/,1X,
     +'[',I3,' electrons found in the effective core potential]')
  932 FORMAT(1X,
     +'  1 low occupancy (<',F6.4,'e) core orbital  found',
     +' on ',A2,I3)
  934 FORMAT(1X,I3,
     +' low occupancy (<',F6.4,'e) core orbitals found',
     +' on ',A2,I3)
  936 FORMAT(5X,'Population inversion found on atom ',A2,I3)
  938 FORMAT(//,1X,'Summary of Natural Population Analysis:',//1X,'   ',
     + '                                 Natural Population',/1X,'    ',
     + '        Natural    -------------------------------------------',
     + '--',/1X,' Atom No    Charge        Core      Valence    Rydber',
     + 'g      Total',/1X,'-------------------------------------------',
     + '-------------------------')
  939 FORMAT(//,1X,'Summary of Natural Population Analysis:',//1X,'   ',
     + '                                 Natural Population           ',
     + '      Natural',/1X,'            Natural    -------------------',
     + '--------------------------    Spin',/1X,' Atom No    Charge   ',
     + '     Core      Valence    Rydberg      Total      Density',/1X,
     + '--------------------------------------------------------------',
     + '----------------')
  940 FORMAT(1X,2X,A2,I3,2X,F9.5,4X,F9.5,3X,F9.5,2X,F9.5,3X,F9.5)
  941 FORMAT(1X,2X,A2,I3,2X,F9.5,4X,F9.5,3X,F9.5,2X,F9.5,3X,F9.5,3X,
     + F9.5)
  950 FORMAT(1X,68('='),/,1X,'* Total *',F9.5,4X,F9.5,3X,F9.5,2X,
     + F9.5,3X,F9.5)
  951 FORMAT(1X,79('='),/,1X,'* Total *',F9.5,4X,F9.5,3X,F9.5,2X,
     + F9.5,3X,F9.5,3X,F9.5)
  960 FORMAT(/,1X,
     +'                                Natural Population      ',/,1X,
     +'--------------------------------------------------------')
  970 FORMAT(1X,'  Effective Core          ',F10.5)
  980 FORMAT(1X,'  Core                    ',F10.5,' (',F8.4,
     +'% of',I4,')')
  990 FORMAT(1X,'  Valence                 ',F10.5,' (',F8.4,
     +'% of',I4,')')
 1000 FORMAT(1X,'  Natural Minimal Basis   ',F10.5,' (',F8.4,
     +'% of',I4,')')
 1010 FORMAT(1X,'  Natural Rydberg Basis   ',F10.5,' (',F8.4,
     +'% of',I4,')',/,1X,
     +'--------------------------------------------------------')
 1040 FORMAT(/1X,
     +'   Atom No         Natural Electron Configuration',/,1X,
     + 76('-'))
 1050 FORMAT(1X,4X,A2,I3,6X,6X,(13(I1,A1,'(',F5.2,')')))
 1060 FORMAT(1X,4X,A2,I3,6X,'[core]',(13(I1,A1,'(',F5.2,')')))
 1300 FORMAT(/1X,'FATAL ERROR:  Non-physical NAO occupancy (',F8.5,
     + ' electrons), orbital',I4,'.',/4X,
     + 'Check input data or density.')
 1305 FORMAT(/1X,'WARNING:  Non-physical NAO occupancy (',F8.5,
     + ' electrons), orbital',I4,'.',/4X,
     + 'Check input data or density.  Program will continue.')
 1310 FORMAT(/1X,'FATAL ERROR: Total number of electrons (',F10.5,
     + ') not an integer:',/4X,
     + 'Check input data or density (or try FIXDM keyword).')
 1315 FORMAT(/1X,'WARNING:  Total number of electrons (',F10.5,
     + ') not an integer.',/11X,'Program will continue.')
 2500 FORMAT(/1X,'Subroutine NAOANL could not find a ',A1,'-type ',
     + 'core orbital on atom ',A2,I3,'.',/,1X,'ICORE :',4I3,
     + '     M :',I3,'     LA :',I3)
 2600 FORMAT(/1X,'Subroutine NAOANL could not find a ',A1,'-type ',
     + 'valence orbital on atom ',A2,I3,'.',/,1X,'IVAL :',4I3,
     + '     M :',I3,'     LA :',I3)
      END
C***********************************************************************
      SUBROUTINE FRMTMO(T,TMO,C,SCR,INDEX,IFLG)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER*80 TITLE
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION T(NDIM,NDIM),TMO(NDIM,NDIM),C(NDIM,NDIM),
     +          SCR(NDIM*(NDIM+5))
C
C  Input:
C     T     --  transformation from AO basis to current basis
C     INDEX --  current basis = 2,3,4,5 (NAO,NHO,NBO,NLMO)
C     IFLG  --  number of columns of TMO to print
C               or external LFN to write to
C
      IND = ABS(INDEX)
C
C  Fetch the AO to MO transformation matrix:
C
      CALL FEAOMO(C,IT)
      IF(IT.EQ.0) RETURN
C
C  Fetch the AO overlap matrix:
C
      CALL FESRAW(SCR)
C
C  Right multiply by the AO-MO transformation:
C
      CALL MATMLT(SCR,C,TMO,NDIM,NBAS)
C
C  Left-multiply by the current set-AO transformation:
C
      CALL COPY(T,TMO,NDIM,NBAS,NBAS)
      CALL NBTRSP(TMO,NDIM,NBAS)
      CALL MATMLT(TMO,SCR,C,NDIM,NBAS)
C
C  Write or print the MO transformation matrix:
C
      IF(IFLG.EQ.0) RETURN
      IF(IND.EQ.2) TITLE = 'MOs in the NAO basis:'
      IF(IND.EQ.3) TITLE = 'MOs in the NHO basis:'
      IF(IND.EQ.4) TITLE = 'MOs in the NBO basis:'
      IF(IND.EQ.5) TITLE = 'MOs in the NLMO basis:'
      CALL AOUT(TMO,NDIM,NBAS,NBAS,TITLE,IND,IFLG)
      RETURN
      END
C***********************************************************************
C NBO 5.G -- Natural Bond Orbital Analysis Programs
C (c) Copyright 1996-2008 Board of Regents of the University of Wisconsin System
C     on behalf of the Theoretical Chemistry Institute.  All Rights Reserved.
C***********************************************************************
C
C  ROUTINES CALLED BY SR NAO:
C
C      SUBROUTINE LOADAV(LISTAO,NL,M,S,NDIM,A,B,MXAOLM)
C      SUBROUTINE ATDIAG(N,DM,S,EVAL,T,SCR,MAP,NK,L,IAT,IATNO)
C      SUBROUTINE SETBAS(LSTOCC,LSTEMT,NOCC,NEMT,IAT,L,NL,NF,NDIM)
C      SUBROUTINE NEWWTS(S,T,WT)
C      SUBROUTINE WORTH(S,T,BLK,LIST,NDIM,NBAS,N,OCC,EVAL,BIGBLK)
C      SUBROUTINE SHMDT(T,S,NDIM,NBAS,NOCC,LSTOCC,NEMT,LSTEMT,SBLK)
C      SUBROUTINE NEWRYD(T,S,TPNAO,DMBLK,SBLK,EVECT,OCC,EVAL,EVAL2,
C     +                       LIST,IRPNAO)
C      SUBROUTINE RYDIAG(T,S,TPNAO,DMBLK,SBLK,OCC,EVAL,EVECT,EVAL2,
C     +                    IORB,NC,NM,NSTART,NRYDC,LARC,LIST,IRPNAO)
C      SUBROUTINE RYDSEL(LSTEMT,NEMT,NSEL1,LIST1,NSEL2,LIST2,WT)
C      SUBROUTINE REDIAG(DM,T,TPNAO,EVAL,BLK,C,IRANK,IRPNAO)
C      SUBROUTINE REDBLK(T,TPNAO,IL,DM,BLK,EVAL,C,NF,IORB,NC,IRANK,IRPNAO)
C
C***********************************************************************
      SUBROUTINE LOADAV(LISTAO,NL,M,S,NDIM,A,B,MXAOLM)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION S(NDIM,NDIM),LISTAO(MXAOLM,9),A(NL,NL),B(NL,NL)
C
      SAVE ONE,ZERO
      DATA ONE,ZERO/1.0D0,0.0D0/
C
C  AVERAGE THE AO DENSITY MATRIX ELEMENTS OVER THE M=2*L+1 COMPONENTS
C  OF L FOR A PARTICULAR ATOM.
C
C  LOAD DENSITY MATRIX ELEMENTS (UPPER TRIANGLE OF S, INCL. DIAGONAL)
C  INTO A, OVERLAP MATRIX ELEMENTS (LOWER TRIANGLE OF S) INTO B, FOR
C  ORBITALS OF 'LISTAO'
C
      DO 30 J = 1,NL
        DO 20 I = 1,J
C
C  FIND AVERAGE DM ELEMENT OVER THE VALUES OF IM:
C
          SUM = ZERO
          DO 10 IM = 1,M
            IAO = LISTAO(I,IM)
            JAO = LISTAO(J,IM)
            SUM = SUM + S(IAO,JAO)
   10     CONTINUE
          AVE = SUM / M
C
C  DENSITY MATRIX ELEMENTS INTO A:
C
          A(I,J) = AVE
          A(J,I) = AVE
C
C  OVERLAP MATRIX ELEMENTS INTO B:
C
          B(I,J) = S(JAO,IAO)
          B(J,I) = B(I,J)
   20   CONTINUE
        B(J,J) = ONE
   30 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE ATDIAG(N,DM,S,EVAL,T,S1,MAP,NK,L,IAT,IATNO)
C***********************************************************************
C 29-May-01  EDG  Remove linearly dependent atomic subshells
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  Solve the generalized eigenvalue problem (DM-EVAL(k)*S)*T(k) = 0:
C
C  Input:      DM(N,N):   density matrix block
C              S(N,N):    overlap matrix block
C
C  Output:     T(N,N):    eigenvectors of density block
C
C  Keep only the linearly independent eigenvectors (NK in number):
C
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION DM(N,N),S(N,N),EVAL(N),T(N,N),S1(N,N),MAP(N)
      CHARACTER*1 SHELL(8)
      CHARACTER*2 CHARAT
C
      SAVE ZERO,ONE,THRESH
      SAVE ICNT,SHELL
      DATA ZERO,ONE,THRESH/0.0D0,1.0D0,1.0D-6/
      DATA ICNT/0/
      DATA SHELL/'s','p','d','f','g','h','i','j'/
C
C  Store copy of S in S1:
C
      CALL COPY(S,S1,N,N,N)
C
C  Evaluate eigenvectors of S:
C
      CALL NBJACOBI(N,S1,EVAL,T,N,N,0)
C
C  Sort eigenvectors and eigenvalues:
C
      CALL RANK(EVAL,N,N,MAP)
      DO I = 1,N
        CALL COPY(T(1,MAP(I)),S1(1,I),N,N,1)
      END DO
C
C  Keep NK linearly independent vectors:
C
      NK = 0
      DO I = 1,N
        IF(EVAL(I).LT.THRESH) THEN
          IF(IAT.GT.0) THEN
            IF(IAT.EQ.0) CALL NBHALT('Error in ATDIAG logic.')
            IF(ICNT.EQ.0) WRITE(LFNPR,*)
            ICNT = ICNT + 1
            WRITE(LFNPR,900) CHARAT(IATNO),IAT,SHELL(L+1)
          END IF
        ELSE
          NK = NK + 1
          EVAL(NK) = ONE / SQRT(EVAL(NK))
        END IF
      END DO
C
C  Form S**(-1/2) in T (the last N-NK columns can be neglected):
C
      DO I = 1,N
        DO J = 1,I
          TEMP = ZERO
          DO K = 1,NK
            TEMP = TEMP + EVAL(K) * S1(I,K) * S1(J,K)
          END DO
          T(I,J) = TEMP
          T(J,I) = TEMP
        END DO
      END DO
C
C  Normalize S**(-1/2):
C
      CALL NORMLZ(T,S,N,N,NK)
C
C  Replace S by S**(-1/2):
C
      CALL COPY(T,S,N,N,N)
C
C  Similarity transform DM by S**(-1/2) (giving DM'):
C
      CALL SIMTR1(DM,S,S1,N,N,N,NK)
C
C  Evaluate eigenvalues (EVAL) and eigenvectors of DM':
C
      CALL NBJACOBI(NK,DM,EVAL,T,N,N,0)
C
C  Sort eigenvectors and eigenvalues:
C
      CALL RANK(EVAL,NK,NK,MAP)
      DO I = 1,NK
        CALL COPY(T(1,MAP(I)),S1(1,I),NK,NK,1)
      END DO
C
C  Eigenvectors of original DM are S**(-1/2)*T:
C
      DO I = 1,N
        DO J = 1,NK
          TEMP = ZERO
          DO K = 1,NK
            TEMP = TEMP + S(I,K) * S1(K,J)
          END DO
          T(I,J) = TEMP
        END DO
      END DO
      RETURN
C
  900 FORMAT(1X,'Intraatomic linear dependence detected on ',A2,I3,
     + '; ',A1,'-type subshell deleted')
      END
C***********************************************************************
      SUBROUTINE SETBAS(LSTOCC,LSTEMT,NOCC,NEMT,IAT,L,NL,NNAO,NDIM)
C***********************************************************************
C
C  Select the set of natural minimal basis (NMB) orbitals for a particular
C  atom and angular symmetry type:
C
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION LSTOCC(NDIM),LSTEMT(NDIM)
      DIMENSION ICORE(4),IVAL(4)
C
C  If g orbitals or orbitals of even higher angular symmetry are selected,
C  there are none in the NMB:
C
      IF(L.GE.4) GOTO 100
C
C  Find core and valence orbitals for this atom:
C
      IECP = 0
      CALL CORTBL(IAT,ICORE,IECP)
      CALL VALTBL(IAT,IVAL,0)
C
C  Determine the number of shells with angular symmetry L in the NMB.
C  If there are a negative number of core orbitals, ignore them:
C
      NSHELL = MAX0(ICORE(L+1),0) + IVAL(L+1)
      IF(NSHELL.EQ.0) GOTO 100
C
C  Select sets of occupied and empty NAO's:
C
      DO 10 J = 1,NSHELL
        NOCC = NOCC + 1
        LSTOCC(NOCC) = NNAO + J
   10 CONTINUE
      LEFT = NL - NSHELL
      IF(LEFT.EQ.0) RETURN
      DO 20 J = 1,LEFT
        NEMT = NEMT + 1
        LSTEMT(NEMT) = NNAO + NSHELL + J
   20 CONTINUE
      RETURN
C
C  No NMB `L'-type orbitals found for this atom:
C
  100 CONTINUE
      DO 110 J = 1,NL
        NEMT = NEMT + 1
        LSTEMT(NEMT) = NNAO + J
  110 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE DISCRD(T,S,BLK,EVAL,S1,S2,S3,OCC,NDIM,NBAS,NNAO,
     +       NAOCTR,NAOL,LSTOCC,NOCC,LSTEMT,NEMT,LIST,IATNO,NATOMS)
C***********************************************************************
C 30-May-01  EDG  New routine
C-----------------------------------------------------------------------
C
C   Discard PNAOs to avoid interatomic linear dependence
C
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION T(NDIM,NDIM),S(NDIM,NNAO),BLK(NDIM,NDIM),EVAL(NDIM),
     + S1(NDIM,NDIM),S2(NDIM),S3(NDIM),OCC(NDIM)
      DIMENSION NAOCTR(NNAO),NAOL(NNAO),LSTOCC(NOCC),LSTEMT(NEMT),
     + LIST(NNAO),IATNO(NATOMS)
      CHARACTER*1 SHELL(8)
      CHARACTER*2 CHARAT
      LOGICAL LOOP
C
      SAVE ZERO,EPS,THRESH
      SAVE SHELL
      DATA ZERO,EPS,THRESH/0.0D0,1.0D-4,1.0D-6/
      DATA SHELL/'s','p','d','f','g','h','i','j'/
C
C  Loop until all interatomic linear dependence is removed:
C
      ICNT = 0
      LOOP = .TRUE.
      DO WHILE(LOOP)
C
C  Calculate PNAO overlap matrix:
C
        CALL COPY(S,S1,NDIM,NBAS,NBAS)
        CALL SIMTR1(S1,T,EVAL,NDIM,NBAS,NBAS,NNAO)
C
C  Compute eigenvalues (EVAL) and eigenvectors (BLK) of the overlap:
C
        CALL AXWBX(NDIM,NNAO,S1,XDUM,EVAL,1,1,BLK,S2,S3,IERR,LFNPR)
C
C  Find the smallest eigenvalue:
C
        IP = 1
        DO I = 2,NNAO
          IF(EVAL(I).LT.EVAL(IP)) IP = I
        END DO
C
C  Generate list of empty PNAOs to discard:
C
        IF(EVAL(IP).LT.THRESH) THEN
          IF(NEMT.EQ.0) CALL NBHALT('DISCRD: no empty PNAOs to discard')
          ICNT = ICNT + 1
          IF(ICNT.EQ.1.AND.NNAO.EQ.NBAS) WRITE(LFNPR,*)
          JJ = 1
          JP = LSTEMT(JJ)
          XP = ABS(BLK(JP,IP))
          DO J = 2,NEMT
            JE = LSTEMT(J)
            IF(ABS(BLK(JE,IP))-XP.GT.EPS) THEN
              JJ = J
              JP = JE
              XP = ABS(BLK(JE,IP))
            END IF
          END DO
          NL = 1
          LIST(NL) = JP
          DO J = 1,NNAO
            IF(J.NE.JP) THEN
              IF(ABS(ABS(BLK(J,IP))-XP).LE.EPS) THEN
                NL = NL + 1
                LIST(NL) = J
              END IF
            END IF
          END DO
          DO J = 1,NL
            JP = LIST(J)
            JC = NAOCTR(JP)
            JL = NAOL(JP) / 100
            WRITE(LFNPR,900) SHELL(JL+1),CHARAT(IATNO(JC)),JC
          END DO
C
C  Discard full subshells:
C
          NUP = NL
          DO K = 1,NUP
            JP = LIST(K)
            KC = NAOCTR(JP)
            KL = NAOL(JP) / 100
            KM = MOD(NAOL(JP),100) - 50
            IF(KL.GT.0) THEN
              DO J = 1,NNAO
                IF(J.NE.JP) THEN
                  JC = NAOCTR(J)
                  JL = NAOL(J) / 100
                  JM = MOD(NAOL(J),100) - 50
                  IF(JC.EQ.KC.AND.JL.EQ.KL.AND.JM.NE.KM) THEN
                    IF(OCC(J).EQ.OCC(JP)) THEN
                      NL = NL + 1
                      LIST(NL) = J
                    END IF
                  END IF
                END IF
              END DO
            END IF
          END DO
C
C  Loop over list of PNAOs:
C
          DO K = 1,NL
            JP = LIST(K)
C
C  Collapse T, OCC, NAOCTR, and NAOL:
C
            DO J = JP,NNAO-1
              CALL COPY(T(1,J+1),T(1,J),NDIM,NBAS,1)
              OCC(J) = OCC(J+1)
              NAOCTR(J) = NAOCTR(J+1)
              NAOL(J) = NAOL(J+1)
            END DO
            DO J = 1,NBAS
              T(J,NNAO) = ZERO
            END DO
            OCC(NNAO) = ZERO
            NAOCTR(NNAO) = 0
            NAOL(NNAO) = 0
C
C  Renumber PNAOs in LSTOCC:
C
            DO J = 1,NOCC
              IF(LSTOCC(J).GT.JP) LSTOCC(J) = LSTOCC(J) - 1
            END DO
C
C  Discarded PNAO should be in the list of empty orbitals:
C
            KP = 1
            DO WHILE(LSTEMT(KP).NE.JP)
              KP = KP + 1
              IF(KP.GT.NEMT) CALL NBHALT('Discarding occupied PNAO!')
            END DO
C
C  Collapse LSTEMT and renumber:
C
            DO J = KP,NEMT-1
              LSTEMT(J) = LSTEMT(J+1)
            END DO
            LSTEMT(NEMT) = 0
            DO J = 1,NEMT-1
            IF(LSTEMT(J).GT.JP) LSTEMT(J) = LSTEMT(J) - 1
            END DO
C
C  Renumber PNAOs in LIST:
C
            DO J = K+1,NL
              IF(LIST(J).GT.JP) LIST(J) = LIST(J) - 1
            END DO
C
C  One fewer empty orbital, one fewer NAO:
C
            NEMT = NEMT - 1
            NNAO = NNAO - 1
            IF(NNAO.EQ.0) CALL NBHALT('All PNAOs discarded in DISCRD')
          END DO
C
C  No (additional) linear dependencies detected:
C
        ELSE
          LOOP = .FALSE.
        END IF
      END DO
      RETURN
C
  900 FORMAT(1X,'Interatomic linear dependence detected; ',A1,
     + '-type subshell on ',A2,I3,' deleted')
      END
C***********************************************************************
      SUBROUTINE NEWWTS(DM,T,WT)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),LSTEMT(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
C
      DIMENSION T(NDIM,NDIM),DM(NDIM,NDIM),WT(NDIM)
      CHARACTER*80 TITLE
C
      SAVE ZERO
      DATA ZERO/0.0D0/
C
C  RECOMPUTE OCCUPANCY WEIGHTS:
C
      NOCC = 0
      DO 30 I = 1,NBAS
        SUM = ZERO
        DO 20 J = 1,NBAS
          DO 10 K = 1,NBAS
            DMJK = DM(J,K)
            IF(J.GT.K) DMJK = DM(K,J)
            SUM = SUM + T(J,I) * DMJK * T(K,I)
   10     CONTINUE
   20   CONTINUE
        WT(I) = SUM
C
C  REFORMAT LIST LSTOCC:
C
        IF(LSTOCC(I).NE.0) THEN
          NOCC = NOCC + 1
          LSTOCC(NOCC) = I
        END IF
   30 CONTINUE
      DO 40 I = NOCC+1,NBAS
        LSTOCC(I) = 0
   40 CONTINUE
C
C  SYMMETRY-AVERAGE WEIGHTS:
C
      NL = 1
      IORB = 0
  100 IORB = IORB + NL
        IF(IORB.GT.NBAS) GO TO 200
        NL = 1
        ILBL = NAOCTR(IORB)
        IL = NAOL(IORB) / 100
        NM = IL * 2 + 1
        DO 110 IADD = 1,NBAS-IORB
          JORB = IORB + IADD
          JLBL = NAOCTR(JORB)
          JL = NAOL(JORB) / 100
          IF(JLBL.NE.ILBL.OR.JL.NE.IL) GO TO 120
          NL = NL + 1
  110   CONTINUE
        IF(MOD(NL,NM).NE.0) CALL NBHALT('Missing components in NEWWTS?')
  120   NC = NL / NM
        DO 150 I = 1,NC
          SUM = ZERO
          DO 130 M = 1,NM
            INAO = IORB + (I-1) + (M-1) * NC
            SUM = SUM + WT(INAO)
  130     CONTINUE
          AV = SUM / NM
          DO 140 M = 1,NM
            INAO = IORB + (I-1) + (M-1) * NC
            WT(INAO) = AV
  140     CONTINUE
  150   CONTINUE
      GO TO 100
C
C  PRINT NEW WEIGHTS:
C
  200 TITLE = 'New symmetry-averaged occupancy weights:'
      CALL AOUT(WT,NBAS,NBAS,1,TITLE,-1,1)
      RETURN
      END
C***********************************************************************
      SUBROUTINE WORTH(S,T,BLK,S1,S2,S3,LIST,NDIM,NBAS,N,OCC,EVAL)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C***********************************************************************
C
C   WORTH: OCCUPANCY WEIGHTED ORTHOGONALIZATION SUBROUTINE
C
C   S:           FULL OVERLAP MATRIX (PURE AO BASIS)
C                 (NOTE: UPPER TRIANGLE USED FOR SCRATCH, BUT RESTORED AGAIN)
C   T:           PURE AO TO PRE-NAO TRANSFORMATION
C   LIST:        LIST OF ORBITALS TO BE ORTHOGONALIZED
C   N:           NUMBER OF ORBITALS IN LIST
C   OCC:         LIST OF SYMMETRY AVERAGED OCCUPANCY WEIGHTINGS
C
C  IMPORTANT CONSTANTS:
C           WTTHR           ALL WEIGHTING FACTORS SMALLER THAN WTTHR ARE SET
C                            TO THE VALUE OF WTTHR.
C
C***********************************************************************
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION S(NDIM,NDIM),T(NDIM,NDIM),BLK(NDIM,NDIM),S1(NDIM,NDIM),
     + S2(NDIM),S3(NDIM),OCC(NDIM),LIST(NDIM),EVAL(NDIM)
C
      SAVE ZERO,ONE,THRESH,WTTHR
      DATA ZERO,ONE/0.0D0,1.0D0/
      DATA THRESH,WTTHR/1.0D-12,1.0D-4/
C
C  Scale the weights so that the leading weight is one, and set all
C  weights less than WTTHR to WTTHR:
C
      WTMAX = ZERO
      DO 10 I = 1,N
        IP = LIST(I)
        WTMAX = MAX(OCC(IP),WTMAX)
   10 CONTINUE
      DO 20 I = 1,N
        IP = LIST(I)
        EVAL(IP) = OCC(IP)/WTMAX
        EVAL(IP) = MAX(EVAL(IP),WTTHR)
   20 CONTINUE
C
C  Form the weighted-PNAO vectors:
C
      DO 40 J = 1,N
        JP = LIST(J)
        DO 30 I = 1,NBAS
          T(I,JP) = T(I,JP) * EVAL(JP)
   30   CONTINUE
   40 CONTINUE
C
C  Form the weighted-overlap of the vectors:
C
      DO 70 I = 1,N
        IP = LIST(I)
        DO 60 J = 1,NBAS
          SIJ = ZERO
          DO 50 K = 1,NBAS
            TKI = T(K,IP)
            SIJ = SIJ + TKI * S(K,J)
   50     CONTINUE
          BLK(J,I) = SIJ
   60   CONTINUE
   70 CONTINUE
      DO 110 I = 1,N
        DO 100 J = 1,I
          JP = LIST(J)
          SIJ = ZERO
          DO 90 K = 1,NBAS
            TKJ = T(K,JP)
            SIJ = SIJ + BLK(K,I) * TKJ
   90     CONTINUE
          S1(J,I) = SIJ
          S1(I,J) = SIJ
  100   CONTINUE
  110 CONTINUE
C
C  Diagonalize the weighted-overlap matrix:
C
      CALL AXWBX(NDIM,N,S1,XDUM,EVAL,1,1,BLK,S2,S3,IERR,LFN)
C
C  Form S**(-1/2) from the eigenvectors:
C
      DO 120 I = 1,N
        EIGENV = EVAL(I)
        IF(EIGENV.LT.THRESH) GO TO 900
        EVAL(I) = ONE / SQRT(EIGENV)
  120 CONTINUE
      DO 150 I = 1,N
        DO 140 J = 1,I
          SIJ = ZERO
          DO 130 K = 1,N
            SIJ = SIJ + EVAL(K) * BLK(I,K) * BLK(J,K)
  130     CONTINUE
          S(J,I) = SIJ
  140   CONTINUE
  150 CONTINUE
C
C  Form the transformation to orthogonal functions:
C
      DO 200 I = 1,NBAS
        DO 180 J = 1,N
          EVAL(J) = ZERO
          DO 160 K = 1,J
            KP = LIST(K)
            TIK = T(I,KP)
            EVAL(J) = EVAL(J) + TIK * S(K,J)
  160     CONTINUE
          DO 170 K = J+1,N
            KP = LIST(K)
            TIK = T(I,KP)
            EVAL(J) = EVAL(J) + TIK * S(J,K)
  170     CONTINUE
  180   CONTINUE
        DO 190 J = 1,N
          JP = LIST(J)
          T(I,JP) = EVAL(J)
  190   CONTINUE
  200 CONTINUE
C
C  Restore the full PAO overlap matrix in S:
C
      DO 220 I = 1,NBAS
        DO 210 J = 1,I-1
          S(J,I) = S(I,J)
  210   CONTINUE
        S(I,I) = ONE
  220 CONTINUE
      RETURN
C
  900 WRITE(LFNPR,1000)
      CALL NBHALT('Linear dependence of PNAOs encountered in SR WORTH.')
C
 1000 FORMAT(//1X,'Linear dependence of the weighted PNAOs has been ',
     + 'encountered in WORTH.',/1X,'Routines ATDIAG and DISCRD have ',
     + 'not removed all linearly dependent PNAOs.')
      END
C***********************************************************************
      SUBROUTINE SHMDT(T,S,NDIM,NBAS,N1,LIST1,N2,LIST2,SBLK)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  Schmidt orthogonalization of the column vectors in T:
C
C  Schmidt orthogonalize the orbitals listed in LIST2 to the
C  orthonormal orbitals listed in LIST1:
C
      DIMENSION T(NDIM,NDIM),S(NDIM,NDIM),LIST1(N1),LIST2(N2),
     +          SBLK(NDIM,NDIM)
C
      SAVE ZERO
      DATA ZERO/0.0D0/
C
      DO 30 I = 1,NBAS
        DO 20 J = 1,N1
          JP = LIST1(J)
          SJI = ZERO
          DO 10 K = 1,NBAS
            SJI = SJI + T(K,JP) * S(K,I)
   10     CONTINUE
          SBLK(I,J)=SJI
   20   CONTINUE
   30 CONTINUE
C
C  Schmidt orthogonalize each |UI> to each |VJ>:
C
C  Loop over |UI>'s in LIST2:
C
      DO 70 I = 1,N2
        IP = LIST2(I)
C
C  Loop over |VJ>'s in LIST1:
C
        DO 60 J = 1,N1
          JP = LIST1(J)
C
C  Calculate overlaps SJI = <VJ|UI>:
C
          SJI = ZERO
          DO 40 K = 1,NBAS
            SJI = SJI + SBLK(K,J) * T(K,IP)
   40     CONTINUE
C
C  Remove |VJ> component of |UI>:
C
          DO 50 K = 1,NBAS
            T(K,IP) = T(K,IP) - SJI * T(K,JP)
   50     CONTINUE
   60   CONTINUE
   70 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE NEWRYD(T,S,TPNAO,DMBLK,SBLK,EVECT,OCC,EVAL,EVAL2,
     +                  SCR,LIST,IRPNAO,NOCC)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),LSTEMT(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
C
      DIMENSION T(NDIM,NDIM),S(NDIM,NDIM),TPNAO(NDIM,NDIM),OCC(NDIM),
     +          DMBLK(MXAOLM,MXAOLM),SBLK(MXAOLM,MXAOLM),EVAL(NDIM),
     +          EVECT(MXAOLM,MXAOLM),EVAL2(NDIM),SCR(NDIM,NDIM),
     +          LIST(MXAOLM)
C
      SAVE ONE
      DATA ONE/1.0D0/
C
C  Compute new Rydberg NAOs after Schmidt orthogonalization to minimal
C  NAO set:
C
C  If requested, update T-PNAO with the TRYD:
C
      IF(IRPNAO.EQ.1) CALL FEPNAO(TPNAO)
C
      NL = 1
      IORB = 0
   10 IORB = IORB + NL
        IF(IORB.GT.NNAO) GO TO 100
        NL = 1
        IC = NAOCTR(IORB)
        IL = NAOL(IORB) / 100
        NM = IL*2 + 1
        DO 20 JORB = IORB+1,NNAO
          JC = NAOCTR(JORB)
          JL = NAOL(JORB) / 100
          IF(JC.NE.IC.OR.JL.NE.IL) GO TO 30
          NL = NL + 1
   20   CONTINUE
   30   NC = NL / NM
        NSKIP = 0
        IMAX = IORB - 1 + NC
        DO 40 I = 1,NOCC
          INAO = LSTOCC(I)
          IF(INAO.GE.IORB.AND.INAO.LE.IMAX) NSKIP = NSKIP + 1
   40   CONTINUE
C
C  Ignore this angular symmetry if all PNAOs are occupied:
C
        IF(NSKIP.EQ.NC) GO TO 10
C
C  Orthogonalize the Rydbergs:
C
        NSTART = NSKIP + 1
        NRYDC  = NC - NSKIP
        CALL RYDIAG(T,S,TPNAO,DMBLK,SBLK,OCC,EVAL,EVECT,SCR,EVAL2,
     +              IORB,NC,NM,NSTART,NRYDC,LARC,LIST,IRPNAO)
      GO TO 10
C
C  Restore S:
C
  100 CONTINUE
      DO 120 I = 1,NBAS
        DO 110 J = 1,I-1
          S(J,I) = S(I,J)
  110   CONTINUE
        S(I,I) = ONE
  120 CONTINUE
C
C  Save the updated T-PNAO transformation:
C
      IF(IRPNAO.EQ.1) CALL SVPNAO(TPNAO)
      RETURN
      END
C***********************************************************************
      SUBROUTINE RYDIAG(T,S,TPNAO,DMBLK,SBLK,OCC,EVAL,EVECT,EVAL2,
     +                  SCR,IORB,NC,NM,NSTART,NRYDC,LARC,LIST,IRPNAO)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
      DIMENSION T(NDIM,NDIM),S(NDIM,NDIM),TPNAO(NDIM,NDIM),OCC(NDIM),
     +        DMBLK(NRYDC,NRYDC),SBLK(NRYDC,NRYDC),EVAL(NDIM),
     +        EVECT(NRYDC,NRYDC),LARC(NRYDC),LIST(NRYDC),EVAL2(NDIM),
     +        SCR(NDIM,NDIM)
C
      SAVE ZERO
      DATA ZERO/0.0D0/
C
C  Diagonalize one Rydberg block, update T-NAO (in T) and, if IRPNAO.eq.1,
C  update tpnao:
C
C  Initialize density and overlap blocks:
C
      DO 20 I = 1,NRYDC
        DO 10 J = 1,NRYDC
          DMBLK(I,J) = ZERO
          SBLK(I,J) = ZERO
   10   CONTINUE
   20 CONTINUE
C
C  Evaluate symmetry-averaged density and overlap blocks:
C
      II = 0
      DO 400 I = NSTART,NC
        II = II + 1
        DO 300 M = 1,NM
          INAO = IORB + (I-1) + (M-1) * NC
          DO 120 K = 1,NBAS
            DMSUM = ZERO
            SSUM = ZERO
            DO 100 L = 1,K-1
              TLI = T(L,INAO)
              DMSUM = DMSUM + TLI * S(L,K)
              SSUM  = SSUM  + TLI * S(K,L)
  100       CONTINUE
            TKI = T(K,INAO)
            DMSUM = DMSUM + TKI * S(K,K)
            SSUM  = SSUM  + TKI
            DO 110 L = K+1,NBAS
              TLI = T(L,INAO)
              DMSUM = DMSUM + TLI * S(K,L)
              SSUM  = SSUM  + TLI * S(L,K)
  110       CONTINUE
            EVAL(K) = DMSUM
            EVAL2(K) = SSUM
  120     CONTINUE
          JJ = 0
          DO 210 J = NSTART,I
            JJ = JJ + 1
            JNAO = IORB + (J-1) + (M-1) * NC
            DMSUM = ZERO
            SSUM  = ZERO
            DO 200 K = 1,NBAS
              TKJ = T(K,JNAO)
              DMSUM = DMSUM + EVAL(K)  * TKJ
              SSUM  = SSUM  + EVAL2(K) * TKJ
  200       CONTINUE
            DMBLK(II,JJ) = DMBLK(II,JJ) + DMSUM
            SBLK(II,JJ)  = SBLK(II,JJ)  + SSUM
  210     CONTINUE
  300   CONTINUE
        DO 310 JJ = 1,II
          DMBLK(II,JJ) = DMBLK(II,JJ) / NM
          DMBLK(JJ,II) = DMBLK(II,JJ)
          SBLK(II,JJ) = SBLK(II,JJ) / NM
          SBLK(JJ,II) = SBLK(II,JJ)
  310   CONTINUE
  400 CONTINUE
C
C  Solve the generalized eigenvalue problem:
C
      CALL ATDIAG(NRYDC,DMBLK,SBLK,EVAL,EVECT,SCR,LARC,NK,0,0,0)
C
C  Update T:
C
      CALL COPY(EVECT,SBLK,NRYDC,NRYDC,NRYDC)
      DO 520 M = 1,NM
        JJ = 0
        DO 510 J = NSTART,NC
          JJ = JJ + 1
          JNAO = IORB + (J-1) + (M-1) * NC
          OCC(JNAO) = EVAL(JJ)
          LIST(JJ) = JNAO
  510   CONTINUE
        CALL LIMTRN(T,LIST,SBLK,DMBLK,NDIM,NBAS,NRYDC,NRYDC,1)
  520 CONTINUE
C
C  We're finished, unless RPNAOs are desired:
C
      IF(IRPNAO.EQ.0) RETURN
C
C  Update T-PNAO, but do this in such a way that the intraatomic blocks
C  of the overlap matrix in the revised PNAO matrix remain diagonal and
C  that the PNAOs remain normalized.  In order to accomplish this, we
C  must Lowdin-orthogonalize the Rydberg transformation in SBLK:
C
      CALL SYMORT(EVECT,SBLK,DMBLK,NRYDC,NRYDC,EVAL,IERR,1)
      DO 610 M = 1,NM
        JJ = 0
        DO 600 J = NSTART,NC
          JJ = JJ + 1
          LIST(JJ) = IORB + (J-1) + (M-1) * NC
  600   CONTINUE
        CALL LIMTRN(TPNAO,LIST,SBLK,DMBLK,NDIM,NBAS,NRYDC,NRYDC,1)
  610 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE RYDSEL(LSTEMT,NEMT,NSEL1,LIST1,NSEL2,LIST2,WT)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  DIVIDE THE RYDBERG ORBITALS INTO 2 GROUPS:
C      LIST1:     RYDBERGS OF SIGNIFICANT OCCUPANCY ( .GT.WTTHR )
C
C      LIST2:     RYDBERGS OF LOW OCCUPANCY ( .LT.WTTHR )
C
C      WTTHR IS SET TO 0.0001
C
C  SET THE WEIGHTS OF THE RYDBERGS IN LIST2 TO ONE SO THAT THE WEIGHTED
C  ORTHOGONALIZATION THAT WILL LATER BE DONE AMONG THESE ORBITALS WILL
C  BE IN FACT A LOWDIN ORTHOG.
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
      DIMENSION WT(NDIM),LIST1(NBAS),LIST2(NBAS),LSTEMT(NBAS)
C
      SAVE ONE,WTTHR
      DATA ONE,WTTHR/1.0D0,1.0D-4/
C
      NSEL1 = 0
      NSEL2 = 0
      DO 10 I = 1,NEMT
        IRYD = LSTEMT(I)
        IF(WT(IRYD).GE.WTTHR) THEN
          NSEL1 = NSEL1 + 1
          LIST1(NSEL1) = IRYD
        ELSE
          NSEL2 = NSEL2 + 1
          LIST2(NSEL2) = IRYD
          WT(IRYD) = ONE
        END IF
   10 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE REDIAG(DM,T,TPNAO,EVAL,BLK,C,IRANK,IRPNAO)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXBAS = 2000)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LDEG(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),LSTEMT(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
C
      DIMENSION DM(NDIM,NDIM),T(NDIM,NDIM),TPNAO(NDIM,NDIM),
     +  C(MXAOLM,MXAOLM),EVAL(NDIM),BLK(MXAOLM,MXAOLM),IRANK(NBAS)
C
C  REDIAGONALIZE THE SYMMETRY AVERAGED DM SUBBLOCKS FOR EACH ANGULAR
C  SYMMETRY ON EACH ATOM:
C
C  READ IN OLD T-PNAO INTO TPNAO SO THAT IT CAN BE UPDATED (IF IRPNAO.EQ.1):
C
      IF(IRPNAO.EQ.1) CALL FEPNAO(TPNAO)
      NF = 0
      IORB = 0
      NL = 1
   10 IORB = IORB + NL
        IF(IORB.GT.NNAO) GO TO 100
        NL = 1
        ILBL = NAOCTR(IORB)
        IL = NAOL(IORB) / 100
        NM = IL * 2 + 1
        DO 30 JORB = IORB+1,NNAO
          JLBL = NAOCTR(JORB)
          JL = NAOL(JORB)/100
          IF(JLBL.NE.ILBL.OR.JL.NE.IL) GO TO 40
          NL = NL + 1
   30   CONTINUE
   40   NC = NL / NM
        IF(NC.EQ.1) THEN
          NF = NF + NM
        ELSE
          CALL REDBLK(T,TPNAO,IL,DM,BLK,EVAL,C,NF,IORB,NC,IRANK,IRPNAO)
        END IF
        GO TO 10
  100 CONTINUE
      IF(IRPNAO.EQ.0) RETURN
C
C  SAVE NEW T-PNAO FROM TPNAO:
C
      CALL SVPNAO(TPNAO)
      RETURN
      END
C***********************************************************************
      SUBROUTINE REDBLK(T,TPNAO,IL,DM,BLK,EVAL,C,NF,IORB,NC,IRANK,
     +                  IRPNAO)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXBAS = 2000)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LDEG(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),LSTEMT(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
C
      DIMENSION DM(NDIM,NDIM),BLK(NC,NC),C(NC,NC),EVAL(NDIM),
     +  T(NDIM,NDIM),TPNAO(NDIM,NDIM),IRANK(NBAS)
C
      SAVE ZERO
      DATA ZERO/0.0D0/
C
C  Find the rediagonalization transformation for the DM subblock
C  for the angular momemtum "IL" on an atom:
C
      NM = IL*2 + 1
      DO 30 J = 1,NC
        DO 20 I = 1,J
          SUM = ZERO
          DO 10 M = 1,NM
            INAO = IORB + I-1 + (M-1)*NC
            JNAO = IORB + J-1 + (M-1)*NC
            SUM = SUM + DM(INAO,JNAO)
   10     CONTINUE
          AVE = SUM/NM
          BLK(I,J) = AVE
          BLK(J,I) = AVE
   20   CONTINUE
   30 CONTINUE
C
C  Diagonalize symmetry-averaged block of DM:
C
      CALL NBJACOBI(NC,BLK,EVAL,C,NC,NC,1)
C
C  Sort eigenvalues and eigenvectors:
C
      CALL RANK(EVAL,NC,NC,LARC)
      DO 90 J = 1,NC
        JC = LARC(J)
        DO 80 I = 1,NC
          BLK(I,J) = C(I,JC)
   80   CONTINUE
   90 CONTINUE
C
C  Transformation T:
C
      DO 110 M = 1,NM
        DO 100 J = 1,NC
          NF = NF + 1
          IRANK(J) = NF
  100   CONTINUE
        CALL LIMTRN(T,IRANK,BLK,C,NDIM,NBAS,NC,NC,1)
        CALL LIMTRN(DM,IRANK,BLK,C,NDIM,NBAS,NC,NC,0)
        IF(IRPNAO.EQ.1) CALL LIMTRN(TPNAO,IRANK,BLK,C,NDIM,NBAS,NC,NC,1)
  110 CONTINUE
C
      RETURN
      END
C***********************************************************************
C NBO 5.G -- Natural Bond Orbital Analysis Programs
C (c) Copyright 1996-2008 Board of Regents of the University of Wisconsin System
C     on behalf of the Theoretical Chemistry Institute.  All Rights Reserved.
C***********************************************************************
C
C  ROUTINES CALLED BY THE NBO/NLMO DRIVERS:
C
C      SUBROUTINE NATHYB(DM,T,GUIDE,BNDOCC,POL,Q,V,BLK,C,EVAL,BORB,
C     +                                       P,TA,HYB,VA,VB,TOPO)
C      SUBROUTINE CHSDRV(DM,T,GUIDE,BNDOCC,POL,Q,V,BLK,C,EVAL,BORB,
C     +                                       P,TA,HYB,VA,VB,TOPO)
C      SUBROUTINE NBCHSE(DM,T,GUIDE,BNDOCC,POL,Q,V,BLK,C,EVAL,BORB,
C     +                                  P,TA,HYB,VA,VB,TOPO,IFLG)
C      SUBROUTINE SRTNBO(T,BNDOCC)
C      SUBROUTINE XCITED(DM,T,HYB,THYB,S,OCC,SCR,ISCR)
C      SUBROUTINE ANLYZE(T,BNDOCC,HYB,HYCOEF,THYB)
C      SUBROUTINE HTYPE(HYB,LTYP,MXAO,NH,COEF,PCT,NL,ISGN)
C      SUBROUTINE FRMHYB(HYB,THYB,COEF,HYCOEF,KL,KU,NHYB)
C      SUBROUTINE HYBDIR(BNDOCC,ATCOOR,THYB,TBND,SCR)
C      SUBROUTINE HYBCMP(PCMP,PPCT,DCMP,DPCT,IHYB,JCTR,HYB)
C      SUBROUTINE NHOANG(THYB,ATCRD,NATOMS,NBAS,NDIM,LFNPR)
C      SUBROUTINE FNDMOL(IATOMS)
C      SUBROUTINE NBOCLA(BNDOCC,ACCTHR)
C      SUBROUTINE FNBOAN(BNDOCC,F,MOLNBO)
C      SUBROUTINE NBOSUM(F,BNDOCC,LIST,LISTA,SCR)
C      SUBROUTINE GETDEL(IBO,OCC,THR1,THR2,NL,LIST,DEL,DELOC,IFLG)
C      SUBROUTINE DLCSTR(IBO,IL,NL,LIST,ML,ISTR)
C      SUBROUTINE NLMO(N,A,EVAL,EVEC,PRM,TSYM,RESON,NOCC,IALARM)
C      SUBROUTINE LMOANL(T,S,RESON,OCC,TS,BORDER,OWBORD,ATLMO,SIAB,NOCC,NAB)
C      SUBROUTINE DIPANL(DM,T,C,TNBO,DX,DY,DZ,SCR,INDEX)
C      SUBROUTINE DIPELE(DXYZ,C,T,SCR,ETA,NOCC,INDEX)
C      SUBROUTINE DIPNUC(DX,DY,DZ,ATCOOR,ETA,NOCC)
C
C***********************************************************************
      SUBROUTINE NATHYB(DM,T,GUIDE,BNDOCC,POL,Q,V,BLK,C,EVAL,BORB,
     *                                       P,TA,HYB,VA,VB,TOPO)
C***********************************************************************
C 30-Jun-94  JKB  Added secondary threshold of occupancy -0.01/2.01e and
C                    total electrons +/-0.5e to allow for MP2, CI DM
C 28-Jun-94  JKB  Modified NHO loop to avoid checking NOPVAL(IORDER(0))
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  Construct orthogonal matrix T for transformation from AO's to
C  Natural Hybrid Bond Orbitals using input density matrix DM.
C
C  REQUIRED INPUT INCLUDES:
C        DM = DENSITY MATRIX IN ORTHONORMAL ATOMIC ORBITAL BASIS;
C                  REAL(1,NDIM;1,NDIM)
C      NNAO = NO. OF ORBITALS = ACTUAL DIMENSION OF DM,S,T,NAOL,DMT
C    NATOMS = NO. OF ATOMS (NOT INCLUDING GHOSTS) IN THE MOLECULE
C     IATNO = LIST OF ATOMIC NUMBERS
C    NAOCTR = ORBITAL LABEL LIST.  NAOCTR(I)=IAT IF NAO # I IS ON ATOM IAT
C                INTEGER(1,NDIM).  NAOS OF GIVEN ATOM GROUPED TOGETHER.
C      IW3C = 1 IF PROGRAM IS TO SEARCH FOR 3-CENTER BONDS,
C           = 0 OTHERWISE
C     GUIDE = WIBERG ATOM-ATOM BOND INDEX MATRIX, USED AS GUIDE FOR NBO SEARCH
C
C  OUTPUT:
C         T = BOND ORBITAL TRANSFORMATION MATRIX (NDIM,NDIM).
C                ROWS ARE LABELLED BY NAOS, COLUMNS BY NBOS.
C     LABEL = LIST OF BOND ORBITAL LABELS
C      IBXM = PERMUTATION LIST OF BOND ORBITAL LABELS (VERY IMPORTANT!)
C
      LOGICAL DETAIL,NOBOND,FIRST
      INTEGER UL
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       UL(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBTHR/THRSET,PRJSET,ACCTHR,CRTSET,E2THR,ATHR,PTHR,ETHR,
     +             DTHR,DLTHR,CHSTHR,REFTHR,STTHR,PRTHR,THRNCS,THRNJC
      COMMON/NBTOPO/IORDER(MAXATM),JORDER(MAXATM),NTOPO(MAXATM,MAXATM),
     +            N3CTR,I3CTR(10,3)
      COMMON/IOCWAR/IOCWAR
      DIMENSION DM(NDIM,NDIM),T(NDIM,NDIM),V(NDIM),BORB(MXBO),
     * POL(NDIM,3),BNDOCC(NDIM),NAME(3),HYBEXP(3),
     * Q(MXAO,NDIM),BLK(MXBO,MXBO),EVAL(MXBO),C(MXBO,MXBO),
     * P(MXAO,MXAO),TA(MXAO,MXAO),HYB(MXAO),VA(MXAO),VB(MXAO),
     * GUIDE(NATOMS,NATOMS),TOPO(NATOMS*NATOMS)
C
      SAVE GTHRSH,ISTAR,IBLNK,NAME,LRY,LCR,ZERO,ZEROP,TENTH,ONE,TWO,FOUR
      SAVE TWOP,TOTP,PT8,PT99,PRJINC
      SAVE ZEROX,TWOX,TOTX
C
      DATA GTHRSH/1.5D-1/
      DATA ISTAR,IBLNK/1H*,1H /
      DATA NAME/2HLP,2HBD,2H3C/
      DATA LRY,LCR/2HRY,2HCR/
      DATA ZERO,ZEROP,TENTH,ONE,TWO,FOUR
     * /0.D0,1.D-5,0.1D0,1.0D0,2.0D0,4.0D0/
      DATA TWOP,TOTP/2.0001D0,5D-4/
      DATA PT8,PT99/0.8D0,0.99D0/
      DATA ZEROX,TWOX,TOTX/1.D-2,2.01D0,5D-1/
C
C  PRJINC, the amount to increase PRJTHR by if problems with linear
C  dependency between the hybrids arise.
C
      DATA PRJINC/0.05D0/
C
      NOPVAL(I) = NORBS(I) - INO(I)
C
      JPRINT(1) = 0
      DETAIL = .FALSE.
      IF(IWDETL.NE.0) DETAIL = .TRUE.
      NOBOND = .FALSE.
      IF(JPRINT(10).NE.0) NOBOND = .TRUE.
C
C  Initial iteration loop:  If no satisfactory Lewis structure (all
C  antibond occupancies < 0.1) for THRESH = 1.90, THRESH is decremented
C  up to 4 times by 0.1 in search of a better structure.  If the DM is
C  not spinless, THRESH is set to 0.90 and is decremented as above.
C
      PRJTHR = ABS(PRJSET)
      THRESH = ABS(THRSET)
      IF(ISPIN.NE.0) THRESH = THRESH - ONE
      IF(NOBOND) THRESH = ONE
      IF(NOBOND.AND.(ISPIN.NE.0)) THRESH = ONE/TWO
      IF(ISPIN.NE.0) GTHRSH = GTHRSH/FOUR
C
C  Determine the atom ordering for the initial search for bonds:
C
      IF(NATOMS.EQ.1) THEN
        IORDER(1) = 1
        GOTO 45
      END IF
C
C  Find the two atoms which have the largest bond index:
C
      GMAX = ZERO
      DO 10 J = 2,NATOMS
        DO 5 I = 1,J-1
          IF(GUIDE(I,J).GT.GMAX) THEN
            GMAX = GUIDE(I,J)
            IAT  = I
          END IF
    5   CONTINUE
   10 CONTINUE
      IORDER(1) = IAT
C
C  Add atoms to IORDER according to these connectivities:
C
      ICNT = 1
      INXT = ICNT
      JCNT = ICNT
   15 IPTR = INXT
        I1ST = 1
        DO 20 I = 1,NATOMS
          TOPO(I) = GUIDE(I,IORDER(IPTR))
   20   CONTINUE
        CALL RANK(TOPO,NATOMS,NATOMS,JORDER)
        JPTR = 1
   25   IF(TOPO(JPTR).GT.PT8) THEN
          IFLG = 1
          DO 30 I = 1,ICNT
            IF(IORDER(I).EQ.JORDER(JPTR)) IFLG = 0
   30     CONTINUE
          IF(IFLG.EQ.1) THEN
            ICNT = ICNT + 1
            IORDER(ICNT) = JORDER(JPTR)
            IF(I1ST.EQ.1) THEN
              I1ST = 0
              INXT = ICNT
            END IF
          END IF
        ELSE
          GOTO 35
        END IF
        JPTR = JPTR + 1
        GOTO 25
C
   35   CONTINUE
        IF(I1ST.EQ.1) THEN
          JCNT = JCNT + 1
          INXT = JCNT
          IF(INXT.GT.NATOMS) GOTO 45
          IF(INXT.GT.ICNT) THEN
            KPTR = 0
   40       KPTR = KPTR + 1
            KFLG = 1
            DO 41 I = 1,ICNT
              IF(IORDER(I).EQ.KPTR) KFLG = 0
   41       CONTINUE
            IF(KFLG.EQ.0) GOTO 40
            ICNT = ICNT + 1
            IORDER(ICNT) = KPTR
          END IF
        END IF
      GOTO 15
C
   45 CONTINUE
      ITER   = 0
      IALARM = 0
   50 IF(IALARM.EQ.0) ITER = ITER + 1
C
C  Store density matrix in upper triangle of T:
C
      DO 60 J = 1,NNAO
        DO 60 I = 1,J
   60     T(I,J) = DM(I,J)
C
C  Zero arrays Q, POL, IATHY, INO, and LABEL:
C
      DO 100 I = 1,NNAO
        DO 70 K = 1,2
   70     LABEL(I,K) = IBLNK
        DO 80 K = 3,6
   80     LABEL(I,K) = 0
        DO 90 K = 1,3
          POL(I,K) = ZERO
   90     IATHY(I,K) = 0
        DO 100 K = 1,MXAO
  100     Q(K,I) = ZERO
      DO 110 I = 1,NATOMS
  110   INO(I) = 0
C
C  Remove core orbitals from the density matrix:
C
      IBD = 0
      CALL NBCORE(DM,T,BORB,POL,Q,HYB,BNDOCC,IBD,DETAIL,LFNPR)
C
C  Main NHO loops
C  --------------
C  Doubly occupied (IOCC=1) or singly occupied (IOCC=2) NHO's
C  If ISPIN.NE.0, search is only for singly occupied nbos (IOCC=1):
C
      OCCMX = THRESH
C
C  Main NHO loops over singles, doubles, and triples of atoms:
C
      NA1 = NATOMS + 1
      DO 310 IA1 = 1,NA1
        IA = IA1 - 1
        IF(IA.GT.0) THEN
          NOPIA = NOPVAL(IORDER(IA))
        ELSE
          NOPIA = 0
        END IF
        IF((IA.GT.0).AND.(NOPIA.LE.0)) GO TO 310
        DO 300 IB1 = 1,NA1
          IB = IB1 - 1
          IF((IB.EQ.0).AND.(IA.GT.0)) GO TO 300
          IF(IB.GT.0) THEN
            NOPIB = NOPVAL(IORDER(IB))
          ELSE
            NOPIB = 0
          END IF
          IF((IB.GT.0).AND.(NOPIB.LE.0)) GO TO 300
          DO 290 IC1 = 2,NA1
            IC = IC1 - 1
            NOPIC = NOPVAL(IORDER(IC))
            IF((IC.GT.0).AND.(NOPIC.LE.0)) GO TO 290
            IF(IA.NE.0) GO TO 130
            IF(IB.NE.0) GO TO 120
C
C  Lone pairs:
C
            NCTR = 1
            IAT1 = IORDER(IC)
            IAT2 = 0
            IAT3 = 0
            GO TO 140
C
C  Bond pairs:
C
  120       CONTINUE
            IF(NOBOND) GO TO 290
            NCTR = 2
            IAT1 = IORDER(IB)
            IAT2 = IORDER(IC)
            IAT3 = 0
            IF(IAT1.GE.IAT2) GO TO 290
            IF(GUIDE(IAT1,IAT2).LT.GTHRSH) GO TO 290
            GO TO 140
C
C  3-center bonds:
C
  130       CONTINUE
            IF(IW3C.NE.1) GO TO 320
            NCTR = 3
            IAT1 = IORDER(IA)
            IAT2 = IORDER(IB)
            IAT3 = IORDER(IC)
            IF(IAT1.GE.IAT2) GO TO 300
            IF(IAT2.GE.IAT3) GO TO 290
            IF(GUIDE(IAT1,IAT2).GT.GTHRSH) GO TO 140
            IF(GUIDE(IAT1,IAT3).GT.GTHRSH) GO TO 140
            IF(GUIDE(IAT2,IAT3).GT.GTHRSH) GO TO 140
            GO TO 290
  140       CONTINUE
C
C  Deplete DM of one(two) center orbitals if search for two(three)
C  center orbitals is beginning:
C
            IF(IWPRJ(NCTR).NE.0)
     *            CALL DEPLET(DM,T,Q,POL,BORB,BNDOCC,IBD)
C
C  Load proper atomic blocks of DM into BLK:
C
            CALL LOAD(DM,IAT1,IAT2,IAT3,BLK,NB)
C
C  Diagonalize BLK:
C
            CALL NBJACOBI(NB,BLK,EVAL,C,MXBO,MXBO,1)
C
C  Rank eigenvectors by occupancy eigenvalue:
C
            CALL RANK(EVAL,NB,MXBO,LARC)
            IF(DETAIL) WRITE(LFNPR,1400) IAT1,IAT2,IAT3
            IF(DETAIL) WRITE(LFNPR,1403) THRESH
            IF(DETAIL) WRITE(LFNPR,1405) (EVAL(IRNK),IRNK=1,NB)
            IACCEP = 0
            DO 250 IRNK = 1,NB
              IR = LARC(IRNK)
              OCC = EVAL(IRNK)
              DO 200 I = 1,NB
  200           BORB(I) = C(I,IR)
              IF(DETAIL) WRITE(LFNPR,1410) IRNK,OCC
              IF(DETAIL) WRITE(LFNPR,1420) (BORB(I),I=1,NB)
C
C  Throw out orbital if occupancy is less than the threshhold "OCCMX":
C
              IF(OCC.LT.OCCMX) GO TO 280
C
C  Check to see that bond orbital "BORB" doesn't contain previously used
C  hybrids:
C
              IF(NCTR.EQ.1) GO TO 240
              CALL PRJEXP(BORB,IAT1,IAT2,IAT3,Q,P,TA,HYB,VA,VB,HYBEXP)
              IF(.NOT.DETAIL) GO TO 220
              DO 210 IHYB = 1,NCTR
  210           WRITE(LFNPR,1500) IHYB,HYBEXP(IHYB)
  220         CONTINUE
              DO 230 IHYB = 1,NCTR
  230           IF(HYBEXP(IHYB).LT.PRJTHR) GO TO 250
  240         CONTINUE
              IBD = IBD + 1
              IACCEP = IACCEP + 1
C
C  Decompose "BORB" into its constituent atomic hybrids and store in Q:
C
              CALL STASH(BORB,IBD,IAT1,IAT2,IAT3,POL,Q,HYB)
C
C  Construct bond orbital labels:
C
              LABEL(IBD,1) = NAME(NCTR)
              LABEL(IBD,2) = IBLNK
              LABEL(IBD,3) = IACCEP
              LABEL(IBD,4) = IAT1
              LABEL(IBD,5) = IAT2
              LABEL(IBD,6) = IAT3
              BNDOCC(IBD) = OCC
              IF(DETAIL) WRITE(LFNPR,1600) IBD,(LABEL(IBD,I),I=1,3)
  250         CONTINUE
  280       CONTINUE
  290       CONTINUE
  300     CONTINUE
  310   CONTINUE
  320 CONTINUE
C
C  Symmetric orthogonalization of principal hybrids:
C
      CALL ORTHYB(Q,BLK,TA,EVAL,C,IALARM,0)
C
C   IALARM sounds the alarm that there is linear dependency between some
C   of the hybrids. The remedy is to increase prjthr and repeat the NBO
C   search. IALARM is equal to the number of the violating atom.
C
      IF(IALARM.NE.0) THEN
        OLDPRJ = PRJTHR
        PRJTHR = OLDPRJ + PRJINC
        IF(JPRINT(5).NE.0) WRITE(LFNPR,1800) OLDPRJ,PRJTHR
        IF(PRJTHR.GE.PT99) THEN
          WRITE(LFNPR,1810) IALARM
          JPRINT(1) = -1
          RETURN
        END IF
        GOTO 700
      END IF
C
C  Augment open-valence atoms with non-arbitrary hybrids orthogonal to
C  those found previously:
C
      DO 580 IA = 1,NATOMS
        IF(NOPVAL(IA).LE.0) GO TO 580
C
C  IULA: upper limit of NAOs on atom. Find NMB, the number of natural
C  minimal basis functions on the atom:
C
        LLA = LL(IA)
        IULA = UL(IA)
        NMB = 0
        DO 470 I = LLA,IULA
          IF(LSTOCC(I).EQ.1) NMB = NMB + 1
  470   CONTINUE
C
C  Find the number of bond, core, and lone pair hybrids on the atom, IOCC:
C  Also find IOCCLP, number of lone pair orbitals already found on IA, for
C  use in labelling the extra lone pairs below:
C
        IOCC = 0
        IOCCLP = 0
        DO 480 IB = 1,IBD
          IF((LABEL(IB,4).NE.IA).AND.(LABEL(IB,5).NE.IA).AND.
     *            (LABEL(IB,6).NE.IA)) GO TO 480
          IOCC = IOCC + 1
          IF(LABEL(IB,1).EQ.NAME(1)) IOCCLP = IOCCLP + 1
  480   CONTINUE
C
C  NEXLP: number of extra (low occupancy) LP orbitals on atom IAT. (This
C  is the number of low occupancy orbitals with valence shell character)
C  Set NEXLP to zero if (NMB-IOCC) is less than zero in order that the
C  orbitals are not miscounted!!
C
        NEXLP = NMB - IOCC
        IF(NEXLP.LT.0) NEXLP = 0
        NOCC = INO(IA)
        CALL NBFPRJ(P,IA,Q,NOCC,TA,VA,VB)
        NORB = NORBS(IA)
        NAUGM = NORB - NOCC
        CALL AUGMNT(P,BLK,C,EVAL,DM,TA,BORB,V,LARC,IA,NOCC,NORB)
C
C  Stash and label extra lone pairs that AUGMNT put in BLK: (These ar
C  taken to be the highest occupied orbitals, which AUGMNT places first)
C
        DO 510 IAUGM = 1,NEXLP
          DO 500 J = 1,NORB
  500       BORB(J) = BLK(J,IAUGM)
          IBD = IBD + 1
          CALL STASH(BORB,IBD,IA,0,0,POL,Q,HYB)
          LABEL(IBD,1) = NAME(1)
          LABEL(IBD,2) = IBLNK
          LABEL(IBD,3) = IAUGM + IOCCLP
          LABEL(IBD,4) = IA
          LABEL(IBD,5) = 0
          LABEL(IBD,6) = 0
  510   CONTINUE
C
C  Stash and label the Rydberg orbitals that AUGMNT put in BLK:
C
        IRYD = 0
        NSTART = NEXLP + 1
        DO 540 IAUGM = NSTART,NAUGM
          DO 530 J = 1,NORB
  530       BORB(J) = BLK(J,IAUGM)
          IBD = IBD + 1
          IRYD = IRYD + 1
          CALL STASH(BORB,IBD,IA,0,0,POL,Q,HYB)
          LABEL(IBD,1) = LRY
          LABEL(IBD,2) = ISTAR
          LABEL(IBD,3) = IRYD
          LABEL(IBD,4) = IA
          LABEL(IBD,5) = 0
          LABEL(IBD,6) = 0
  540     CONTINUE
  580   CONTINUE
C
C  Include antibond labels:
C
      IBO = IBD
      DO 660 I = 1,IBO
C
C  Exit loop if LABEL(I,1) is 'LP', 'RY', or 'CR':
C
        IF(LABEL(I,1).EQ.NAME(1)) GO TO 660
        IF(LABEL(I,1).EQ.LRY) GO TO 660
        IF(LABEL(I,1).EQ.LCR) GO TO 660
         NAB = 1
         IF(LABEL(I,1).EQ.NAME(3)) NAB = 2
         DO 650 IAB = 1,NAB
           IBD = IBD + 1
           DO 640 J = 1,6
  640        LABEL(IBD,J) = LABEL(I,J)
           LABEL(IBD,2) = ISTAR
  650      CONTINUE
  660   CONTINUE
C
C  Replace density matrix DM from T:
C
  700 CONTINUE
      DO 740 J=1,NNAO
        DO 740 I=1,J
          DM(I,J)=T(I,J)
          DM(J,I)=DM(I,J)
          T(J,I)=ZERO
  740     T(I,J)=ZERO
C
C  Remember the alarm!
C
      IF(IALARM.NE.0) GO TO 50
C
C  Miscounted bond orbitals...exit for open shell:
C
      IF(IBD.NE.NNAO) THEN
        WRITE(LFNPR,1200) THRESH,IBD,NNAO
        WRITE(LFNPR,1210) (I,(LABEL(I,J),J=1,6),I=1,IBD)
        CALL NBHALT('Bond orbitals miscounted in SR NATHYB.')
      END IF
C
C  Find new polarization parameters for orthonormal hybrids:
C
      CALL REPOL(DM,Q,POL,BLK,EVAL,C,IBD)
C
C  Form final T-NAB (NAO to NBO transformation) from orthonormal
C  hybrids:
C
      CALL FORMT(T,Q,POL)
C
C  Find occupancies, find total number of electrons and occupied orbitals:
C
      TOTELE = ZERO
      DO 800 I = 1,NNAO
        OCCI = ZERO
        DO 790 J = 1,NNAO
          DO 790 K = 1,NNAO
  790       OCCI = OCCI + T(J,I) * DM(J,K) * T(K,I)
        IF(OCCI.LE.-ZEROP.AND.OCCI.GT.-ZEROX) THEN
          IOCWAR = IOCWAR + 1
          IF(IOCWAR.LE.5) WRITE(LFNPR,1305) OCCI,I
          IF(IOCWAR.EQ.5) WRITE(LFNPR,1306)
        END IF
        IF(OCCI.LT.ZERO.AND.OCCI.GT.-ZEROP) OCCI = ZERO
        IF(OCCI.GE.TWOP.AND.OCCI.LT.TWOX) THEN
          IOCWAR = IOCWAR + 1
          IF(IOCWAR.LE.5) WRITE(LFNPR,1305) OCCI,I
          IF(IOCWAR.EQ.5) WRITE(LFNPR,1306)
        END IF
        IF(OCCI.GT.TWO.AND.OCCI.LT.TWOP) OCCI = TWO
        IF(OCCI.LE.-ZEROX.OR.OCCI.GE.TWOX) GO TO 960
        BNDOCC(I) = OCCI
        V(I) = OCCI
        TOTELE = TOTELE + BNDOCC(I)
  800 CONTINUE
      NEL = INT(TOTELE + TENTH)
      ELECHK = ABS(TOTELE - DFLOAT(NEL))
      IF(ELECHK.GE.TOTP.AND.ELECHK.LT.TOTX) WRITE(LFNPR,1315) TOTELE
      IF(ELECHK.GT.TOTX) GO TO 970
      TOTELE = NEL
      NOCC = NEL
      IF(ISPIN.EQ.0) NOCC = NOCC/2 + MOD(NOCC,2)
C
C  Make sure all but the NOCC highest occupied NBOs are starred:
C
      CALL RANK(V,NNAO,NDIM,LARC)
      DO 804 I = 1,NOCC
        IR = LARC(I)
        LABEL(IBXM(IR),2) = IBLNK
  804 CONTINUE
      DO 805 I = NOCC+1,NNAO
        IR = LARC(I)
        LABEL(IBXM(IR),2) = ISTAR
  805 CONTINUE
C
C  Determine whether this is a good resonance structure:
C
      CALL CYCLES(ITER,THRESH,GUIDE,BNDOCC,TOPO,ICONT)
      IF(ICONT.EQ.0) THEN
        JPRINT(1) = -1
        RETURN
      END IF
      IF(ICONT.EQ.-1) GO TO 50
      IF(ICONT.EQ.1) GO TO 50
C
C  Before final return, write out info about core orbitals which
C  were isolated in subroutine NBCORE:
C
      CRTHRS = CRTSET
      IF(ISPIN.NE.0) CRTHRS = CRTHRS - ONE
      FIRST = .TRUE.
      DO 952 IAT = 1,NATOMS
        ILOW = 0
        DO 951 I = 1,NNAO
          IF(LABEL(IBXM(I),1).EQ.LCR.AND.LABEL(IBXM(I),4).EQ.IAT
     +       .AND.BNDOCC(I).LT.CRTHRS) ILOW = ILOW + 1
  951   CONTINUE
        IF(ILOW.NE.0) THEN
          IF(FIRST) THEN
            FIRST = .FALSE.
            NAM = NAMEAT(IATNO(IAT))
            IF(ILOW.NE.1) THEN
              IF(JPRINT(5).EQ.1) WRITE(LFNPR,3010) ILOW,CRTHRS,NAM,IAT
            ELSE
              IF(JPRINT(5).EQ.1) WRITE(LFNPR,3011) ILOW,CRTHRS,NAM,IAT
            END IF
          ELSE
            NAM = NAMEAT(IATNO(IAT))
            IF(ILOW.NE.1) THEN
              IF(JPRINT(5).EQ.1) WRITE(LFNPR,3020) ILOW,CRTHRS,NAM,IAT
            ELSE
              IF(JPRINT(5).EQ.1) WRITE(LFNPR,3021) ILOW,CRTHRS,NAM,IAT
            END IF
          END IF
        END IF
  952 CONTINUE
      RETURN
C
C  Problems with a bond orbital occupancy:
C
  960 WRITE(LFNPR,1300) OCCI,I
      JPRINT(1) = -1
      RETURN
C
C  Total number of electrons is not an integer:
C
  970 WRITE(LFNPR,1310) TOTELE
      JPRINT(1) = -1
      RETURN
C
 1200 FORMAT(/,1X,'For an occupancy threshold of ',F4.2,' the search',
     + ' for NBOs found',/,1X,I3,' orbitals orbitals rather than ',I4)
 1210 FORMAT(3X,'Label ',I3,':',A3,A1,I2,3I3)
 1300 FORMAT(/1X,'FATAL ERROR:  Non-physical NBO occupancy (',F8.5,
     + ' electrons), orbital',I4,'.',/4X,
     + 'Check input data or density.')
 1305 FORMAT(/1X,'WARNING:  Non-physical NBO occupancy (',F8.5,
     + ' electrons), orbital',I4,'.',/4X,
     + 'Check input data or density.  Program will continue.')
 1306 FORMAT(/1X,'NON-PHYSICAL OCCUPANCIES!  Further warning ',
     + 'messages suppressed.',/4X,'(Try FIXDM keyword.)')
 1310 FORMAT(/1X,'FATAL ERROR: Total number of electrons (',F10.5,
     + ') not an integer:',/4X,
     + 'Check input data or density (or try FIXDM keyword).')
 1315 FORMAT(/1X,'WARNING:  Total number of electrons (',F10.5,
     + ') not an integer.')
 1400 FORMAT(/1X,'Search of DM block between the following atoms:',
     +          3I4)
 1403 FORMAT(6X,'Select orbitals with eigenvalue > ',F9.6)
 1405 FORMAT(6X,8F9.6)
 1410 FORMAT(6X,'Eigenvector (',I2,') has occupancy ',F9.6,':')
 1420 FORMAT(11X,8F7.4)
 1500 FORMAT(11X,'Hybrid ',I1,' in eigenvector has a projection ',
     +    'expectation of ',F6.3)
 1600 FORMAT(11X,'*** NBO accepted: Number',I4,'.   Label:',A2,A1,
     + '(',I2,')')
 1800 FORMAT(/4X,'PRJTHR will be raised from ',F6.3,' to',F6.3,
     + ' and the NBO search repeated.',/)
 1810 FORMAT(//,1X,'Linearly independent hybrids for atom',I3,
     +' cannot be found.',/,1X,'The NBO program must abort.')
 3010 FORMAT(/,1X,
     +'        ',I3,' low occupancy (<',F6.4,'e) core orbitals ',
     +'found on ',A2,I2)
 3011 FORMAT(/,1X,
     +'        ',I3,' low occupancy (<',F6.4,'e) core orbital  ',
     +'found on ',A2,I2)
 3020 FORMAT(1X,
     +'        ',I3,' low occupancy (<',F6.4,'e) core orbitals ',
     +'found on ',A2,I2)
 3021 FORMAT(1X,
     +'        ',I3,' low occupancy (<',F6.4,'e) core orbital  ',
     +'found on ',A2,I2)
      END
C***********************************************************************
      SUBROUTINE CHSDRV(DM,T,GUIDE,BNDOCC,POL,Q,V,BLK,C,EVAL,BORB,
     *                                       P,TA,HYB,VA,VB,TOPO)
C***********************************************************************
C  5-Mar-01  EDG  Initialize NBTOPO to fix open-shell CHOOSE bug
C 28-Sep-07  FAW  Fixed misplaced comma (/,KH,/1HH/) in DATA
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL END,ERROR,EQUAL,BRANCH
C
      PARAMETER(MAXATM = 200)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBTOPO/IORDER(MAXATM),JORDER(MAXATM),NTOPO(MAXATM,MAXATM),
     +            N3CTR,I3CTR(10,3)
      DIMENSION DM(NDIM,NDIM),T(NDIM,NDIM),GUIDE(NATOMS,NATOMS),
     * BNDOCC(NDIM),POL(NDIM,3),Q(MXAO,NDIM),V(NDIM),BLK(MXBO,MXBO),
     * C(MXBO,MXBO),EVAL(MXBO),BORB(MXBO),P(MXAO,MXAO),TA(MXAO,MXAO),
     * HYB(MXAO),VA(MXAO),VB(MXAO),TOPO(NATOMS,NATOMS)
      DIMENSION KEYWD(6),KLONE(4),KBOND(4),K3CBON(6),KALPHA(5),
     * KBETA(4),IVAL(4),KALT(4)
C
      SAVE KLONE,KBOND,K3CBON,KALPHA,KBETA,KS,KD,KT,KQ,KP,KH,KALT
C
      DATA KLONE/1HL,1HO,1HN,1HE/,
     *     KBOND/1HB,1HO,1HN,1HD/,
     *     K3CBON/1H3,1HC,1HB,1HO,1HN,1HD/,
     *     KALPHA/1HA,1HL,1HP,1HH,1HA/,
     *     KBETA/1HB,1HE,1HT,1HA/,
     *     KS/1HS/,KD/1HD/,KT/1HT/,KQ/1HQ/,KP/1HP/,KH/1HH/,
     *     KALT/1H$,1HE,1HN,1HD/
C
C  Initialize the NTOPO array:
C
      DO 10 I = 1,NATOMS
        DO 5 J = 1,NATOMS
          NTOPO(J,I) = 0
    5   CONTINUE
   10 CONTINUE
C
C  Search for `ALPHA' or `BETA' character string in case of alpha or
C  beta spin density matrices:
C
      IF(ISPIN.EQ.2) THEN
   20   LENG = 5
          CALL HFLD(KEYWD,LENG,END)
          IF(END.AND.LENG.EQ.0) GOTO 810
          IF(.NOT.EQUAL(KEYWD,KALPHA,5)) GOTO 20
        CONTINUE
      ELSE IF(ISPIN.EQ.-2) THEN
   30   LENG = 5
          CALL HFLD(KEYWD,LENG,END)
          IF(END.AND.LENG.EQ.0) GOTO 820
          IF(.NOT.EQUAL(KEYWD,KBETA,4)) GOTO 30
        CONTINUE
      END IF
C
C  Fill diagonal elements of the TOPO matrix with nominal numbers of
C  lone pairs to be found on each atom:
C
      DO 50 IAT = 1,NATOMS
        NLP = 0
        CALL VALTBL(IAT,IVAL,0)
        DO 40 L = 0,3
          NLP = NLP + IVAL(L+1)*(2*L + 1)
   40   CONTINUE
        NTOPO(IAT,IAT) = 100 + NLP
   50 CONTINUE
C
C  Read in chosen lone pairs, bonds, and 3-center bonds:
C
      NCTR = 0
      N3CTR = 0
   60 CONTINUE
        LENG = 6
        CALL HFLD(KEYWD,LENG,END)
        IF(END.OR.EQUAL(KEYWD,KALT,4)) GOTO 300
        NCTRO = NCTR
        NCTR = 0
        IF(EQUAL(KEYWD,KLONE,4))  NCTR = 1
        IF(EQUAL(KEYWD,KBOND,4))  NCTR = 2
        IF(EQUAL(KEYWD,K3CBON,6)) NCTR = 3
        IF(NCTR.EQ.0) GO TO 1010
        IF(NCTR.LT.NCTRO) GO TO 1020
        GOTO (100,150,200), NCTR
C
C  Read in lone pairs:
C
  100 CONTINUE
        CALL IFLD(IAT,ERROR)
        IF(ERROR) THEN
          LENG = 6
          CALL HFLD(KEYWD,LENG,END)
          GO TO 60
        END IF
        CALL IFLD(NUM,ERROR)
        IF(ERROR) GOTO 830
        NTOPO(IAT,IAT) = NUM
      GOTO 100
C
C  Read in bonds:
C
  150 CONTINUE
        LENG = 1
        CALL HFLD(KEYWD,LENG,END)
        IF(END) GOTO 60
        NUM = 0
        IF(EQUAL(KEYWD,KS,1)) NUM = 1
        IF(EQUAL(KEYWD,KD,1)) NUM = 2
        IF(EQUAL(KEYWD,KT,1)) NUM = 3
        IF(EQUAL(KEYWD,KQ,1)) NUM = 4
        IF(EQUAL(KEYWD,KP,1)) NUM = 5
        IF(EQUAL(KEYWD,KH,1)) NUM = 6
        IF(NUM.EQ.0) GOTO 840
        CALL IFLD(IAT1,ERROR)
        IF(ERROR) GOTO 840
        CALL IFLD(IAT2,ERROR)
        IF(ERROR) GOTO 840
        IAT = MAX0(IAT1,IAT2)
        JAT = MIN0(IAT1,IAT2)
        NTOPO(IAT,JAT) = NUM
        NTOPO(JAT,IAT) = NUM
      GOTO 150
C
C  Read in 3-center bonds:
C
  200 CONTINUE
        IF(IW3C.NE.1) IW3C = 1
        LENG = 1
        CALL HFLD(KEYWD,LENG,END)
        IF(END) GOTO 60
        NUM = 0
        IF(EQUAL(KEYWD,KS,1)) NUM = 1
        IF(EQUAL(KEYWD,KD,1)) NUM = 2
        IF(EQUAL(KEYWD,KT,1)) NUM = 3
        IF(EQUAL(KEYWD,KQ,1)) NUM = 4
        IF(EQUAL(KEYWD,KP,1)) NUM = 5
        IF(EQUAL(KEYWD,KH,1)) NUM = 6
        IF(NUM.EQ.0) GOTO 860
        CALL IFLD(IAT1,ERROR)
        IF(ERROR) GOTO 860
        CALL IFLD(IAT2,ERROR)
        IF(ERROR) GOTO 860
        CALL IFLD(IAT3,ERROR)
        IF(ERROR) GOTO 860
        N3CTR = N3CTR + 1
        IF(N3CTR.GT.10) GOTO 870
        I3CTR(N3CTR,1) = IAT1
        I3CTR(N3CTR,2) = IAT2
        I3CTR(N3CTR,3) = IAT3
      GOTO 200
C
C  Modify nominal sets of lone pairs by number of bonds and 3-center
C  bonds.
C
  300 CONTINUE
      DO 330 IAT = 1,NATOMS
        NLP = NTOPO(IAT,IAT)
        IF(NLP.LT.100) GOTO 330
        NLP = MOD(NLP,100)
        NBD = 0
        DO 310 JAT = 1,NATOMS
          IF(IAT.NE.JAT.AND.NTOPO(JAT,IAT).NE.0) THEN
            NBD = NBD + NTOPO(JAT,IAT)
          END IF
  310   CONTINUE
        DO 320 KAT = 1,3
          DO 315 JAT = 1,N3CTR
            IF(I3CTR(JAT,KAT).EQ.IAT) NBD = NBD + 1
  315     CONTINUE
  320   CONTINUE
        NLP = NLP - NBD
        IF(NLP.LT.0) NLP = 0
        NTOPO(IAT,IAT) = NLP
  330 CONTINUE
C
C  Determine the order in which the atoms will be searched for electron pairs:
C
      CALL ATMORD(GUIDE,0)
C
C  Use NBCHSE to find bond orbitals using NTOPO and I3CTR:
C
      IFLG = 0
      BRANCH = .FALSE.
      CALL NBCHSE(DM,T,GUIDE,BNDOCC,POL,Q,V,BLK,C,EVAL,BORB,P,TA,HYB,
     +            VA,VB,TOPO,IFLG,BRANCH)
      RETURN
C
  810 WRITE(LFNPR,1180)
      JPRINT(1) = -1
      RETURN
C
  820 WRITE(LFNPR,1190)
      JPRINT(1) = -1
      RETURN
  830 WRITE(LFNPR,1130)
      JPRINT(1) = -1
      RETURN
C
  840 WRITE(LFNPR,1140)
      JPRINT(1) = -1
      RETURN
C
  860 WRITE(LFNPR,1160)
      JPRINT(1) = -1
      RETURN
C
  870 WRITE(LFNPR,1170)
      JPRINT(1) = -1
      RETURN
C
 1010 WRITE(LFNPR,1110) (KEYWD(I),I=1,6)
      JPRINT(1) = -1
      RETURN
C
 1020 WRITE(LFNPR,1120)
      JPRINT(1) = -1
      RETURN
C
 1110 FORMAT(/1X,'Error in input of bond orbitals:',/,1X,
     * 'Keyword for orbital type is not LONE, BOND, or 3CBOND (read `',
     * 6A1,''')')
 1120 FORMAT(/1X,'Error in input of bond orbitals:',/,1X,
     * 'Orbital types should be in the order: LONE, BOND, 3CBOND')
 1130 FORMAT(/1X,'Error in input of bond orbitals:',/,1X,
     * 'Unrecognizable characters in input of lone orbitals')
 1140 FORMAT(/1X,'Error in input of bond orbitals:',/,1X,
     * 'Unrecognizable characters in input of two center orbitals')
 1160 FORMAT(/1X,'Error in input of bond orbitals:',/,1X,
     * 'Unrecognizable characters in input of three center orbitals')
 1170 FORMAT(/1X,'Too many three center bonds:',
     * '  Increase parameter MAX3C')
 1180 FORMAT(/1X,'End of file encountered before the word ALPHA was ',
     * 'found')
 1190 FORMAT(/1X,'End of file encountered before the word BETA was ',
     * 'found')
      END
C***********************************************************************
      SUBROUTINE NBCHSE(DM,T,GUIDE,BNDOCC,POL,Q,V,BLK,C,EVAL,BORB,
     +                  P,TA,HYB,VA,VB,TOPO,IFLG,BRANCH)
C***********************************************************************
C 29-Jul-94  JKB  Projection threshold set down from 1.9 to 1.5
C 30-Jun-94  JKB  Added secondary threshold of occupancy -0.01/2.01e and
C                    total electrons +/-0.5e to allow for MP2, CI DM
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  Construct orthogonal matrix T for transformation from AO's to
C  Natural Hybrid Bond Orbitals using input density matrix DM
C  with the chosen bonding pattern read from LFNIN
C
      LOGICAL DETAIL,FIRST,PRINT,LEFT,BRANCH
      INTEGER UL
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       UL(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBTHR/THRSET,PRJSET,ACCTHR,CRTSET,E2THR,ATHR,PTHR,ETHR,
     +             DTHR,DLTHR,CHSTHR,REFTHR,STTHR,PRTHR,THRNCS,THRNJC
      COMMON/NBTOPO/IORDER(MAXATM),JORDER(MAXATM),NTOPO(MAXATM,MAXATM),
     +            N3CTR,I3CTR(10,3)
      COMMON/NBALT/IDX(MAXATM),JDX(MAXATM),KDX(MAXBAS),JCNT
      COMMON/IOCWAR/IOCWAR
C
      DIMENSION DM(NDIM,NDIM),T(NDIM,NDIM),GUIDE(NATOMS,NATOMS),
     * BNDOCC(NDIM),POL(NDIM,3),Q(MXAO,NDIM),V(NDIM),BLK(MXBO,MXBO),
     * C(MXBO,MXBO),EVAL(MXBO),BORB(MXBO),P(MXAO,MXAO),TA(MXAO,MXAO),
     * HYB(MXAO),VA(MXAO),VB(MXAO),TOPO(NATOMS,NATOMS)
      DIMENSION NAME(3),HYBEXP(3),KTOPO(MAXATM,MAXATM),KFLG(10)
C
      SAVE ISTAR,IBLNK,NAME,LRY,LCR
      SAVE ZERO,ZEROP,TOTP,TENTH,PT99,ONE,TWO,TWOP
      SAVE IONE,PRJINC
      SAVE ZEROX,TWOX,TOTX
C
      DATA ISTAR,IBLNK,NAME,LRY,LCR/1H*,1H ,2HLP,2HBD,2H3C,2HRY,2HCR/
      DATA ZERO,ZEROP,TENTH,PT99,ONE,TWO,TWOP,TOTP/0.0D0,1.0D-5,
     +     0.1D0,0.99D0,1.0D0,2.0D0,2.0001D0,5D-4/
      DATA IONE/1/
      DATA ZEROX,TWOX,TOTX/1.D-2,2.01D0,5D-1/
C
C  IFLG is a print flag on entering NBCHSE.  If set to 0(1), NBCHSE
C  will(not) print some output to LFNPR.  On exit, if IFLG is set to
C  -1, there was an error in finding the requested structure:
C
C  PRJINC, the amount to increase PRJTHR by if problems with linear
C  dependency between the hybrids arise.
C
      DATA PRJINC/0.05D0/
C
      NOPVAL(I) = NORBS(I) - INO(I)
C
      DETAIL = .FALSE.
      IF(IWDETL.NE.0) DETAIL = .TRUE.
      PRINT = .FALSE.
      IF(IFLG.EQ.0) PRINT = .TRUE.
      IF(JPRINT(5).EQ.0) PRINT = .FALSE.
      IF(DETAIL) PRINT = .TRUE.
C
C  Initialize KTOPO and KFLG arrays:  (KFLG is set to 1 if the 3-center
C  bond has not been found yet.)
C
      DO 10 I = 1,NATOMS
        DO 5 J = 1,I
          KTOPO(I,J) = NTOPO(I,J)
          KTOPO(J,I) = NTOPO(J,I)
    5   CONTINUE
   10 CONTINUE
      DO 15 I = 1,N3CTR
        KFLG(I) = 1
   15 CONTINUE
C
C  Return to here if it should prove necessary to raise PRJTHR:
C
      ITER = 0
      IALARM = 0
      PRJTHR = ABS(PRJSET)
      GTHR = 1.5D0
      IF(ISPIN.NE.0) GTHR = GTHR / 2
      CTHR = CHSTHR
      IF(ISPIN.NE.0) CTHR = CTHR / 2
   35 IF(IALARM.EQ.0) ITER = ITER + 1
      OCCMAX = ZERO
      OCCTHR = ABS(THRSET)
      IF(ISPIN.NE.0) OCCTHR = OCCTHR / 2
      BRTHR = OCCTHR
C
C  Either make a temporary copy of the branching indices or restore
C  the indices from the previous pass through NBCHSE:
C
      ICNT = 0
      IF(BRANCH.AND.IALARM.EQ.0) THEN
        IF(ITER.EQ.1) THEN
          CALL IDCOPY
        ELSE
          CALL IDREST
        END IF
      END IF
C
C  Restore the KTOPO matrix, if necessary:
C
      IF(ITER.GT.1.OR.IALARM.NE.0) THEN
        DO 37 I = 1,NATOMS
          DO 36 J = 1,I
            KTOPO(I,J) = NTOPO(I,J)
            KTOPO(J,I) = NTOPO(J,I)
   36     CONTINUE
   37   CONTINUE
        DO 38 I = 1,N3CTR
          KFLG(I) = 1
   38   CONTINUE
      END IF
C
C  Store density matrix in upper triangle of T:
C
      DO 50 J = 1,NNAO
        DO 40 I = 1,J
          T(I,J) = DM(I,J)
   40   CONTINUE
   50 CONTINUE
C
C  Zero arrays Q,POL,IATHY,INO,LABEL:
C
      DO 100 I = 1,NNAO
        DO 60 K = 1,2
          LABEL(I,K) = IBLNK
   60   CONTINUE
        DO 70 K = 3,6
          LABEL(I,K) = 0
   70   CONTINUE
        DO 80 K = 1,3
          POL(I,K) = ZERO
          IATHY(I,K) = 0
   80   CONTINUE
        DO 90 K = 1,MXAO
          Q(K,I) = ZERO
   90   CONTINUE
  100 CONTINUE
      DO 110 I = 1,NATOMS
        INO(I) = 0
  110 CONTINUE
C
C  Remove core orbitals from the density matrix:
C
      IBD = 0
      CALL NBCORE(DM,T,BORB,POL,Q,HYB,BNDOCC,IBD,DETAIL,LFNPR)
C
C  Return here if there are still more lone pairs or bonds to be found.
C  Lower the occupancy threshold for acceptance by a tenth:
C
  115 CONTINUE
      LEFT = .FALSE.
C
C   ********      START DIRECTED NBO SEARCH      *********
C
C  Loop over numbers of centers, removing lone pairs and 2- and 3-center
C  bonds from the density matrix according to KTOPO and I3CTR:
C
      NCTR = 0
  120 NCTR = NCTR + 1
C
C  Deplete DM of one(two) center orbitals if search for two(three)
C  center orbitals is beginning:
C
        IF(NCTR.NE.1) CALL DEPLET(DM,T,Q,POL,BORB,BNDOCC,IBD)
C
C  Return here for 3-c bonds and lone pairs:
C
        ICNTR = 0
  130   ICNTR = ICNTR + 1
          IF(NCTR.EQ.1) THEN
            IF(ICNTR.GT.NATOMS) GOTO 120
            NUM = KTOPO(IORDER(ICNTR),IORDER(ICNTR))
            IF(NUM.LE.0) GOTO 130
            IAT1 = IORDER(ICNTR)
            IAT2 = 0
            IAT3 = 0
            GOTO 200
          ELSE IF(NCTR.EQ.2) THEN
            IF(ICNTR.GT.NATOMS) GOTO 120
            JCNTR = ICNTR
C
C  Return here for 2-c bonds:
C
  150       JCNTR = JCNTR + 1
              IF(JCNTR.GT.NATOMS) GOTO 130
              NUM = KTOPO(IORDER(JCNTR),IORDER(ICNTR))
              IF(NUM.EQ.0) GOTO 150
              IAT1 = MIN(IORDER(ICNTR),IORDER(JCNTR))
              IAT2 = MAX(IORDER(ICNTR),IORDER(JCNTR))
              IAT3 = 0
              GOTO 200
          ELSE IF(NCTR.EQ.3) THEN
            IF(ICNTR.GT.N3CTR) GOTO 120
            IF(KFLG(ICNTR).EQ.0) GOTO 130
            NUM = 1
            IAT1 = MIN(I3CTR(ICNTR,1),I3CTR(ICNTR,2),I3CTR(ICNTR,3))
            IAT3 = MAX(I3CTR(ICNTR,1),I3CTR(ICNTR,2),I3CTR(ICNTR,3))
            IAT2 = I3CTR(ICNTR,1)
            IF(IAT2.EQ.IAT1.OR.IAT2.EQ.IAT3) IAT2 = I3CTR(ICNTR,2)
            IF(IAT2.EQ.IAT1.OR.IAT2.EQ.IAT3) IAT2 = I3CTR(ICNTR,3)
            GOTO 200
          ELSE
            GOTO 300
          END IF
C
C  Load proper atomic blocks of DM into BLK, and diagonalize BLK:
C
  200 CONTINUE
      CALL LOAD(DM,IAT1,IAT2,IAT3,BLK,NB)
      CALL NBJACOBI(NB,BLK,EVAL,C,MXBO,MXBO,1)
C
C  Rank eigenvectors by occupancy eigenvalue:
C
      CALL RANK(EVAL,NB,MXBO,LARC)
      IF(DETAIL) WRITE(LFNPR,1400) IAT1,IAT2,IAT3
      IF(DETAIL) WRITE(LFNPR,1402) NUM,OCCTHR
      IF(DETAIL) WRITE(LFNPR,1405) (EVAL(IRNK),IRNK=1,NB)
C
C  If we want more orbitals than are available (NUM.GT.NB), modify
C  the topo matrix and write a warning:
C
      IF(NUM.GT.NB) THEN
        IF(NCTR.EQ.1) THEN
          KTOPO(IAT1,IAT1) = NB
          IF(PRINT) WRITE(LFNPR,1900) NB,NUM,IAT1
        ELSE IF(NCTR.EQ.2) THEN
          KTOPO(IAT1,IAT2) = NB
          KTOPO(IAT2,IAT1) = NB
          IF(PRINT) WRITE(LFNPR,2000) NB,NUM,IAT1,IAT2
        ELSE
          KFLG(ICNTR) = 0
          IF(PRINT) WRITE(LFNPR,2100) IAT1,IAT2,IAT3
        END IF
        NUM = NB
        IFLG = -1
      END IF
C
C  Find a list KDX of candidate orbitals (NC in number) with occupancy
C  greater than OCCTHR and projection expectation greater than PRJTHR.
C  Determine the number of healthy orbitals NH having occupancy greater
C  than GTHR:
C
      IB = 0
      NC = 0
      NH = 0
      OTHR = OCCTHR
  210 IB = IB + 1
      IF(IB.GT.NB) GOTO 250
      IF(EVAL(IB).LT.OTHR) GOTO 250
        IR = LARC(IB)
        DO 220 I = 1,NB
          BORB(I) = C(I,IR)
  220   CONTINUE
        IF(DETAIL) WRITE(LFNPR,1410) IB,EVAL(IB)
        IF(DETAIL) WRITE(LFNPR,1420) (BORB(I),I=1,NB)
        CALL PRJEXP(BORB,IAT1,IAT2,IAT3,Q,P,TA,HYB,VA,VB,HYBEXP)
        IF(DETAIL) THEN
          DO 230 IHYB = 1,NCTR
            WRITE(LFNPR,1500) IHYB,HYBEXP(IHYB)
  230     CONTINUE
        END IF
        DO 240 IHYB = 1,NCTR
          IF(HYBEXP(IHYB).LT.PRJTHR) GOTO 210
  240   CONTINUE
        NC = NC + 1
        IF(EVAL(IB).GE.GTHR) NH = NH + 1
        KDX(NC) = IB
        IF(NC.EQ.NUM) THEN
          IF(EVAL(IB).GT.GTHR) THEN
            OTHR = GTHR
          ELSE
            IF(NCTR.NE.1) OTHR = MAX(OTHR,EVAL(IB)-ABS(CTHR))
          END IF
        END IF
      GOTO 210
  250 CONTINUE
C
C  If OCCTHR.le.zero and no candidate orbitals can be found, error out
C  after replenishing the DM from T:
C
      IF(OCCTHR.LE.ZERO.AND.NC.EQ.0) THEN
        IF(PRINT) WRITE(LFNPR,1950)
        IFLG = -1
        JPRINT(1) = -1
        DO 255 J = 1,NNAO
          DO 254 I = 1,J
            DM(I,J) = T(I,J)
            DM(J,I) = DM(I,J)
            T(J,I) = ZERO
            T(I,J) = ZERO
  254     CONTINUE
  255   CONTINUE
        RETURN
      END IF
C
C  If there are more candidate orbitals than we want (i.e. NC>NUM),
C  let's take a particular selection (branch according to JDX).  We
C  can run NBCHSE later to pick up alternate selections. (If the
C  projection threshold needed to be raised, IALARM.NE.0, use the same
C  branching indices employed during the previous pass):
C
      IF(NC.GT.NUM.AND.OCCTHR.EQ.BRTHR.AND.BRANCH) THEN
        IF(IALARM.EQ.0) THEN
          ICNT = ICNT + 1
          IF(ICNT.GT.JCNT) THEN
            CALL IDINIT(ICNT,NC,NH,NUM)
          ELSE IF(ICNT.EQ.JCNT) THEN
            CALL IDINCR(ICNT,NC,NH,NUM)
          END IF
          JDXT = JDX(ICNT)
          IF(PRINT.AND.(ICNT.EQ.1.OR.DETAIL)) WRITE(LFNPR,1000)
          IF(PRINT) WRITE(LFNPR,1100) ICNT,IAT1,IAT2,IAT3,NC,NUM,
     +                                JDX(ICNT),IDX(ICNT)
        ELSE
          ICNT = ICNT + 1
          IF(ICNT.LE.JCNT) THEN
            JDXT = JDX(ICNT)
            IF(PRINT.AND.(ICNT.EQ.1.OR.DETAIL)) WRITE(LFNPR,1000)
            IF(PRINT) WRITE(LFNPR,1100) ICNT,IAT1,IAT2,IAT3,NC,NUM,
     +                                  JDX(ICNT),IDX(ICNT)
          ELSE
            JDXT = -1
          END IF
        END IF
      ELSE
        JDXT = -1
      END IF
C
C  Before selecting orbitals from the candidate list, prepare to label
C  the orbitals:
C
      IF(NCTR.EQ.1) THEN
        ISHIFT = NTOPO(IAT1,IAT1) - KTOPO(IAT1,IAT1)
      ELSE IF(NCTR.EQ.2) THEN
        ISHIFT = NTOPO(IAT1,IAT2) - KTOPO(IAT1,IAT2)
      ELSE
        ISHIFT = 0
      END IF
C
C  Loop through the candidate orbitals, making a selection of NUM
C  orbitals according to JDXT:
C
      IACCEP = 0
      DO 270 IC = 1,NC
        IF(IDTEST(JDXT,IC,NUM).EQ.1) THEN
          IR = LARC(KDX(IC))
          DO 260 I = 1,NB
            BORB(I) = C(I,IR)
  260     CONTINUE
C
C  If this is the second, third,.. bond orbital selected for the current
C  TOPO matrix element, check its hybrid projection expectation value again:
C
          IF(IACCEP.NE.0.AND.NCTR.NE.1) THEN
            CALL PRJEXP(BORB,IAT1,IAT2,IAT3,Q,P,TA,HYB,VA,VB,HYBEXP)
            DO 265 IHYB = 1,NCTR
              IF(DETAIL) WRITE(LFNPR,1500) IHYB,HYBEXP(IHYB)
              IF(HYBEXP(IHYB).LT.PRJTHR) THEN
                IF(JDXT.GT.0) THEN
                  IF(PRINT) WRITE(LFNPR,1950)
                  IFLG = -1
                  JPRINT(1) = -1
                  DO 264 J = 1,NNAO
                    DO 263 I = 1,J
                      DM(I,J) = T(I,J)
                      DM(J,I) = DM(I,J)
                      T(J,I) = ZERO
                      T(I,J) = ZERO
  263               CONTINUE
  264             CONTINUE
                  RETURN
                ELSE
                  GOTO 270
                END IF
              END IF
  265       CONTINUE
          END IF
C
C  Decompose "BORB" into its constituent atomic hybrids and store in Q:
C
          IBD = IBD + 1
          CALL STASH(BORB,IBD,IAT1,IAT2,IAT3,POL,Q,HYB)
C
C  Construct bond orbital labels:
C
          IACCEP = IACCEP + 1
          LABEL(IBD,1) = NAME(NCTR)
          LABEL(IBD,2) = IBLNK
          LABEL(IBD,3) = IACCEP + ISHIFT
          LABEL(IBD,4) = IAT1
          LABEL(IBD,5) = IAT2
          LABEL(IBD,6) = IAT3
          BNDOCC(IBD)  = EVAL(KDX(IC))
          IF(DETAIL) WRITE(LFNPR,1600) KDX(IC),IBD,
     +                                 (LABEL(IBD,I),I=1,3)
        END IF
  270 CONTINUE
C
C  Adjust the KTOPO matrix:
C
      IP = 1
      IF(NC.GT.0) IP = KDX(NC) + 1
      IF(IP.GT.NB) IP = NB
      IF(NCTR.EQ.1) THEN
        KTOPO(IAT1,IAT1) = KTOPO(IAT1,IAT1) - IACCEP
        IF(KTOPO(IAT1,IAT1).GT.0) THEN
          IF(DETAIL) WRITE(LFNPR,1610) KTOPO(IAT1,IAT1)
          IF(LEFT) THEN
            IF(OCCMAX.LT.EVAL(IP)) OCCMAX = EVAL(IP)
          ELSE
            LEFT = .TRUE.
            OCCMAX = EVAL(IP)
          END IF
        END IF
      ELSE IF(NCTR.EQ.2) THEN
        KTOPO(IAT1,IAT2) = KTOPO(IAT1,IAT2) - IACCEP
        KTOPO(IAT2,IAT1) = KTOPO(IAT1,IAT2)
        IF(KTOPO(IAT1,IAT2).GT.0) THEN
          IF(DETAIL) WRITE(LFNPR,1610) KTOPO(IAT1,IAT2)
          IF(LEFT) THEN
            IF(OCCMAX.LT.EVAL(IP)) OCCMAX = EVAL(IP)
          ELSE
            LEFT = .TRUE.
            OCCMAX = EVAL(IP)
          END IF
        END IF
      ELSE
        KFLG(ICNTR) = KFLG(ICNTR) - IACCEP
        IF(KFLG(ICNTR).GT.0) THEN
          IF(DETAIL) WRITE(LFNPR,1610) IONE
          IF(LEFT) THEN
            IF(OCCMAX.LT.EVAL(IP)) OCCMAX = EVAL(IP)
          ELSE
            LEFT = .TRUE.
            OCCMAX = EVAL(IP)
          END IF
        END IF
      END IF
      IF(NCTR.EQ.1.OR.NCTR.EQ.3) THEN
        GOTO 130
      ELSE
  290   JCNTR = JCNTR + 1
        IF(JCNTR.GT.NATOMS) GOTO 130
        NUM = KTOPO(IORDER(JCNTR),IORDER(ICNTR))
        IF(NUM.EQ.0) GOTO 290
        IAT1 = MIN(IORDER(ICNTR),IORDER(JCNTR))
        IAT2 = MAX(IORDER(ICNTR),IORDER(JCNTR))
        IAT3 = 0
        GOTO 200
      END IF
C
C   ******** END OF LOOP FOR DIRECTED NBO SEARCH *********
C
  300 CONTINUE
C
C  If some orbitals were left behind, go back and fetch them:
C
      IF(LEFT) THEN
        OCCTHR = OCCTHR - TENTH
        IF(OCCTHR.GT.OCCMAX) OCCTHR = OCCMAX - TENTH
        IF(OCCTHR.LT.ZERO) OCCTHR = ZERO
        GOTO 115
      END IF
C
C  Symmetrically orthogonalize principal hybrids:
C
      CALL ORTHYB(Q,BLK,TA,EVAL,C,IALARM,IFLG)
C
C  IALARM sounds the alarm that there is linear dependency between some of the
C  hybrids.  IALARM is equal to the number of the violating atom.  Replenish
C  DM from T and repeat the NBO search:
C
      IF(IALARM.NE.0) THEN
C
C  Note that incrementing PRJTHR is incompatible with the branching algorithm.
C  Skip this structure if branching is turned on:
C
        IF(BRANCH) THEN
          IFLG = -1
          JPRINT(1) = -1
          DO 320 J = 1,NNAO
            DO 310 I = 1,J
              DM(I,J) = T(I,J)
              DM(J,I) = DM(I,J)
              T(I,J) = ZERO
              T(J,I) = ZERO
  310       CONTINUE
  320     CONTINUE
          RETURN
        END IF
        OLDPRJ = PRJTHR
        PRJTHR = OLDPRJ + PRJINC
        IF(PRINT) WRITE(LFNPR,1800) OLDPRJ,PRJTHR
        IF(PRJTHR.GE.PT99) THEN
          IF(PRINT) WRITE(LFNPR,1810) IALARM
          IFLG = -1
          JPRINT(1) = -1
          RETURN
        END IF
        GOTO 700
      END IF
C
C  Augment open-valence atoms with non-arbitrary hybrids orthogonal to those
C  found previously:
C
      DO 580 IA = 1,NATOMS
        IF(NOPVAL(IA).LE.0) GOTO 580
C
C  Find NMB, the number of natural minimal basis functions on this atom:
C
        LLA = LL(IA)
        IULA = UL(IA)
        NMB = 0
        DO 470 I = LLA,IULA
          IF(LSTOCC(I).EQ.1) NMB = NMB + 1
  470   CONTINUE
C
C  Find the number of bond, core, and lone pair hybrids on this atom, IOCC.
C  Also find IOCCLP, the number of lone pair orbitals already found
C  on atom IA for use in labelling the extra lone pairs below:
C
        IOCC = 0
        IOCCLP = 0
        DO 480 IB = 1,IBD
          IF((LABEL(IB,4).NE.IA).AND.(LABEL(IB,5).NE.IA).AND.
     *            (LABEL(IB,6).NE.IA)) GOTO 480
          IOCC = IOCC + 1
          IF(LABEL(IB,1).EQ.NAME(1)) THEN
            IOCCLP = IOCCLP + 1
          END IF
  480   CONTINUE
C
C  NEXLP, the number of extra (low occupancy) LP orbitals on atom IAT.
C  (This is the number of low occupancy orbitals with valence shell character)
C  Set NEXLP to zero if (NMB-IOCC) is less than zero!!
C
        NEXLP = NMB - IOCC
        IF(NEXLP.LT.0) NEXLP = 0
        NOCC = INO(IA)
        CALL NBFPRJ(P,IA,Q,NOCC,TA,VA,VB)
        NORB = NORBS(IA)
        NAUGM = NORB - NOCC
        CALL AUGMNT(P,BLK,C,EVAL,DM,TA,BORB,V,LARC,IA,NOCC,NORB)
C
C  Stash and label extra lone pairs that AUGMNT put in BLK:
C  (These are taken to be the highest occupied orbitals, which
C  AUGMNT places first)
C
        DO 510 IAUGM = 1,NEXLP
          DO 500 J = 1,NORB
  500       BORB(J) = BLK(J,IAUGM)
          IBD = IBD + 1
          CALL STASH(BORB,IBD,IA,0,0,POL,Q,HYB)
          LABEL(IBD,1) = NAME(1)
          LABEL(IBD,2) = ISTAR
          LABEL(IBD,3) = IAUGM+IOCCLP
          LABEL(IBD,4) = IA
          LABEL(IBD,5) = 0
          LABEL(IBD,6) = 0
  510   CONTINUE
C
C  Stash and label the Rydberg orbitals that AUGMNT put in BLK:
C
        IRYD = 0
        NSTART = NEXLP + 1
        DO 540 IAUGM = NSTART,NAUGM
          DO 530 J = 1,NORB
  530       BORB(J) = BLK(J,IAUGM)
          IBD = IBD + 1
          IRYD = IRYD + 1
          CALL STASH(BORB,IBD,IA,0,0,POL,Q,HYB)
          LABEL(IBD,1) = LRY
          LABEL(IBD,2) = ISTAR
          LABEL(IBD,3) = IRYD
          LABEL(IBD,4) = IA
          LABEL(IBD,5) = 0
          LABEL(IBD,6) = 0
  540   CONTINUE
  580 CONTINUE
C
C  Include antibond labels:
C
      IBO = IBD
      DO 660 I = 1,IBO
C
C  Exit loop if LABEL(I,1) is 'LP', 'RY', OR 'CR':
C
        IF(LABEL(I,1).EQ.NAME(1)) GOTO 660
        IF(LABEL(I,1).EQ.LRY)     GOTO 660
        IF(LABEL(I,1).EQ.LCR)     GOTO 660
          NAB = 1
          IF(LABEL(I,1).EQ.NAME(3)) NAB = 2
          DO 650 IAB = 1,NAB
            IBD = IBD + 1
            DO 640 J = 1,6
  640         LABEL(IBD,J) = LABEL(I,J)
            LABEL(IBD,2) = ISTAR
  650     CONTINUE
  660 CONTINUE
      IF(IBD.EQ.NNAO) GOTO 670
      CALL NBHALT('Miscounted orbitals, program must abort.')
  670 CONTINUE
C
C  Replace density matrix DM from T:
C
  700 CONTINUE
      DO 750 J = 1,NNAO
        DO 740 I = 1,J
          DM(I,J) = T(I,J)
          DM(J,I) = DM(I,J)
          T(J,I) = ZERO
          T(I,J) = ZERO
  740   CONTINUE
  750 CONTINUE
C
C  If the alarm sounded, repeat directed NBO search:
C
      IF(IALARM.NE.0) GOTO 35
C
C  Find new polarization parameters for orthonormal hybrids:
C
      CALL REPOL(DM,Q,POL,BLK,EVAL,C,IBD)
C
C  Form final T-NAB (NAO to NBO transformation) from orthonormal hybrids:
C
      CALL FORMT(T,Q,POL)
C
C  Find occupancies, find total number of electrons and occupied orbitals:
C
      TOTELE = ZERO
      DO 800 I = 1,NNAO
        OCCI = ZERO
        DO 790 J = 1,NNAO
          DO 790 K = 1,NNAO
  790       OCCI = OCCI + T(J,I) * DM(J,K) * T(K,I)
        IF(OCCI.LE.-ZEROP.AND.OCCI.GT.-ZEROX) THEN
          IOCWAR = IOCWAR + 1
          IF(IOCWAR.LE.5) WRITE(LFNPR,1305) OCCI,I
          IF(IOCWAR.EQ.5) WRITE(LFNPR,1306)
        END IF
        IF(OCCI.LT.ZERO.AND.OCCI.GT.-ZEROP) OCCI = ZERO
        IF(OCCI.GE.TWOP.AND.OCCI.LT.TWOX) THEN
          IOCWAR = IOCWAR + 1
          IF(IOCWAR.LE.5) WRITE(LFNPR,1305) OCCI,I
          IF(IOCWAR.EQ.5) WRITE(LFNPR,1306)
        END IF
        IF(OCCI.GT.TWO.AND.OCCI.LT.TWOP) OCCI = TWO
        IF(OCCI.LE.-ZEROX.OR.OCCI.GE.TWOX) GO TO 960
        BNDOCC(I) = OCCI
        V(I) = OCCI
        TOTELE = TOTELE + BNDOCC(I)
  800 CONTINUE
      NEL = INT(TOTELE + TENTH)
      ELECHK = ABS(TOTELE - DFLOAT(NEL))
      IF(ELECHK.GE.TOTP.AND.ELECHK.LT.TOTX) WRITE(LFNPR,1315) TOTELE
      IF(ELECHK.GT.TOTX) GO TO 965
      TOTELE = NEL
      NOCC = NEL
      IF(ISPIN.EQ.0) NOCC = NOCC/2 + MOD(NOCC,2)
C
C  If the number of unstarred orbitals is not equal to the number of occupied
C  MOs, then simply rank the orbitals by occupancy, and ``unstarr'' the NOCC
C  highest occupied:  (This can be dangerous!  However, many of the subsequent
C  routines assume the only NOCC orbitals are starred, and therefore, any
C  discrepancy must be corrected.)
C
      NOSTR = 0
      DO 801 I = 1,NNAO
        IF(LABEL(IBXM(I),2).NE.ISTAR) NOSTR = NOSTR + 1
  801 CONTINUE
      IF(NOSTR.NE.NOCC) THEN
        CALL RANK(V,NNAO,NDIM,LARC)
        DO 804 I = 1,NOCC
          IR = LARC(I)
          LABEL(IBXM(IR),2) = IBLNK
  804   CONTINUE
        DO 805 I = NOCC+1,NNAO
          IR = LARC(I)
          LABEL(IBXM(IR),2) = ISTAR
  805   CONTINUE
      END IF
C
C  Determine whether this is a good resonance structure: (Don't run
C  CYCLES if the branching algorithm is turned on.  CYCLES will mess
C  up the IORDER array)
C
      IF(PRINT.AND..NOT.BRANCH) THEN
        THRABS = ABS(THRSET)
        CALL CYCLES(ITER,THRABS,GUIDE,BNDOCC,TOPO,ICONT)
      END IF
C
C  Write out info about core orbitals which were isolated in subroutine
C  CORE:
C
      IF(PRINT) THEN
        CRTHRS = CRTSET
        IF(ISPIN.NE.0) CRTHRS = CRTHRS - ONE
        FIRST = .TRUE.
        DO 952 IAT = 1,NATOMS
          ILOW = 0
          DO 951 I = 1,NNAO
            IF(LABEL(IBXM(I),1).EQ.LCR.AND.LABEL(IBXM(I),4).EQ.IAT
     +         .AND.BNDOCC(I).LT.CRTHRS) ILOW = ILOW + 1
  951     CONTINUE
          IF(ILOW.NE.0) THEN
            IF(FIRST) THEN
              FIRST = .FALSE.
              NAM = NAMEAT(IATNO(IAT))
              IF(ILOW.NE.1) THEN
                WRITE(LFNPR,3010) ILOW,CRTHRS,NAM,IAT
              ELSE
                WRITE(LFNPR,3011) ILOW,CRTHRS,NAM,IAT
              END IF
            ELSE
              NAM = NAMEAT(IATNO(IAT))
              IF(ILOW.NE.1) THEN
                WRITE(LFNPR,3020) ILOW,CRTHRS,NAM,IAT
              ELSE
                WRITE(LFNPR,3021) ILOW,CRTHRS,NAM,IAT
              END IF
            END IF
          END IF
  952   CONTINUE
      END IF
      RETURN
C
C  Bad orbital occupancy:
C
  960 IF(PRINT) WRITE(LFNPR,1300) OCCI,I
      IFLG = -1
      JPRINT(1) = -1
      RETURN
C
C  Total number of electrons is not an integer:
C
  965 WRITE(LFNPR,1310) TOTELE
      IFLG = -1
      JPRINT(1) = -1
      RETURN
C
 1000 FORMAT(/1X,'  Branch     Atoms    # Candidate  # Requested   Bra',
     + 'nching     Limiting',/1X,'  Point    1   2   3   Orbitals     ',
     + 'Orbitals       Index        Index',/1X,'======================',
     + '===================================================')
 1100 FORMAT(1X,I5,I7,2I4,I8,3I13)
 1300 FORMAT(/1X,'FATAL ERROR:  Non-physical NBO occupancy (',F8.5,
     + ' electrons), orbital',I4,'.',/4X,
     + 'Check input data or density.')
 1305 FORMAT(/1X,'WARNING:  Non-physical NBO occupancy (',F8.5,
     + ' electrons), orbital',I4,'.',/4X,
     + 'Check input data or density.  Program will continue.')
 1306 FORMAT(/1X,'NON-PHYSICAL OCCUPANCIES!  Further warning ',
     + 'messages suppressed.')
 1310 FORMAT(/1X,'FATAL ERROR: Total number of electrons (',F10.5,
     + ') not an integer:',/4X,'Check input data or density.')
 1315 FORMAT(/1X,'WARNING:  Total number of electrons (',F10.5,
     + ') not an integer.  Program will continue.')
 1400 FORMAT(/1X,'Search of DM block between the following atoms:',
     +          3I4)
 1402 FORMAT(6X,'Select ',I2,' orbital(s) with eigenvalue > ',F9.6)
 1405 FORMAT(6X,8F9.6)
 1410 FORMAT(6X,'Eigenvector (',I2,') has occupancy ',F9.6,':')
 1420 FORMAT(11X,8F7.4)
 1500 FORMAT(11X,'Hybrid ',I1,' in eigenvector has a projection ',
     +    'expectation of ',F6.3)
 1600 FORMAT(6X,'Eigenvector (',I2,') accepted: Number',I3,'.  ',
     + ' Label:',A2,A1,'(',I2,')')
 1610 FORMAT(1X,'Still need to find',I2,' more orbital(s)')
 1800 FORMAT(/4X,'PRJTHR will be raised from ',F6.3,' to',F6.3,
     + ' and the NBO search repeated',/)
 1810 FORMAT(//,1X,'Linearly independent hybrids for atom',I3,
     +' cannot be found.',/,1X,'The NBO program must abort.')
 1900 FORMAT(/1X,'Only ',I1,' of the ',I1,' requested lone pairs on ',
     + 'atom ',I2,' can be found.')
 1950 FORMAT(/1X,'CHOOSE cannot find an acceptable resonance ',
     + 'structure.')
 2000 FORMAT(/1X,'Only ',I1,' of the ',I1,' requested bonds between ',
     + 'atoms ',I2,' and ',I2,' can be found.')
 2100 FORMAT(/1X,'Only ',I1,' of the ',I1,' requested bonds between ',
     + 'atoms ',I2,', ',I2,', and ',I2,' can be found.')
 3010 FORMAT(/,1X,
     +'        ',I3,' low occupancy (<',F6.4,'e) core orbitals ',
     +'found on ',A2,I2)
 3011 FORMAT(/,1X,
     +'        ',I3,' low occupancy (<',F6.4,'e) core orbital  ',
     +'found on ',A2,I2)
 3020 FORMAT(1X,
     +'        ',I3,' low occupancy (<',F6.4,'e) core orbitals ',
     +'found on ',A2,I2)
 3021 FORMAT(1X,
     +'        ',I3,' low occupancy (<',F6.4,'e) core orbital  ',
     +'found on ',A2,I2)
      END
C***********************************************************************
      SUBROUTINE SRTNBO(T,BNDOCC)
C***********************************************************************
C  6-May-93  EDG  Place all LP* orbitals after LP and before RY*.
C                 NLMO expects all unstarred orbitals to appear first
C                 in list of NBO's
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL PERMUT
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
C
      DIMENSION T(NDIM,NDIM),BNDOCC(NDIM)
      DIMENSION NAME(4)
C
      SAVE LBD,L3C,NAME,LSTAR
      DATA LBD,L3C,NAME,LSTAR/2HBD,2H3C,2HCR,2HLP,2HLP,2HRY,1H*/
C
C  Reorder the NBOs according to bond type and constituent atomic centers:
C
C  Fix atom ordering in the NBO labels:
C
      DO 100 I = 1,NNAO
        NCTR = 0
        DO 10 J = 4,6
          IF(LABEL(I,J).NE.0) THEN
            NCTR = NCTR + 1
            LARC(NCTR) = LABEL(I,J)
          END IF
   10   CONTINUE
        DO 30 J = 1,NCTR-1
          DO 20 K = 1,NCTR-J
            IF(LARC(K).GT.LARC(K+1)) THEN
              ITEMP     = LARC(K)
              LARC(K)   = LARC(K+1)
              LARC(K+1) = ITEMP
            END IF
   20     CONTINUE
   30   CONTINUE
        DO 40 J = 1,NCTR
          LABEL(I,J+3) = LARC(J)
   40   CONTINUE
        DO 50 J = NCTR+1,3
          LABEL(I,J+3) = 0
   50   CONTINUE
  100 CONTINUE
C
C  Place the 2- and 3-center bonds first in the list of NBOs: (No bonds if
C  the NOBOND keyword was specified)
C
      ICNT = 0
      IF(JPRINT(10).EQ.0) THEN
        DO 200 I = 1,NATOMS-1
          DO 190 J = I+1,NATOMS
            IF(I.NE.J) THEN
              K = -1
  110         K = K + 1
              DO 180 L = ICNT+1,NNAO
                LBL1 = LABEL(IBXM(L),1)
                LBL2 = LABEL(IBXM(L),2)
                LBL3 = LABEL(IBXM(L),3)
                LBL4 = LABEL(IBXM(L),4)
                LBL5 = LABEL(IBXM(L),5)
                LBL6 = LABEL(IBXM(L),6)
                IF((LBL1.EQ.LBD.OR.LBL1.EQ.L3C).AND.LBL2.NE.LSTAR) THEN
                  IF(LBL4.EQ.I.AND.LBL5.EQ.J.AND.LBL6.EQ.K) THEN
                    ICNT = ICNT + 1
                    LABEL(IBXM(L),1)    = LABEL(IBXM(ICNT),1)
                    LABEL(IBXM(L),2)    = LABEL(IBXM(ICNT),2)
                    LABEL(IBXM(L),3)    = LABEL(IBXM(ICNT),3)
                    LABEL(IBXM(L),4)    = LABEL(IBXM(ICNT),4)
                    LABEL(IBXM(L),5)    = LABEL(IBXM(ICNT),5)
                    LABEL(IBXM(L),6)    = LABEL(IBXM(ICNT),6)
                    LABEL(IBXM(ICNT),1) = LBL1
                    LABEL(IBXM(ICNT),2) = LBL2
                    LABEL(IBXM(ICNT),3) = LBL3
                    LABEL(IBXM(ICNT),4) = LBL4
                    LABEL(IBXM(ICNT),5) = LBL5
                    LABEL(IBXM(ICNT),6) = LBL6
                    TEMP         = BNDOCC(L)
                    BNDOCC(L)    = BNDOCC(ICNT)
                    BNDOCC(ICNT) = TEMP
                    DO 170 M = 1,NNAO
                      TEMP      = T(M,L)
                      T(M,L)    = T(M,ICNT)
                      T(M,ICNT) = TEMP
  170               CONTINUE
                  END IF
                END IF
  180         CONTINUE
              IF(IW3C.NE.0.AND.K.EQ.0) K = J
              IF(K.GT.0.AND.K.LT.NATOMS) GOTO 110
            END IF
  190     CONTINUE
  200   CONTINUE
      END IF
C
C  Next add any core, lone pair, lone pair*, and Rydberg orbitals:
C
      DO 300 II = 1,4
        DO 290 I = 1,NATOMS
          DO 280 J = ICNT+1,NNAO
            LBL1 = LABEL(IBXM(J),1)
            LBL2 = LABEL(IBXM(J),2)
            LBL4 = LABEL(IBXM(J),4)
            IF(II.EQ.2.AND.LBL2.EQ.LSTAR) GOTO 280
            IF(II.EQ.3.AND.LBL2.NE.LSTAR) GOTO 280
            IF(LBL1.EQ.NAME(II).AND.LBL4.EQ.I) THEN
              ICNT = ICNT + 1
              DO 260 K = 1,6
                ITEMP               = LABEL(IBXM(J),K)
                LABEL(IBXM(J),K)    = LABEL(IBXM(ICNT),K)
                LABEL(IBXM(ICNT),K) = ITEMP
  260         CONTINUE
              TEMP         = BNDOCC(J)
              BNDOCC(J)    = BNDOCC(ICNT)
              BNDOCC(ICNT) = TEMP
              DO 270 K = 1,NNAO
                TEMP      = T(K,J)
                T(K,J)    = T(K,ICNT)
                T(K,ICNT) = TEMP
  270         CONTINUE
            END IF
  280     CONTINUE
  290   CONTINUE
  300 CONTINUE
C
C  Add in any antibonds:
C
      IF(JPRINT(10).EQ.0) THEN
        DO 400 I = 1,NATOMS-1
          DO 390 J = I+1,NATOMS
            IF(I.NE.J) THEN
              K = -1
              IF(IW3C.NE.0) K = J
  310         K = K + 1
              DO 380 L = ICNT+1,NNAO
                LBL1 = LABEL(IBXM(L),1)
                LBL2 = LABEL(IBXM(L),2)
                LBL3 = LABEL(IBXM(L),3)
                LBL4 = LABEL(IBXM(L),4)
                LBL5 = LABEL(IBXM(L),5)
                LBL6 = LABEL(IBXM(L),6)
                IF((LBL1.EQ.LBD.OR.LBL1.EQ.L3C).AND.LBL2.EQ.LSTAR) THEN
                  IF(LBL4.EQ.I.AND.LBL5.EQ.J.AND.LBL6.EQ.K) THEN
                    ICNT = ICNT + 1
                    LABEL(IBXM(L),1)    = LABEL(IBXM(ICNT),1)
                    LABEL(IBXM(L),2)    = LABEL(IBXM(ICNT),2)
                    LABEL(IBXM(L),3)    = LABEL(IBXM(ICNT),3)
                    LABEL(IBXM(L),4)    = LABEL(IBXM(ICNT),4)
                    LABEL(IBXM(L),5)    = LABEL(IBXM(ICNT),5)
                    LABEL(IBXM(L),6)    = LABEL(IBXM(ICNT),6)
                    LABEL(IBXM(ICNT),1) = LBL1
                    LABEL(IBXM(ICNT),2) = LBL2
                    LABEL(IBXM(ICNT),3) = LBL3
                    LABEL(IBXM(ICNT),4) = LBL4
                    LABEL(IBXM(ICNT),5) = LBL5
                    LABEL(IBXM(ICNT),6) = LBL6
                    TEMP         = BNDOCC(L)
                    BNDOCC(L)    = BNDOCC(ICNT)
                    BNDOCC(ICNT) = TEMP
                    DO 370 M = 1,NNAO
                      TEMP      = T(M,L)
                      T(M,L)    = T(M,ICNT)
                      T(M,ICNT) = TEMP
  370               CONTINUE
                  END IF
                END IF
  380         CONTINUE
              IF(K.GT.0.AND.K.LT.NATOMS) GOTO 310
            END IF
  390     CONTINUE
  400   CONTINUE
      END IF
C
C  Lastly, make sure orbitals are ordered by serial number:
C
  410 PERMUT = .FALSE.
      DO 500 I = 1,NNAO-1
        IF(LABEL(IBXM(I),1).EQ.LABEL(IBXM(I+1),1)) THEN
          IF(LABEL(IBXM(I),2).EQ.LABEL(IBXM(I+1),2)) THEN
            IF(LABEL(IBXM(I),4).EQ.LABEL(IBXM(I+1),4)) THEN
              IF(LABEL(IBXM(I),5).EQ.LABEL(IBXM(I+1),5)) THEN
                IF(LABEL(IBXM(I),6).EQ.LABEL(IBXM(I+1),6)) THEN
                  IF(LABEL(IBXM(I),3).GT.LABEL(IBXM(I+1),3)) THEN
                    PERMUT = .TRUE.
                    LBL3 = LABEL(IBXM(I),3)
                    LABEL(IBXM(I),3) = LABEL(IBXM(I+1),3)
                    LABEL(IBXM(I+1),3) = LBL3
                    TEMP = BNDOCC(I)
                    BNDOCC(I) = BNDOCC(I+1)
                    BNDOCC(I+1) = TEMP
                    DO 490 J = 1,NNAO
                      TEMP = T(J,I)
                      T(J,I) = T(J,I+1)
                      T(J,I+1) = TEMP
  490               CONTINUE
                  END IF
                END IF
              END IF
            END IF
          END IF
        END IF
  500 CONTINUE
      IF(PERMUT) GOTO 410
      RETURN
      END
C***********************************************************************
      SUBROUTINE XCITED(DM,T,HYB,THYB,S,OCC,SCR,ISCR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL FIRST
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBNAO/NAOC(MAXBAS),NAOA(MAXBAS),LTYP1(MAXBAS),
     +       IPRIN(MAXBAS)
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LTYP(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      DIMENSION DM(NDIM,NDIM),T(NDIM,NDIM),HYB(MXAO),THYB(NDIM,NDIM),
     +          S(NDIM,NDIM),OCC(NDIM),SCR(NDIM),ISCR(NDIM)
      DIMENSION PCT(5),IAT(3)
C
      SAVE LLP,LBD,L3C,LCR,LRY,ZERO,TENTH,ONE,THRESH,LSTAR,LBLNK
      DATA LLP,LBD,L3C,LCR,LRY/2HLP,2HBD,2H3C,2HCR,2HRY/
      DATA ZERO,TENTH,ONE,THRESH/0.0D0,0.1D0,1.0D0,1.0D-4/
      DATA LSTAR,LBLNK/1H*,1H /
C
C  Form a temporary NAO to NHO transformation matrix.  Check hybrid
C  overlap to make sure the NBO's were properly labelled as Lewis
C  and non-Lewis orbitals:
C
C  Count number of hybrids as they are written out:
C
      NHYB = 0
C
C  Main loop over bond orbitals:
C
      IPAR3C = 1
      DO 200 NBOND = 1,NNAO
        IB = IBXM(NBOND)
        LBL = LABEL(IB,1)
        IF(LBL.EQ.LLP.OR.LBL.EQ.LCR.OR.LBL.EQ.LRY) NCTR = 1
        IF(LBL.EQ.LBD) NCTR = 2
        IF(LBL.EQ.L3C) NCTR = 3
C
C  Loop over atomic centers of bond orbital NBOND:
C
        DO 190 ICTR = 1,NCTR
          I = LABEL(IB,ICTR+3)
          KL = LL(I)
          KU = LU(I)
          DO 120 K = 1,MXAO
            LTYP(K) = 0
  120       HYB(K) = ZERO
C
C  Choose sign for polarization coefficients:
C
          ISGN = 1
          IF(LABEL(IB,2).NE.LSTAR) GO TO 130
          IF(ICTR.LT.2) GO TO 130
          IF(ICTR.EQ.3) IPAR3C = -IPAR3C
          IF(ICTR.EQ.3.AND.IPAR3C.GT.0) GO TO 130
          ISGN = -ISGN
  130     CONTINUE
C
C  Extract hybrid (HYB) from transformation matrix T; LTYP(I) is the
C  orbital angular momentum quantum no. of A.O. # I:
C
          KH = 0
          DO 140 K = KL,KU
            KH = KH + 1
            HYB(KH) = T(K,NBOND)
  140       LTYP(KH) = NAOA(K)/100
          CALL HTYPE(HYB,LTYP,MXAO,KH,COEF,PCT,NL,ISGN)
          IF(ABS(COEF).LT.THRESH) GO TO 190
C
C  Check to see if this orbital has been found before:
C
          DO 160 IHYB = 1,NHYB
            TEMP = ZERO
            IH = 0
            DO 150 K = KL,KU
              IH = IH + 1
              TEMP = TEMP + HYB(IH)*THYB(K,IHYB)
  150       CONTINUE
            IF(ABS(ABS(TEMP)-ONE).LT.THRESH) GO TO 190
            IF(ABS(TEMP).GT.THRESH) THEN
              WRITE(LFNPR,900) NHYB+1,NBOND,ICTR,TEMP,IHYB
              CALL NBHALT('XCITED: Non-negligible overlap of NHOs.')
            END IF
  160     CONTINUE
C
C  Add this hybrid to the temporary THYB:
C
          NHYB = NHYB + 1
          IF(NHYB.GT.NNAO) CALL NBHALT('XCITED: Too many hybrids.')
          DO 170 K = 1,NNAO
            THYB(K,NHYB) = ZERO
  170     CONTINUE
          IH = 0
          DO 180 K = KL,KU
            IH = IH + 1
            THYB(K,NHYB) = HYB(IH)
  180     CONTINUE
  190   CONTINUE
  200 CONTINUE
      IF(NHYB.LT.NNAO) CALL NBHALT('XCITED: Missing hybrids.')
C
C  THYB now contains the temporary NAO to NHO transformation matrix.
C  Form the non-orthogonal PNHO overlap and NHO to NBO transformation matrices:
C
      CALL FESNAO(S)
      CALL SIMTRS(S,THYB,SCR,NDIM,NNAO)
C
      CALL NBTRSP(THYB,NDIM,NNAO)
      CALL MATMLT(THYB,T,SCR,NDIM,NNAO)
C
C  Check to see that the bonds and antibonds have the correct hybrid
C  overlap.  Fix the labels if there is a problem:
C
      FIRST = .TRUE.
      DO 300 NBOND = 1,NNAO
        IB = IBXM(NBOND)
        LBL1 = LABEL(IB,1)
        IF(LBL1.EQ.LLP.OR.LBL1.EQ.LCR.OR.LBL1.EQ.LRY) ICTR = 1
        IF(LBL1.EQ.LBD) ICTR = 2
        IF(LBL1.EQ.L3C) ICTR = 3
        NCTR = 0
        DO 210 IHYB = 1,NHYB
          IF(ABS(THYB(IHYB,NBOND)).GT.THRESH) THEN
            NCTR = NCTR + 1
            IF(NCTR.GT.3) THEN
              WRITE(LFNPR,910) NBOND
              CALL NBHALT('NBO has contributions from >3 centers.')
            END IF
            IAT(NCTR) = IHYB
          END IF
  210   CONTINUE
        IF(NCTR.GT.ICTR) THEN
          WRITE(LFNPR,920) ICTR,NBOND,NCTR
          CALL NBHALT('Contributions from too many centers.')
        END IF
        IF(NCTR.GT.1) THEN
          ISGN = 1
          DO 230 JCTR = 1,NCTR-1
            DO 220 KCTR = JCTR+1,NCTR
              JHYB = IAT(JCTR)
              KHYB = IAT(KCTR)
              TEMP = S(JHYB,KHYB)*THYB(JHYB,NBOND)*THYB(KHYB,NBOND)
              IF(TEMP.LT.ZERO) ISGN = -1
  220       CONTINUE
  230     CONTINUE
          LBL2 = LABEL(IB,2)
          IF(LBL2.EQ.LBLNK.AND.ISGN.EQ.-1) THEN
            IF(FIRST.AND.JPRINT(5).NE.0) WRITE(LFNPR,930)
            FIRST = .FALSE.
            LABEL(IB,2) = LSTAR
            IF(JPRINT(5).NE.0) WRITE(LFNPR,940) NBOND,LBL1,LSTAR
          ELSE IF(LBL2.EQ.LSTAR.AND.ISGN.EQ.1) THEN
            IF(FIRST.AND.JPRINT(5).NE.0) WRITE(LFNPR,930)
            FIRST = .FALSE.
            LABEL(IB,2) = LBLNK
            IF(JPRINT(5).NE.0) WRITE(LFNPR,940) NBOND,LBL1,LBLNK
          END IF
        END IF
  300 CONTINUE
C
C  Determine the number of occupied orbitals:
C
      TOT = ZERO
      DO 310 I = 1,NNAO
        TOT = TOT + DM(I,I)
  310 CONTINUE
      NOCC = INT(TOT + TENTH)
      IF(ISPIN.EQ.0) NOCC = NOCC/2 + MOD(NOCC,2)
C
C  Count the number of unstarred orbitals:
C
      ICNT = 0
      DO 320 I = 1,NNAO
        IF(LABEL(IBXM(I),2).NE.LSTAR) ICNT = ICNT + 1
  320 CONTINUE
C
C  If the number of unstarred orbitals is not equal to the number of
C  occupied orbitals, fix the orbital labels:
C
      IF(ICNT.NE.NOCC) THEN
        DO 330 I = 1,NNAO
          OCC(I) = DM(I,I)
  330   CONTINUE
        CALL RANK(OCC,NNAO,NDIM,ISCR)
C
C  If there are more unstarred orbitals than occupied, add stars to the
C  least occupied lone pairs:
C
        IF(ICNT.GT.NOCC) THEN
          IDIFF = ICNT - NOCC
          DO 350 I = 1,IDIFF
            IP = 0
            DO 340 J = 1,NNAO
              JP = IBXM(ISCR(J))
              IF(LABEL(JP,1).EQ.LLP.AND.LABEL(JP,2).NE.LSTAR) IP = J
  340       CONTINUE
            IF(IP.EQ.0) THEN
              WRITE(LFNPR,950) ICNT,NOCC
              CALL NBHALT('Unable to label NBOs properly.')
            END IF
            LABEL(IBXM(ISCR(IP)),2) = LSTAR
            IF(JPRINT(5).NE.0) WRITE(LFNPR,940) ISCR(IP),
     +                         LABEL(IBXM(ISCR(IP)),1),LSTAR
  350     CONTINUE
C
C  Remove stars from the highest occupied lone pairs/Rydbergs if there are
C  too few starred orbitals:
C
        ELSE
          IDIFF = NOCC - ICNT
          DO 370 I = 1,IDIFF
            IP = 0
            DO 360 J = NNAO,1,-1
              JP = IBXM(ISCR(J))
              IF((LABEL(JP,1).EQ.LLP.OR.LABEL(JP,1).EQ.LRY)
     +                         .AND.LABEL(JP,2).EQ.LSTAR) IP = J
  360       CONTINUE
            IF(IP.EQ.0) THEN
              WRITE(LFNPR,950) ICNT,NOCC
              CALL NBHALT('Unable to label NBOs properly.')
            END IF
            LABEL(IBXM(ISCR(IP)),2) = LBLNK
            IF(JPRINT(5).NE.0) WRITE(LFNPR,940) ISCR(IP),
     +                         LABEL(IBXM(ISCR(IP)),1),LBLNK
  370     CONTINUE
        END IF
      END IF
      RETURN
C
  900 FORMAT(/1X,'Hybrid',I4,' (NBO',I4,', Center',I3,') has a ',
     + 'non-negligible overlap of ',F8.5,/,1X,'with hybrid',I4,'.')
  910 FORMAT(/1X,'NBO',I4,' has hybrid contributions from more than ',
     + '3 atomic centers.')
  920 FORMAT(/1X,'Error: the ',I1,'-center NBO ',I3,' has ',
     + 'contributions from ',I2,' atomic centers.')
  930 FORMAT(/1X,'          --- Apparent excited state configuration ',
     + '---',/1X,'The following "inverted" NBO labels reflect the ',
     + 'actual hybrid overlap:')
  940 FORMAT(1X,'                NBO',I4,' has been relabelled ',A2,A1)
  950 FORMAT(/1X,'Unable to label the NBOs properly:',I4,' unstarred ',
     + 'orbitals',/1X,'                                  ',I4,
     + ' occupied orbitals')
      END
C***********************************************************************
      SUBROUTINE ANLYZE(T,BNDOCC,HYB,HYCOEF,THYB)
C***********************************************************************
C 9-May-02  FAW  Correction for atom numbers > 99
      IMPLICIT REAL*8 (A-H,O-Z)
      INTEGER UL
C
C  Print out details of bond-orbital transformation from matrix T.
C
C  Required input:
C         T = Transformation matrix from S.R. NATHYB; REAL (1,NDIM;1,NDIM)
C      NDIM = Declared dimensionality of array T
C      NNAO = No. of orbitals = actual dimension of T, NAOL
C      NAOL = Integer list of orbital angular momentum type
C                NAOL(I)/100 = l = Q.N. of atomic orbital I
C     IATNO = List of atomic numbers; IATNO(I) is the atomic number
C                of atom I as an integer
C    NATOMS = No. of atoms (not including ghosts) in the molecule
C    IWHYBS = 1 if hybrid A.O. coefficients are to be printed,
C             0 otherwise
C     LFNPR = Logical file number for printout.
C    NAOCTR = List of atomic centers of OAO or NAO basis orbitals
C     LABEL = List of bond orbital labels
C      IBXM = Permutation list of bond orbitals
C    BNDOCC = List of bond orbital occupancies
C     ISPIN = 0 for spinless NBOs
C           = 2 for alpha spin NBOs
C           =-2 for beta  spin NBOs
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       UL(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBNAO/NAOC(MAXBAS),NAOA(MAXBAS),LTYP1(MAXBAS),
     +       IPRIN(MAXBAS)
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LTYP(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION T(NDIM,NDIM),HYB(MXAO),BNDOCC(NDIM),THYB(NDIM,NDIM),
     * PCT(5),POW(5),LNAME(5),ISP(3),NAM(3),ICH(3,2),HYCOEF(NDIM),
     * ICH3(3,3)
C
      SAVE LLP,LBD,L3C,LCR,LRY,LNAME
      SAVE ZERO,THRESH,T99,T99P
      SAVE TENTH,HUNDRD,TTHOTH
      SAVE LHYP,LBLNK,LSTAR,L2BLNK
C
      DATA LLP,LBD,L3C,LCR,LRY/2HLP,2HBD,2H3C,2HCR,2HRY/
      DATA LNAME/1Hs,1Hp,1Hd,1Hf,1Hg/
      DATA ZERO,THRESH,T99,T99P/0.0D0,1.D-2,99.99D0,99.995D0/
      DATA TENTH,HUNDRD,TTHOTH/0.1D0,100.0D0,0.0001D0/
      DATA LHYP,LBLNK,LSTAR,L2BLNK/1H-,1H ,1H*,2H  /
C
C  Count the number of electrons:
C
      TOTELE = ZERO
      DO 20 I = 1,NNAO
        TOTELE = TOTELE + BNDOCC(I)
   20   CONTINUE
      NEL = INT(TOTELE + TENTH)
      TOTELE = DFLOAT(NEL)
C
C  Count the number of core orbitals and the occupancies of the core,
C  valence Lewis, valence non-Lewis, and extra-valence Rydberg orbitals.
C  (Also count the number of electrons in the ECP, if employed)
C
      MCR = 0
      OCCCR = ZERO
      OCCVL = ZERO
      OCCVNL = ZERO
      DO 50 I = 1,NNAO
        IF(LABEL(IBXM(I),2).NE.LSTAR) THEN
          IF(LABEL(IBXM(I),1).EQ.LCR) THEN
            MCR = MCR + 1
            OCCCR = OCCCR + BNDOCC(I)
          ELSE
            OCCVL = OCCVL + BNDOCC(I)
          END IF
        ELSE
          IF(LABEL(IBXM(I),1).NE.LRY) THEN
            OCCVNL = OCCVNL + BNDOCC(I)
          END IF
        END IF
   50 CONTINUE
      OCCEVR = TOTELE - OCCCR - OCCVL - OCCVNL
      IF(ISPIN.EQ.0) THEN
        MCR = 2 * MCR
      END IF
      MVL = NEL - MCR
      MECP = 0
      IF(IPSEUD.NE.0) THEN
        DO 60 I = 1,NATOMS
          MECP = MECP + IATNO(I) - IZNUC(I)
   60   CONTINUE
        IF(ISPIN.NE.0) MECP = MECP/2
      END IF
      MLEW = MCR + MVL + MECP
      OCCLEW = OCCCR + OCCVL + MECP
      OCCNON = OCCVNL + OCCEVR
C
C  Write summary of NBO occupancies:
C
      IF(JPRINT(5).EQ.1.AND.NEL.NE.0) THEN
        WRITE(LFNPR,2000)
        IF(IPSEUD.NE.0) WRITE(LFNPR,2010) FLOAT(MECP)
        IF(MCR.NE.0) THEN
          PCENT = OCCCR/MCR * HUNDRD
          WRITE(LFNPR,2020) OCCCR,PCENT,MCR
        END IF
        IF(MVL.NE.0) THEN
          PCENT = OCCVL/MVL * HUNDRD
          WRITE(LFNPR,2030) OCCVL,PCENT,MVL
        END IF
        WRITE(LFNPR,2040)
        PCENT = OCCLEW/MLEW * HUNDRD
        WRITE(LFNPR,2050) OCCLEW,PCENT,MLEW
        WRITE(LFNPR,2060)
        PCENT = OCCVNL/MLEW * HUNDRD
        WRITE(LFNPR,2070) OCCVNL,PCENT,MLEW
        PCENT = OCCEVR/MLEW * HUNDRD
        WRITE(LFNPR,2080) OCCEVR,PCENT,MLEW
        WRITE(LFNPR,2040)
        PCENT = OCCNON/MLEW * HUNDRD
        WRITE(LFNPR,2090) OCCNON,PCENT,MLEW
        WRITE(LFNPR,2100)
      END IF
C
C  Write out NBOs:
C
      IF(JPRINT(5).EQ.1) THEN
        WRITE(LFNPR,1000)
        WRITE(LFNPR,1100) (LHYP,J=1,79)
      END IF
C
C  Main loop over bond orbitals:
C
      NHYB = 0
      MHYB = 0
      IPAR3C = 1
      DO 180 NBOND = 1,NNAO
        IB = IBXM(NBOND)
        LBL = LABEL(IB,1)
        IF(LBL.EQ.LLP.OR.LBL.EQ.LCR.OR.LBL.EQ.LRY) NCTR = 1
        IF(LBL.EQ.LBD) NCTR = 2
        IF(LBL.EQ.L3C) NCTR = 3
        DO 110 I = 1,3
          IA = LABEL(IB,I+3)
          CALL CONVRT2N(IA,ICH(I,1),ICH(I,2))
          CALL CONVRT3(IA,ICH3(I,1),ICH3(I,2),ICH3(I,3))
          NAM(I) = L2BLNK
          IF(IA.GT.0) NAM(I) = NAMEAT(IATNO(IA))
          ISP(I) = LHYP
          IF(I.GE.NCTR) ISP(I) = LBLNK
  110     CONTINUE
C
C  Loop over atomic centers of bond orbital NBOND:
C
        DO 170 ICTR = 1,NCTR
          I = LABEL(IB,ICTR+3)
          NEL = NAMEAT(IATNO(I))
          KL = LL(I)
          KU = UL(I)
          DO 120 K = 1,MXAO
            LTYP(K) = 0
  120       HYB(K) = ZERO
C
C  Choose sign for polarization coefficients:
C
          ISGN = 1
          IF(LABEL(IB,2).NE.LSTAR) GO TO 130
          IF(ICTR.LT.2) GO TO 130
          IF(ICTR.EQ.3) IPAR3C = -IPAR3C
          IF(ICTR.EQ.3.AND.IPAR3C.GT.0) GO TO 130
          ISGN = -ISGN
  130     CONTINUE
C
C  Extract hybrid (HYB) from transformation matrix T; LTYP(I) is the
C  orbital angular momentum quantum no. of A.O. # I:
C
          KH = 0
          DO 140 K = KL,KU
            KH = KH + 1
            HYB(KH) = T(K,NBOND)
  140       LTYP(KH) = NAOA(K)/100
          CALL HTYPE(HYB,LTYP,MXAO,KH,COEF,PCT,NL,ISGN)
C
C  Find leading non-zero contribution to determine POW(L) for each L:
C
          LSTD = 0
          DO 160 L = 1,NL
            IF(LSTD.GT.0) GO TO 150
            POW(L) = ZERO
            STD = PCT(L)
            IF(STD.LT.THRESH) GO TO 160
            LSTD = L
  150       POW(L) = PCT(L)/STD
            IF(POW(L).GT.T99P) POW(L) = T99
  160       CONTINUE
C
C  Write out NHO for center ICTR:
C
          COEFSQ = COEF * COEF * HUNDRD
          NL1 = NL
          IF(NL1.GT.3) NL1 = 3
          IF(ICTR.EQ.1.AND.NCTR.EQ.1.AND.JPRINT(5).EQ.1)
     +      WRITE(LFNPR,1210) NBOND,BNDOCC(NBOND),
     +        (LABEL(IB,K),K=1,3),NAM(1),ICH3(1,1),ICH3(1,2),ICH3(1,3),
     +        PCT(1),(LNAME(L),POW(L),PCT(L),L=2,NL1)
          IF(ICTR.EQ.1.AND.NCTR.GT.1.AND.JPRINT(5).EQ.1)
     +      WRITE(LFNPR,1220) NBOND,BNDOCC(NBOND),
     +        (LABEL(IB,K),K=1,3),
     +        (NAM(K),ICH3(K,1),ICH3(K,2),ICH3(K,3),ISP(K),K=1,3)
          IF(NCTR.NE.1.AND.JPRINT(5).EQ.1) THEN
              CALL CONVRT3(I,I1,I2,I3)
              WRITE(LFNPR,1300) COEFSQ,
     +        COEF,NEL,I1,I2,I3,PCT(1),(LNAME(L),POW(L),PCT(L),L=2,NL1)
          ENDIF
          IF(NL.GT.3.AND.JPRINT(5).EQ.1) WRITE(LFNPR,1310)
     +        (LNAME(L),POW(L),PCT(L),L=4,NL)
          IF(IWHYBS.NE.0.AND.BNDOCC(NBOND).GT.TTHOTH.AND.JPRINT(5).EQ.1)
     +        WRITE(LFNPR,1500) (HYB(K),K=1,KH)
          CALL FRMHYB(HYB,THYB,COEF,HYCOEF,KL,KU,NHYB)
C
C  If this is a new hybrid, form its label:
C
          IF(MHYB.NE.NHYB) THEN
            MHYB = NHYB
            CALL LBLNHO(NHYB,NBOND,ICTR,NCTR)
          END IF
  170   CONTINUE
  180 CONTINUE
      RETURN
C
 1000 FORMAT(//,1X,'    (Occupancy)   Bond orbital/ Coefficients/ ',
     + 'Hybrids')
 1100 FORMAT(1X,80A1)
 1210 FORMAT(I4,'. (',F7.5,') ',A2,A1,'(',I2,')',A2,3A1,12X,
     + ' s(',F6.2,'%)',2(A1,F5.2,'(',F6.2,'%)'))
 1220 FORMAT(I4,'. (',F7.5,') ',A2,A1,'(',I2,')',3(A2,4A1))
 1300 FORMAT(15X,'(',F6.2,'%)',2X,
     + F7.4,'*',A2,3A1,' s(',F6.2,'%)',2(A1,F5.2,'(',F6.2,'%)'))
 1310 FORMAT(50X,2(A1,F5.2,'(',F6.2,'%)'))
 1500 FORMAT(39X,5F8.4)
 2000 FORMAT(/,1X,56('-'))
 2010 FORMAT(1X,'  Effective Core          ',F9.5)
 2020 FORMAT(1X,'  Core                    ',F9.5,' (',F7.3,'% of',
     +  I4,')')
 2030 FORMAT(1X,'  Valence Lewis           ',F9.5,' (',F7.3,'% of',
     +  I4,')')
 2040 FORMAT(2X,18('='),7X,28('='))
 2050 FORMAT(1X,'  Total Lewis             ',F9.5,' (',F7.3,'% of',
     +  I4,')')
 2060 FORMAT(2X,53('-'))
 2070 FORMAT(1X,'  Valence non-Lewis       ',F9.5,' (',F7.3,'% of',
     +  I4,')')
 2080 FORMAT(1X,'  Rydberg non-Lewis       ',F9.5,' (',F7.3,'% of',
     +  I4,')')
 2090 FORMAT(1X,'  Total non-Lewis         ',F9.5,' (',F7.3,'% of',
     +  I4,')')
 2100 FORMAT(1X,56('-'))
      END
C***********************************************************************
      SUBROUTINE HTYPE(HYB,LTYP,MXAO,NH,COEF,PCT,NL,ISGN)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION HYB(MXAO),LTYP(MXAO),PCT(5)
C
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
C  ANALYZE INPUT HYBRID 'HYB' FOR POLARIZATION COEFFICIENT 'COEF'
C  AND PERCENTAGES OF EACH ANGULAR MOMENTUM COMPONENT.
C
      SAVE ZERO,THRESH,HUNDRD
      DATA ZERO,THRESH,HUNDRD/0.0D0,1.D-4,100.0D0/
C
      NL = 0
C
C  ZERO PERCENTAGES AND POLARIZATION COEFFICIENT:
C
      DO 10 L1 = 1,5
   10   PCT(L1) = ZERO
      COEF = ZERO
C
C  LOOP OVER ATOMIC CONTRIBUTIONS TO HYBRID, COMPUTING PERCENTAGES
C  AND POLARIZATION COEFFICIENT:
C
      DO 20 I = 1,NH
        L1 = LTYP(I) + 1
        IF(L1.GT.5) GO TO 800
        PCT(L1) = PCT(L1) + HYB(I)**2
   20   COEF = COEF + HYB(I)**2
      IF(ABS(COEF).LT.THRESH) RETURN
C
C  CALCULATE PERCENTAGE CONTRIBUTION FOR EACH ANGULAR SYMMETRY:
C
      DO 30 L1 = 1,5
   30   PCT(L1) = PCT(L1)/COEF*HUNDRD
      COEF = SQRT(COEF)
C
C  SWITCH THE SIGN OF THE COEFFICIENT IF ISGN IS NEGATIVE:
C
      IF(ISGN.LT.0) COEF = -COEF
C
C  NORMALIZE THE HYBRID:
C
      DO 50 I = 1,NH
   50   HYB(I) = HYB(I)/COEF
C
C  FIND THE MAXIMUM NUMBER OF ANGULAR MOMENTUM TYPES (NL):
C
      DO 60 I = 1,NH
        IF(ABS(HYB(I)).LT.THRESH) GO TO 60
         IF(LTYP(I).LE.NL) GO TO 60
          NL = LTYP(I)
   60   CONTINUE
      NL = NL + 1
      RETURN
C
  800 CONTINUE
      WRITE(LFNPR,900) L1-1
      CALL NBHALT('AO with unknown angular symmetry found.')
C
  900 FORMAT(/1X,'AO with unknown angular symmetry, l = ',I3)
      END
C***********************************************************************
      SUBROUTINE FRMHYB(HYB,THYB,COEF,HYCOEF,KL,KU,NHYB)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      DIMENSION HYB(*),THYB(NDIM,NDIM),HYCOEF(NDIM)
C
      SAVE ZERO,ONE,THRESH
      DATA ZERO,ONE,THRESH/0.0D0,1.0D0,1.0D-4/
C
C  FORM FULL NAO TO NHO TRANFORMATION IN THYB, ADDING ONE HYBRID WITH
C  EACH CALL.  PUT POLARIZATION COEF IN HYCOEF FOR EACH HYBRID.
C
C  MAKE SURE THIS HYBRID ISN'T ALREADY IN THE LIST:
C
      IF(ABS(COEF).LT.THRESH) RETURN
      DO 20 IHYB = 1,NHYB
        TEMP = ZERO
        IH = 0
        DO 10 K = KL,KU
          IH = IH + 1
          TEMP = TEMP + HYB(IH)*THYB(K,IHYB)
   10   CONTINUE
        IF(ABS(ABS(TEMP)-ONE).LT.THRESH) RETURN
        IF(ABS(TEMP).GT.THRESH) THEN
          WRITE(LFNPR,900) NHYB+1,TEMP,IHYB
          CALL NBHALT('FRMHYB: Non-negligible overlap of NHOs.')
        END IF
   20 CONTINUE
C
C  ADD THIS HYBRID TO THE LIST:
C
      NHYB = NHYB + 1
      IF(NHYB.GT.NNAO) CALL NBHALT('FRMHYB: Too many hybrids.')
      DO 50 I = 1,NNAO
        THYB(I,NHYB) = ZERO
   50 CONTINUE
      IH = 0
      DO 70 I = KL,KU
        IH = IH + 1
        THYB(I,NHYB) = HYB(IH)
   70 CONTINUE
      HYCOEF(NHYB) = COEF
      IF(NHYB.NE.NNAO) RETURN
      CALL SVTNHO(THYB)
      RETURN
C
  900 FORMAT(/1X,'Hybrid',I4,' has a ',
     + 'non-negligible overlap of ',F8.5,' with hybrid',I4,'.')
      END
C***********************************************************************
      SUBROUTINE HYBDIR(BNDOCC,ATCOOR,THYB,TBND,SCR)
C***********************************************************************
C  2-Jan-01  FAW  Include d-character (numerical Powell search)
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LTYP(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBTHR/THRSET,PRJSET,ACCTHR,CRTSET,E2THR,ATHR,PTHR,ETHR,
     +             DIPTHR,DLTHR,CHSTHR,REFTHR,STTHR,PRTHR,THRNCS,THRNJC
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      DIMENSION BNDOCC(NDIM),ATCOOR(NATOMS*3),THYB(NDIM,NDIM),
     +          TBND(NDIM,NDIM),SCR(NDIM)
      DIMENSION ISTR(8),PHYB(3),PCMP(3,2),KHYB(3),AZI(2),POL(2),DEV(2)
      DIMENSION ISKIP(2),DCMP(5,2),DHYB(5)
      COMMON/BENDS/CX,CY,CZ,C1,C2,C3,C4,C5,MINJOB
      DIMENSION SV2(2,1),ISV1(2),XI(2,2),
     + Q(2,2),XVAR(2),XIT(2),PT(2),PTT(2),W(2),WP(2)
C
      SAVE LCR,LLP,LRY,LBD,L3C,LHYP,ZERO,ONE,TWO,THRESH,CUTOFF
      DATA LCR,LLP,LRY,LBD,L3C/2HCR,2HLP,2HRY,2HBD,2H3C/
      DATA LHYP/1H-/
      DATA ZERO,ONE,TWO,THRESH,CUTOFF/0.0D0,1.0D0,2.0D0,1.0D-4,1.0D-8/
C
C  Compute hybrid directionality and bond bending for selected NBO's:
C
C  Thresholds:   ATHR  --   Angular deviation threshold
C                PTHR  --   Percentage p-character threshold
C                ETHR  --   Occupancy threshold
C
      CONV = 180.0D0/(4.0D0*ATAN(ONE))
      RT3 = SQRT(3.0D0)
      RT5 = SQRT(5.0D0)
      RT15 = RT3*RT5
      WRITE(LFNPR,900) ABS(ATHR),ABS(PTHR),ABS(ETHR)
C
C  Get atomic centers, NAO to NHO trans., and NAO to NBO trans.:
C
      CALL FECOOR(ATCOOR)
      CALL FETNHO(THYB)
      CALL FETNAB(TBND)
      CALL NBTRSP(TBND,NDIM,NNAO)
      CALL MATMLT(TBND,THYB,SCR,NDIM,NNAO)
C
C  Loop over NBOs:
C
      ICNT = 0
      DO 100 IBAS = 1,NNAO
        IB = IBXM(IBAS)
        LBL1 = LABEL(IB,1)
        LBL2 = LABEL(IB,2)
        LBL3 = LABEL(IB,3)
        IF(LBL1.EQ.LLP.OR.LBL1.EQ.LRY) NCTR = 1
        IF(LBL1.EQ.LBD) NCTR = 2
C
C  Skip 3-center orbitals, core orbitals, low occupancy orbitals:
C
        IF(LBL1.EQ.L3C) GO TO 100
        IF(LBL1.EQ.LCR) GO TO 100
        IF(BNDOCC(IBAS).LT.ABS(ETHR)) GO TO 100
C
C  Find the hybrids which contribute to this NBO:
C
        ICTR = 0
        DO 10 IHYB = 1,NNAO
          IF(ABS(TBND(IBAS,IHYB)).GT.THRESH) THEN
            ICTR = ICTR + 1
            KHYB(ICTR) = IHYB
          END IF
   10   CONTINUE
        IF(ICTR.NE.NCTR) THEN
          WRITE(LFNPR,910) NCTR,IBAS,ICTR
          CALL NBHALT('Contributions to NBO from too many centers.')
        END IF
C
C  Make sure the hybrids are on the proper nuclear centers and compute
C  the percentage p- and d-character in the hybrid:
C
        DO 30 ICTR = 1,NCTR
          IHYB = KHYB(ICTR)
          JCTR = LABEL(IB,ICTR+3)
          CALL HYBCMP(PCMP(1,ICTR),PHYB(ICTR),DCMP(1,ICTR),DHYB(ICTR),
     +         IHYB,JCTR,THYB(1,IHYB))
   30   CONTINUE
C
C  If these hybrids have low p- and/or d-character, skip them:
C
        ISKIP(1) = 0
        ISKIP(2) = 0
        PDPCT1 = PHYB(1) + DHYB(1)
        IF(NCTR.EQ.1.AND.PDPCT1.LT.ABS(PTHR)) GO TO 100
        IF(NCTR.EQ.2) THEN
          PDPCT2 = PHYB(2) + DHYB(2)
          IF(PDPCT1.LT.ABS(PTHR)) ISKIP(1) = 1
          IF(PDPCT2.LT.ABS(PTHR)) ISKIP(2) = 1
          IF(ISKIP(1).EQ.1.AND.ISKIP(2).EQ.1) GO TO 100
        END IF
C
C  Compute the polar and azimuthal angles (degrees) from center 1 to 2
C
        IF(NCTR.EQ.2) THEN
          ICTR = LABEL(IB,4)
          JCTR = LABEL(IB,5)
          X = ATCOOR(JCTR*3-2) - ATCOOR(ICTR*3-2)
          Y = ATCOOR(JCTR*3-1) - ATCOOR(ICTR*3-1)
          Z = ATCOOR(JCTR*3)   - ATCOOR(ICTR*3)
          IF(ABS(X).LT.CUTOFF) X = ZERO
          IF(ABS(Y).LT.CUTOFF) Y = ZERO
          IF(ABS(Z).LT.CUTOFF) Z = ZERO
          R = SQRT(X*X + Y*Y + Z*Z)
          X = X / R
          Y = Y / R
          Z = Z / R
          CALL ANGLES(X,Y,Z,THETA,PHI)
        ENDIF
        DO 70 ICTR = 1,NCTR
          IF(ISKIP(ICTR).EQ.1) GO TO 70
C  Load the coefficients of p-type and d-type cartesian angular forms
          CX = PHYB(ICTR)*RT3*PCMP(1,ICTR)
          CY = PHYB(ICTR)*RT3*PCMP(2,ICTR)
          CZ = PHYB(ICTR)*RT3*PCMP(3,ICTR)
          C1 = DHYB(ICTR)*1.5D0*RT5*DCMP(5,ICTR)
          C2 = DHYB(ICTR)*0.5D0*RT15*DCMP(4,ICTR)
          C3 = DHYB(ICTR)*RT15*DCMP(1,ICTR)
          C4 = DHYB(ICTR)*RT15*DCMP(2,ICTR)
          C5 = DHYB(ICTR)*RT15*DCMP(3,ICTR)
C Convert to radians and store initial guesses
          IF(ICTR.EQ.1) THEN
            XVAR(1) = THETA/CONV
            XVAR(2) = PHI/CONV
          ELSE IF(ICTR.EQ.2) THEN
            XVAR(1) = (180.0D0 - THETA)/CONV
            PHITMP = 180.0D0 + PHI
            IF(PHITMP.GT.360.0D0) PHITMP = PHITMP - 360.0D0
            XVAR(2) = PHITMP/CONV
          ENDIF
C Is this already a stationary point?
          ST=SIN(THETA)
          CT=COS(THETA)
          SP=SIN(PHI)
          CP=COS(PHI)
C          X=ST*CP
C          Y=ST*SP
C          Z=CT
          HYB = CX*X + CY*Y + CZ*Z + C1*(Z*Z) + C2*(X*X - Y*Y)
     +        + C3*X*Y + C4*X*Z + C5*Y*Z
C Theta derivatives
          XP1=CT*CP
          YP1=CT*SP
          ZP1=-ST
C Phi derivatives
          XP2=-ST*SP
          YP2=ST*CP
C Hybrid derivative w.r.t. theta
          HP1=CX*XP1+CY*YP1+CZ*ZP1+TWO*C1*Z*ZP1+TWO*C2*(X*XP1-Y*YP1)
     +      +C3*(X*YP1+Y*XP1)+C4*(X*ZP1+Z*XP1)+C5*(Y*ZP1+Z*YP1)
C Hybrid derivative w.r.t. phi
          HP2=CX*XP2+CY*YP2+TWO*C2*(X*XP2-Y*YP2)
     +      +C3*(X*YP2+Y*XP2)+C4*(Z*XP2)+C5*(Z*YP2)
          IF(ABS(HYB).LT.THRESH) HYB = THRESH
          TEST = ABS(HP1/HYB) + ABS(HP2/HYB)
          IF(TEST.LT.1.D-6) THEN
            CONTINUE
          ELSE
C Find the maximum-amplitude direction with Powell algorithm
            NVAR = 2
            MAXVAR = 2
            MINJOB = 1
            CALL NBPWLL(PHIMIN,1.0D0,SV2,Q,XVAR,XI,PT,XIT,PTT,
     +          W,WP,ISV1,1,MAXVAR,1,1,NVAR,ITER)
          ENDIF
          MINJOB = 0
          POL(ICTR) = XVAR(1) * CONV
          AZI(ICTR) = XVAR(2) * CONV
          IF(AZI(ICTR).GE.359.95D0) AZI(ICTR) = AZI(ICTR) - 360.0D0
   70   CONTINUE
        IF(NCTR.EQ.2) THEN
C Deviation for hybrid 1
          THETAR = THETA/CONV
          PHIR = PHI/CONV
          ST = SIN(THETAR)
          CT = COS(THETAR)
          SP = SIN(PHIR)
          CP = COS(PHIR)
          X1 = ST*CP
          Y1 = ST*SP
          Z1 = CT
          THETARH = POL(1)/CONV
          PHIRH = AZI(1)/CONV
          STH = SIN(THETARH)
          CTH = COS(THETARH)
          SPH = SIN(PHIRH)
          CPH = COS(PHIRH)
          X1H = STH*CPH
          Y1H = STH*SPH
          Z1H = CTH
          R1 = SQRT(X1*X1 + Y1*Y1 + Z1*Z1)
          R1H = SQRT(X1H*X1H + Y1H*Y1H + Z1H*Z1H)
          DP1 = X1*X1H + Y1*Y1H + Z1*Z1H
          ARG = DP1/(R1*R1H)
          IF(ARG.GT.ONE) THEN
            ARG = ONE
          ELSE IF(ARG.LT.-ONE) THEN
            ARG = -ONE
          ENDIF
          DEV(1) = ACOS(ARG) * CONV
C Deviation for hybrid 2
          THETAP = 180.0D0 - THETA
          PHIP = 180.0D0 + PHI
          THETAR = THETAP/CONV
          PHIR = PHIP/CONV
          ST = SIN(THETAR)
          CT = COS(THETAR)
          SP = SIN(PHIR)
          CP = COS(PHIR)
          X2 = ST*CP
          Y2 = ST*SP
          Z2 = CT
          THETARH = POL(2)/CONV
          PHIRH = AZI(2)/CONV
          STH = SIN(THETARH)
          CTH = COS(THETARH)
          SPH = SIN(PHIRH)
          CPH = COS(PHIRH)
          X2H = STH*CPH
          Y2H = STH*SPH
          Z2H = CTH
          R2 = SQRT(X2*X2 + Y2*Y2 + Z2*Z2)
          R2H = SQRT(X2H*X2H + Y2H*Y2H + Z2H*Z2H)
          DP2 = X2*X2H + Y2*Y2H + Z2*Z2H
          ARG = DP2/(R2*R2H)
          IF(ARG.GT.ONE) THEN
            ARG = ONE
          ELSE IF(ARG.LT.-ONE) THEN
            ARG = -ONE
          ENDIF
          DEV(2) = ACOS(ARG) *CONV
          IF(DEV(1).LT.ABS(ATHR)) ISKIP(1) = 1
          IF(DEV(2).LT.ABS(ATHR)) ISKIP(2) = 1
          IF(ISKIP(1).EQ.1.AND.ISKIP(2).EQ.1) GO TO 100
        ENDIF
C
C  Write out directionality info:
C
        ICNT = ICNT + 1
        ISTR(1) = LBL1
        ISTR(2) = LBL2
        ISTR(3) = LBL3
        ISTR(4) = NAMEAT(IATNO(LABEL(IB,4)))
        ISTR(5) = LABEL(IB,4)
        IF(NCTR.EQ.2) THEN
          ISTR(6) = LHYP
          ISTR(7) = NAMEAT(IATNO(LABEL(IB,5)))
          ISTR(8) = LABEL(IB,5)
          IF(ISKIP(1).EQ.1) THEN
            WRITE(LFNPR,940) IBAS,(ISTR(I),I=1,8),THETA,PHI,POL(2),
     +                       AZI(2),DEV(2)
          ELSE IF(ISKIP(2).EQ.1) THEN
            WRITE(LFNPR,950) IBAS,(ISTR(I),I=1,8),THETA,PHI,POL(1),
     +                       AZI(1),DEV(1)
          ELSE
            WRITE(LFNPR,960) IBAS,(ISTR(I),I=1,8),THETA,PHI,POL(1),
     +                       AZI(1),DEV(1),POL(2),AZI(2),DEV(2)
          END IF
        ELSE
          WRITE(LFNPR,970) IBAS,(ISTR(I),I=1,5),POL(1),AZI(1)
        END IF
  100 CONTINUE
      IF(ICNT.EQ.0) WRITE(LFNPR,980)
      RETURN
C
  900 FORMAT(//1X,'NHO DIRECTIONALITY AND BOND BENDING (deviations ',
     + 'from line of nuclear centers)',//1X,'        [Thresholds for ',
     + 'printing:  angular deviation  > ',F4.1,' degree]',/1X,
     + '                                   p- or d-character  > ',F4.1,
     + '%',/1X,'                                   orbital occupancy  ',
     + '>  ',F4.2,'e',//1X,'                      Line of Centers     ',
     + '   Hybrid 1              Hybrid 2',/1X,'                      ',
     + '---------------  -------------------   ------------------',/1X,
     + '          NBO           Theta   Phi    Theta   Phi    Dev    ',
     + 'Theta   Phi    Dev',/1X,'=====================================',
     + '==========================================')
  910 FORMAT(/1X,'Error: the ',I1,'-center NBO',I4,' has ',
     + 'contributions from ',I2,' atomic centers.')
  940 FORMAT(I4,'. ',A2,A1,'(',I2,')',A2,I2,A1,A2,I2,3X,F5.1,2X,F5.1,
     + '     --     --    --     ',F5.1,2X,F5.1,1X,F5.1)
  950 FORMAT(I4,'. ',A2,A1,'(',I2,')',A2,I2,A1,A2,I2,3X,F5.1,2X,F5.1,
     + 3X,F5.1,2X,F5.1,1X,F5.1,'      --     --    --')
  960 FORMAT(I4,'. ',A2,A1,'(',I2,')',A2,I2,A1,A2,I2,3X,F5.1,2X,F5.1,
     + 3X,F5.1,2X,F5.1,1X,F5.1,4X,F5.1,2X,F5.1,1X,F5.1)
  970 FORMAT(I4,'. ',A2,A1,'(',I2,')',A2,I2,'          --     --',4X,
     + F5.1,2X,F5.1,'   --       --     --    --')
  980 FORMAT(1X,'   None exceeding thresholds')
      END
C***********************************************************************
      SUBROUTINE HYBCMP(PCMP,PPCT,DCMP,DPCT,IHYB,JCTR,HYB)
C***********************************************************************
C  2-Jan-01  FAW  Include d-character
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION PCMP(3),HYB(*),DCMP(5)
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBNAO/NAOC(MAXBAS),NAOA(MAXBAS),LTYP(MAXBAS),
     +       IPRIN(MAXBAS)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      SAVE ZERO,THRESH,CUTOFF
      DATA ZERO,THRESH,CUTOFF/0.0D0,1.0D-4,1.0D-8/
C
C  Add the px,py,pz components of this hybrid vectorially and determine
C  its percentage p- and d-character:
C
      DO I = 1,3
        PCMP(I) = ZERO
      ENDDO
      DO I = 1,5
        DCMP(I) = ZERO
      ENDDO
      PPCT  = ZERO
      DPCT  = ZERO
      HNORM  = ZERO
C
C  Make sure this hybrid is situated on the correct atom, JCTR:
C
      JMAX  = 1
      TMAX  = ABS(HYB(1))
      DO 10 INAO = 2,NNAO
        IF(ABS(HYB(INAO)).GT.TMAX) THEN
          JMAX = INAO
          TMAX = ABS(HYB(INAO))
        END IF
   10 CONTINUE
      IF(NAOC(JMAX).NE.JCTR) THEN
        WRITE(LFNPR,920) IHYB,JCTR,NAOC(JMAX)
        CALL NBHALT('Hybrid located on wrong nuclear center.')
      END IF
C
C  Find the sign of the largest s-component of this hybrid:
C
      JMAX  = 0
      TMAX  = ZERO
      DO 20 INAO = 1,NNAO
        L = NAOA(INAO)/100
        IF(L.EQ.0.AND.ABS(HYB(INAO)).GT.TMAX) THEN
          JMAX = INAO
          TMAX = ABS(HYB(INAO))
        END IF
   20 CONTINUE
C
C  If the sign of the largest s-component is negative, change the
C  phase of this hybrid:
C
      IF(JMAX.NE.0.AND.HYB(JMAX).LT.-THRESH) THEN
        DO 30 INAO = 1,NNAO
          HYB(INAO) = -HYB(INAO)
   30   CONTINUE
      ENDIF
C
C  Sum the px,py,pz components of this hybrid to determine the percent
C  p-character, and similarly sum dxy, dxz, dyz, dx2y2, and dz2
C  components to determine percent d-character
C
      DO 40 INAO = 1,NNAO
        IF(NAOC(INAO).EQ.JCTR) THEN
          L = NAOA(INAO)/100
          IF(L.EQ.1) THEN
            PPCT = PPCT + HYB(INAO)*HYB(INAO)
            M = MOD(NAOA(INAO),50)
            PCMP(M) = PCMP(M) + HYB(INAO)
          ELSE IF(L.EQ.2) THEN
            DPCT = DPCT + HYB(INAO)*HYB(INAO)
            M = MOD(NAOA(INAO),50)
            DCMP(M) = DCMP(M) + HYB(INAO)
          END IF
          HNORM = HNORM + HYB(INAO)*HYB(INAO)
        END IF
   40 CONTINUE
      IF(HNORM.LT.THRESH) THEN
        WRITE(LFNPR,930) JCTR,IHYB
        CALL NBHALT('AOs contributing to hybrid on different center.')
      END IF
      PPCT = PPCT/HNORM * 100.0D0
      DPCT = DPCT/HNORM * 100.0D0
C
C  Normalize the px,py,pz vector:
C
      HNORM = ZERO
      DO 50 IX = 1,3
        IF(ABS(PCMP(IX)).LT.CUTOFF) PCMP(IX) = ZERO
        HNORM = HNORM + PCMP(IX)*PCMP(IX)
   50 CONTINUE
      HNORM = SQRT(HNORM)
      IF(ABS(HNORM).LT.CUTOFF) THEN
        PPCT = ZERO
      ELSE
        DO 60 IX = 1,3
          PCMP(IX) = PCMP(IX)/HNORM
   60   CONTINUE
      END IF
C
C  Normalize the d-component vector:
C
      HNORM = ZERO
      DO 70 IX = 1,5
        IF(ABS(DCMP(IX)).LT.CUTOFF) DCMP(IX) = ZERO
        HNORM = HNORM + DCMP(IX)*DCMP(IX)
   70 CONTINUE
      HNORM = SQRT(HNORM)
      IF(ABS(HNORM).LT.CUTOFF) THEN
        DPCT = ZERO
      ELSE
        DO 80 IX = 1,5
          DCMP(IX) = DCMP(IX)/HNORM
   80   CONTINUE
      END IF
      RETURN
C
  920 FORMAT(/1X,'Expected to find hybrid',I4,' on nuclear center',
     + I3,' rather than center',I3,'.')
  930 FORMAT(/1X,'The atomic orbitals on nuclear center',I3,' do not ',
     + 'contribute to hybrid',I4,'.')
      END
C***********************************************************************
      SUBROUTINE NHOANG(THYB,ATCRD,NATOMS,NNAO,NDIM,LFNPR)
C***********************************************************************
C  7-Jan-01  FAW  New subroutine (BEND or JPRINT(36).GT.1)
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER CHARAT*2,BLBL*6,STR*10,ALBL*6,DASH*8,BLANK*6,SCR*6,
     + ENTRY*8,STR1*1
C
C  Print out table of inter-hybrid valence angles (BEND keyword)
C
C  Required input:
C      THYB = Matrix of NHOs (columns) in the NAO basis
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LTYP(MAXBAS),IATHY(MAXBAS,3)
C
      DIMENSION BNDTBL(6,6),LNKAT(6),LNKLP(6),BLBL(6),
     + IHOL(10),LNKHY(6),PCMP(3),DCMP(5),THYB(NDIM,NDIM),
     + ATCRD(3,NATOMS),VEC1(3),VEC2(3),ENTRY(6,6)
C
      SAVE LLP,LBD,LCR,L3C,LSTAR
      SAVE ZERO,ONE,TWO,THREE,THRSH,DASH,PI,BLANK
C
      DATA LLP,LBD,LCR,L3C,LSTAR/2HLP,2HBD,2HCR,2H3C,1H*/
      DATA ZERO/0.0D0/ONE/1.0D0/TWO/2.0D0/THREE/3.0D0/THRSH/5.D-3/
      DATA DASH/'--------'/PI/3.14159265357979D0/BLANK/'      '/
      CONV = 180.0D0/PI
      WRITE(LFNPR,1000)
      CALL FECOOR(ATCRD)
C Prepare table of inter-hybrid angles for skeletal atoms
      DO 100 IAT = 1,NATOMS
        IZA = IATNO(IAT)
        CALL IDIGIT(IAT,IHOL,ND,10)
        CALL SCNVRT(IHOL,STR,ND,IERR)
        ALBL = CHARAT(IZA)//' '//STR(1:ND)
        NLNKAT = 0
        NLNKHY = 0
        NLNKBD = 0
        NLNKLP = 0
        NHY = 0
        DO IBX = 1,NNAO
          IBAS = IBXM(IBX)
          IA = LABEL(IBAS,4)
          IB = LABEL(IBAS,5)
          LTRY = LABEL(IBAS,1)
          IF((LTRY.EQ.LBD.OR.LTRY.EQ.LLP).AND.
     +       (IA.EQ.IAT.OR.IB.EQ.IAT)) THEN
            IF(IAT.EQ.IA) THEN
              IL = IB
              ILOC = 1
            ELSE
              IL = IA
              ILOC = 2
            ENDIF
            IF(LABEL(IBAS,1).EQ.LBD.AND.LABEL(IBAS,2).NE.LSTAR) THEN
              IBM1 = IBAS - 1
              IF(IBM1.GT.0.AND.LABEL(IBAS,4).EQ.LABEL(IBM1,4).AND.
     +                LABEL(IBAS,5).EQ.LABEL(IBM1,5)) THEN
                CONTINUE
              ELSE
                NLNKAT = NLNKAT + 1
                LNKAT(NLNKAT) = IL
                NLNKBD = NLNKBD + 1
                NLNKHY = NLNKHY +1
                IHY = NHY + ILOC
                LNKHY(NLNKHY) = IHY
                NHY = NHY + 2
              ENDIF
            ELSE IF(LABEL(IBAS,1).EQ.LLP) THEN
              NLNKLP = NLNKLP + 1
              LNKLP(NLNKLP) = IBAS
              NLNKHY = NLNKHY + 1
              IHY = NHY + 1
              LNKHY(NLNKHY) = IHY
              NHY = NHY + 1
            ENDIF
          ELSE
            IF(LABEL(IBAS,1).EQ.LBD) NHY = NHY + 2
            IF(LABEL(IBAS,1).EQ.LLP) NHY = NHY + 1
            IF(LABEL(IBAS,1).EQ.LCR) NHY = NHY + 1
            IF(LABEL(IBAS,1).EQ.L3C) NHY = NHY + 3
          ENDIF
        ENDDO
        IF(NLNKBD.LT.2) GOTO 100
        NLNK = NLNKBD + NLNKLP
C Find the links A-I with hybrid IHYB
        DO ILNK = 1,NLNK
          IF(ILNK.LE.NLNKBD) THEN
            ILAT = LNKAT(ILNK)
C Form the vector (VEC1) from IAT to ILAT
            VEC1(1) = ATCRD(1,ILAT) - ATCRD(1,IAT)
            VEC1(2) = ATCRD(2,ILAT) - ATCRD(2,IAT)
            VEC1(3) = ATCRD(3,ILAT) - ATCRD(3,IAT)
            RI = VECLEN(VEC1,3,3)
C Form the bond label (BLBL)
            IZLI = IATNO(ILAT)
            CALL IDIGIT(ILAT,IHOL,ND,10)
            CALL SCNVRT(IHOL,STR,ND,IERR)
            SCR = CHARAT(IZLI)//' '//STR(1:ND)
            NB = 6-(ND+3)
            IF(NB.GT.0) THEN
              BLBL(ILNK) = BLANK(1:NB)//SCR
            ELSE
              BLBL(ILNK) = SCR
            ENDIF
          ELSE
            ILNKLP = ILNK - NLNKBD
            ILAT = 0
            ILP = LNKLP(ILNKLP)
            ILPNO = LABEL(ILP,3)
            CALL IDIGIT(ILPNO,IHOL,ND,10)
            CALL SCNVRT(IHOL,STR,ND,IERR)
            SCR = 'LP('//STR(1:ND)//')'
            NB = 6-(ND+4)
            IF(NB.GT.0) THEN
              BLBL(ILNK) = BLANK(1:NB)//SCR
            ELSE
              BLBL(ILNK) = SCR
            ENDIF
          ENDIF
          IHYB = LNKHY(ILNK)
          CALL HYBCMP(PCMP,PPCTI,DCMP,DPCTI,IHYB,IAT,THYB(1,IHYB))
          SPCTI = 100.0D0 - PPCTI - DPCTI
          IF(SPCTI.LE.THRSH) SPCTI = THRSH
          HLI = PPCTI/SPCTI
          HMI = DPCTI/SPCTI
C Find the links A-J with hybrid JHYB (J < I)
          DO JLNK = 1,ILNK-1
            IF(JLNK.LE.NLNKAT) THEN
              JLAT = LNKAT(JLNK)
C Form the vector (VEC2) from IAT to JLAT
              VEC2(1) = ATCRD(1,JLAT) - ATCRD(1,IAT)
              VEC2(2) = ATCRD(2,JLAT) - ATCRD(2,IAT)
              VEC2(3) = ATCRD(3,JLAT) - ATCRD(3,IAT)
              RJ = VECLEN(VEC2,3,3)
              RIRJ=VEC1(1)*VEC2(1)+VEC1(2)*VEC2(2)+VEC1(3)*VEC2(3)
              ANGIJ = ACOS(RIRJ/(RI*RJ))*CONV
            ELSE
              JLAT = 0
              ANGIJ = ZERO
            ENDIF
            JHYB = LNKHY(JLNK)
            CALL HYBCMP(PCMP,PPCTJ,DCMP,DPCTJ,JHYB,IAT,THYB(1,JHYB))
            SPCTJ = 100.0D0 - PPCTJ - DPCTJ
            IF(SPCTJ.LE.THRSH) SPCTJ = THRSH
            HLJ = PPCTJ/SPCTJ
            HMJ = DPCTJ/SPCTJ
C Evaluate the angle between valence hybrids IHYB, JHYB
            HL = SQRT(HLI*HLJ)
            HM = SQRT(HMI*HMJ)
            IF(HM.LE.THRSH) THEN
C sp^lambda hybrids
              ACUTE = ZERO
              IF(HL.LT.ONE) HL = ONE
              OBTUSE = ACOS(-ONE/HL)*CONV
            ELSE IF(HL.LE.THRSH) THEN
C sd^mu hybrids
              IF(HM.LE.TWO) THEN
                ACUTE = (PI/TWO)*CONV
                OBTUSE = ACUTE
              ELSE
                RAD = SQRT((HM - TWO)/(THREE*HM))
                ACUTE = ACOS(+RAD)*CONV
                OBTUSE = ACOS(-RAD)*CONV
              ENDIF
            ELSE
C general s(p^lambda)(d^mu) hybrids
              ARG = HL*HL - THREE*HM*(TWO - HM)
              IF(ARG.LT.ZERO) ARG = ZERO
              RAD = SQRT(ARG)
              T1 = -HL/(THREE*HM)
              T2 = RAD/(THREE*HM)
              TP = T1 + T2
              TM = T1 - T2
              IF(TP.LE.ONE) THEN
                ACUTE = ACOS(TP)*CONV
              ELSE
                ACUTE = ZERO
              ENDIF
              IF(TM.GE.-ONE) THEN
                OBTUSE = ACOS(TM)*CONV
              ELSE
                OBTUSE = ZERO
              ENDIF
            ENDIF
C Store entries in table
            IF(ABS(ANGIJ-ACUTE).LT.ABS(ANGIJ-OBTUSE)) THEN
              HANGIJ = ACUTE
            ELSE
              HANGIJ = OBTUSE
            ENDIF
            BNDTBL(ILNK,JLNK) = ANGIJ
            BNDTBL(JLNK,ILNK) = HANGIJ
          ENDDO
        ENDDO
C Prepare each table ENTRY as character string
        DO I = 1,NLNK
          DO J = 1,NLNK
C Convert numerical value to string
            VAL = BNDTBL(I,J)
            IVAL = INT(VAL)
            DVAL = VAL - IVAL
            IDVAL = INT(10.0D0*DVAL)
            CALL IDIGIT(IVAL,IHOL,ND,10)
            CALL SCNVRT(IHOL,STR,ND,IERR)
            CALL IDIGIT(IDVAL,IHOL,ND1,10)
            CALL SCNVRT(IHOL,STR1,ND1,IERR)
            IF(VAL.NE.ZERO) THEN
              SCR = STR(1:ND)//'.'//STR1(1:1)
              NL = ND+2
              IF(J.GT.I) THEN
                ENTRY(I,J) = BLANK(1:8-NL)//SCR(1:NL)
              ELSE IF(J.LT.I) THEN
                ENTRY(I,J) = BLANK(1:6-NL)//'('//SCR(1:NL)//')'
                IF(I.GT.NLNKBD) ENTRY(I,J) = BLANK
              ENDIF
            ELSE
              ENTRY(I,J) = BLANK
            ENDIF
            IF(I.EQ.J) ENTRY(I,J) = '     ---'
          ENDDO
        ENDDO
C Print the table for central atom IAT
        WRITE(LFNPR,1100) ALBL,(BLBL(L),L=1,NLNK)
        WRITE(LFNPR,1200) (DASH,L=1,NLNK)
        DO ILNK = 1,NLNK
          WRITE(LFNPR,1300) BLBL(ILNK),(ENTRY(ILNK,JLNK),JLNK=1,NLNK)
        ENDDO
  100 CONTINUE
 1000 FORMAT(//,1X,'NHO Interhybrid (and Internuclear) ',
     + 'Valence Angles ')
 1100 FORMAT(/,1X,A6,'|',6(2X,A6))
 1200 FORMAT(1X,'-------',6A8)
 1300 FORMAT(1X,A6,'|',6A8)
      RETURN
      END
C***********************************************************************
      SUBROUTINE FNDMOL(IATOMS)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXATM = 200)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBMOL/NMOLEC,MOLAT(MAXATM),MOLEC(MAXATM,MAXATM),
     +              NMOLA,MOLATA(MAXATM),MOLECA(MAXATM,MAXATM)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
C
      DIMENSION IATOMS(NATOMS)
      LOGICAL BDFIND
C
C  FIND MOLECULAR UNITS :  Modified algorithm replacing original which
C  had problems with determining molecular units for odd numberings of
C  atoms.   (E. Glendening  3/12/88)
C
      NMOLEC = 0
      DO 20 I = 1,NATOMS
        MOLAT(I) = 0
        DO 10 J = 1,NATOMS
          MOLEC(I,J) = 0
   10   CONTINUE
   20 CONTINUE
      DO 30 I = 1,NATOMS
        IATOMS(I) = I
   30 CONTINUE
      LATOMS = NATOMS
   40 CONTINUE
        NMOLEC = NMOLEC+1
        MOLAT(NMOLEC) = 1
        MOLEC(NMOLEC,1) = IATOMS(1)
        LATOMS = LATOMS-1
        IF(LATOMS.NE.0) THEN
          DO 50 I = 1,LATOMS
            IATOMS(I) = IATOMS(I+1)
   50     CONTINUE
          IAT = 1
   60     CONTINUE
            I = 1
   70       CONTINUE
              IF(BDFIND(MOLEC(NMOLEC,IAT),IATOMS(I))) THEN
                MOLAT(NMOLEC) = MOLAT(NMOLEC)+1
                MOLEC(NMOLEC,MOLAT(NMOLEC)) = IATOMS(I)
                LATOMS = LATOMS-1
                IF(I.LE.LATOMS) THEN
                  DO 80 J = I,LATOMS
                    IATOMS(J) = IATOMS(J+1)
   80             CONTINUE
                END IF
              ELSE
                I = I+1
              END IF
            IF(I.LE.LATOMS) GOTO 70
            IAT = IAT+1
          IF(IAT.LE.MOLAT(NMOLEC).AND.LATOMS.NE.0) GOTO 60
        END IF
      IF(LATOMS.GT.0) GOTO 40
C
C  SORT ATOMS IN MOLECULAR UNITS:
C
      DO 110 I = 1,NMOLEC
        DO 100 J = 1,MOLAT(I)-1
          DO 90 K = 1,MOLAT(I)-J
            IF(MOLEC(I,K).GT.MOLEC(I,K+1)) THEN
              ITEMP = MOLEC(I,K)
              MOLEC(I,K) = MOLEC(I,K+1)
              MOLEC(I,K+1) = ITEMP
            END IF
   90     CONTINUE
  100   CONTINUE
  110 CONTINUE
C
C  ALPHA SPIN: SAVE BONDING INFO IN NMOLA,MOLATA,MOLECA:
C
      IF(ISPIN.EQ.2) THEN
        NMOLA = NMOLEC
        DO 610 IMOL = 1,NMOLEC
          MOLATA(IMOL) = MOLAT(IMOL)
          IMOLAT = MOLAT(IMOL)
          DO 600 IATMOL = 1,IMOLAT
            MOLECA(IMOL,IATMOL) = MOLEC(IMOL,IATMOL)
  600     CONTINUE
  610   CONTINUE
C
C  BETA SPIN: MAKE SURE THAT BETA MOLECULAR UNITS ARE THE SAME AS ALPHA:
C
      ELSE IF(ISPIN.EQ.-2) THEN
        IF(NMOLA.NE.NMOLEC) GO TO 800
        DO 730 IMOL = 1,NMOLEC
          IMOLAT = MOLAT(IMOL)
          IF(IMOLAT.NE.MOLATA(IMOL)) GO TO 800
          DO 720 IATMOL = 1,IMOLAT
            IF(MOLECA(IMOL,IATMOL).NE.MOLEC(IMOL,IATMOL)) GO TO 800
  720     CONTINUE
  730   CONTINUE
      END IF
      RETURN
C
  800 IF(JPRINT(5).EQ.1) WRITE(LFNPR,1800)
      NMOLA = -NMOLA
      RETURN
C
 1800 FORMAT(/1X,'The molecular units found in the alpha and beta ',
     + 'manifolds are inequivalent.',/1X,'For labelling purposes, ',
     + 'the molecular units of the beta system will be used.')
      END
C***********************************************************************
      SUBROUTINE NBOCLA(BNDOCC,ACCTHR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),MOLLST(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBMOL/NMOLEC,MOLAT(MAXATM),MOLEC(MAXATM,MAXATM),
     +              NMOLA,MOLATA(MAXATM),MOLECA(MAXATM,MAXATM)
      DIMENSION BNDOCC(NNAO)
C
      SAVE LBD,L3C,LSTAR,THRESH,ONE,ZERO,TWO,DONTHR
      DATA LBD,L3C,LSTAR/2HBD,2H3C,1H*/
      DATA THRESH,ONE,ZERO,TWO/1.50D0,1.0D0,0.0D0,2.0D0/
      DATA DONTHR/1.0D-1/
C
C  CLASSIFY NBOS ACCORDING TO DONOR/ACCEPTOR TYPE:
C
      IF(ACCTHR.LE.ZERO) THEN
        ACCTHR = THRESH
        IF(ISPIN.NE.0) ACCTHR = ACCTHR - ONE
      END IF
      IF(ISPIN.NE.0) DONTHR = DONTHR / TWO
C
C  MAKE UP LIST MOLLST OF WHICH "MOLECULE" EACH ATOM IS IN:
C
      DO 80 IAT = 1,NATOMS
        DO 60 IMOL = 1,NMOLEC
          IMOLAT = MOLAT(IMOL)
          DO 50 IATMOL = 1,IMOLAT
            IF(MOLEC(IMOL,IATMOL).EQ.IAT) GO TO 70
   50     CONTINUE
   60   CONTINUE
        CALL NBHALT('SR NBOCLA cannot find which molecule atom is in')
   70   MOLLST(IAT) = IMOL
   80   CONTINUE
C
C  MAKE UP LISTS OF NBO ORBITALS:
C    NBOUNI(IBAS) = MOLECULAR UNIT
C    NBOTYP(IBAS) = NUMBER OF CENTERS (+10 IF A LOW OCCUPANCY LONE PAIR)
C                                     (+20 IF AN ANTIBOND/RYDBERG)
      DO 200 IBAS = 1,NNAO
        IB = IBXM(IBAS)
        IAT = LABEL(IB,4)
        IMOL = MOLLST(IAT)
        NBOUNI(IBAS) = IMOL
        LAB = LABEL(IB,1)
        NCTR = 1
        IF(LAB.EQ.LBD) NCTR = 2
        IF(LAB.EQ.L3C) NCTR = 3
        NBOTYP(IBAS) = NCTR
        IF(LABEL(IB,2).EQ.LSTAR) GO TO 180
        IF(BNDOCC(IBAS).GT.ACCTHR) GO TO 200
C
C  LOW OCCUPANCY VALENCE ORBITAL
C
          NBOTYP(IBAS) = NCTR + 10
          GO TO 200
C
C  ANTIBOND/RYDBERG
C
  180   NBOTYP(IBAS) = NCTR + 20
C
C  HIGH OCCUPANCY RY* OR BD* ORBITAL
C
        IF(BNDOCC(IBAS).GT.DONTHR) NBOTYP(IBAS) = NCTR + 10
  200 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE FNBOAN(BNDOCC,F,MOLNBO)
C***********************************************************************
C 28-Oct-99  FAW  Skip low-occupancy BD* "donors"
C 21-Nov-00  FAW  Correct AUKCAL, EVKCAL conversion factors
C 30-Jan-01  FAW  Add COMMON/DAINT/ table of intermolecular
C                 donor-acceptor (coordination) interactions
C 21-Jun-01  FAW  Add SR DALIST to get ordered list for COMMON/DAINT/
C                 without overrunning memory
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL UNPACK
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),MOLLST(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBMOL/NMOLEC,MOLAT(MAXATM),MOLEC(MAXATM,MAXATM),
     +              NMOLA,MOLATA(MAXATM),MOLECA(MAXATM,MAXATM)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBTHR/THRSET,PRJSET,ACCTHR,CRTSET,E2THR,ATHR,PTHR,ETHR,
     +             DTHR,DLTHR,CHSTHR,REFTHR,STTHR,PRTHR,THRNCS,THRNJC
      DIMENSION BNDOCC(NBAS),F(NDIM,NDIM),MOLNBO(2,NBAS,NMOLEC)
      DIMENSION INAM(3),JNAM(3),ICH(3,2),JCH(3,2),ISP(3),JSP(3)
C
      SAVE LBD,L3C,LBLNK1,LBLNK2,LHYP,HUNDTH
      SAVE AUKCAL,EVKCAL,ZERO,ONE,TWO,TEN
      DATA LBD/2HBD/,L3C/2H3C/,LBLNK1/1H /,LBLNK2/2H  /,LHYP/1H-/
      DATA LSTAR/1H*/
      DATA HUNDTH/0.01D0/
      DATA AUKCAL/627.5093314D0/,EVKCAL/23.061D0/
      DATA ZERO,ONE,TWO,TEN/0.0D0,1.0D0,2.0D0,1.0D1/
C
C  PERFORM 2ND ORDER ANALYSIS OF THE FOCK MATRIX:
C
C  ETHR1 IS THE THRESHOLD FOR PRINTING THE INTRAMOLECULAR PERTURBATIONAL
C  ENERGIES (0.5 KCAL/MOL FOR CLOSED SHELL, 0.25 KCAL/MOL FOR OPEN SHELL)
C  SIMILARLY, ETHR2 IS THE INTERMOLECULAR THRESHOLD, (0.05 KCAL/MOL).
C
      ETHR1 = ABS(E2THR)
      IF(ISPIN.NE.0.AND.E2THR.LT.ZERO) ETHR1 = ETHR1/TWO
      ETHR2 = ABS(E2THR)/TEN
      IF(ISPIN.NE.0.AND.E2THR.LT.ZERO) ETHR2 = ETHR2/TWO
C
C  FETCH THE NBO FOCK MATRIX:
C
      CALL FEFNBO(F)
      CALL UNPACK(F,NDIM,NNAO)
C
C  ANALYZE FOCK MATRIX:
C
C  MAKE UP LIST MOLNBO(1,IBAS,IMOL) OF CORE/LP/BOND NBOS IN MOLEC. UNIT IMOL
C               MOLNBO(2,IBAS,IMOL) OF RYDBERG/ANTIBOND NBOS IN MOLEC. IMOL
C
      DO 200 IMOL = 1,NMOLEC
        NOCC = 0
        NSTAR = 0
        DO 110 IBAS = 1,NNAO
          DO 100 I = 1,2
            MOLNBO(I,IBAS,IMOL) = 0
  100     CONTINUE
  110   CONTINUE
        DO 150 IBAS = 1,NNAO
          IF(IMOL.NE.NBOUNI(IBAS)) GO TO 150
          IF(NBOTYP(IBAS).GT.20) GO TO 130
            NOCC = NOCC + 1
            MOLNBO(1,NOCC,IMOL) = IBAS
            IF(NBOTYP(IBAS).LT.10) GO TO 150
  130     CONTINUE
            NSTAR = NSTAR + 1
            MOLNBO(2,NSTAR,IMOL) = IBAS
  150   CONTINUE
  200 CONTINUE
C
C  DETERMINE THE CONVERSION FROM INPUT ENERGY UNITS TO KCAL:
C
      IF(MUNIT.EQ.0) THEN
        CONV = AUKCAL
      ELSE IF(MUNIT.EQ.1) THEN
        CONV = EVKCAL
      ELSE
        CONV = ONE
      END IF
C
C  LOOP OVER PAIRS OF UNITS:
C
      WRITE(LFNPR,2700) ETHR1
      IF(NMOLEC.GT.1) WRITE(LFNPR,2710) ETHR2
      IF(MUNIT.EQ.0) THEN
        WRITE(LFNPR,2720)
      ELSE IF(MUNIT.EQ.1) THEN
        WRITE(LFNPR,2730)
      ELSE
        WRITE(LFNPR,2740)
      END IF
      DO 400 IMOL = 1,NMOLEC
        DO 400 JMOL = 1,NMOLEC
          IF(IMOL.EQ.JMOL) WRITE(LFNPR,2300) IMOL
          IF(IMOL.NE.JMOL) WRITE(LFNPR,2400) IMOL,JMOL
          ETHRSH = ETHR1
          IF(IMOL.NE.JMOL) ETHRSH = ETHR2
          NELE = 0
          DO 305 IOCC = 1,NNAO
            IBAS = MOLNBO(1,IOCC,IMOL)
            IF(IBAS.EQ.0) GO TO 305
            IB = IBXM(IBAS)
C Skip if this "donor" is an antibond of low occupancy,
C because the perturbation theory is invalid in this case
            IF(LABEL(IB,2).EQ.LSTAR) THEN
              IF((ISPIN.EQ.0.AND.BNDOCC(IBAS).GT.1.6D0).OR.
     +           (ISPIN.NE.0.AND.BNDOCC(IBAS).GT.0.6D0)) THEN
                CONTINUE
              ELSE
                GOTO 305
              ENDIF
            ENDIF
            LBL = LABEL(IB,1)
            NCTR = 1
            IF(LBL.EQ.LBD) NCTR = 2
            IF(LBL.EQ.L3C) NCTR = 3
            DO 250 I = 1,3
              IA = LABEL(IB,I+3)
              CALL CONVRT2N(IA,ICH(I,1),ICH(I,2))
              INAM(I) = LBLNK2
              IF(IA.GT.0) INAM(I) = NAMEAT(IATNO(IA))
              ISP(I) = LHYP
              IF(I.GE.NCTR) ISP(I) = LBLNK1
  250       CONTINUE
            DO 300 JSTAR = 1,NNAO
              JBAS = MOLNBO(2,JSTAR,JMOL)
              IF(JBAS.EQ.0) GO TO 300
              IF(IBAS.EQ.JBAS) GO TO 300
              DE = F(JBAS,JBAS) - F(IBAS,IBAS)
              IF(DE.LT.HUNDTH) GO TO 300
              ABSFIJ = ABS(F(IBAS,JBAS))
              EPERT = (ABSFIJ**2)/DE
C
C  COMPUTE OCCUPANCY FACTOR TO MULTIPLY BY:
C
              TOTOCC = BNDOCC(IBAS)+BNDOCC(JBAS)
              FULLOC = TWO
              IF(ISPIN.NE.0) FULLOC = ONE
              OCCFAC = TOTOCC
              IF(TOTOCC.GT.FULLOC) OCCFAC = TWO * FULLOC - TOTOCC
C
C  MULTIPLY EPERT BY SUM OF OCCUPANCIES OF NBOS IBAS AND JBAS:
C
              EPERT = EPERT * OCCFAC
              EKCAL = EPERT * CONV
              IF(EKCAL.LT.ETHRSH) GO TO 300
              NELE = NELE + 1
              JB = IBXM(JBAS)
              LBL = LABEL(JB,1)
              NCTR = 1
              IF(LBL.EQ.LBD) NCTR = 2
              IF(LBL.EQ.L3C) NCTR = 3
              DO 260 J = 1,3
                JA = LABEL(JB,J+3)
                CALL CONVRT2N(JA,JCH(J,1),JCH(J,2))
                JNAM(J) = LBLNK2
                IF(JA.GT.0) JNAM(J) = NAMEAT(IATNO(JA))
                JSP(J) = LHYP
                IF(J.GE.NCTR) JSP(J) = LBLNK1
  260         CONTINUE
              WRITE(LFNPR,2800) IBAS,(LABEL(IB,K),K=1,3),
     *           (INAM(K),ICH(K,1),ICH(K,2),ISP(K),K=1,2),
     *            INAM(3),ICH(3,1),ICH(3,2),
     *                           JBAS,(LABEL(JB,K),K=1,3),
     *           (JNAM(K),JCH(K,1),JCH(K,2),JSP(K),K=1,2),
     *            JNAM(3),JCH(3,1),JCH(3,2),
     *                          EKCAL,DE,ABSFIJ
C Add to the intermolecular donor-acceptor list in COMMON/DAINT/ ?
              IF(IMOL.NE.JMOL.AND.EKCAL.GT.1.0D0) THEN
                CALL DALIST(EKCAL,IBAS,JBAS,0,0,IMOL,JMOL)
              ENDIF
  300       CONTINUE
  305     CONTINUE
          IF(NELE.EQ.0) WRITE(LFNPR,2500)
  400 CONTINUE
      RETURN
C
 2300 FORMAT(/1X,'within unit',I3)
 2400 FORMAT(/1X,'from unit',I3,' to unit',I3)
 2500 FORMAT(1X,'      None above threshold')
 2700 FORMAT(//,1X,'SECOND ORDER PERTURBATION THEORY ANALYSIS ',
     *             'OF FOCK MATRIX IN NBO BASIS'//,1X,
     *          '    Threshold for printing:  ',F5.2,' kcal/mol')
 2710 FORMAT(1X,'   (Intermolecular threshold:',F5.2,' kcal/mol)')
 2720 FORMAT(56X,'  E(2)  E(j)-E(i) F(i,j)'/
     * 6X,'Donor NBO (i)',14X,'Acceptor NBO (j)',7X,
     *            'kcal/mol   a.u.    a.u. ',/1X,79('='))
 2730 FORMAT(56X,'  E(2)  E(j)-E(i) F(i,j)'/
     * 6X,'Donor NBO (i)',14X,'Acceptor NBO (j)',7X,
     *            'kcal/mol   e.V.    e.V. ',/1X,79('='))
 2740 FORMAT(56X,'  E(2)  E(j)-E(i) F(i,j)'/
     * 6X,'Donor NBO (i)',14X,'Acceptor NBO (j)',7X,
     *            'kcal/mol   kcal    kcal ',/1X,79('='))
 2800 FORMAT(I4,'. ',A2,A1,'(',I2,')',A2,3A1,A2,3A1,A2,2A1,
     *   I4,'. ',A2,A1,'(',I2,')',A2,3A1,A2,3A1,A2,2A1,
     *       F8.2,F8.2,F9.3)
      END
C***********************************************************************
      SUBROUTINE NBOSUM(F,BNDOCC,LIST,LISTA,SCR)
C***********************************************************************
C 9-May-02  FAW  Correction for atom numbers > 99
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL UNPACK
      LOGICAL FIRST
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBMOL/NMOLEC,MOLAT(MAXATM),MOLEC(MAXATM,MAXATM),
     +              NMOLA,MOLATA(MAXATM),MOLECA(MAXATM,MAXATM)
      COMMON/NBTHR/THRSET,PRJSET,ACCTHR,CRTSET,E2THR,ATHR,PTHR,ETHR,
     +             DTHR,DLTHR,CHSTHR,REFTHR,STTHR,PRTHR,THRNCS,THRNJC
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      DIMENSION F(NDIM,NDIM),BNDOCC(NDIM),LIST(NDIM),LISTA(NATOMS,2),
     +          SCR(*)
      DIMENSION ISTR(80),ILAB(9)
C
      SAVE ZERO,EPS,TWO,TEN,HUNDRD,TENTH,LSTAR,LRY
      DATA ZERO,EPS,TWO,TEN,HUNDRD/0.0D0,5.0D-6,2.0D0,1.0D1,1.0D2/
      DATA TENTH/1.0D-1/
      DATA LSTAR,LRY/1H*,2HRY/
C
C  Set flag to zero -- Determine strong delocalizations from perturbative
C  analysis of the NBO Fock matrix:
C
      IFLG = 0
C
C  Threshold for printing delocalizations:
C
      THR1 = ABS(E2THR)
      IF(ISPIN.NE.0) THR1 = THR1/TWO
      THR2 = THR1 / TEN
C
C  Get Fock matrix if there is one:
C
      IF(IWFOCK.NE.0) THEN
        CALL FEFNBO(F)
        CALL UNPACK(F,NDIM,NNAO)
      END IF
C
C  Print summary heading, then loop over molecules:
C
      IF(IWFOCK.NE.0) THEN
        WRITE(LFNPR,900)
      ELSE
        WRITE(LFNPR,910)
      END IF
      DO 200 IMOL = 1,NMOLEC
C
C  Determine the molecular formula, the nuclear charge, and the number of
C  ECP electrons of this molecular unit:
C
        NAT  = 0
        MECP = 0
        CHARGE = ZERO
        DO 20 IAT = 1,MOLAT(IMOL)
          KAT = IATNO(MOLEC(IMOL,IAT))
          MECP = MECP + KAT - IZNUC(MOLEC(IMOL,IAT))
          CHARGE = CHARGE + DFLOAT(KAT)
          DO 10 JAT = 1,NAT
            IF(LISTA(JAT,1).EQ.KAT) THEN
              LISTA(JAT,2) = LISTA(JAT,2) + 1
              GO TO 20
            END IF
   10     CONTINUE
          NAT = NAT + 1
          LISTA(NAT,1) = KAT
          LISTA(NAT,2) = 1
   20   CONTINUE
        IF(ISPIN.NE.0) MECP = MECP/2
        IF(ISPIN.NE.0) CHARGE = CHARGE/TWO
        CALL CHEM(NAT,NATOMS,LISTA,NL,ISTR)
        WRITE(LFNPR,920) IMOL,(ISTR(I),I=1,NL)
C
C  Loop over NBO's on this molecular unit:
C
        OCCLEW = DFLOAT(MECP)
        OCCNON = ZERO
        OCCRYD = ZERO
        DO 190 IBAS = 1,NNAO
          IF(NBOUNI(IBAS).EQ.IMOL) THEN
            IB = IBXM(IBAS)
            ILAB(1) = LABEL(IB,1)
            ILAB(2) = LABEL(IB,2)
            ILAB(3) = LABEL(IB,3)
            IPTR    = 3
            NCTR    = MOD(NBOTYP(IBAS),10)
            DO 30 ICTR = 1,NCTR
              IPTR         = IPTR + 2
              ILAB(IPTR)   = LABEL(IB,ICTR+3)
              ILAB(IPTR-1) = NAMEAT(IATNO(ILAB(IPTR)))
   30       CONTINUE
            OCC  = BNDOCC(IBAS)
            IF(ILAB(1).EQ.LRY) THEN
              OCCRYD = OCCRYD + OCC
            ELSE IF(ILAB(2).EQ.LSTAR) THEN
              OCCNON = OCCNON + OCC
            ELSE
              OCCLEW = OCCLEW + OCC
            END IF
C
C  If there is a Fock matrix, find the orbital energy and principal
C  delocalizations:
C
            IF(IWFOCK.NE.0) THEN
              ENRG  = F(IBAS,IBAS)
              CALL GETDEL(IBAS,OCC,THR1,THR2,NL,LIST,SCR,F,IFLG)
              FIRST = .TRUE.
              IL    = 0
   40         CALL DLCSTR(IBAS,IL,NL,LIST,ML,ISTR)
              IF(FIRST) THEN
                IF(NCTR.EQ.1) THEN
                  WRITE(LFNPR,930) IBAS,(ILAB(I),I=1,IPTR),OCC,ENRG,
     +                             (ISTR(J),J=1,ML)
                ELSE IF(NCTR.EQ.2) THEN
                  WRITE(LFNPR,940) IBAS,(ILAB(I),I=1,IPTR),OCC,ENRG,
     +                             (ISTR(J),J=1,ML)
                ELSE
                  WRITE(LFNPR,950) IBAS,(ILAB(I),I=1,IPTR),OCC,ENRG,
     +                             (ISTR(J),J=1,ML)
                END IF
                FIRST = .FALSE.
              ELSE
                  WRITE(LFNPR,960) (ISTR(J),J=1,ML)
              END IF
              IF(IL.LT.NL) GO TO 40
C
C  Otherwise only write out orbital labels and occupancy:
C
            ELSE
              IF(NCTR.EQ.1) THEN
                WRITE(LFNPR,930) IBAS,(ILAB(I),I=1,IPTR),OCC
              ELSE IF(NCTR.EQ.2) THEN
                WRITE(LFNPR,940) IBAS,(ILAB(I),I=1,IPTR),OCC
              ELSE
                WRITE(LFNPR,950) IBAS,(ILAB(I),I=1,IPTR),OCC
              END IF
            END IF
          END IF
  190   CONTINUE
        WRITE(LFNPR,970)
        TOTAL = OCCLEW + OCCNON + OCCRYD
C
C  Make sure the total number of electrons is an integer if there is only
C  one molecular unit:
C
        IF(NMOLEC.EQ.1) THEN
          NEL    = INT(TOTAL + TENTH)
          TOTAL  = DFLOAT(NEL)
          OCCRYD = TOTAL - OCCLEW - OCCNON
        END IF
C
C  Write a summary of the electron population on this molecular unit:
C
        IF(ABS(TOTAL-DFLOAT(NINT(TOTAL))).LT.1.0D-5)
     +                    TOTAL = DFLOAT(NINT(TOTAL))
        CHARGE = CHARGE - TOTAL
        IF(TOTAL.GT.EPS) THEN
          PLEW = OCCLEW/TOTAL*HUNDRD
          PNON = OCCNON/TOTAL*HUNDRD
          PRYD = OCCRYD/TOTAL*HUNDRD
        ELSE
          PLEW = ZERO
          PNON = ZERO
          PRYD = ZERO
        END IF
        WRITE(LFNPR,980) OCCLEW,PLEW
        WRITE(LFNPR,990) OCCNON,PNON
        WRITE(LFNPR,1000) OCCRYD,PRYD
        WRITE(LFNPR,970)
        WRITE(LFNPR,1010) IMOL,TOTAL,HUNDRD
        WRITE(LFNPR,1020) IMOL,CHARGE
        IF(IMOL.LT.NMOLEC) WRITE(LFNPR,*)
  200 CONTINUE
      RETURN
C
  900 FORMAT(//1X,'NATURAL BOND ORBITALS (Summary):',//53X,'Principal ',
     + 'Delocalizations',/1X,'          NBO                 Occupancy',       
     + '    Energy   (geminal,vicinal,remote)',/1X,79('='))
  910 FORMAT(//1X,'Natural Bond Orbitals (Summary):',//1X,'          ',
     + 'NBO              Occupancy  ',/1X,40('-'))
  920 FORMAT(1X,'Molecular unit ',I2,'  ',60A1)
  930 FORMAT(I4,'. ',A2,A1,'(',I2,')',A2,I3,12X,F9.5,F12.5,3X,28A1)
  940 FORMAT(I4,'. ',A2,A1,'(',I2,')',A2,I3,'-',A2,I3,6X,F9.5,F12.5,
     + 2X,28A1)
  950 FORMAT(I4,'. ',A2,A1,'(',I2,')',A2,I3,'-',A2,I3,'-',A2,I3,F9.5,
     + F12.5,1X,28A1)
  960 FORMAT(52X,28A1)
  970 FORMAT(4X,'      -------------------------------')
  980 FORMAT(4X,'             Total Lewis',F11.5,'  (',F8.4,'%)')
  990 FORMAT(4X,'       Valence non-Lewis',F11.5,'  (',F8.4,'%)')
 1000 FORMAT(4X,'       Rydberg non-Lewis',F11.5,'  (',F8.4,'%)')
 1010 FORMAT(4X,'           Total unit ',I2,F11.5,'  (',F8.4,'%)')
 1020 FORMAT(4X,'          Charge unit ',I2,F11.5)
      END
C***********************************************************************
      SUBROUTINE GETDEL(IBO,OCC,THR1,THR2,NL,LIST,DEL,DELOC,IFLG)
C***********************************************************************
C 21-Nov-00  FAW  Correct AUKCAL, EVKCAL conversion factors
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION LIST(NDIM),DEL(NDIM),DELOC(NDIM,NDIM)
C
      SAVE ZERO,ONE,CUTOFF,TENTH,AUKCAL,EVKCAL
      DATA ZERO,ONE,CUTOFF,TENTH/0.0D0,1.0D0,1.0D-4,0.1D0/
      DATA AUKCAL,EVKCAL/627.5093314D0,23.061D0/
C
C Determine the conversion factor to kcal:
C
      IF(MUNIT.EQ.0) THEN
        CONV = AUKCAL
      ELSE IF(MUNIT.EQ.1) THEN
        CONV = EVKCAL
      ELSE
        CONV = ONE
      END IF
C
C Determine the strength of each delocalization:
C
      DO 10 JBO = 1,NNAO
        LIST(JBO) = 0
        DEL(JBO) = ZERO
   10 CONTINUE
C
      NL = 0
      IF(OCC.LT.TENTH) RETURN
      DO 20 JBO = 1,NNAO
        IF(IBO.NE.JBO) THEN
          IF(NBOTYP(JBO).GE.10) THEN
            DEL(JBO) = DELOC(IBO,JBO)*DELOC(IBO,JBO)
            IF(IFLG.EQ.0) THEN
              DIV = ABS(DELOC(IBO,IBO)-DELOC(JBO,JBO))
              IF(DIV.NE.ZERO) THEN
                DEL(JBO) = OCC * DEL(JBO)/DIV * CONV
              ELSE
                DEL(JBO) = ZERO
              END IF
            END IF
          END IF
          IF(DEL(JBO).GT.THR2.AND.NBOUNI(IBO).NE.NBOUNI(JBO)) THEN
            NL = NL + 1
            LIST(NL) = JBO
          ELSE IF(DEL(JBO).GT.THR1) THEN
            NL = NL + 1
            LIST(NL) = JBO
          END IF
        END IF
   20 CONTINUE
C
C  Sort delocalizations:
C
      DO 100 I = 1,NL
        DO 90 J = 1,NL-1
          KBO = LIST(J)
          LBO = LIST(J+1)
          IF(DEL(LBO)-DEL(KBO).GT.CUTOFF) THEN
            LIST(J) = LBO
            LIST(J+1) = KBO
          END IF
   90   CONTINUE
  100 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE DLCSTR(IBO,IL,NL,LIST,ML,ISTR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER (MAXCHR = 28, MAXD = 4)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
      DIMENSION LIST(NDIM),ISTR(80)
      INTEGER IK(MAXD)
C
      SAVE ICOMMA,ILEFT,IRIGHT
      DATA ICOMMA,ILEFT,IRIGHT/1H,,1H(,1H)/
C
C  Build a character string (for the NBO summary table) which contains
C  the delocalization information for NBO # IBO:
C
      ML = 0
   10 IL = IL + 1
      IF(IL.GT.NL) GO TO 30
      CALL IDIGIT(LIST(IL),IK,ND,MAXD)
      IF(ML+ND+4.GT.MAXCHR) GO TO 30
      IF(ML.NE.0) THEN
        ML = ML + 1
        ISTR(ML) = ICOMMA
      END IF
      DO 20 I = 1,ND
        ML = ML + 1
        ISTR(ML) = IK(I)
   20 CONTINUE
      ML = ML + 1
      ISTR(ML) = ILEFT
      ML = ML + 1
      ISTR(ML) = IHTYP(IBO,LIST(IL))
      ML = ML + 1
      ISTR(ML) = IRIGHT
      GO TO 10
C
   30 IL = IL - 1
      RETURN
      END
C***********************************************************************
      SUBROUTINE NLMO(A,EVAL,EVEC,PRM,TSYM,RESON,NOCC,IALARM)
C***********************************************************************
C  1-May-03  FAW  Rescale density matrix to regain integer electrons
C                 on second pass (IALARM.ne.0)
C 11-May-02  FAW  Increased IUNIQ, JUNIQ,... dimensions to 200
C  4-Mar-01  FAW  Add NLMO restart with relaxed DONE, EPS if IALARM.NE.0
C 13-Nov-00  FAW  Remove message re correlated methods
C 12-Nov-00  FAW  Permute (PRM) high-occ. NL and low-occ. L orbitals
C                 to let NLMO continue past previous stop.
C  9-May-96  FAW  Evaluate SQ2I=1/SQRT(2) to machine precision;
C                 "DONE" test of off-diagonal elements altered
C                 to warning (9550) with no IALARM=1.
C  2-Mar-94  EDG  Renormalize NLMOs and recalculate occupancies to
C                 avoid roundoff errors
C  4-Jan-94  FAW  DIFFER set from 1E-05 to 5E-05
C  9-Apr-93  EDG  Allow non-diagonal NLMO density matrices for all
C                 calculations (typically correlated) having no Fock
C                 matrix, but write warning
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  FORM NATURAL LOCALIZED MOLECULAR ORBITALS FROM DENSITY MATRIX A.
C
C     TSYM: SCRATCH
C    RESON: SQUARES OF DIAGONAL ELEMENTS OF NBO TO NLMO TRANSF, TIMES 100%
C   IALARM: ALARM THAT THE ORBITAL OCCUPANCIES ARE OUT OF ORDER AND THAT
C           THE LMO STEP SHOULD BE AVOIDED
C
C  THESE VALUES ARE SET:
C
C     DIFFER = 5.0D-5
C
C     DONE   = 1.0D-10 (THIS IS THE PARAMETER FOR CONVERGENCE OF THE OFF-
C                       DIAGONAL MATRIX ELEMENTS.)
C
C     EPS    = 1.0D-11 (THIS PARAMETER HAS TO DO WITH THE MACHINE PRECISION
C                       AND SHOULD BE SET TO A VALUE BETWEEN "DONE" AND THE
C                       MACHINE PRECISION.)
C
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ZEROJ
C
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
C
      DIMENSION A(NDIM,NDIM),EVEC(NDIM,*),EVAL(*),TSYM(*),RESON(NDIM)
      DIMENSION ROT(2,2),PRM(NDIM,NDIM),IPRM(200,2)
      DIMENSION ILIST(200),JLIST(200),IOFF(200),JOFF(200),IUNIQ(200),
     +   JUNIQ(200)
C
C  IMPORTANT PARAMETERS:
C
      SAVE DIFFER,DONE,EPS,DEGTHR,NOFFMX,ZERO,ONE,HUNDRD
      DATA DIFFER,DONE,EPS/5.0D-5,1.0D-10,1.0D-11/
C
C  NOFFMX IS SET TO THE DIMENSION OF VECTORS ILIST,JLIST,IOFF,JOFF,IUNIQ,JUNIQ:
C
      DATA DEGTHR,NOFFMX/1.0D-3,100/
      DATA ZERO,ONE,HUNDRD/0.0D0,1.0D0,100.0D0/
C
C  IS THIS A RE-START (IALARM.NE.0)?  IF SO, WEAKEN THE CONVERGENCE THRESHOLDS
      IF(IALARM.NE.0) THEN
        IALARM = 0
        DONE = 10.0D0*DONE
        EPS = 10.0D0*EPS
        WRITE(LFNPR,8380) DONE,EPS
      ENDIF
      SQ2I=1.0D0/SQRT(2.0D0)
      IF(IPRINT.GT.0) WRITE(LFNPR,8390)
      THR1 = ONE - DEGTHR
      THR2 = ONE - DEGTHR*5
      NTIME = 0
C
C  IF THERE IS ONLY ONE BASIS FUNCTION, SOLVE THIS TRIVIAL CASE AND RETURN:
C
      IF(NNAO.GT.1) GO TO 10
        EVEC(1,1) = ONE
        EVAL(1) = A(1,1)
        RETURN
   10 CONTINUE
C
      DO 30 J = 1,NNAO
        DO 20 I = 1,NNAO
   20     EVEC(I,J) = ZERO
   30   EVEC(J,J) = ONE
C
C  COUNT THE NUMBER OF ELECTRONS AND OCCUPIED ORBITALS:
C
      TOTELE = ZERO
      DO 50 I = 1,NNAO
   50   TOTELE = TOTELE + A(I,I)
      TOTELE = TOTELE + DIFFER
      NOCC = INT(TOTELE)
      IF(ISPIN.EQ.0) NOCC = NOCC/2 + MOD(NOCC,2)
      NVIRST = NOCC + 1
C
C  QUIT IF THERE ARE NO OCCUPIED ORBITALS:
C
      IF(NOCC.EQ.0) THEN
        WRITE(LFNPR,9910)
        RETURN
      END IF
C
C Are any Lewis-type NBOs of higher occupancy than non-Lewis NBOs?
C
      DO I =1,NNAO
        EVAL(I) = A(I,I)
      ENDDO
      NSWAP = 0
   60 DMIN = HUNDRD
      DO I = 1,NOCC
        IF(EVAL(I).LT.DMIN) THEN
          DMIN = EVAL(I)
          IMIN = I
        ENDIF
      ENDDO
      DMAX = ZERO
      DO J = NOCC+1,NNAO
        IF(EVAL(J).GT.DMAX) THEN
          DMAX = EVAL(J)
          JMAX = J
        ENDIF
      ENDDO
C
C If so, swap the pair and save the swap-pair in IPRM
C
      IF(DMAX.GT.DMIN) THEN
        NSWAP = NSWAP + 1
        IPRM(NSWAP,1) = IMIN
        IPRM(NSWAP,2) = JMAX
        DT = EVAL(IMIN)
        EVAL(IMIN) = EVAL(JMAX)
        EVAL(JMAX) = DT
        IF(NSWAP.LT.100) THEN
          GOTO 60
        ELSE
          IALARM = 1
          WRITE(LFNPR,1000)
 1000 FORMAT(1X,'NLMO overflows IPRM array (NSWAP > 100); must abort.')
          RETURN
        ENDIF
      ENDIF
C
C Form the permutation matrix if NSWAP > 0
C
      IF(NSWAP.GT.0) THEN
C
C First, form the unit matrix
C
        DO I = 1,NNAO
          DO J = 1,NNAO
            PRM(I,J) = ZERO
          ENDDO
          PRM(I,I) = ONE
        ENDDO
C
C Then, loop over swap-pairs to form the permutation matrix
C
        DO KSWAP = 1,NSWAP
          IC = IPRM(KSWAP,1)
          JC = IPRM(KSWAP,2)
          DO I = 1,NNAO
            PT = PRM(I,IC)
            PRM(I,IC) = PRM(I,JC)
            PRM(I,JC) = PT
          ENDDO
        ENDDO
C
C Transform input density matrix to permuted order
C
        CALL SIMTRS(A,PRM,EVAL,NDIM,NNAO)
      ENDIF
C
C   START LOOP:
C
  100 CONTINUE
      NTIME = NTIME + 1
C
C  FIRST, FIND ELEMENT A(IOCC,JEMT) OF LARGEST MAGNITUDE, OFFTOP:
C
      OFFTOP = ZERO
      DO 200 JEMT = NVIRST,NNAO
        DO 200 IOCC = 1,NOCC
          ABSAIJ = ABS(A(IOCC,JEMT))
          IF(ABSAIJ.LT.OFFTOP) GO TO 200
          OFFTOP = ABSAIJ
          AII = A(IOCC,IOCC)
          AJJ = A(JEMT,JEMT)
  200 CONTINUE
C
C  RETURN IF CONVERGENCE HAS BEEN ACHIEVED:
C
      IF(OFFTOP.LT.DONE) GO TO 900
C
C  FIND ALL ELEMENTS DEGENERATE WITH LARGEST ONE, OFFTOP:
C  (CHECK CORRESPONDING DIAGONAL ELEMENTS ALSO)
C  NOFF: NUMBER OF DEGENERATE ELEMENTS
C  IOFF(K),JOFF(K): KTH DEGENERATE ELEMENT
C
      OFFTST = OFFTOP * THR1
      AIIL = AII*THR2
      AJJL = AJJ*THR2
      AIIU = AII/THR2
      AJJU = AJJ/THR2
      ZEROJ = .FALSE.
      IF(AJJ.LT.DIFFER) ZEROJ = .TRUE.
      NOFF = 0
      DO 250 JEMT = NVIRST,NNAO
        DO 250 IOCC = 1,NOCC
          ABSAIJ = ABS(A(IOCC,JEMT))
          IF(ABSAIJ.LT.OFFTST) GO TO 250
          AIII = A(IOCC,IOCC)
          AJJJ = A(JEMT,JEMT)
          IF((AIII.LT.AIIL).OR.(AIII.GT.AIIU)) GO TO 250
C
C  SKIP TEST OF DIAG. ELEM. IF SMALL (.LT.DIFFER):
C
          IF(ZEROJ) GO TO 240
          IF((AJJJ.LT.AJJL).OR.(AJJJ.GT.AJJU)) GO TO 250
  240     NOFF = NOFF + 1
          IOFF(NOFF) = IOCC
          JOFF(NOFF) = JEMT
  250     CONTINUE
      IF(NOFF.LT.NOFFMX) GO TO 260
        WRITE(LFNPR,2500) NOFF,NOFFMX
 2500   FORMAT(//1X,'NOFF = ',I5,' IS GREATER THAN NOFFMX =',I5,
     *            /5X,'  MUST ABORT NLMO PROCEDURE')
        IALARM = 1
        RETURN
  260 CONTINUE
C
      S = AJJ - AII
      ABSS = ABS(S)
C
C  IF THE ROTATION IS VERY CLOSE TO 45 DEGREES, SET SIN AND COS TO 1/(ROOT 2)
C
      TEST=EPS*OFFTOP
      IF (ABSS.GT.TEST) GO TO 330
      S=SQ2I
      C=S
      GO TO 340
C
C  CALCULATION OF SIN AND COS FOR ROTATION THAT IS NOT VERY CLOSE TO 45 DEGREES
  330 T=OFFTOP/S
      S=0.25D0/ SQRT(0.25D0+T*T)
C
C    JACOBI ROTATION ANGLE:   COS=C ,  SIN=S
      C= SQRT(0.5D0+S)
      S=2.D0*T*S/C
  340 CONTINUE
C  PRINT STATEMENTS FOR NLMO PROCEDURE DETAILS:
C      WRITE(LFNPR,9903) OFFTOP,S,C,NOFF
C 9903 FORMAT(' ******   OFFTOP,S,C,NOFF:',3F14.9,I3)
C      WRITE(LFNPR,9901) (IOFF(I),I=1,NOFF)
C 9901 FORMAT(' IOFF:',20I3)
C      WRITE(LFNPR,9902) (JOFF(I),I=1,NOFF)
C 9902 FORMAT(' JOFF:',20I3)
C
C     SIMPLE 2 BY 2 ROTATION, NO DEGENERACY PROBLEMS:
      IF(NOFF.GT.1) GO TO 400
        IOCC=IOFF(1)
        JEMT=JOFF(1)
        IF(A(IOCC,JEMT).LT.ZERO) S=-S
        ROT(1,1)=C
        ROT(2,2)=C
        ROT(1,2)=S
        ROT(2,1)=-S
        IOFF(2)=JOFF(1)
        CALL LIMTRN(A,IOFF,ROT,EVAL,NDIM,NNAO,2,2,0)
C
C     ROTATION COMPLETED
        DO 380 I=1,NNAO
          T=EVEC(I,IOCC)
          EVEC(I,IOCC)=C*T-EVEC(I,JEMT)*S
  380     EVEC(I,JEMT)=S*T+EVEC(I,JEMT)*C
        GO TO 800
C
  400 CONTINUE
C
C  NOFF.GT.1:
C   COMPUTE "AVERAGED" UNITARY TRANSFORMATION SO THAT SYMMETRY IS PRESERVED
C
C    CONSTRUCT UNIQUE LISTS OF ORBITALS INVOLVED:
C
C      IUNIQ(L): L-TH UNIQUE OCCUPIED ORB.
C      NIUNIQ:   NO. OF UNIQUE OCC. ORBS
C      ILIST(L): LOCATION IN THE UNIQUE LIST (IUNIQ) OF THE I VALUE OF THE
C                            L-TH OFFDIAG. ELEMENT
C      JUNIQ, NJUNIQ, AND JLIST ARE FOR THE EMPTY ORBITALS.
C
        IUNIQ(1)=IOFF(1)
        ILIST(1)=1
        NIUNIQ=1
        DO 500 MOFF=2,NOFF
          I=IOFF(MOFF)
          IIMAX=MOFF-1
          DO 490 II=1,IIMAX
            IF(IOFF(II).NE.I) GO TO 490
            ILIST(MOFF)=ILIST(II)
            GO TO 500
  490       CONTINUE
          NIUNIQ=NIUNIQ+1
          ILIST(MOFF)=NIUNIQ
          IUNIQ(NIUNIQ)=I
  500     CONTINUE
C
        JUNIQ(1)=JOFF(1)
        JLIST(1)=NIUNIQ+1
        NJUNIQ=1
        DO 540 MOFF=2,NOFF
          J=JOFF(MOFF)
          JJMAX=MOFF-1
          DO 530 JJ=1,JJMAX
            IF(JOFF(JJ).NE.J) GO TO 530
            JLIST(MOFF)=JLIST(JJ)
            GO TO 540
  530       CONTINUE
          NJUNIQ=NJUNIQ+1
          JLIST(MOFF)=NJUNIQ+NIUNIQ
          JUNIQ(NJUNIQ)=J
  540     CONTINUE
        NROT=NIUNIQ+NJUNIQ
        NROT2=NROT*NROT
        N1=NROT2+1
        N2=NROT2+N1
C
C  CONSTRUCT TSYM:
C
        CALL SYMUNI(TSYM,A,C,S,TSYM(N1),TSYM(N2),EVAL,NROT,NIUNIQ,
     +              NJUNIQ,ILIST,JLIST,NOFF,IOFF,JOFF,NDIM)
C
C  MAKE IUNIQ INTO A COMPLETE LIST OF THE UNIQUE ORBITALS, AND TRANSFORM
C  THE NBO TO NLMO TRANSF. (EVEC) AND THE DM (A) BY TSYM:
C
        II=NIUNIQ
        DO 700 I=1,NJUNIQ
          II=II+1
  700     IUNIQ(II)=JUNIQ(I)
        CALL LIMTRN(EVEC,IUNIQ,TSYM,EVAL,NDIM,NNAO,NROT,NROT,1)
        CALL LIMTRN(A,IUNIQ,TSYM,EVAL,NDIM,NNAO,NROT,NROT,0)
  800   CONTINUE
      GO TO 100
C
C Nearly finished!
C
  900 CONTINUE
C
C Transform density matrix back to original order with transposed PRM
C
      IF(NSWAP.GT.0) THEN
        CALL NBTRSP(A,NDIM,NNAO)
        CALL SIMTRS(A,PRM,EVAL,NDIM,NNAO)
      ENDIF
C
C  FINISHED: RECONSTRUCT THE NLMO DENSITY MATRIX (MATRIX A ALREADY CONTAINS
C  THIS, BUT WE CALCULATE IT AGAIN BECAUSE ROUND-OFF ERRORS MAY BE LARGE).
C  ALSO, RENORMALIZE THE NLMOS IN EVEC:
C
      CALL FESRAW(A)
      CALL FETNBO(TSYM)
      CALL SIMTR1(A,TSYM,RESON,NDIM,NBAS,NBAS,NNAO)
      CALL NORMLZ(EVEC,A,NDIM,NNAO,NNAO)
      CALL FEDNAO(A)
      CALL FETNAB(TSYM)
      CALL SIMTRS(A,TSYM,RESON,NDIM,NNAO)
      CALL SIMTRS(A,EVEC,RESON,NDIM,NNAO)
C
C  PLACE OCCUPANCIES IN EVAL AND COUNT UP ELECTRONS:
C
      TOTELE = ZERO
      DO 910 J = 1,NNAO
        EVAL(J) = A(J,J)
        TOTELE = TOTELE + EVAL(J)
        X = EVEC(J,J)
        RESON(J) = X * X * HUNDRD
  910 CONTINUE
      TOTP = TOTELE + DIFFER
      NEL = INT(TOTP)
      TOT = DFLOAT(NEL)
      FRACT = ABS(TOTELE-TOT)
C***********************************************************************
C FAW: bypass "differ" test; rescale density matrix to integer electrons
      IF(FRACT.GT.DIFFER) THEN
        NELEC=INT(TOTELE+0.5D0)
        ELOSS=NELEC-TOTELE
        WRITE(LFNPR,9920) ELOSS
 9920 FORMAT(/1X,'Bad numerics in total electron check (',F8.5,');',
     + /,1X,'will attempt to re-scale density matrix and proceed...')
        SCALE=DFLOAT(NELEC)/TOTELE
        DO I = 1,NNAO
          DO J = I,NNAO
            A(I,J) = SCALE*A(I,J)
            A(J,I) = A(I,J)
          ENDDO
        ENDDO
      ENDIF
C***********************************************************************
C
C  FIND THE LARGEST OFF-DIAGONAL DENSITY MATRIX ELEMENT:
C
      AMAX = ZERO
      DO 960 J = 2,NNAO
        JM1 = J - 1
        DO 950 I = 1,JM1
          IF(ABS(A(I,J)).LT.AMAX) GO TO 950
          AMAX = ABS(A(I,J))
  950   CONTINUE
  960 CONTINUE
      IF(IPRINT.GT.0) WRITE(LFNPR,9500) AMAX
C
C  IF THIS IS A CORRELATED WAVEFUNCTION, RETURN TO THE CALLING ROUTINE:
C
      IF(CI.OR.MCSCF.OR.AUHF) THEN
        RETURN
      END IF
C
C  FOR SCF WAVEFUNCTIONS, MAKE SURE THIS MATRIX ELEMENT IS SMALL:
C
      IF(AMAX.LT.HUNDRD*HUNDRD*DONE) RETURN
      IF(IWFOCK.EQ.0) THEN
        WRITE(LFNPR,9540)
        RETURN
      END IF
      WRITE(LFNPR,9550)
C      IALARM = 1
      RETURN
C
 8380 FORMAT(/1X,'Restarting NLMO with less stringent thresholds: ',
     + 'DONE =',D9.2,', EPS =',D9.2)
 8390 FORMAT(//1X,'NATURAL LOCALIZED MOLECULAR ORBITAL (NLMO) ',
     *     'ANALYSIS:')
 9500 FORMAT(/1X,'Maximum off-diagonal element of DM in NLMO basis:',
     *         D13.5)
 9540 FORMAT(/1X,'WARNING:  NLMO density matrix is not diagonal.  ',
     * 'Since a Fock matrix is',/1X,'          not available, the ',
     * 'program will continue, but assume that the',/1X,'          ',
     * 'density corresponds to a correlated wavefunction.')
 9550 FORMAT(/1X,'WARNING: this density matrix element exceeds ',
     + 'threshold; attempt to proceed.')
 9910 FORMAT(/1X,'No occupied orbitals, NLMO analysis abandoned.')
      END
C***********************************************************************
      SUBROUTINE LMOANL(T,S,RESON,OCC,TS,BORDER,OWBORD,ATLMO,SIAB,
     +                  NOCC,NAB)
C***********************************************************************
C  AER 03-Mar-88  Revision 1.2: To reduce amount of output, deleted some
C                 blank lines, commented out print of atom totals for
C                 bond orders, and the atomic contrib. to the NLMO is
C                 only printed if it is greater than 0.01%.
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      INTEGER UL
      LOGICAL CLOSED
C
C  PRINT OUT DETAILS OF NAO TO NLMO TRANSFORMATION IN MATRIX T.
C
C  REQUIRED INPUT:
C      NDIM = DECLARED DIMENSIONALITY OF ARRAY T
C      NNAO = NO. OF ORBITALS = ACTUAL DIMENSION OF T, NAOL
C      NAOL = INTEGER LIST OF ORBITAL ANG. MOMENTUM TYPE
C                NAOL(I)/100 = L = Q.N. OF ATOMIC ORBITAL I
C     IATNO = LIST OF ATOMIC NUMBERS; IATNO(I) IS THE NUCLEAR CHARGE
C                OF ATOM I AS AN INTEGER
C    NATOMS = NO. OF ATOMS (NOT INCLUDING GHOSTS) IN THE MOLECULE
C    IWHYBS = 1 IF HYBRID A.O. COEFFICIENTS ARE TO BE PRINTED,
C             0 OTHERWISE.
C     LFNPR = LOGICAL FILE NUMBER FOR PRINTOUT.
C    NAOCTR = LIST OF ATOMIC CENTERS OF OAO OR NAO BASIS ORBITALS
C     LABEL = LIST OF BOND ORBITAL LABELS
C      IBXM = PERMUTATION LIST OF BOND ORBITALS
C    BNDOCC = LIST OF BOND ORBITAL OCCUPANCIES
C     ISPIN = 0 FOR CLOSED SHELL
C           = 2 FOR ALPHA SPIN
C           =-2 FOR BETA  SPIN
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBNAO/NAOCTR(MAXBAS),NAOL(MAXBAS),LTYP1(MAXBAS),
     +       IPRIN(MAXBAS)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       UL(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LTYP(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      DIMENSION T(NDIM,NDIM),S(NDIM,NDIM),OCC(NDIM),RESON(NDIM),
     * TS(NDIM),SIAB(NOCC,NAB),ATLMO(NOCC,NATOMS),
     * BORDER(NATOMS,NATOMS),OWBORD(NATOMS,NATOMS),
     * PCT(5),POW(5),LNAME(5),ISP(3),NAM(3),ICH3(3,3)
      CHARACTER*80 TITLE
C
      SAVE LLP,LBD,L3C,LCR,LRY
      SAVE LNAME,ZERO,HUNDTH,T99,T99P
      SAVE TWO,TENTH,HUNDRD,THR
      SAVE LHYP,LBLNK,L2BLNK,BOTHR
C
      DATA LLP,LBD,L3C,LCR,LRY/2HLP,2HBD,2H3C,2HCR,2HRY/
      DATA LNAME/1Hs,1Hp,1Hd,1Hf,1Hg/
      DATA ZERO,HUNDTH,T99,T99P/0.0D0,1.D-2,99.99D0,99.995D0/
      DATA TWO,TENTH,HUNDRD,THR/2.0D0,0.1D0,100.0D0,1.0D-6/
      DATA LHYP,LBLNK,L2BLNK/1H-,1H ,2H  /
      DATA BOTHR/2.0D-3/
C
      IF(IPRINT.LE.0) RETURN
      CLOSED=.TRUE.
      IF(ISPIN.NE.0) CLOSED=.FALSE.
      IF(ISPIN.EQ.0) WRITE(LFNPR,8400)
      IF(ISPIN.EQ.2) WRITE(LFNPR,8410)
      IF(ISPIN.EQ.-2) WRITE(LFNPR,8420)
      WRITE(LFNPR,8000)
      WRITE(LFNPR,8100) (LHYP,J=1,79)
C  LOOP OVER OCCUPIED NLMOS:
      DO 900 NLMO=1,NNAO
        IF(OCC(NLMO).LT.TENTH) GO TO 900
        IB=IBXM(NLMO)
        LBL=LABEL(IB,1)
        IF(LBL.EQ.LLP.OR.LBL.EQ.LCR.OR.LBL.EQ.LRY) NCTR=1
        IF(LBL.EQ.LBD) NCTR=2
        IF(LBL.EQ.L3C) NCTR=3
        DO 110 I=1,3
          IA=LABEL(IB,I+3)
          CALL CONVRT3(IA,ICH3(I,1),ICH3(I,2),ICH3(I,3))
          NAM(I)=L2BLNK
          IF(IA.GT.0) NAM(I)=NAMEAT(IATNO(IA))
          ISP(I)=LHYP
          IF(I.GE.NCTR) ISP(I)=LBLNK
  110     CONTINUE
C  LOOP OVER ATOMIC CENTERS OF BOND ORBITAL NBOND
        DO 170 ICTR=1,NCTR
          ISP(ICTR)=LHYP
          IF(ICTR.EQ.NCTR) ISP(ICTR)=LBLNK
          I=LABEL(IB,ICTR+3)
          NEL=NAMEAT(IATNO(I))
  170     CONTINUE
          WRITE(LFNPR,8220) NLMO,OCC(NLMO),RESON(NLMO),(LABEL(IB,K),
     +      K=1,3),(NAM(K),ICH3(K,1),ICH3(K,2),ICH3(K,3),ISP(K),K=1,3)
          IF(OCC(NLMO).LT.TENTH.AND.LBL.EQ.LRY) GO TO 900
C  LOOP OVER ATOMS:  (J COUNTS OVER NAOS)
        DO 700 IAT=1,NATOMS
          NL=0
          DO 200 L=1,5
  200       PCT(L)=ZERO
          JLOW=LL(IAT)
          JHIGH=UL(IAT)
          DO 300 J=JLOW,JHIGH
            L=NAOL(J)/100+1
            COEF=T(J,NLMO)
            PCT(L)=PCT(L)+COEF*COEF
  300       CONTINUE
C  PRINT OUT CONTRIBUTION FROM ATOM IAT (AND SAVE IN ATLMO):
          NL=L
          POL=ZERO
          DO 340 L=1,5
  340       POL=POL+PCT(L)
          IF(NLMO.LE.NOCC) ATLMO(NLMO,IAT)=POL
          PCTPOL=POL*HUNDRD
C  PRINT ONLY CONTRIBUTIONS GREATER THAN 0.01%
          IF(PCTPOL.LT.HUNDTH) GO TO 700
          DO 350 L=1,5
  350       PCT(L)=HUNDRD*PCT(L)/POL
C  FIND LEADING NON-ZERO CONTRIBUTION TO DETERMINE POW(L) FOR EACH L
          LSTD=0
          DO 460 L=1,NL
            IF(LSTD.GT.0) GO TO 450
             POW(L)=ZERO
             STD=PCT(L)
             IF(STD.LT.HUNDTH) GO TO 460
              LSTD=L
  450       POW(L)=PCT(L)/STD
             IF(POW(L).GT.T99P) POW(L)=T99
  460     CONTINUE
          NL1=NL
          NEL=NAMEAT(IATNO(IAT))
          IF(NL1.GT.3) NL1=3
          WRITE(LFNPR,8300)
     *        PCTPOL,NEL,IAT,PCT(1),(LNAME(L),POW(L),PCT(L),L=2,NL1)
          IF(NL.GT.3) WRITE(LFNPR,8310)
     *        (LNAME(L),POW(L),PCT(L),L=4,NL)
  700     CONTINUE
  900   CONTINUE
C
C  NOW, COMPUTE HYBRID OVERLAPS SIAB:
C
      IF(ORTHO) GOTO 2200
      CALL FESNAO(S)
      DO 1500 NLMO=1,NOCC
        IAB=0
        NATM1=NATOMS-1
        DO 1400 IAT=1,NATM1
          IALOW=LL(IAT)
          IAHIGH=UL(IAT)
          DO 1100 L=1,NNAO
            IF(L.GE.IALOW.AND.L.LE.IAHIGH) GO TO 1100
            TS(L)=ZERO
            DO 1050 K=IALOW,IAHIGH
 1050         TS(L)=TS(L)+T(K,NLMO)*S(K,L)
 1100       CONTINUE
C          IF(IAT.GT.2) GO TO 1130
C          CALL ALTOUT(TS,1,NDIM,1,NDIM)
C 1130     CONTINUE
          JAT0=IAT+1
          DO 1300 JAT=JAT0,NATOMS
            IAB=IAB+1
            OVP=ZERO
            JALOW=LL(JAT)
            JAHIGH=UL(JAT)
            DO 1200 L=JALOW,JAHIGH
 1200         OVP=OVP+TS(L)*T(L,NLMO)
            ANORM=SQRT(ATLMO(NLMO,IAT)*ATLMO(NLMO,JAT))
            IF(ANORM.LT.THR) GO TO 1250
            SIAB(NLMO,IAB)=OVP/ANORM
C            IF(IAT.GT.2) GO TO 1300
C            WRITE(LFNPR,9996) JAT,IAB,JALOW,JAHIGH,OVP,ANORM,
C     *                    SIAB(NLMO,IAB)
C 9996       FORMAT(1X,'JAT,IAB,JALOW,JAHIGH,OVP,ANORM,SIAB:',
C     *              /5X,4I3,3F11.6)
            GO TO 1300
 1250       SIAB(NLMO,IAB)=ZERO
C            IF(IAT.GT.2) GO TO 1300
C            WRITE(LFNPR,9996) JAT,IAB,JALOW,JAHIGH,OVP,ANORM,
C     *                    SIAB(NLMO,IAB)
 1300       CONTINUE
 1400     CONTINUE
 1500   CONTINUE
C  NOW WE ARE READY TO COMPUTE BOND ORDERS!
      IF(JPRINT(12).NE.0) THEN
        IAB=0
        NATM1=NATOMS-1
        WRITE(LFNPR,9000)
        DO 2000 IAT=1,NATM1
          JAT0=IAT+1
          DO 1900 JAT=JAT0,NATOMS
            IAB=IAB+1
            SUM=ZERO
            OWSUM=ZERO
            DO 1800 NLMO=1,NOCC
              ALAMA2=ATLMO(NLMO,IAT)
              ALAMB2=ATLMO(NLMO,JAT)
              OVP=SIAB(NLMO,IAB)
              BO=ALAMA2
              IF(ALAMB2.LT.ALAMA2) BO=ALAMB2
C              WRITE(LFNPR,8999) ALAMA2,ALAMB2,BO
C 8999         FORMAT(1X,'ALAMA2,ALAMB2,BO:',3F14.7)
              IF(CLOSED) BO=BO*TWO
              OWBO=BO*OVP
              IF(OVP.LT.ZERO) BO=-BO
              IF(ABS(BO).GT.BOTHR)
     *          WRITE(LFNPR,9100) IAT,JAT,NLMO,BO,OVP
              SUM=SUM+BO
              OWSUM=OWSUM+OWBO
 1800         CONTINUE
C            WRITE(LFNPR,9110) SUM,OWSUM
            BORDER(IAT,JAT)=SUM
            BORDER(JAT,IAT)=SUM
            OWBORD(IAT,JAT)=OWSUM
            OWBORD(JAT,IAT)=OWSUM
 1900       CONTINUE
 2000     CONTINUE
C  ZERO DIAGONAL ELEMENTS!
        DO 2020 IAT=1,NATOMS
          BORDER(IAT,IAT)=ZERO
 2020     OWBORD(IAT,IAT)=ZERO
C  COMPUTE TOTALS BY ATOM AND PRINT RESULTS:
        DO 2100 IAT=1,NATOMS
          SUM=ZERO
          DO 2050 JAT=1,NATOMS
            SUM=SUM+BORDER(IAT,JAT)
 2050     CONTINUE
          TS(IAT)=SUM
 2100   CONTINUE
        TITLE = 'Atom-Atom Net Linear NLMO/NPA Bond Orders:'
        CALL AOUT(BORDER,NATOMS,NATOMS,NATOMS,TITLE,0,NATOMS)
        TITLE = 'Linear NLMO/NPA Bond Orders, Totals by Atom:'
        CALL AOUT(TS,NATOMS,NATOMS,1,TITLE,0,1)
      END IF
 2200 CONTINUE
      RETURN
C
 8000 FORMAT(1X,'NLMO/Occupancy/Percent from Parent NBO/ Atomic ',
     + 'Hybrid Contributions')
 8100 FORMAT(1X,80A1)
 8220 FORMAT(I4,'. (',F7.5,') ',F8.4,'%  ',A2,A1,'(',I2,')',
     + 3(A2,4A1))
 8300 FORMAT(25X,F7.3,'% ',A2,I3,' s(',F6.2,'%)',2(A1,F5.2,'(',
     +  F6.2,'%)'))
 8310 FORMAT(50X,2(A1,F5.2,'(',F6.2,'%)'))
 8400 FORMAT(/1X,'Hybridization/Polarization Analysis of NLMOs ',
     *  'in NAO Basis:')
 8410 FORMAT(/1X,'Hybridization/Polarization Analysis of NLMOs ',
     *  'in NAO Basis, Alpha Spin:')
 8420 FORMAT(/1X,'Hybridization/Polarization Analysis of NLMOs ',
     *  'in NAO Basis, Beta Spin:')
 9000 FORMAT(/1X,'Individual LMO bond orders greater than 0.002',
     *   ' in magnitude,'/1X,
     * 'with the overlap between the hybrids in the NLMO given:',//1X,
     *   'Atom I / Atom J / NLMO / Bond Order / Hybrid Overlap /')
 9100 FORMAT(1X,I4,I8,2X,I6,F14.7,F16.7)
      END
C***********************************************************************
      SUBROUTINE DIPANL(DM,T,C,TNBO,DX,DY,DZ,SCR,LISTA,INDEX)
C***********************************************************************
C  8-Apr-93  EDG  Add dipole summary by molecular unit
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL RESID,TEST
C
C  DM       --  NLMO density matrix (input)
C  T        --  AO to NLMO transformation matrix (input)
C  C        --  NBO to NLMO transformation matrix (retrieved from NBODAF)
C  TNBO     --  AO to NBO transformation (retrieved from NBODAF)
C  DX,DY,DZ --  AO dipole matrices (retrieved from NBODAF)
C  SCR      --  NDIM*NDIM word scratch vector
C  INDEX    --  temporary indexing array
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBDXYZ/XDIP,YDIP,ZDIP,CHARGE(MAXATM),XDNLMO(MAXATM),
     +       YDNLMO(MAXATM),ZDNLMO(MAXATM),XDNBO(MAXATM),YDNBO(MAXATM),
     +       ZDNBO(MAXATM),XDDEL(MAXATM),YDDEL(MAXATM),ZDDEL(MAXATM)
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORB(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBTHR/THRSET,PRJSET,ACCTHR,CRTSET,E2THR,ATHR,PTHR,ETHR,
     +             DTHR,DLTHR,CHSTHR,REFTHR,STTHR,PRTHR,THRNCS,THRNJC
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBMOL/NMOLEC,MOLAT(MAXATM),MOLEC(MAXATM,MAXATM),
     +              NMOLA,MOLATA(MAXATM),MOLECA(MAXATM,MAXATM)
C
      DIMENSION DM(NDIM,NDIM),T(NDIM,NDIM),C(NDIM,NDIM),TNBO(NDIM,NDIM),
     +         DX(NDIM,NDIM),DY(NDIM,NDIM),DZ(NDIM,NDIM),SCR(NDIM*NDIM),
     +         INDEX(NDIM),LISTA(NATOMS,2)
      DIMENSION ISTR(80),JSTR(80),COUPLE(3)
C
      SAVE TENTEN,SMALL,ZERO,TENTH,ONE,TWO,TOESU,IHYPH,IBLNK
      DATA TENTEN,SMALL,ZERO,TENTH,ONE,TWO/1.0D-10,1.0D-5,0.0D0,0.1D0,
     +                                     1.0D0,2.0D0/
      DATA TOESU/4.803242D-10/
      DATA IHYPH,IBLNK/1H-,1H /
C
      DEBYE = TOESU / TENTEN
C
C  Copy the nuclear charges into CHARGE and initialize fragment dipole
C  moments:
C
      IF(ALPHA.OR..NOT.OPEN) THEN
        DO 10 I = 1,NATOMS
          CHARGE(I) = IZNUC(I)
   10   CONTINUE
        DO 15 I = 1,NMOLEC
          XDNLMO(I) = ZERO
          YDNLMO(I) = ZERO
          ZDNLMO(I) = ZERO
          XDNBO(I)  = ZERO
          YDNBO(I)  = ZERO
          ZDNBO(I)  = ZERO
          XDDEL(I)  = ZERO
          YDDEL(I)  = ZERO
          ZDDEL(I)  = ZERO
   15   CONTINUE
      END IF
C
C  Determine the number of occupied orbitals and make sure that the
C  occupied NLMOs are at the beginning of the list:
C
      TOT = ZERO
      DO 20 I = 1,NNAO
        TOT = TOT + DM(I,I)
        SCR(I) = DM(I,I)
   20 CONTINUE
      NEL = INT(TOT + TENTH)
      TOT = DFLOAT(NEL)
      NOCC = NEL
      IF(.NOT.OPEN) NOCC = NOCC/2 + MOD(NOCC,2)
C
      CALL RANK(SCR,NNAO,NDIM,INDEX)
      DO 30 I = 1,NOCC
        IF(INDEX(I).GT.NOCC) THEN
          WRITE(LFNPR,1000)
          RETURN
        END IF
   30 CONTINUE
C
C  Determine the occupancy factor:
C
      ETA = TWO
      IF(OPEN) ETA = ONE
C
C  Compute the electronic contributions to the NBO bond dipole moments:
C
      CALL FETLMO(C)
      CALL FETNBO(TNBO)
      II = 1
      CALL DIPELE(DX,C,TNBO,SCR,ETA,NOCC,II)
      IF(II.EQ.0) RETURN
      II = 2
      CALL DIPELE(DY,C,TNBO,SCR,ETA,NOCC,II)
      IF(II.EQ.0) RETURN
      II = 3
      CALL DIPELE(DZ,C,TNBO,SCR,ETA,NOCC,II)
      IF(II.EQ.0) RETURN
C
C  Add the nuclear contributions to these bond dipole moments:
C
      CALL DIPNUC(DX,DY,DZ,SCR,ETA,NOCC)
C
C  Convert to Debye:
C
      DO 50 I = 1,NOCC
        DO 40 J = 1,NNAO
          DX(J,I) = DX(J,I) * DEBYE
          DY(J,I) = DY(J,I) * DEBYE
          DZ(J,I) = DZ(J,I) * DEBYE
   40   CONTINUE
   50 CONTINUE
C
C  Print dipole analysis:
C
      XNBO  = ZERO
      YNBO  = ZERO
      ZNBO  = ZERO
      XNLMO = ZERO
      YNLMO = ZERO
      ZNLMO = ZERO
      DO 100 I = 1,NOCC
        IF(I.EQ.1) THEN
          IF(ALPHA) WRITE(LFNPR,1010)
          IF(BETA)  WRITE(LFNPR,1020)
          IF(.NOT.OPEN) WRITE(LFNPR,1030)
          WRITE(LFNPR,1040) ABS(DTHR)
        ELSE
          WRITE(LFNPR,1050)
        END IF
C
C  Build the label for this NBO/NLMO:
C
        IB = IBXM(I)
        ISTR(1) = LABEL(IB,1)
        ISTR(2) = LABEL(IB,2)
        ISTR(3) = LABEL(IB,3)
        DO 70 J = 1,3
          J4 = 4 * J
          IF(LABEL(IB,J+3).EQ.0) THEN
            DO 60 K = J4-1,J4+2
              ISTR(K) = IBLNK
   60       CONTINUE
          ELSE
            IF(J.NE.1) ISTR(J4-1) = IHYPH
            ISTR(J4)   = NAMEAT(IATNO(LABEL(IB,J+3)))
            CALL CONVRT2N(LABEL(IB,J+3),ISTR(J4+1),ISTR(J4+2))
          END IF
   70   CONTINUE
C
C  Compute the NLMO bond dipole (the NBO bond dipoles are on the diagonal
C  of DX,DY,DZ):
C
        X = ZERO
        Y = ZERO
        Z = ZERO
        DO 80 J = 1,NNAO
          X = X + DX(J,I)
          Y = Y + DY(J,I)
          Z = Z + DZ(J,I)
   80   CONTINUE
C
        XNBO  = XNBO  + DX(I,I)
        YNBO  = YNBO  + DY(I,I)
        ZNBO  = ZNBO  + DZ(I,I)
        XNLMO = XNLMO + X
        YNLMO = YNLMO + Y
        ZNLMO = ZNLMO + Z
        IFRG = NBOUNI(I)
        XDNBO(IFRG)  = XDNBO(IFRG)  + DX(I,I)
        YDNBO(IFRG)  = YDNBO(IFRG)  + DY(I,I)
        ZDNBO(IFRG)  = ZDNBO(IFRG)  + DZ(I,I)
        XDNLMO(IFRG) = XDNLMO(IFRG) + X
        YDNLMO(IFRG) = YDNLMO(IFRG) + Y
        ZDNLMO(IFRG) = ZDNLMO(IFRG) + Z
        XDDEL(IFRG)  = XDDEL(IFRG)  + X - DX(I,I)
        YDDEL(IFRG)  = YDDEL(IFRG)  + Y - DY(I,I)
        ZDDEL(IFRG)  = ZDDEL(IFRG)  + Z - DZ(I,I)
C
C  Compute the net dipole for these orbitals:
C
        TOT = SQRT(DX(I,I)*DX(I,I) + DY(I,I)*DY(I,I) + DZ(I,I)*DZ(I,I))
        TOTNLM = SQRT(X*X + Y*Y + Z*Z)
C
        WRITE(LFNPR,1060) I,(ISTR(J),J=1,14),X,Y,Z,TOTNLM,
     +                    DX(I,I),DY(I,I),DZ(I,I),TOT
C
C  Print delocalization terms which are stronger than ABS(DTHR):
C
        ICNT = 0
        DO 90 J = 1,NNAO
          IF(J.NE.I) THEN
            TOT = SQRT(DX(J,I)*DX(J,I) + DY(J,I)*DY(J,I)
     +                                  + DZ(J,I)*DZ(J,I))
            IF(TOT.GT.ABS(DTHR)) THEN
              ICNT = ICNT + 1
              INDEX(ICNT) = J
              SCR(ICNT) = TOT
            END IF
          END IF
   90   CONTINUE
C
        DO 95 J = 1,ICNT
          DO 94 K = 1,ICNT-J
            IF(SCR(K+1)-SCR(K).GT.SMALL) THEN
              ITEMP      = INDEX(K)
              INDEX(K)   = INDEX(K+1)
              INDEX(K+1) = ITEMP
              TEMP       = SCR(K)
              SCR(K)     = SCR(K+1)
              SCR(K+1)   = TEMP
            END IF
   94     CONTINUE
   95   CONTINUE
C
        DO 96 JJ = 1,ICNT
          J = INDEX(JJ)
          WRITE(LFNPR,1070) J,DX(J,I),DY(J,I),DZ(J,I),SCR(JJ)
   96   CONTINUE
  100 CONTINUE
C
C  Compute and print the correction for residual nuclear charges:
C
      IF(.NOT.ALPHA) THEN
        CALL FECOOR(SCR)
        X = ZERO
        Y = ZERO
        Z = ZERO
        RESID = .FALSE.
        DO 110 I = 1,NATOMS
          IF(ABS(CHARGE(I)).GT.SMALL) RESID = .TRUE.
          X = X + SCR(3*I-2) * CHARGE(I) * DEBYE
          Y = Y + SCR(3*I-1) * CHARGE(I) * DEBYE
          Z = Z + SCR(3*I)   * CHARGE(I) * DEBYE
  110   CONTINUE
        IF(RESID) THEN
          TOT = SQRT(X*X + Y*Y + Z*Z)
          WRITE(LFNPR,1080) X,Y,Z,TOT,X,Y,Z,TOT
          XNBO  = XNBO  + X
          YNBO  = YNBO  + Y
          ZNBO  = ZNBO  + Z
          XNLMO = XNLMO + X
          YNLMO = YNLMO + Y
          ZNLMO = ZNLMO + Z
          XRES  = X
          YRES  = Y
          ZRES  = Z
        END IF
      END IF
C
C  Print net dipole moments:
C
      TOT = SQRT(XNBO*XNBO + YNBO*YNBO + ZNBO*ZNBO)
      TOTNLM = SQRT(XNLMO*XNLMO + YNLMO*YNLMO + ZNLMO*ZNLMO)
      WRITE(LFNPR,1090) XNLMO,YNLMO,ZNLMO,TOTNLM,XNBO,YNBO,ZNBO,TOT
C
C  Compute and print the total delocalization correction:
C
      X = XNLMO - XNBO
      Y = YNLMO - YNBO
      Z = ZNLMO - ZNBO
      TOT = SQRT(X*X + Y*Y + Z*Z)
      WRITE(LFNPR,1100) X,Y,Z,TOT
C
C  Compute and print the NLMO coupling correction:
C
      TEST = .FALSE.
      DO 130 I = 1,NNAO
        IF(I.GT.NOCC.AND.ABS(DM(I,I)).GT.SMALL) TEST = .TRUE.
        DO 120 J = I+1,NNAO
          IF(ABS(DM(J,I)).GT.SMALL) TEST = .TRUE.
  120   CONTINUE
  130 CONTINUE
      IF(TEST) THEN
        TOT = ZERO
        DO 160 K = 1,3
          II = K
          CALL FEDXYZ(DX,II)
          CALL SIMTR1(DX,T,SCR,NDIM,NBAS,NBAS,NNAO)
          COUPLE(K) = ZERO
          DO 150 I = 1,NNAO
            IF(I.LE.NOCC) THEN
              COUPLE(K) = COUPLE(K) + (ETA - DM(I,I)) * DX(I,I)
            ELSE
              COUPLE(K) = COUPLE(K) - DM(I,I) * DX(I,I)
            END IF
            DO 140 J = I+1,NNAO
              COUPLE(K) = COUPLE(K) - TWO * DM(J,I) * DX(J,I)
  140       CONTINUE
  150     CONTINUE
          COUPLE(K) = COUPLE(K) * DEBYE
          TOT = TOT + COUPLE(K) * COUPLE(K)
  160   CONTINUE
        TOT = SQRT(TOT)
        WRITE(LFNPR,1110) XNLMO,YNLMO,ZNLMO,TOTNLM,XNLMO,YNLMO,ZNLMO,
     +                    TOTNLM,(COUPLE(K),K=1,3),TOT
        XNLMO = XNLMO + COUPLE(1)
        YNLMO = YNLMO + COUPLE(2)
        ZNLMO = ZNLMO + COUPLE(3)
        TOTNLM = SQRT(XNLMO*XNLMO + YNLMO*YNLMO + ZNLMO*ZNLMO)
        IF(ALPHA) WRITE(LFNPR,1120) XNLMO,YNLMO,ZNLMO,TOTNLM
        IF(BETA)  WRITE(LFNPR,1130) XNLMO,YNLMO,ZNLMO,TOTNLM
        IF(.NOT.OPEN) WRITE(LFNPR,1140) XNLMO,YNLMO,ZNLMO,TOTNLM
      ELSE
        IF(ALPHA) WRITE(LFNPR,1120) XNLMO,YNLMO,ZNLMO,TOTNLM,
     +                              XNLMO,YNLMO,ZNLMO,TOTNLM
        IF(BETA)  WRITE(LFNPR,1130) XNLMO,YNLMO,ZNLMO,TOTNLM,
     +                              XNLMO,YNLMO,ZNLMO,TOTNLM
        IF(.NOT.OPEN) WRITE(LFNPR,1140) XNLMO,YNLMO,ZNLMO,TOTNLM,
     +                                  XNLMO,YNLMO,ZNLMO,TOTNLM
      END IF
C
C  Save the alpha spin dipoles:
C
      IF(ALPHA) THEN
        XDIP = XNLMO
        YDIP = YNLMO
        ZDIP = ZNLMO
      END IF
C
C  Print out the total dipole moment for open shell species:
C
      IF(BETA) THEN
        XNLMO  = XNLMO + XDIP
        YNLMO  = YNLMO + YDIP
        ZNLMO  = ZNLMO + ZDIP
        TOTNLM = SQRT(XNLMO*XNLMO + YNLMO*YNLMO + ZNLMO*ZNLMO)
        WRITE(LFNPR,1140) XNLMO,YNLMO,ZNLMO,TOTNLM
      END IF
C
C  Print fragment analysis:
C
      IF(.NOT.ALPHA.AND.NMOLEC.GT.1) THEN
        WRITE(LFNPR,1150)
        X = ZERO
        Y = ZERO
        Z = ZERO
        DO 210 IMOL = 1,NMOLEC
          IF(IMOL.NE.1) WRITE(LFNPR,1050)
          NAT  = 0
          DO 180 IAT = 1,MOLAT(IMOL)
            KAT = IATNO(MOLEC(IMOL,IAT))
            DO 170 JAT = 1,NAT
              IF(LISTA(JAT,1).EQ.KAT) THEN
                LISTA(JAT,2) = LISTA(JAT,2) + 1
                GO TO 180
              END IF
  170       CONTINUE
            NAT = NAT + 1
            LISTA(NAT,1) = KAT
            LISTA(NAT,2) = 1
  180     CONTINUE
          CALL CHEM(NAT,NATOMS,LISTA,NL,ISTR)
          DO 190 I = 1,NL-2
            JSTR(I) = ISTR(I+1)
  190     CONTINUE
          DO 200 I = NL-1,80
            JSTR(I) = IBLNK
  200     CONTINUE
          X = X + XDNLMO(IMOL)
          Y = Y + YDNLMO(IMOL)
          Z = Z + ZDNLMO(IMOL)
          TOTNLM = SQRT(XDNLMO(IMOL)*XDNLMO(IMOL)
     +                + YDNLMO(IMOL)*YDNLMO(IMOL)
     +                + ZDNLMO(IMOL)*ZDNLMO(IMOL))
          TOTNBO = SQRT(XDNBO(IMOL) *XDNBO(IMOL)
     +                + YDNBO(IMOL) *YDNBO(IMOL)
     +                + ZDNBO(IMOL) *ZDNBO(IMOL))
          TOTDEL = SQRT(XDDEL(IMOL) *XDDEL(IMOL)
     +                + YDDEL(IMOL) *YDDEL(IMOL)
     +                + ZDDEL(IMOL) *ZDDEL(IMOL))
          WRITE(LFNPR,1160) IMOL,(JSTR(K),K=1,20),
     +                XDNLMO(IMOL),YDNLMO(IMOL),ZDNLMO(IMOL),TOTNLM,
     +                XDNBO(IMOL),YDNBO(IMOL),ZDNBO(IMOL),TOTNBO
          IF(TOTDEL.GT.ABS(DTHR)) WRITE(LFNPR,1170)
     +                XDDEL(IMOL),YDDEL(IMOL),ZDDEL(IMOL),TOTDEL
  210   CONTINUE
        IF(RESID) THEN
          TOTRES = SQRT(XRES*XRES + YRES*YRES + ZRES*ZRES)
          WRITE(LFNPR,1080) XRES,YRES,ZRES,TOTRES,XRES,YRES,ZRES,TOTRES
          X = X + XRES
          Y = Y + YRES
          Z = Z + ZRES
        END IF
        IF(TEST) THEN
          XT = XNLMO - X
          YT = YNLMO - Y
          ZT = ZNLMO - Z
          TOT = SQRT(XT*XT + YT*YT + ZT*ZT)
          WRITE(LFNPR,1180) XT,YT,ZT,TOT,XT,YT,ZT,TOT
        END IF
        TOT = SQRT(XNLMO*XNLMO + YNLMO*YNLMO + ZNLMO*ZNLMO)
        WRITE(LFNPR,1190) XNLMO,YNLMO,ZNLMO,TOT,XNLMO,YNLMO,ZNLMO,TOT
      END IF
      RETURN
C
 1000 FORMAT(/1X,'The highest occupied NBOs are not at the beginning ',
     + 'of the list.',/1X,'The dipole moment analysis is currently not',
     + ' set up to handle this.')
 1010 FORMAT(//1X,'DIPOLE MOMENT ANALYSIS, alpha spin:')
 1020 FORMAT(//1X,'DIPOLE MOMENT ANALYSIS, beta spin:')
 1030 FORMAT(//1X,'DIPOLE MOMENT ANALYSIS:')
 1040 FORMAT(/1X,'[Print threshold: Net dipole >',F5.3,' Debye]',//1X,
     + '                                NLMO bond dipole            ',
     + 'NBO bond dipole',/1X,'                            ----------',
     + '---------------  ------------------------',/1X,'         ',
     + 'Orbital              x     y     z   Total      x     y     ',
     + 'z   Total',/1X,79('='))
 1050 FORMAT(1X)
 1060 FORMAT(1X,I3,'. ',A2,A1,'(',I2,')',A2,3A1,A2,3A1,A2,2A1,1X,4F6.3,
     + 3X,4F6.3)
 1070 FORMAT(1X,44X,'deloc ',I3,':',4F6.3)
 1080 FORMAT(/1X,'  Residual nuclear charge  ',4F6.3,'   ',4F6.3)
 1090 FORMAT(1X,'                           -----------------------',
     + '-----------------------------',/1X,'        Net dipole moment',
     + '  ',4F6.3,'   ',4F6.3)
 1100 FORMAT(1X,'Delocalization correction  ',24X,'   ',4F6.3,/1X,
     + '                           -----------------------------',
     + '-----------------------')
 1110 FORMAT(1X,'        Net dipole moment  ',4F6.3,'   ',4F6.3,/1X,
     + ' NLMO coupling correction  ',4F6.3,/1X,'                  ',
     + '         -------------------------')
 1120 FORMAT(1X,'        Alpha spin dipole  ',4F6.3,'   ',4F6.3)
 1130 FORMAT(1X,'         Beta spin dipole  ',4F6.3,'   ',4F6.3)
 1140 FORMAT(1X,'      Total dipole moment  ',4F6.3,'   ',4F6.3)
 1150 FORMAT(//1X,'Dipole moment analysis by molecular fragment:',//1X,
     + '                              NLMO fragment dipole        ',
     + 'NBO fragment dipole',/1X,'                            ----',
     + '---------------------  ------------------------',/1X,'    ',
     + '  Molecular fragment      x     y     z   Total      x    ',
     + ' y     z   Total',/1X,79('='))
 1160 FORMAT(1X,I3,'. ',20A1,'  ',4F6.3,'   ',4F6.3)
 1170 FORMAT(1X,44X,'    deloc:',4F6.3)
 1180 FORMAT(/1X,' NLMO coupling correction  ',4F6.3,'   ',4F6.3)
 1190 FORMAT(1X,'                           -----------------------',
     + '-----------------------------',/1X,'      Total dipole moment',
     + '  ',4F6.3,'   ',4F6.3)
      END
C***********************************************************************
      SUBROUTINE DIPELE(DXYZ,C,T,SCR,ETA,NOCC,INDEX)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION DXYZ(NDIM,NDIM),C(NDIM,NDIM),T(NDIM,NDIM),SCR(NDIM,NDIM)
C
C
C  Compute the electronic contribution for the x (INDEX=1), y (=2),
C  and z (=3) components of the dipole:
C
C  Get the AO dipole matrix and transform to the NBO basis:
C
      CALL FEDXYZ(DXYZ,INDEX)
      IF(INDEX.EQ.0) RETURN
      CALL SIMTR1(DXYZ,T,SCR,NDIM,NBAS,NBAS,NNAO)
C
C  Compute the electronic contribution for doubly occupied, filled NBOs:
C
      DO 30 I = 1,NOCC
        SCR(I,I) = -ETA * DXYZ(I,I)
   30 CONTINUE
C
C  Compute delocalization contributions for each filled NBO:
C
      DO 60 I = 1,NOCC
        DO 50 J = 1,NNAO
          IF(J.NE.I) THEN
            SCR(J,I) = C(J,I) * DXYZ(I,I) - C(I,I) * DXYZ(J,I)
            DO 40 K = 1,NNAO
                SCR(J,I) = SCR(J,I) - C(K,I) * DXYZ(K,J)
   40       CONTINUE
            SCR(J,I) = ETA * C(J,I) * SCR(J,I)
          END IF
   50   CONTINUE
   60 CONTINUE
      CALL COPY(SCR,DXYZ,NDIM,NNAO,NNAO)
      RETURN
      END
C***********************************************************************
      SUBROUTINE DIPNUC(DX,DY,DZ,ATCOOR,ETA,NOCC)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBDXYZ/XDIP,YDIP,ZDIP,CHARGE(MAXATM),XDNLMO(MAXATM),
     +       YDNLMO(MAXATM),ZDNLMO(MAXATM),XDNBO(MAXATM),YDNBO(MAXATM),
     +       ZDNBO(MAXATM),XDDEL(MAXATM),YDDEL(MAXATM),ZDDEL(MAXATM)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      DIMENSION DX(NDIM,NDIM),DY(NDIM,NDIM),DZ(NDIM,NDIM),
     +          ATCOOR(3,NATOMS)
C
      SAVE ZERO
      DATA ZERO/0.0D0/
C
C  Fetch the atomic coordinates:
C
      CALL FECOOR(ATCOOR)
C
C  Calculate the nuclear contributions to the dipole moment:
C
      DO 20 I = 1,NOCC
        NCTR = MOD(NBOTYP(I),10)
        X = ZERO
        Y = ZERO
        Z = ZERO
        DO 10 J = 1,NCTR
          IAT = LABEL(IBXM(I),J+3)
          X   = X + ATCOOR(1,IAT)
          Y   = Y + ATCOOR(2,IAT)
          Z   = Z + ATCOOR(3,IAT)
          CHARGE(IAT) = CHARGE(IAT) - ETA/NCTR
   10   CONTINUE
        X = ETA * X / NCTR
        Y = ETA * Y / NCTR
        Z = ETA * Z / NCTR
        DX(I,I) = DX(I,I) + X
        DY(I,I) = DY(I,I) + Y
        DZ(I,I) = DZ(I,I) + Z
   20 CONTINUE
      RETURN
      END
C***********************************************************************
C***********************************************************************
C NBO 5.G -- Natural Bond Orbital Analysis Programs
C (c) Copyright 1996-2008 Board of Regents of the University of Wisconsin System
C     on behalf of the Theoretical Chemistry Institute.  All Rights Reserved.
C***********************************************************************
C
C  ROUTINES CALLED BY SR NATHYB, SR NBCHSE:
C
C      SUBROUTINE NBCORE(DM,T,BORB,POL,Q,HYB,BNDOCC,IBD,DETAIL,LFNPR)
C      FUNCTION IWPRJ(NCTR)
C      SUBROUTINE DEPLET(DM,T,Q,POL,BORB,BNDOCC,NBD)
C      SUBROUTINE LOAD(DM,IAT1,IAT2,IAT3,BLK,NB)
C      SUBROUTINE PRJEXP(BORB,IAT1,IAT2,IAT3,Q,P,PK,HYB,VA,VB,HYBEXP)
C      SUBROUTINE STASH(BORB,IBD,IAT1,IAT2,IAT3,POL,Q,HYB)
C      SUBROUTINE ORTHYB(Q,S,TA,EVAL,C,IALARM,IFLG)
C      SUBROUTINE NBFPRJ(P,IA,Q,NK,PK,VK,PI)
C      SUBROUTINE AUGMNT(P,BLK,C,EVAL,DM,TA,BORB,V,LARC,IA,NOCC,NORB)
C      SUBROUTINE REPOL(DM,Q,POL,BLK,EVAL,C,NBD)
C      SUBROUTINE FORMT(T,Q,POL)
C      SUBROUTINE CYCLES(ITER,THRESH,GUIDE,BNDOCC,TOPO,ICONT)
C
C***********************************************************************
      SUBROUTINE NBCORE(DM,T,BORB,POL,Q,HYB,BNDOCC,IBD,DETAIL,LFNPR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  Label core, valence, and Rydberg NAO's and deplete DM of the density
C  of the core orbitals
C
      LOGICAL DETAIL,FIRST
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBNAO/NAOCTR(MAXBAS),NAOL(MAXBAS),LTYP(MAXBAS),
     +       IPRIN(MAXBAS)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),ILL(MAXATM),
     +       IUL(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
C
      DIMENSION DM(NDIM,NDIM),T(NDIM,NDIM),BORB(MXBO),POL(NDIM,3),
     *  Q(MXAO,NDIM),HYB(MXAO),BNDOCC(NDIM),ICORE(4),IVAL(4),IANG(5)
C
      SAVE ZERO,ONE,IBLK,ICOR,IRYD,ICHCOR,ICHVAL,IANG
C
      DATA ZERO,ONE/0.0D0,1.0D0/
      DATA IBLK,ICOR,IRYD/2H  ,2HCR,3HRyd/
      DATA ICHCOR,ICHVAL/3HCor,3HVal/
      DATA IANG/1Hs,1Hp,1Hd,1Hf,1Hg/
C
C  Label NAO's on each center:
C
      DO 10 I = 1,NNAO
        LTYP(I) = IRYD
   10 CONTINUE
      IECP = 0
      DO 110 NCTR = 1,NATOMS
        CALL CORTBL(NCTR,ICORE,IECP)
        CALL VALTBL(NCTR,IVAL,0)
C
C  Loop over s,p,d,f orbitals:
C
        DO 100 L = 0,3
          ITYP = IANG(L+1)
          LNUM = 2*L + 1
          IF(ICORE(L+1).LE.0) GOTO 50
C
C  Label core orbitals:
C
          DO 40 M = 1,ICORE(L+1)
            DO 30 LA = 1,LNUM
              MORB = 0
              OCC = -1.0D0
              DO 20 N = 1,NNAO
                LM = NAOL(N)
                NORB = LM/100
                IL = IANG(NORB+1)
                NA = MOD(NAOL(N),50)
                IF(NAOCTR(N).EQ.NCTR.AND.IL.EQ.ITYP.AND.
     +            DM(N,N).GT.OCC.AND.LTYP(N).EQ.IRYD.AND.
     +                                         LA.EQ.NA) THEN
                      MORB = N
                      OCC = DM(N,N)
                END IF
   20         CONTINUE
              IF(MORB.EQ.0) THEN
                WRITE(LFNPR,2500) ITYP,NAMEAT(IATNO(NCTR)),NCTR,
     +                            (ICORE(I),I=1,4),M,LA
                CALL NBHALT('SR CORE could not find core orbital.')
              END IF
              LTYP(MORB) = ICHCOR
   30       CONTINUE
   40     CONTINUE
   50     CONTINUE
          IF(IVAL(L+1).LE.0) GOTO 90
C
C  Label valence orbitals:
C
          DO 80 M = 1,IVAL(L+1)
            DO 70 LA = 1,LNUM
              MORB = 0
              OCC = -1.0D0
              DO 60 N = 1,NNAO
                LM = NAOL(N)
                NORB = LM/100
                IL = IANG(NORB+1)
                NA = MOD(NAOL(N),50)
                IF(NAOCTR(N).EQ.NCTR.AND.IL.EQ.ITYP.AND.
     +            DM(N,N).GT.OCC.AND.LTYP(N).EQ.IRYD.AND.
     +                                         LA.EQ.NA) THEN
                      MORB = N
                      OCC = DM(N,N)
                END IF
   60         CONTINUE
              IF(MORB.EQ.0) THEN
                WRITE(LFNPR,2600) ITYP,NAMEAT(IATNO(NCTR)),NCTR,
     +                            (IVAL(I),I=1,4),M,LA
                CALL NBHALT('SR CORE could not find valence orbital.')
              END IF
              LTYP(MORB) = ICHVAL
   70       CONTINUE
   80     CONTINUE
   90     CONTINUE
  100   CONTINUE
  110 CONTINUE
C
C  Isolate core orbitals on all atoms, removing their density from the
C  density matrix:
C
      DO 300 IAT = 1,NATOMS
        NB = IUL(IAT) - ILL(IAT) + 1
        IAC = 0
        FIRST = .TRUE.
        DO 290 N = ILL(IAT),IUL(IAT)
          IF(LTYP(N).EQ.ICHCOR) THEN
            IF(DETAIL.AND.FIRST) THEN
              FIRST = .FALSE.
              WRITE(LFNPR,1000) IAT
            END IF
            IAC = IAC + 1
            IBD = IBD + 1
            DO 280 I = 1,NB
              BORB(I) = ZERO
  280       CONTINUE
            BORB(N-ILL(IAT)+1) = ONE
            CALL STASH(BORB,IBD,IAT,0,0,POL,Q,HYB)
            LABEL(IBD,1) = ICOR
            LABEL(IBD,2) = IBLK
            LABEL(IBD,3) = IAC
            LABEL(IBD,4) = IAT
            BNDOCC(IBD)  = DM(N,N)
            IF(DETAIL) WRITE(LFNPR,1010) IAC,BNDOCC(IBD)
            IF(DETAIL) WRITE(LFNPR,1020) (BORB(I),I=1,NB)
            IF(DETAIL) WRITE(LFNPR,1030) IBD,(LABEL(IBD,I),I=1,3)
          END IF
  290   CONTINUE
  300 CONTINUE
C
C  Deplete the density matrix of CR orbitals:
C
      CALL DEPLET(DM,T,Q,POL,BORB,BNDOCC,IBD)
      RETURN
C
 1000 FORMAT(/,1X,'Search of DM block for core orbitals on atom:',I4)
 1010 FORMAT(6X,'Eigenvector (',I2,') has occupancy ',F9.6,':')
 1020 FORMAT(11X,8F7.4)
 1030 FORMAT(11X,'*** NBO accepted: Number',I3,'.   Label:',A2,A1,
     + '(',I2,')')
 2500 FORMAT(/1X,'Subroutine CORE could not find a ',A1,'-type ',
     + 'core orbital on atom ',A2,I2,'.',/,1X,'ICORE :',4I3,
     + '     M :',I3,'     LA :',I3)
 2600 FORMAT(/1X,'Subroutine CORE could not find a ',A1,'-type ',
     + 'valence orbital on atom ',A2,I2,'.',/,1X,'IVAL :',4I3,
     + '     M :',I3,'     LA :',I3)
      END
C***********************************************************************
      FUNCTION IWPRJ(NCTR)
C***********************************************************************
      SAVE NCTR0
      DATA NCTR0/0/
C
C  RETURN 0 (NO PROJECTION WANTED) IF NCTR IS UNCHANGED, 1 OTHERWISE.
C
      IWPRJ = 0
      IF(NCTR.EQ.NCTR0) RETURN
       IWPRJ = 1
       NCTR0 = NCTR
       RETURN
      END
C***********************************************************************
      SUBROUTINE DEPLET(DM,T,Q,POL,BORB,BNDOCC,NBD)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  DEPLETE DENSITY MATRIX DM OF CONTRIBUTION FROM B.O.'BORB':
C     DM ==> DM - OCC*BORB*BORB(TRANSPOSE).
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),ILL(MAXATM),
     +       IUL(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
C
      DIMENSION DM(NDIM,NDIM),T(NDIM,NDIM),Q(MXAO,NDIM),POL(NDIM,3),
     +  BORB(MXBO),BNDOCC(NDIM)
      DIMENSION IAT(3)
C
C  RESTORE DM FROM T:
C
      DO 20 J = 1,NNAO
        DO 10 I = 1,J
          DM(I,J) = T(I,J)
          DM(J,I) = DM(I,J)
   10   CONTINUE
   20 CONTINUE
C
C  MAIN LOOP OVER NBD AVAILABLE BOND ORBITALS:
C
      DO 110 IBD = 1,NBD
        OCC = BNDOCC(IBD)
C
C  FIND ATOMS FOR B.O. IBD:
C
        NCTR = 0
        DO 30 J = 1,3
          IAT(J) = LABEL(IBD,J+3)
          IF(IAT(J).LE.0) GO TO 40
          NCTR = NCTR + 1
   30   CONTINUE
C
C  RECONSTRUCT BORB FOR B.O. IBD:
C
   40   NELM = 0
        DO 60 ICTR = 1,NCTR
          IA = IAT(ICTR)
          IHYB = IATHY(IBD,ICTR) + ILL(IA) - 1
          P = POL(IBD,ICTR)
          NH = NORBS(IA)
          DO 50 IH = 1,NH
            NELM = NELM + 1
            BORB(NELM) = P * Q(IH,IHYB)
   50     CONTINUE
   60   CONTINUE
C
C  SUBTRACT OCC*BORB*BORB(T) FROM DM:
C
        NROW = 0
        DO 100 ICTR = 1,NCTR
          IA = IAT(ICTR)
          IU = IUL(IA)
          IL = ILL(IA)
          DO 90 IROW = IL,IU
            NROW = NROW + 1
            NCOL = 0
            DO 80 JCTR = 1,NCTR
              JA = IAT(JCTR)
              JU = IUL(JA)
              JL = ILL(JA)
              DO 70 ICOL = JL,JU
                NCOL = NCOL + 1
                DM(IROW,ICOL) = DM(IROW,ICOL)-OCC*BORB(NROW)*BORB(NCOL)
   70         CONTINUE
   80       CONTINUE
   90     CONTINUE
  100   CONTINUE
  110 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE LOAD(DM,IAT1,IAT2,IAT3,BLK,NB)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  ZERO THE MATRIX 'BLK' AND LOAD IN ATOMIC BLOCKS OF DENSITY
C  MATRIX 'DM' FOR THE ATOMS LISTED IN 'IAT'
C
      PARAMETER(MAXATM = 200)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),ILL(MAXATM),
     +       IUL(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
C
      DIMENSION BLK(MXBO,MXBO),DM(NDIM,NDIM),IAT(3)
C
      SAVE ZERO
      DATA ZERO/0.0D0/
C
      IAT(1) = IAT1
      IAT(2) = IAT2
      IAT(3) = IAT3
C
C  ZERO 'BLK':
C
      DO 10 J = 1,MXBO
        DO 5 I = 1,MXBO
          BLK(I,J) = ZERO
    5   CONTINUE
   10 CONTINUE
      NROW = 0
      NCOL = 0
      DO 50 I = 1,3
        IA = IAT(I)
        IF(IA.EQ.0) GO TO 50
        IU = IUL(IA)
        IL = ILL(IA)
        DO 40 IROW = IL,IU
          NROW = NROW + 1
          NCOL = 0
          DO 30 J = 1,3
            JA = IAT(J)
            IF(JA.EQ.0) GO TO 30
            JU = IUL(JA)
            JL = ILL(JA)
            DO 20 ICOL = JL,JU
              NCOL = NCOL + 1
              BLK(NROW,NCOL) = DM(IROW,ICOL)
   20       CONTINUE
   30     CONTINUE
   40   CONTINUE
   50 CONTINUE
      NB = NROW
      RETURN
      END
C***********************************************************************
      SUBROUTINE PRJEXP(BORB,IAT1,IAT2,IAT3,Q,P,PK,HYB,VA,VB,HYBEXP)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  DETERMINE HOW MUCH OF BORB IS COMPOSED OF PREVIOUSLY USED HYBRIDS.
C
C  RETURN HYBEXP(I) = EXPECTATION VALUE OF HYBRID "I" IN BORB OVER THE
C                     PROJECTION OPERATOR P FOR THE ATOM OF THE HYBRID.
C
C  IF NO HYBRID ON ATOM I CONTRIBUTES TO BORB, HYBEXP(I) = ZERO.
C
      PARAMETER(MAXATM = 200)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),ILL(MAXATM),
     +       IUL(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
C
      DIMENSION IAT(3),HYB(MXAO),BORB(MXBO),Q(MXAO,NDIM),P(MXAO,MXAO),
     *  PK(MXAO,MXAO),VA(MXAO),VB(MXAO),HYBEXP(3)
C
      SAVE ZERO,ONE,EPS
      DATA ZERO,ONE,EPS/0.0D0,1.0D0,1.0D-5/
C
C  LOOP OVER ATOMIC HYBRIDS:
C
      IAT(1) = IAT1
      IAT(2) = IAT2
      IAT(3) = IAT3
      KMAX   = 0
      DO 50 I = 1,3
        HYBEXP(I) = ZERO
        IA = IAT(I)
        IF(IA.EQ.0) GO TO 50
C
C  EXTRACT THE ITH ATOMIC HYBRID FROM BORB:
C
        NU = IUL(IA)
        NL = ILL(IA)
        KMIN = KMAX + 1
        KMAX = KMAX + NU - NL + 1
        MJ = 0
        DO 10 K = KMIN,KMAX
          MJ = MJ + 1
          HYB(MJ) = BORB(K)
   10   CONTINUE
C
C  DO HYBRIDS FROM THE ITH ATOM CONTRIBUTE TO BORB?
C
        S = ZERO
        DO 20 J = 1,MJ
          S = S + HYB(J)**2
   20   CONTINUE
        IF(S.LT.EPS) GO TO 50
C
C  DETERMINE THE PROJECTION EXPECTATION FOR THIS HYBRID:
C
        NH = INO(IA)
        IF(NH.EQ.0) THEN
          HYBEXP(I) = ONE
        ELSE
          CALL NBFPRJ(P,IA,Q,NH,PK,VA,VB)
          PAV = ZERO
          DO 40 J = 1,MJ
            DO 30 K = 1,MJ
              PAV = PAV + HYB(K) * P(K,J) * HYB(J)
   30       CONTINUE
   40     CONTINUE
          HYBEXP(I) = ABS(PAV) / S
        END IF
   50 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE STASH(BORB,IBD,IAT1,IAT2,IAT3,POL,Q,HYB)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  DECOMPOSE BOND ORBITAL 'BORB' AND STORE CONSTITUENT HYBRIDS IN Q
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),ILL(MAXATM),
     +       IUL(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
C
      DIMENSION POL(NDIM,3),Q(MXAO,NDIM),BORB(MXBO),IAT(3),HYB(MXAO)
C
      SAVE ZERO
      DATA ZERO/0.0D0/
C
C  LOOP OVER CENTERS:
C
      IAT(1) = IAT1
      IAT(2) = IAT2
      IAT(3) = IAT3
      KMAX   = 0
      DO 40 I = 1,3
        IA = IAT(I)
        IF(IA.EQ.0) GO TO 40
        NU = IUL(IA)
        NL = ILL(IA)
C
C  EXTRACT HYBRID FROM BOND ORBITAL FOR ATOM IA:
C
        KMIN = KMAX + 1
        KMAX = KMAX + NU - NL + 1
        MJ = 0
        DO 10 K = KMIN,KMAX
          MJ = MJ + 1
          HYB(MJ) = BORB(K)
   10   CONTINUE
C
C  EXTRACT POLARIZATION COEFFICIENT, STORE IN 'POL':
C
        PSQ = ZERO
        DO 20 J = 1,MJ
          PSQ = PSQ + HYB(J)**2
   20   CONTINUE
        P = SQRT(PSQ)
        POL(IBD,I) = P
C
C  ONE MORE HYBRID FOR ATOM IA:
C
        INO(IA) = INO(IA) + 1
        NCOL = ILL(IA) + INO(IA) - 1
C
C  PLACE NORMALIZED HYBRID IN APPROPRIATE BLOCK OF Q:
C
        NH = NU - NL + 1
        DO 30 NROW = 1,NH
          IF(P.EQ.ZERO) THEN
            Q(NROW,NCOL) = ZERO
          ELSE
            Q(NROW,NCOL) = HYB(NROW)/P
          END IF
   30   CONTINUE
        IATHY(IBD,I) = INO(IA)
   40 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE ORTHYB(Q,S,TA,EVAL,C,IALARM,IFLG)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  SYMMETRIC ORTHOGONALIZATION OF AVAILABLE HYBRIDS IN Q:
C
      PARAMETER(MAXATM = 200)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       ILU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
C
      DIMENSION Q(MXAO,NDIM),S(MXBO,MXBO),TA(MXAO,MXAO),
     *                    EVAL(MXBO),C(MXBO,MXBO)
C
      SAVE ZERO,ONE,TOOSML
      DATA ZERO,ONE/0.0D0,1.0D0/
      DATA TOOSML/1.0D-4/
C
C  TOOSML: "TOO SMALL" -- THRESHOLD FOR AN S MATRIX EIGENVALUE THAT IS TOO
C   SMALL AND WILL CAUSE NUMERICAL PROBLEMS AND IS INDICATIVE OF NEAR-LINEAR
C   DEPENDENCY IN THE HYBRIDS:
C
      IALARM = 0
      DO 100 IA = 1,NATOMS
        IL = LL(IA)
        NH = INO(IA)
        IF(NH.GT.MXAO) GO TO 800
        IF(NH.LE.1) GO TO 100
C
C  LOAD IA-BLOCK OF Q INTO TA:
C
        DO 10 J = 1,NH
          DO 5 I = 1,MXAO
            TA(I,J) = Q(I,IL+J-1)
    5     CONTINUE
   10   CONTINUE
C
C  FORM OVERLAP MATRIX S = TA(TRANSP)*TA:
C
        DO 30 J = 1,NH
          DO 25 I = J,NH
            TEMP = ZERO
            DO 20 K = 1,MXAO
              TEMP = TEMP + TA(K,I) * TA(K,J)
   20       CONTINUE
            S(I,J) = TEMP
            S(J,I) = TEMP
   25     CONTINUE
   30   CONTINUE
C
C  DIAGONALIZE OVERLAP MATRIX:
C
        CALL NBJACOBI(NH,S,EVAL,C,MXBO,MXBO,0)
C
C  FORM INVERSE SQUARE ROOT OF S, STORE IN S: (AVOID NUMERICAL PROBLEMS
C  OF LINEAR DEPENDENCE ("TOO SMALL" EIGENVALUES) BY PRESCREENING THE
C  EIGENVALUES)
C
        DO 40 I = 1,NH
          IF(EVAL(I).LT.TOOSML) GO TO 810
          EVAL(I) = ONE / SQRT(EVAL(I))
   40   CONTINUE
        DO 60 J = 1,NH
          DO 55 I = J,NH
            TEMP = ZERO
            DO 50 K = 1,NH
              TEMP = TEMP + EVAL(K) * C(I,K) * C(J,K)
   50       CONTINUE
            S(I,J) = TEMP
            S(J,I) = TEMP
   55     CONTINUE
   60   CONTINUE
C
C  FORM NEW TAP=TA*S**(-1/2), STORE IN C:
C
        DO 80 J = 1,NH
          DO 75 I = 1,MXAO
            TEMP = ZERO
            DO 70 K = 1,NH
              TEMP = TEMP + TA(I,K) * S(K,J)
   70       CONTINUE
            C(I,J) = TEMP
   75     CONTINUE
   80   CONTINUE
C
C  REPLACE ORTHOGONALIZED TA IN ARRAY Q:
C
        DO 90 J = 1,NH
          DO 85 I = 1,MXAO
            Q(I,IL+J-1) = C(I,J)
   85     CONTINUE
   90   CONTINUE
  100 CONTINUE
C
C  SYMMETRIC ORTHOGONALIZATION COMPLETE:
C
      RETURN
C
C  SOUND THE ALARM THAT TOO MANY HYBRIDS WERE FOUND ON THIS ATOM:
C
  800 CONTINUE
      IALARM = IA
      IF(IFLG.EQ.0) WRITE(LFNPR,900) MXAO,IA,NH
      RETURN
C
C  SOUND THE ALARM THAT THERE ARE TOO MANY HYBRIDS OR THAT THERE IS
C  LINEAR DEPENDENCY IN THE HYBRIDS!!
C
  810 CONTINUE
      IALARM = IA
      IF(IFLG.EQ.0) WRITE(LFNPR,910) IA,EVAL(I),TOOSML
      RETURN
C
  900 FORMAT(/4X,'Only expected to find',I3,' hybrids on atom',I3,
     + ', but found',I3,'.')
  910 FORMAT(/4X,'The hybrids on atom',I3,' are linearly dependent.',
     + '  An eigenvalue (',F10.6,')',/4X,'of the hybrid overlap ',
     + 'matrix is too small (<',F7.5,').')
      END
C***********************************************************************
      SUBROUTINE NBFPRJ(P,IA,Q,NK,PK,VK,PI)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  FORM PROJECTION MATRIX P TO ANNIHILATE COMPONENTS OF NK OCCUPIED
C  HYBRIDS FOR ATOM IA.
C
      PARAMETER(MAXATM = 200)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),ILL(MAXATM),
     +       IUL(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
C
      DIMENSION P(MXAO,MXAO),VK(MXAO),PI(MXAO),Q(MXAO,NDIM),
     *          PK(MXAO,MXAO)
C
      SAVE ZERO,ONE
      DATA ZERO,ONE/0.0D0,1.0D0/
C
C  INITIALIZE P = UNIT MATRIX:
C
      NB = NORBS(IA)
      DO 10 J = 1,NB
        DO 5 I = 1,J
          P(I,J) = ZERO
          P(J,I) = ZERO
          IF(I.EQ.J) P(I,J) = ONE
    5   CONTINUE
   10 CONTINUE
C
C  FORM PROJECTION MATRIX P = P1*P2*...*PK*...*PNK TO ANNIHILATE
C  COMPONENTS OF THE NK OCCUPIED HYBRIDS VK:  PK = I - VK*VK(T).
C  LOOP OVER OCCUPIED HYBRIDS VK, K = 1,...,NK:
C
      IF(NK.LE.0) RETURN
C
C  EXTRACT OCCUPIED HYBRID VK FROM ARRAY Q:
C
      DO 90 K = 1,NK
        ICOL = ILL(IA) + K - 1
        DO 30 I = 1,NB
          VK(I) = Q(I,ICOL)
   30   CONTINUE
C
C  FORM PROJECTION MATRIX PK:
C
        DO 40 J = 1,NB
          DO 35 I = 1,J
            PK(I,J) = -VK(I) * VK(J)
            PK(J,I) = PK(I,J)
            IF(I.EQ.J) PK(I,J) = PK(I,J) + ONE
   35     CONTINUE
   40   CONTINUE
C
C  ACCUMULATE TOTAL PROJECTOR P(K) = P(K-1)*PK:
C
        DO 80 I = 1,NB
          DO 60 J = 1,NB
            PI(J) = ZERO
            DO 50 L = 1,NB
              PI(J) = PI(J) + P(I,L) * PK(L,J)
   50       CONTINUE
   60     CONTINUE
          DO 70 J = 1,NB
            P(I,J) = PI(J)
   70     CONTINUE
   80   CONTINUE
   90 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE AUGMNT(P,BLK,C,EVAL,DM,TA,BORB,V,LARC,IA,NOCC,NORB)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
      DIMENSION P(MXAO,MXAO),TA(MXAO,MXAO),DM(NDIM,NDIM),C(MXBO,MXBO),
     + EVAL(MXBO),BORB(MXBO),V(MXBO),BLK(MXBO,MXBO),LARC(NORB)
C
      SAVE ZERO,EPS,PT99,ONE
      DATA ZERO,EPS,PT99,ONE/0.0D0,1.0D-5,0.99D0,1.0D0/
C
C  FIRST, FORM SET OF "OPTIMALLY DIAGONAL" UNIT VECTORS TO SPAN RYDBERG SPACE:
C
      NAUG = NORB - NOCC
      DO 10 I = 1,NORB
        LARC(I) = 0
   10 CONTINUE
C
C  SELECT PROJECTED NAO UNIT VECTOR FROM PROJECTOR IN P:
C
      DO 300 IPROJ = 1,NAUG
        IMAX = 0
        PRJMAX = ZERO
        DO 80 IAO = 1,NORB
          IF(LARC(IAO).NE.0) GO TO 80
          PROJ = ABS(P(IAO,IAO))
          IF(PROJ.GT.PT99) GO TO 100
          IF(PROJ.LT.PRJMAX) GO TO 80
          PRJMAX = PROJ
          IMAX = IAO
   80   CONTINUE
        IAO = IMAX
        PROJ = PRJMAX
  100   CONTINUE
C
C  PUT VECTOR IN BORB, NORMALIZE, AND SAVE IN C:
C
        SB = ZERO
        DO 120 J = 1,NORB
          B = P(IAO,J)
          SB = SB + B * B
          BORB(J) = B
  120   CONTINUE
        LARC(IAO) = IPROJ
        RNORM = ONE / SQRT(SB)
        DO 130 J = 1,NORB
          BORB(J) = BORB(J) * RNORM
  130   CONTINUE
        DO 140 J = 1,NORB
          C(J,IPROJ) = BORB(J)
  140   CONTINUE
        IF(IPROJ.EQ.NAUG) GO TO 300
C
C  ADD BORB TO THE PROJECTOR IN P:
C
        DO 150 J = 1,NORB
          DO 145 I = 1,J
            TA(I,J) = -BORB(I) * BORB(J)
            TA(J,I) = TA(I,J)
            IF(I.EQ.J) TA(I,I) = TA(I,I) + ONE
  145     CONTINUE
  150   CONTINUE
        DO 200 I = 1,NORB
          DO 180 J = 1,NORB
            V(J) = ZERO
            DO 170 L = 1,NORB
              V(J) = V(J) + P(I,L) * TA(L,J)
  170       CONTINUE
  180     CONTINUE
          DO 190 J = 1,NORB
            P(I,J) = V(J)
  190     CONTINUE
  200   CONTINUE
  300 CONTINUE
C
C  PUT PROJECTED VECTORS IN TA, ORDERED ACCORDING TO THE NAO PARENT:
C
      IAUG = 0
      DO 350 IAO = 1,NORB
        IF(LARC(IAO).EQ.0) GO TO 350
        IAUG = IAUG + 1
        ITCOL = LARC(IAO)
        DO 330 J = 1,NORB
          TA(J,IAUG) = C(J,ITCOL)
  330   CONTINUE
  350 CONTINUE
C
C  LOAD DM BLOCK FOR ATOM IA IN BLK:
C
      CALL LOAD(DM,IA,0,0,BLK,NORB)
C
C  FORM BLOCK OF DM IN RYDBERG BASIS IN UPPER CORNER OF BLK:
C
      DO 500 IB = 1,NORB
        DO 450 J = 1,NAUG
          SUM = ZERO
          DO 440 K = 1,NORB
            SUM = SUM + BLK(IB,K) * TA(K,J)
  440     CONTINUE
          V(J) = SUM
  450   CONTINUE
        DO 480 J = 1,NAUG
          BLK(IB,J) = V(J)
  480   CONTINUE
  500 CONTINUE
      DO 550 J = 1,NAUG
        DO 520 I = 1,J
          SUM = ZERO
          DO 510 K = 1,NORB
            SUM = SUM + TA(K,I) * BLK(K,J)
  510     CONTINUE
          V(I) = SUM
  520   CONTINUE
        DO 530 I = 1,NAUG
          BLK(I,J) = V(I)
  530   CONTINUE
  550 CONTINUE
      DO 560 J = 1,NAUG
        JJ = J - 1
        DO 555 I = 1,JJ
          BLK(J,I) = BLK(I,J)
  555   CONTINUE
  560 CONTINUE
C
C  DIAGONALIZE DM:
C
      CALL NBJACOBI(NAUG,BLK,EVAL,C,MXBO,MXBO,1)
C
C  ORDER EIGENVECTORS BY OCCUPANCY (WITHIN EPS), FORM FINAL RYDBERG VECTORS:
C
      DO 570 I = 1,NAUG
        LARC(I) = I
  570 CONTINUE
      NAUG1 = NAUG - 1
      DO 620 I = 1,NAUG1
        I1 = I + 1
        DO 610 J = I1,NAUG
          DIFF = EVAL(J) - EVAL(I)
          IF(DIFF.LT.EPS) GO TO 610
          TEMP = EVAL(I)
          EVAL(I) = EVAL(J)
          EVAL(J) = TEMP
          ITEMP = LARC(I)
          LARC(I) = LARC(J)
          LARC(J) = ITEMP
  610   CONTINUE
  620 CONTINUE
      DO 700 J = 1,NAUG
        LJ = LARC(J)
        DO 680 I = 1,NORB
          SUM = ZERO
          DO 670 K = 1,NAUG
            SUM = SUM + TA(I,K) * C(K,LJ)
  670     CONTINUE
          BLK(I,J) = SUM
  680   CONTINUE
  700 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE REPOL(DM,Q,POL,BLK,EVAL,C,NBD)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL PRINT,FIRST
C
C  DIAGONALIZE DENSITY MATRIX IN BASIS OF ORTHONORMAL HYBRIDS FOR
C  EACH BOND ORBITAL TO FIND NEW POLARIZATION COEFFICIENTS.
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),ILL(MAXATM),
     +       IUL(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION DM(NDIM,NDIM),Q(MXAO,NDIM),POL(NDIM,3),
     *        BLK(MXBO,MXBO),EVAL(MXBO),C(MXBO,MXBO)
C
      SAVE ZERO,PT1,ONE,TWO,LSTAR
      DATA ZERO,PT1,ONE,TWO/0.0D0,0.1D0,1.0D0,2.0D0/
      DATA LSTAR/1H*/
C
C  FIRST, COUNT NUMBER OF BONDS AND 3C BONDS:
C
      NBOND = 0
      N3CB  = 0
      DO 20 IB = 1,NNAO
        IF(LABEL(IB,2).EQ.LSTAR) GO TO 20
        IF(LABEL(IB,5).EQ.0) GO TO 20
        NBOND = NBOND + 1
        IF(LABEL(IB,6).EQ.0) GO TO 20
        N3CB = N3CB + 1
   20 CONTINUE
C
C  IAB+1 IS THE NUMBER OF THE FIRST ANTIBOND IN THE NBO LIST:
C
      IAB = NNAO - NBOND - N3CB
C
      PRINT = JPRINT(5).EQ.1
      FIRST = .TRUE.
      APCOEF = ONE / SQRT(TWO)
      DO 200 IB = 1,NBD
        IF(LABEL(IB,2).EQ.LSTAR) GO TO 200
        NCTR = 1
        IF(LABEL(IB,5).GT.0) NCTR = 2
        IF(LABEL(IB,6).GT.0) NCTR = 3
        IF(NCTR.EQ.1) GO TO 200
        IF(IWAPOL.EQ.0.OR.NCTR.EQ.3) THEN
          DO 120 I = 1,NCTR
            IA  = LABEL(IB,I+3)
            NHI = NORBS(IA)
            DO 115 J = 1,I
              JA  = LABEL(IB,J+3)
              NHJ = NORBS(JA)
              DIJ = ZERO
              DO 110 IR = 1,NHI
                IRP = ILL(IA)+IR-1
                CRI = Q(IR,ILL(IA)+IATHY(IB,I)-1)
                DO 105 JS = 1,NHJ
                  JSP = ILL(JA) + JS - 1
                  CSJ = Q(JS,ILL(JA)+IATHY(IB,J)-1)
                  DIJ = DIJ+CRI*CSJ*DM(IRP,JSP)
  105           CONTINUE
  110         CONTINUE
              BLK(I,J) = DIJ
              BLK(J,I) = DIJ
  115       CONTINUE
  120     CONTINUE
C
C  DIAGONALIZE 'BLK' AND EXTRACT NEW POLARIZATION COEFFICIENTS
C
          CALL NBJACOBI(NCTR,BLK,EVAL,C,MXBO,MXBO,0)
          CALL RANK(EVAL,NCTR,MXBO,LARC)
C
C  MAKE SURE REPOLARIZATION IS NOT TOO DRASTIC (TAKE A LOOK AT THE BOND
C  ORBITAL ONLY):
C
          S = ZERO
          DO 125 I = 1,NCTR
            S = S + POL(IB,I) * C(I,LARC(1))
  125     CONTINUE
          IF(S.LT.PT1.AND.NCTR.EQ.2) THEN
            IF(FIRST.AND.PRINT) WRITE(LFNPR,*)
            FIRST = .FALSE.
            IF(PRINT) WRITE(LFNPR,900) IB,S
            IAB = IAB + 1
            POL(IAB,1) =  POL(IB,2)
            POL(IAB,2) = -POL(IB,1)
          ELSE
C
C  STORE THE NEW POLARIZATION COEFFICIENTS IN POL:
C
            DO 130 I = 1,NCTR
              POL(IB,I) = C(I,LARC(1))
  130       CONTINUE
            IAB = IAB + 1
            DO 150 I = 1,NCTR
              POL(IAB,I) = C(I,LARC(2))
  150       CONTINUE
            IF(NCTR.NE.3) GO TO 200
            IAB = IAB + 1
            DO 160 I = 1,NCTR
              POL(IAB,I) = C(I,LARC(3))
  160       CONTINUE
          END IF
C
C  CONSTRAIN BONDS TO BE APOLAR, IF REQUESTED (NOT SET UP TO WORK WITH
C  3-CENTER BONDS):
C
        ELSE
          POL(IB,1) = APCOEF
          POL(IB,2) = APCOEF
          IAB = IAB + 1
          POL(IAB,1) = APCOEF
          POL(IAB,2) = -APCOEF
        END IF
  200 CONTINUE
      RETURN
C
  900 FORMAT(1X,'WARNING: significant repolarization of NBO',I4,' (S=',
     + F7.4,'); REPOL disabled.')
      END
C***********************************************************************
      SUBROUTINE FORMT(T,Q,POL)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      INTEGER UL
C
C  CONSTRUCTION OF FINAL TRANSFORMATION  MATRIX T FROM ORTHONORMAL
C  HYBRIDS; ROWS OF T LABELLED BY NAOS, COLUMNS BY NBOS.
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOC(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),IBX(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       UL(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBNAO/NAOCTR(MAXBAS),NAOA(MAXBAS),LTYP(MAXBAS),
     +       IPRIN(MAXBAS)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      DIMENSION T(NDIM,NDIM),Q(MXAO,NDIM),POL(NDIM,3)
C
      SAVE LCR,LLP,LBD,LSTAR,LRY,ZERO
      DATA LCR,LLP,LBD,LSTAR,LRY/2HCR,2HLP,2HBD,1H*,2HRY/
      DATA ZERO/0.0D0/
C
C  REORDER OCCUPIED NBOS TO PUT LONE AND CORE PAIRS LAST:
C
      NCR = 0
      NLP = 0
      NBDS = 0
      DO 10 NSCAN = 1,NNAO
        IF(LABEL(NSCAN,2).EQ.LSTAR) GO TO 10
        NBDS = NBDS + 1
        IF(LABEL(NSCAN,1).EQ.LLP) NLP = NLP + 1
        IF(LABEL(NSCAN,1).EQ.LCR) NCR = NCR + 1
   10 CONTINUE
      ICR = 0
      ILP = 0
      IBO = 0
      IAB = 0
      DO 40 IBD = 1,NNAO
        IF(LABEL(IBD,2).EQ.LSTAR) GO TO 30
        IF(LABEL(IBD,1).EQ.LCR) GO TO 15
        IF(LABEL(IBD,1).EQ.LLP) GO TO 20
C
C  PAIR BONDS:
C
        IBO = IBO + 1
        IBX(IBD) = IBO
        GO TO 40
C
C  CORE PAIRS:
C
   15   ICR = ICR + 1
        IBX(IBD) = ICR + NBDS - NCR - NLP
        GO TO 40
C
C  LONE PAIRS AND CORE PAIRS:
C
   20   ILP = ILP + 1
        IBX(IBD) = ILP + NBDS - NLP
        GO TO 40
C
C  ANTIBONDS:
C
   30   IAB = IAB + 1
        IBX(IBD) = NBDS + IAB
   40 CONTINUE
C
C  ZERO TRANSFORMATION ARRAY:
C
      DO 60 I = 1,NNAO
        DO 50 J = 1,NNAO
          T(I,J) = ZERO
   50   CONTINUE
   60 CONTINUE
C
C  DEPOSIT FINAL BOND ORBITALS IN MATRIX T:
C
      NBO = 0
      DO 130 IBD = 1,NNAO
        KBD = IBD
        IF(LABEL(IBD,2).NE.LSTAR) GO TO 100
        IF(LABEL(IBD,1).EQ.LRY) GO TO 100
        IF(LABEL(IBD,1).EQ.LLP) GO TO 100
C
C  ANTIBOND ORBITALS: SEARCH OCCUPIED ORB. LIST TO GET PROPER HYBRIDS.
C  SEARCH OCCUPIED BOND ORBS. FOR MATCH WITH ANTIBOND ATOMS:
C
        DO 90 K = 1,NBO
          DO 70 I = 4,6
            IF(LABEL(K,I).NE.LABEL(IBD,I)) GO TO 90
            IF((LABEL(K,3).LE.0).AND.(LABEL(K,1).EQ.LBD)) GO TO 90
   70     CONTINUE
C
C  NEGATIVE IRNK = LABEL(K,3) MEANS BOND ORBITAL WAS ALREADY USED:
C
C  FOUND MATCH; SET LABEL(K,3)<0:
C
          KBD = K
          LABEL(KBD,3) = -LABEL(KBD,3)
          GO TO 100
   90   CONTINUE
C
C  COULDN'T FIND MATCH...EXIT:
C
        WRITE(LFNPR,9000) IBD,(LABEL(IBD,JJ),JJ=1,6)
        CALL NBHALT('Cannot find bond/antibond match for NBO.')
C
C  DEPOSIT BOND ORBITALS IN T MATRIX:
C
  100   CONTINUE
        DO 120 I = 1,3
          IA = LABEL(IBD,I+3)
          IF(IA.EQ.0) GO TO 120
          JL = LL(IA)
          JU = UL(IA)
          IROW = 0
          ICOL = JL + IATHY(KBD,I) - 1
          DO 110 J = JL,JU
            IROW = IROW + 1
            JB = IBX(IBD)
  110       T(J,JB) = POL(IBD,I) * Q(IROW,ICOL)
  120     CONTINUE
        IF(IBD.EQ.KBD) NBO = IBD
  130   CONTINUE
C
C  RESTORE LABEL(I,3) > 0:
C
      DO 140 I = 1,NNAO
        IF(LABEL(I,3).LT.0) LABEL(I,3) = -LABEL(I,3)
  140   CONTINUE
C
C  SET ARRAY IBXM: IBXM(IB) IS THE CURRENT LOCATION OF B.O. # IB:
C
      DO 150 IB = 1,NNAO
        I = IBX(IB)
  150   IBXM(I) = IB
C
C  SET PHASE OF 1-CENTER ORBITALS SUCH THAT THE LARGEST S-TYPE NAO CONTRIBUTION
C  IS POSITIVE:
C
      DO 200 IB = 1,NNAO
        NCTR = 1
        DO 160 IL = 5,6
          IF(LABEL(IBXM(IB),IL).NE.0) NCTR = NCTR + 1
  160   CONTINUE
        IF(NCTR.EQ.1) THEN
          JMAX = 0
          TMAX = -1.0D0
          DO 170 IN = 1,NNAO
            IF(NAOA(IN).LT.100) THEN
              IF(ABS(T(IN,IB)).GT.TMAX) THEN
                JMAX = IN
                TMAX = ABS(T(IN,IB))
              END IF
            END IF
  170     CONTINUE
          IF(JMAX.NE.0) THEN
            IF(T(JMAX,IB).LT.-1.0D-4) THEN
              DO 180 IN = 1,NNAO
                T(IN,IB) = -T(IN,IB)
  180         CONTINUE
            END IF
          END IF
        END IF
  200 CONTINUE
      RETURN
C
 9000 FORMAT(/,1X,'Can''t find bond/antibond match for NBO',
     + I4,2X,A2,A1,'(',I2,')',3I4)
      END
C***********************************************************************
      SUBROUTINE CYCLES(ITER,THRESH,GUIDE,BNDOCC,TOPO,ICONT)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBTHR/THRSET,PRJSET,ACCTHR,CRTSET,E2THR,ATHR,PTHR,ETHR,
     +             DTHR,DLTHR,CHSTHR,REFTHR,STTHR,PRTHR,THRNCS,THRNJC
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBTOPO/IORDER(MAXATM),JORDER(MAXATM),NTOPO(MAXATM,MAXATM),
     +            N3CTR,I3CTR(10,3)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION GUIDE(NATOMS,NATOMS),BNDOCC(NDIM),TOPO(NATOMS,NATOMS)
C
      SAVE JTER,DEVMIN,RHOMIN,BEST,RHO,JBADL
      SAVE LCR,LBD,L3C,LLP,LSTAR,DEVTHR,JTERMX
      SAVE SMALL,ZERO,TENTH,PT7,ONE,ONEPT5,THREE,HUNDRD
C
      DATA LCR,LBD,L3C,LLP,LSTAR/2HCR,2HBD,2H3C,2HLP,1H*/
      DATA SMALL,ZERO,TENTH,PT7,ONE,ONEPT5,THREE,HUNDRD
     +       /1.0D-4,0.0D0,0.1D0,0.7D0,1.0D0,1.5D0,3.0D0,1.0D2/
      DATA DEVTHR/0.1D0/
      DATA JTERMX/9/
C
C  SR CYCLES controls the search for an acceptable resonance structure:
C
C  Arguments:
C        ITER   : iteration counter incremented by the calling routine
C        THRESH : occupancy threshold used in search for NBOs
C        GUIDE  : Wiberg bond index
C        BNDOCC : array containing the NBO occupancies
C        TOPO   : bond index matrix to be compared with the Wiberg indices
C        ICONT  : control flag (see below)
C
C  ITER, GUIDE, and BNDOCC are unaltered by this routine
C  THRESH is modified by this routine, if the RESONANCE keyword is selected
C  The TOPO matrix is constructed by this routine
C
C  Control flag : (set by this routine)
C    ICONT =  2 : an acceptable Lewis structure has been found, continue
C          =  1 : an acceptable Lewis structure has been found, recompute the
C                 NBOs for this structure
C          =  0 : bogus Lewis structure, terminate search for NBOs
C          = -1 : occupancy threshold and/or atom ordering have been
C                 changed.  Repeat the search for NBOs.
C
C  Set atom permuting counter and minimum deviation in GUIDE-TOPO:
C
      IF(ITER.EQ.1) THEN
        JTER  =  0
        ICONT = -1
      END IF
      JTER = JTER + 1
      IF(JTER.EQ.1) DEVMIN = HUNDRD
C
C  The minimum occupancy threshold is 1.5e (0.7e for open shell):
C
      THRMIN = ONEPT5
      IF(ISPIN.NE.0) THRMIN = PT7
C
C  Determine the number of low occupancy orbitals in the Lewis structure:
C
      IBADL  = 0
      IBADNL = 0
      SUMLEW = ZERO
      TOTELE = ZERO
      DO 10 I = 1,NNAO
        TOTELE = TOTELE + BNDOCC(I)
        IF(LABEL(IBXM(I),2).NE.LSTAR) THEN
          SUMLEW = SUMLEW + BNDOCC(I)
          IF(BNDOCC(I).LT.THRESH) IBADL = IBADL + 1
        ELSE
          IF(BNDOCC(I).GT.ABS(ACCTHR)) IBADNL = IBADNL + 1
        END IF
   10 CONTINUE
      NEL    = INT(TOTELE + TENTH)
      TOTELE = DFLOAT(NEL)
      SUM    = TOTELE - SUMLEW
C
C  Count the ECP electrons in the Lewis structure:
C
      IF(IPSEUD.NE.0) THEN
        MECP = 0
        DO 20 IAT = 1,NATOMS
          MECP = MECP + IATNO(IAT) - IZNUC(IAT)
   20   CONTINUE
        IF(ISPIN.NE.0) MECP = MECP/2
        SUMLEW = SUMLEW + DFLOAT(MECP)
      END IF
C
C  Keep track of the best Lewis structure found so far:
C
      IF(JTER.EQ.1) RHOMIN = HUNDRD
      IF(ITER.EQ.1) RHO    = HUNDRD
      IF(ITER.EQ.1.OR.SUM.LT.RHO) THEN
        BEST  = THRESH
        RHO   = SUM
        JBADL = IBADL
        DO 25 I = 1,NATOMS
          JORDER(I) = IORDER(I)
   25   CONTINUE
      END IF
C
C  Count the number of core, lone pair, and bonding orbitals in this
C  resonance structure:
C
      MCR = 0
      MBD = 0
      M3C = 0
      MLP = 0
      DO 30 I = 1,NNAO
        IF(LABEL(I,1).EQ.LCR.AND.LABEL(I,2).NE.LSTAR) MCR = MCR + 1
        IF(LABEL(I,1).EQ.LBD.AND.LABEL(I,2).NE.LSTAR) MBD = MBD + 1
        IF(LABEL(I,1).EQ.L3C.AND.LABEL(I,2).NE.LSTAR) M3C = M3C + 1
        IF(LABEL(I,1).EQ.LLP.AND.LABEL(I,2).NE.LSTAR) MLP = MLP + 1
   30 CONTINUE
C
C  Build the TOPO matrix from lone pairs and 2- and 3-center bonds:
C
      DO 50 I = 1,NATOMS
        DO 40 J = 1,NATOMS
          TOPO(I,J) = ZERO
   40   CONTINUE
   50 CONTINUE
C
      DO 60 I = 1,NNAO
        IB   = IBXM(I)
        IF(LABEL(IB,1).NE.LCR.AND.LABEL(IB,2).NE.LSTAR) THEN
          IAT1 = LABEL(IB,4)
          NCTR = 1
          IAT2 = LABEL(IB,5)
          IF(IAT2.NE.0) NCTR = 2
          IAT3 = LABEL(IB,6)
          IF(IAT3.NE.0) NCTR = 3
          IF(NCTR.EQ.1) THEN
            TOPO(IAT1,IAT1) = TOPO(IAT1,IAT1) + ONE
          ELSE IF(NCTR.EQ.2) THEN
            TOPO(IAT1,IAT2) = TOPO(IAT1,IAT2) + ONE
            TOPO(IAT2,IAT1) = TOPO(IAT2,IAT1) + ONE
          ELSE
            TOPO(IAT1,IAT2) = TOPO(IAT1,IAT2) + ONE/THREE
            TOPO(IAT2,IAT1) = TOPO(IAT2,IAT1) + ONE/THREE
            TOPO(IAT1,IAT3) = TOPO(IAT1,IAT3) + ONE/THREE
            TOPO(IAT3,IAT1) = TOPO(IAT3,IAT1) + ONE/THREE
            TOPO(IAT2,IAT3) = TOPO(IAT2,IAT3) + ONE/THREE
            TOPO(IAT3,IAT2) = TOPO(IAT3,IAT2) + ONE/THREE
          END IF
        END IF
   60 CONTINUE
C
C  Determine the largest off-diagonal element of GUIDE-TOPO:
C
      DEV = ZERO
      DO 80 J = 2,NATOMS
        DO 70 I = 1,J-1
          IF(GUIDE(I,J)-TOPO(I,J).GT.DEV) THEN
            DEV = GUIDE(I,J) - TOPO(I,J)
            IAT = I
            JAT = J
          END IF
   70   CONTINUE
   80 CONTINUE
C
C  Write info about this resonance structure:
C
      IF(JPRINT(5).EQ.1) THEN
        IF(ITER.EQ.1) WRITE(LFNPR,1000)
        WRITE(LFNPR,1010) ITER,JTER,ABS(THRESH),SUMLEW,SUM,MCR,MBD,
     +                    M3C,MLP,IBADL,IBADNL,DEV
      END IF
C
C  Decide if this structure is acceptable:
C
C   *  Accept the structure if NBCHSE was employed.
C   *  Accept the structure if there is only one atom.
C   *  Accept the structure if there are no low occupancy Lewis orbitals,
C      DEV is less than DEVTHR, and SUM is equal to RHO.
C   *  Accept the structure if the NOBOND option was selected.
C
C  Good resonance structure:
C
      IF(IBADL.EQ.0.AND.DEV.LT.DEVTHR.AND.ABS(SUM-RHO).LT.SMALL) THEN
        IF(JPRINT(5).EQ.1) WRITE(LFNPR,1020)
        IF(JPRINT(5).EQ.1) WRITE(LFNPR,1030)
        ICONT = 2
        RETURN
C
C  Only one atom:
C
      ELSE IF(NATOMS.EQ.1) THEN
        IF(JPRINT(5).EQ.1) WRITE(LFNPR,1020)
        IF(JPRINT(5).EQ.1) WRITE(LFNPR,1035)
        ICONT = 2
        RETURN
C
C  Directed NBO search:
C
      ELSE IF(ICHOOS.EQ.1) THEN
        IF(JPRINT(5).EQ.1) WRITE(LFNPR,1020)
        IF(JPRINT(5).EQ.1) WRITE(LFNPR,1040)
        ICONT = 2
        RETURN
C
C  NOBOND option selected:
C
      ELSE IF(JPRINT(10).NE.0) THEN
        IF(JPRINT(5).EQ.1) WRITE(LFNPR,1020)
        IF(JPRINT(5).EQ.1) WRITE(LFNPR,1050)
        ICONT = 2
        RETURN
      END IF
C
C  Structure accepted due to the specification of the RESONANCE keyword
C  or the occupancy threshold.  Otherwise, accept the structure only if
C  there are no high occupancy Lewis orbitals:
C
      IF(ICONT.EQ.1) THEN
        IF(THRSET.GE.ZERO) THEN
          IF(JPRINT(5).EQ.1) WRITE(LFNPR,1020)
          IF(JPRINT(5).EQ.1) WRITE(LFNPR,1060)
          ICONT = 2
        ELSE IF(JPRINT(14).GT.0) THEN
          IF(JPRINT(5).EQ.1) WRITE(LFNPR,1020)
          IF(JPRINT(5).EQ.1) WRITE(LFNPR,1070)
          ICONT = 2
        ELSE IF(JPRINT(14).LT.0) THEN
          IF(JPRINT(5).EQ.1) WRITE(LFNPR,1020)
          IF(JPRINT(5).EQ.1) WRITE(LFNPR,1090)
          ICONT = 2
        ELSE IF(IBADL.NE.0) THEN
          IF(JPRINT(5).EQ.1) WRITE(LFNPR,1020)
          IF(JPRINT(5).EQ.1) WRITE(LFNPR,1030)
          ICONT = 2
        END IF
        RETURN
      END IF
C
C  If DEV.EQ.DEVMIN.AND.SUM.EQ.RHOMIN or too many atoms permutations,
C  abort atom permutations:
C
      IF((ABS(DEV-DEVMIN).LT.SMALL.AND.ABS(SUM-RHOMIN).LT.SMALL).OR.
     +                                 JTER.GE.JTERMX) THEN
C
C  If the occupancy threshold was set by the user, accept the best
C  structure:
C
        IF(THRSET.GE.ZERO) THEN
          IF(ABS(SUM-RHO).LT.SMALL) THEN
            IF(JPRINT(5).EQ.1) WRITE(LFNPR,1020)
            IF(JPRINT(5).EQ.1) WRITE(LFNPR,1060)
            ICONT = 2
          ELSE
            DO 90 I = 1,NATOMS
              IORDER(I) = JORDER(I)
   90       CONTINUE
            JTER  = 0
            ICONT = 1
          END IF
C
C  If the RESONANCE keyword was specified, pick the best resonance structure
C  for this occupancy threshold, and possibly decrement the threshold and
C  continue the search:
C
        ELSE IF(JPRINT(14).NE.0) THEN
          THRESH = THRESH - TENTH
          IF(THRMIN-THRESH.GT.SMALL) THEN
            THRESH = THRESH + TENTH
            IF(ABS(THRESH-BEST).LT.SMALL.AND.ABS(SUM-RHO).LT.SMALL) THEN
              IF(JPRINT(14).GT.0) THEN
                IF(JPRINT(5).EQ.1) WRITE(LFNPR,1020)
                IF(JPRINT(5).EQ.1) WRITE(LFNPR,1070)
                ICONT = 2
              ELSE
                IF(JPRINT(5).EQ.1) WRITE(LFNPR,1020)
                IF(JPRINT(5).EQ.1) WRITE(LFNPR,1090)
                ICONT = 2
              END IF
            ELSE
              DO 100 I = 1,NATOMS
                IORDER(I) = JORDER(I)
  100         CONTINUE
              THRESH = BEST
              JTER  = 0
              ICONT = 1
            END IF
          ELSE
            DO 110 I = 1,NATOMS
              IORDER(I) = JORDER(I)
  110       CONTINUE
            JTER  =  0
            ICONT = -1
          END IF
C
C  Otherwise, accept the best structure, but only if it had no Lewis
C  orbitals with occupancy less than the occupancy threshold:
C
        ELSE
          IF(ABS(SUM-RHO).LT.SMALL.AND.IBADL.EQ.0) THEN
            IF(JPRINT(5).EQ.1) WRITE(LFNPR,1020)
            IF(JPRINT(5).EQ.1) WRITE(LFNPR,1030)
            ICONT = 2
          ELSE IF(JBADL.EQ.0) THEN
            DO 115 I = 1,NATOMS
              IORDER(I) = JORDER(I)
  115       CONTINUE
            JTER  = 0
            ICONT = 1
          ELSE
            IF(JPRINT(5).EQ.1) WRITE(LFNPR,1020)
            IF(JPRINT(5).EQ.1) WRITE(LFNPR,1080)
            ICONT = 0
          END IF
        END IF
        RETURN
C
C  Loop through atom ordering to find alternative resonance structures:
C
      ELSE
        IF(DEV.LT.DEVMIN) DEVMIN = DEV
        IF(SUM.LT.RHOMIN) RHOMIN = SUM
        IF(IAT.EQ.IORDER(1).AND.JAT.EQ.IORDER(2)) THEN
          DEV1 = ZERO
          DO 130 J = 2,NATOMS
            DO 120 I = 1,J-1
              IF(GUIDE(I,J)-TOPO(I,J).GT.DEV1) THEN
                IF((I.NE.IORDER(1).AND.J.NE.IORDER(2)).AND.
     +             (J.NE.IORDER(1).AND.I.NE.IORDER(2))) THEN
                  DEV1 = GUIDE(I,J) - TOPO(I,J)
                  IAT  = I
                  JAT  = J
                END IF
              END IF
  120       CONTINUE
  130     CONTINUE
        END IF
C
        JFLG = 0
        DO 140 I = NATOMS,2,-1
          IF(IORDER(I).EQ.JAT) JFLG = 1
          IF(JFLG.EQ.1) IORDER(I) = IORDER(I-1)
  140   CONTINUE
        IORDER(1) = JAT
        IFLG = 0
        DO 150 I = NATOMS,2,-1
          IF(IORDER(I).EQ.IAT) IFLG = 1
          IF(IFLG.EQ.1) IORDER(I) = IORDER(I-1)
  150   CONTINUE
        IORDER(1) = IAT
        ICONT = -1
      END IF
      RETURN
C
 1000 FORMAT(/1X,'                      Occupancies       Lewis ',
     + 'Structure    Low   High',/1X,'          Occ.    --------',
     + '-----------  -----------------   occ   occ',/1X,' Cycle ',
     + '  Thresh.   Lewis   Non-Lewis     CR  BD  3C  LP    (L) ',
     + '  (NL)   Dev',/1X,77('='))
 1010 FORMAT(1X,I3,'(',I1,')',3X,F5.2,F12.5,F10.5,3X,4I4,2X,I4,3X,I4,
     + 3X,F5.2)
 1020 FORMAT(1X,77('-'))
 1030 FORMAT(/1X,'Structure accepted: No low occupancy Lewis orbitals')
 1035 FORMAT(/1X,'Structure accepted: Only a single atom')
 1040 FORMAT(/1X,'Structure accepted: NBOs selected via the $CHOOSE ',
     + 'keylist')
 1050 FORMAT(/1X,'Structure accepted: Search for bonds prevented ',
     + 'by NOBOND keyword')
 1060 FORMAT(/1X,'Structure accepted: Occupancy threshold (THRESH) ',
     + 'set by user')
 1070 FORMAT(/1X,'Structure accepted: RESONANCE keyword permits ',
     + 'strongly delocalized structure')
 1080 FORMAT(/1X,'Only strongly delocalized resonance structures can',
     + ' be found.',/1X,'The default procedure is to abort the NBO ',
     + 'search.  Include',/1X,'the RESONANCE keyword in the $NBO ',
     + 'keylist to override this test.')
 1090 FORMAT(/1X,'Strongly delocalized structure accepted')
      END
C***********************************************************************
C NBO 5.G -- Natural Bond Orbital Analysis Programs
C (c) Copyright 1996-2008 Board of Regents of the University of Wisconsin System
C     on behalf of the Theoretical Chemistry Institute.  All Rights Reserved.
C***********************************************************************
C
C  ROUTINES CALLED BY SR NLMO:
C
C      SUBROUTINE SYMUNI(TSYM,A,COS,SIN,OVLP,BLK,EVAL,NROT,
C     +           NIUNIQ,NJUNIQ,ILIST,JLIST,NOFF,IOFF,JOFF,NDIM)
C      SUBROUTINE SYMORT(S,T,BLK,NDIM,N,EVAL,IERR,IPFLG)
C
C***********************************************************************
      SUBROUTINE SYMUNI(TSYM,A,COS,SIN,OVLP,BLK,EVAL,NROT,
     *           NIUNIQ,NJUNIQ,ILIST,JLIST,NOFF,IOFF,JOFF,NDIM)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      DIMENSION TSYM(NROT,NROT),A(NDIM,NDIM),BLK(NROT,NROT),
     *  OVLP(NROT,NROT),EVAL(NROT)
      DIMENSION IOFF(NOFF),JOFF(NOFF),ILIST(NOFF),JLIST(NOFF)
C
      SAVE ZERO,ONE,EPS
      DATA ZERO,ONE/0.0D0,1.0D0/
      DATA EPS/1.0D-6/
C
      DO 40 I=1,NROT
        DO 30 J=1,NROT
   30     TSYM(I,J)=ZERO
   40     TSYM(I,I)=ONE
      DO 60 MOFF=1,NOFF
        IOCC=ILIST(MOFF)
        JEMT=JLIST(MOFF)
        DO 60 I=1,NROT
          T=TSYM(I,IOCC)
          U=TSYM(I,JEMT)
          TSYM(I,IOCC)=COS*T-SIN*U
   60     TSYM(I,JEMT)=SIN*T+COS*U
C
C   AVERAGE GROUPS OF THE ELEMENTS OF THE TRANSFORMATION MATRIX TSYM
C    SO THAT THE SYMMETRY INHERENT IN THE DENSITY MATRIX A IS PRESERVED,
C    MAKING SURE THAT THE RESULTING "AVERAGED" TRANSFORMATION IS UNITARY
C
C
      JST=NIUNIQ+1
      NROT=JST-1+NJUNIQ
C
C   AVE. DIAG. ELEM OF OCC ORBS
      IF(NIUNIQ.EQ.1) GO TO 140
      TOT=ZERO
      DO 100 I=1,NIUNIQ
  100   TOT=TOT+TSYM(I,I)
      AVE=TOT/NIUNIQ
      DO 110 I=1,NIUNIQ
  110   TSYM(I,I)=AVE
C
C   AVE. DIAG. ELEM OF EMPTY ORBS
  140 IF(NJUNIQ.EQ.1) GO TO 180
      TOT=ZERO
      DO 150 J=JST,NROT
  150   TOT=TOT+TSYM(J,J)
      AVE=TOT/NJUNIQ
      DO 160 J=JST,NROT
  160   TSYM(J,J)=AVE
C
C  ZERO OFFDIAG ELEM BETW OCC ORBS:
  180 IF(NIUNIQ.EQ.1) GO TO 240
      DO 220 I=2,NIUNIQ
        DO 220 J=1,I
          IF(I.EQ.J) GO TO 220
          TSYM(I,J)=ZERO
          TSYM(J,I)=ZERO
  220     CONTINUE
C
C  ZERO OFFDIAG ELEM BETW EMPTY ORBS:
  240 IF(NJUNIQ.EQ.1) GO TO 280
      JST2=JST+1
      DO 270 I=JST2,NROT
        DO 270 J=JST,I
          IF(I.EQ.J) GO TO 270
          TSYM(I,J)=ZERO
          TSYM(J,I)=ZERO
  270     CONTINUE
C
C  AVE. OFFDIAG ELEM BETW OCC AND EMPTY ORBS (PIVOTED ELEMENTS ONLY):
  280 CONTINUE
      TOT=ZERO
      DO 310 MOFF=1,NOFF
        II=ILIST(MOFF)
        JJ=JLIST(MOFF)
  310   TOT=TOT+ABS(TSYM(II,JJ))+ABS(TSYM(JJ,II))
      NOFF2=NOFF*2
      AVE=TOT/NOFF2
      DO 330 MOFF=1,NOFF
        II=ILIST(MOFF)
        JJ=JLIST(MOFF)
        TSYM(II,JJ)=-AVE
  330   TSYM(JJ,II)= AVE
C
C  NOW ZERO THE NON-PIVOTED ELEMENTS:
      DO 450 I=1,NIUNIQ
        DO 440 J=JST,NROT
          DO 420 MOFF=1,NOFF
            IF(I.EQ.ILIST(MOFF).AND.J.EQ.JLIST(MOFF)) GO TO 440
  420       CONTINUE
          TSYM(I,J)= ZERO
          TSYM(J,I)= ZERO
  440     CONTINUE
  450   CONTINUE
C
C  RENORMALIZE VECTORS:
      DO 700 J=1,NROT
        TOT=ZERO
        DO 650 I=1,NROT
  650     TOT=TOT+TSYM(I,J)*TSYM(I,J)
        RNORM=SQRT(TOT)
        IF(RNORM.GT.EPS) GO TO 680
          WRITE(LFNPR,2880) NROT,TOT,EPS,RNORM
 2880     FORMAT('NROT,TOT,EPS,RNORM:',I3,3F14.9)
          CALL ALTOUT(TSYM,NROT,NROT,NROT,NROT)
          CALL NBHALT('Error renormalizing vectors.')
  680   CONTINUE
        DO 690 I=1,NROT
  690     TSYM(I,J)=TSYM(I,J)/RNORM
  700   CONTINUE
C
C  NOW, MAKE SURE THE SIGNS ARE CORRECT:
      DO 800 MOFF=1,NOFF
        I=IOFF(MOFF)
        J=JOFF(MOFF)
        IF(A(I,J).GT.ZERO) GO TO 800
          II=ILIST(MOFF)
          JJ=JLIST(MOFF)
          TSYM(II,JJ)=-TSYM(II,JJ)
          TSYM(JJ,II)=-TSYM(JJ,II)
  800   CONTINUE
C
C  FINALLY, THE CRUCIAL STEP OF SYMMETRICALLY ORTHOGONALIZING THE VECTORS
C   SO THAT THE TRANSFORMATION IS UNITARY:
      CALL SYMORT(OVLP,TSYM,BLK,NROT,NROT,EVAL,IERR,1)
      RETURN
C
      END
C***********************************************************************
      SUBROUTINE SYMORT(S,T,BLK,NDIM,N,EVAL,IERR,IPFLG)
C***********************************************************************
C
C   SYMORT: SYMmetric ORThogonalization subroutine
C
C   S:  overlap matrix (calculated, then destroyed!)
C   T:  vectors to be orthogonalized (algorithm assumes basis functions
C       corresponding to the rows of this matrix are orthogonal)
C   N:  number of vectors
C
C   Important Constants:
C
C   DIAGTH          Threshold for matrix diagonalization used in
C                   SR NBJACOBI.  In NBJACOBI, this constant
C                   is called "DONETH".
C   DANGER          Criterion for deciding that the job should be
C                   aborted due to numerical problems caused by near
C                   linear dependencies in the basis set.  All
C                   eigenvalues of the weighted overlap matrix must
C                   be greater than DIAGTH*DANGER.
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION S(N,N),T(NDIM,NDIM),BLK(N,N),EVAL(N)
C
      SAVE ZERO,DIAGTH,ONE,DANGER
      DATA ZERO,DIAGTH,ONE,DANGER/0.0D0,1.0D-12,1.0D0,1.0D3/
C
C  Calculate the overlap matrix:
C
      DO 30 I = 1,N
        DO 20 J = 1,N
          SIJ = ZERO
          DO 10 K = 1,N
            SIJ = SIJ + T(K,I) * T(K,J)
   10     CONTINUE
          S(I,J) = SIJ
   20   CONTINUE
   30 CONTINUE
C     CALL ALTOUT(T,N,N,N,N)
C
C  Compute the eigenvalues (EVAL) and eigenvectors (BLK) of the overlap:
C
      CALL NBJACOBI(N,S,EVAL,BLK,N,N,0)
C
C  Prepare the inverse square root of the overlap:
C
      TOOSML = DIAGTH * DANGER
      DO 40 I = 1,N
        EIGENV = EVAL(I)
        IF(EIGENV.LT.TOOSML) THEN
          IF(IPFLG.EQ.1) WRITE(LFNPR,900) EIGENV,TOOSML
          IERR = IERR + 1
          RETURN
        END IF
        EVAL(I) = ONE / SQRT(EIGENV)
   40 CONTINUE
      DO 70 I = 1,N
        DO 60 J = 1,I
          SIJ = ZERO
          DO 50 K = 1,N
            SIJ = SIJ + EVAL(K) * BLK(I,K) * BLK(J,K)
   50     CONTINUE
          S(I,J) = SIJ
          S(J,I) = SIJ
   60   CONTINUE
   70 CONTINUE
C
C  Now, form the total symmetrically-orthogonalized transformation:
C
      DO 100 I = 1,N
        DO 90 J = 1,N
          TIJ = ZERO
          DO 80 K = 1,N
            TIJ = TIJ + T(I,K) * S(K,J)
   80     CONTINUE
          T(I,J) = TIJ
   90   CONTINUE
  100 CONTINUE
      RETURN
C
  900 FORMAT(1X,'SYMORT:  An eigenvalue of the overlap matrix of ',
     + E13.5,' has been',/4X,'found. This is lower than the allowed ',
     + 'threshold of ',E13.5,'.')
      END
C***********************************************************************
C NBO 5.G -- Natural Bond Orbital Analysis Programs
C (c) Copyright 1996-2008 Board of Regents of the University of Wisconsin System
C     on behalf of the Theoretical Chemistry Institute.  All Rights Reserved.
C***********************************************************************
C
C  NBO ENERGETIC ANALYSIS ROUTINES:
C
C      SUBROUTINE NBOEAN(A,MEMORY,NBOOPT,IDONE)
C      SUBROUTINE NBODEL(A,MEMORY,IDONE,ISET)
C      SUBROUTINE NBDELE(F,TRF,NDIM,IDEL,LEN,DONE,ISPIN,ISET)
C      SUBROUTINE NEWDM(DM,U,EIG,OCC,SCR,NDIM,ISPIN,ISET)
C      SUBROUTINE RNKEIG(RANK,EIG,N,NDIM,ARCRNK)
C
C***********************************************************************
      SUBROUTINE NBOEAN(A,MEMORY,NBOOPT,IDONE)
C***********************************************************************
C
C     NBOEAN: CONTROLLER SUBROUTINE TO DO NBO ENERGETIC ANALYSIS
C               BY FOCK MATRIX DELETION METHOD
C
C       A(MEMORY) IS SCRATCH STORAGE
C
C       NBOOPT(1) = 2       READ IN NEXT DELETION AND FORM NEW DM
C                 = 3       COMPUTE ENERGY CHANGE FOR THIS DELETION
C
C       SET IDONE TO 1 IF NO DELETIONS ARE FOUND:
C
C***********************************************************************
C 12-Jun-96  EDG  Add NAO and NHO deletions
C 21-Nov-00  FAW  Correct AUKCAL, EVKCAL conversion factors
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL ERROR,NEW,DEL
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBEDA/KFRG,NFRG,IFRG(MAXBAS),NFE(MAXBAS),NFEB(MAXBAS)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION A(MEMORY),NBOOPT(10)
C
      SAVE THRNEG,AUKCAL,EVKCAL
      DATA THRNEG/-1.0D-3/
      DATA AUKCAL,EVKCAL/627.5093314D0,23.061D0/
C
C  OPEN THE OLD NBO DAF:
C
      NEW = .FALSE.
      DEL = .FALSE.
      CALL NBOPEN(NEW,ERROR)
      IF(ERROR) THEN
        IDONE = 1
        RETURN
      END IF
      CALL FEINFO(A,ISWEAN)
C
C  ROHF, MCSCF, CI, AND AUHF WAVE FUNCTIONS ARE NOT ACCEPTABLE:
C
      IF(ROHF.OR.MCSCF.OR.CI.OR.AUHF) THEN
        IDONE = 1
        IF(NBOOPT(7).EQ.0) DEL = .TRUE.
        CALL NBCLOS(DEL)
        RETURN
      END IF
C
C  COMPUTE THE ENERGY OF DELETION:
C
      IF(NBOOPT(1).EQ.3) THEN
        CALL FEE0(EDEL,ETOT)
        IF(KFRG.EQ.0) THEN
          ECHANG = EDEL - ETOT
          IF(MUNIT.EQ.0) THEN
            EKCAL = ECHANG * AUKCAL
            WRITE(LFNPR,2100) EDEL,ETOT,ECHANG,EKCAL
          ELSE IF(MUNIT.EQ.1) THEN
            EKCAL = ECHANG * EVKCAL
            WRITE(LFNPR,2110) EDEL,ETOT,ECHANG,EKCAL
          ELSE
            EKCAL = ECHANG
            WRITE(LFNPR,2120) EDEL,ETOT,ECHANG,EKCAL
          END IF
          IF(EKCAL.LT.THRNEG) WRITE(LFNPR,2130)
        END IF
        IF(NFRG.NE.0.AND.NFRG.EQ.KFRG) THEN
          I1  = 1
          I2  = I1  + 4 + 8 * NFRG
          I3  = I2  + NFRG
          I4  = I3  + NFRG
          I5  = I4  + NFRG
          I6  = I5  + NFRG
          I7  = I6  + NFRG
          I8  = I7  + NFRG
          I9  = I8  + NFRG
          I10 = I9  + NFRG
          I11 = I10 + NFRG
          CALL EDAOUT(ETOT,A(I1),A(I2),A(I3),A(I4),A(I5),A(I6),A(I7),
     +                A(I8),A(I9),A(I10),A(I11))
        END IF
        IDONE = 0
        CALL NBCLOS(DEL)
        RETURN
      END IF
C
C  SEARCH FOR THE $DEL KEYLIST:
C
      IF(ISWEAN.EQ.1) THEN
        CALL DELINP(NBOOPT,IDONE)
        IF(IDONE.EQ.1) THEN
          IF(NBOOPT(7).EQ.0) DEL = .TRUE.
          CALL NBCLOS(DEL)
          RETURN
        END IF
        KFRG = 0
        NFRG = 0
      ELSE IF(NBOOPT(10).GT.80) THEN
        CALL STRTIN(LFNIN)
      END IF
C
C  NATURAL ENERGY DECOMPOSITION ANALYSIS:
C
      IF(NFRG.NE.0) THEN
        I1 = 1
        I2 = I1 + NDIM * NDIM
        I3 = I2 + NDIM * NDIM
        I4 = I3 + NDIM * NDIM
        ISPIN = 0
        ALPHA = .FALSE.
        BETA  = .FALSE.
        IF(UHF) ISPIN = 2
        IF(UHF) ALPHA = .TRUE.
        CALL NBOEDA(A(I1),A(I2),A(I3),A(I4))
        IF(UHF) THEN
          ISPIN = -2
          ALPHA = .FALSE.
          BETA  = .TRUE.
          CALL NBOEDA(A(I1),A(I2),A(I3),A(I4))
        END IF
C
C  NBO ENERGETIC ANALYSIS:
C
      ELSE
        ISPIN = 0
        ALPHA = .FALSE.
        BETA  = .FALSE.
        IF(UHF) ISPIN = 2
        IF(UHF) ALPHA = .TRUE.
        CALL NBODEL(A,MEMORY,IDONE,ISET)
        IF(IDONE.EQ.1) THEN
          IF(NBOOPT(7).EQ.0) DEL = .TRUE.
          CALL NBCLOS(DEL)
          RETURN
        END IF
        IF(UHF) THEN
          ISPIN = -2
          ALPHA = .FALSE.
          BETA  = .TRUE.
          CALL NBODEL(A,MEMORY,IDONE,ISET)
        END IF
        IF(ISET.EQ.0) WRITE(LFNPR,3000)
        IF(ISET.EQ.1) WRITE(LFNPR,3010)
        IF(ISET.EQ.2) WRITE(LFNPR,3020)
        IF(ISET.EQ.3) WRITE(LFNPR,3030)
      END IF
      CALL NBCLOS(DEL)
      RETURN
C
 2100 FORMAT(/1X,78('-'),/,3X,
     +'Energy of deletion : ',F20.9,/,3X,
     +'  Total SCF energy : ',F20.9,/,3X,
     +'                       -------------------',/,3X,
     +'     Energy change : ',F17.6,' a.u.,   ',F13.3,' kcal/mol'/
     +1X,78('-'))
 2110 FORMAT(/1X,78('-'),/,3X,
     +'Energy of deletion : ',F20.9,/,3X,
     +'  Total SCF energy : ',F20.9,/,3X,
     +'                       -------------------',/,3X,
     +'     Energy change : ',F17.6,' e.V.,   ',F13.3,' kcal/mol'/
     +1X,78('-'))
 2120 FORMAT(/1X,78('-'),/,3X,
     +'Energy of deletion : ',F13.3,/,3X,
     +'  Total SCF energy : ',F13.3,/,3X,
     +'                       -------------------',/,3X,
     +'     Energy change : ',F13.3,' kcal/mol,   ',F13.3,' kcal/mol'/
     +1X,78('-'))
 2130 FORMAT(/,6X,
     +'***** WARNING *****  The variational principle has been',/,5X,
     +'  violated and the above deletion energy is invalid!!',//,5X,
     +'Probable cause:  A deletion was attempted that did not ',/,5X,
     +'have as high symmetry as was employed in the integral',/,5X,
     +'and SCF computation.  REMEDY:  Redo computation without',/,5X,
     +'symmetry if this non-symmetry-conserving deletion is still',/,5X,
     +'desired.')
 3000 FORMAT(/1X,
     +'NEXT STEP:  Evaluate the energy of the new density matrix',/,1X,
     +'            that has been constructed from the deleted NBO',/,1X,
     +'            Fock matrix by doing one SCF cycle.',//1X,78('-'))
 3010 FORMAT(/1X,
     +'NEXT STEP:  Evaluate the energy of the new density matrix',/,1X,
     +'            that has been constructed from the deleted NHO',/,1X,
     +'            Fock matrix by doing one SCF cycle.',//1X,78('-'))
 3020 FORMAT(/1X,
     +'NEXT STEP:  Evaluate the energy of the new density matrix',/,1X,
     +'            that has been constructed from the deleted NAO',/,1X,
     +'            Fock matrix by doing one SCF cycle.',//1X,78('-'))
 3030 FORMAT(/1X,
     +'NEXT STEP:  Evaluate the energy of the new density matrix',/,1X,
     +'            that has been constructed from the deleted NLMO',/,
     +1X,'            Fock matrix by doing one SCF cycle.',//1X,78('-'))
      END
C***********************************************************************
      SUBROUTINE NBODEL(A,MEMORY,IDONE,ISET)
C***********************************************************************
C
C     IDONE : continue NBO deletions [output]
C             IDONE = 1 if deletions are completed
C             IDONE = 0 otherwise
C
C     ISET  : deletion type          [output]
C             ISET = 0 for NBO deletions (default)
C             ISET = 1 for NHO deletions
C             ISET = 2 for NAO deletions
C             ISET = 3 for NLMO deletions
C
C     A(MEMORY) is scratch storage
C
C-----------------------------------------------------------------------
C 12-Jun-98  EDG  Save AO-MO transformation for all deletions
C 10-Jun-98  EDG  Clean up NEWDM and NBDELE to remove truncation
C 12-Jun-96  EDG  Add NAO and NHO deletions
C  3-Mar-94  EDG  Add UHF capabilities for NEDA
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL PACK,UNPACK
      LOGICAL DONE,ERROR,EQUAL
      DIMENSION A(MEMORY),ICH(3,2),INAM(3),ISP(3)
      DIMENSION KEYWD(6),KNAO(3),KNHO(3),KNBO(3),KNLMO(4),KAUF(3),
     +          KUNS(3)
C
C  NBO Common Blocks:
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       IATNO(MAXBAS),IBXM(MAXBAS),ISCR1(2*MAXBAS),ISCR2(2*MAXBAS)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBEDA/KFRG,NFRG,IFRG(MAXBAS),NFE(MAXBAS),NFEB(MAXBAS)
      COMMON/NBLBL/NLEW,NVAL,IAOLBL(10,MAXBAS),NAOLBL(10,MAXBAS),
     +                       NHOLBL(10,MAXBAS),NBOLBL(10,MAXBAS),
     +                       IPOLBL(10,MAXBAS)
C
      SAVE LBD,L3C,LBLNK2,LBLNK1,LHYP
      SAVE ZERO,EPS,TENTH
      SAVE KEYWD,KNAO,KNHO,KNBO,KNLMO,KAUF,KUNS
C
      DATA ZERO,EPS,TENTH/0.0D0,1.0D-5,1.0D-1/
      DATA LBD/2HBD/,L3C/2H3C/,LBLNK2/2H  /,LBLNK1/1H /,LHYP/1H-/
      DATA KNAO/1HN,1HA,1HO/,KNHO/1HN,1HH,1HO/,KNBO/1HN,1HB,1HO/
      DATA KNLMO/1HN,1HL,1HM,1HO/,KAUF/1HA,1HU,1HF/,KUNS/1HU,1HN,1HS/
C
C  Allocate memory:
C
      NSQ  = NDIM*NDIM
      N1   = 1
      N2   = N1 + NDIM
      N3   = N2 + NDIM
      N4   = N3 + NSQ
      N5   = N4 + NSQ
      N6   = N5 + NSQ
      N7   = N6 + NSQ
      NEND = N7 + NSQ
      IF(NEND.GT.MEMORY) THEN
        WRITE(LFNPR,900) NEND,MEMORY
        IDONE = 1
        RETURN
      END IF
C
C  Read orbital population method for deletions:
C
      IF(ISPIN.NE.-2) THEN
        LEN = 6
        CALL HFLD(KEYWD,LEN,ERROR)
        IF(EQUAL(KEYWD,KAUF,3)) THEN
          IPOP = 1
        ELSE IF(EQUAL(KEYWD,KUNS,3)) THEN
          IPOP = -1
        ELSE
          CALL RTNFLD
          IPOP = 0
        END IF
      END IF
C
C  Read orbital type for deletions:
C
      IF(ISPIN.NE.-2) THEN
        LEN = 6
        CALL HFLD(KEYWD,LEN,ERROR)
        IF(LEN.EQ.3.AND.EQUAL(KEYWD,KNBO,3)) THEN
          ISET = 0
        ELSE IF(LEN.EQ.3.AND.EQUAL(KEYWD,KNHO,3)) THEN
          ISET = 1
        ELSE IF(LEN.EQ.3.AND.EQUAL(KEYWD,KNAO,3)) THEN
          ISET = 2
        ELSE IF(LEN.EQ.4.AND.EQUAL(KEYWD,KNLMO,4)) THEN
          ISET = 3
          NFILE = 46
          CALL NBINQR(NFILE)
          IF(NFILE.EQ.0) THEN
            WRITE(LFNPR,950)
            IDONE = 1
            RETURN
          END IF
        ELSE
          CALL RTNFLD
          ISET = 0
        END IF
      END IF
C
C  NBO deletions:
C
C   A(N1) : NBO occupancies
C   A(N3) : AO to NBO transformation
C   A(N4) : NBO Fock matrix (triangular)
C   A(N5) : scratch
C
      IF(ISET.EQ.0) THEN
        CALL FENBO(A(N3),A(N1),A(N5),A(N5))
        CALL FEFNBO(A(N4))
C
C  NHO deletions:
C
C   A(N1) : NHO occupancies
C   A(N3) : AO to NHO transformation
C   A(N4) : NHO Fock matrix (triangular)
C   A(N5) : NAO to NHO transformation
C   A(N6) : scratch
C   A(N7) : scratch
C
      ELSE IF(ISET.EQ.1) THEN
        CALL FELBLS
        CALL FETNAO(A(N3))
        CALL FETNHO(A(N5))
        CALL MATML1(A(N3),A(N5),A(N7),NDIM,NDIM,NDIM,NBAS,NNAO,NNAO)
        CALL FEDNAO(A(N6))
        CALL SIMTRS(A(N6),A(N5),A(N7),NDIM,NNAO)
        DO 10 I = 1,NNAO
          IOFF1 = N1 + I - 1
          IOFF2 = N6 + (I - 1) * (NDIM + 1)
          A(IOFF1) = A(IOFF2)
   10   CONTINUE
        CALL FEFAO(A(N4),IWFOCK)
        CALL SIMTR1(A(N4),A(N3),A(N7),NDIM,NBAS,NBAS,NNAO)
        CALL PACK(A(N4),NDIM,NNAO)
C
C  NAO deletions:
C
C   A(N1) : NAO OCCUPANCIES
C   A(N3) : AO to NAO transformation
C   A(N4) : NAO Fock matrix (triangular)
C   A(N6) : scratch
C
      ELSE IF(ISET.EQ.2) THEN
        CALL FELBLS
        CALL FETNAO(A(N3))
        CALL FEDNAO(A(N6))
        DO 20 I = 1,NNAO
          IOFF1 = N1 + I - 1
          IOFF2 = N6 + (I - 1) * (NDIM + 1)
          A(IOFF1) = A(IOFF2)
   20   CONTINUE
        CALL FEFAO(A(N4),IWFOCK)
        CALL SIMTR1(A(N4),A(N3),A(N6),NDIM,NBAS,NBAS,NNAO)
        CALL PACK(A(N4),NDIM,NNAO)
C
C  NLMO deletions:
C
C   A(N1) : NLMO occupancies
C   A(N3) : AO to NLMO transformation
C   A(N4) : NLMO Fock matrix (triangular)
C   A(N5) : scratch
C   A(N6) : scratch
C   A(N7) : scratch
C
C  Note:  NBOs are overwritten by NLMOs on DAF (for NEDA)!
C
      ELSE IF(ISET.EQ.3) THEN
        CALL FELBLS
        CALL FENLMO(A(N3),A(N5),A(N5))
        CALL FEDRAW(A(N4),A(N6))
        CALL FESRAW(A(N6))
        CALL SIMTRS(A(N4),A(N6),A(N7),NDIM,NBAS)
        CALL SIMTR1(A(N4),A(N3),A(N7),NDIM,NBAS,NBAS,NNAO)
        DO 30 I = 1,NNAO
          IOFF1 = N1 + I - 1
          IOFF2 = N4 + (I - 1) * (NDIM + 1)
          A(IOFF1) = A(IOFF2)
   30   CONTINUE
        CALL SVNBO(A(N3),A(N1),A(N7))
        CALL FEFAO(A(N4),IWFOCK)
        CALL SIMTR1(A(N4),A(N3),A(N7),NDIM,NBAS,NBAS,NNAO)
        CALL PACK(A(N4),NDIM,NNAO)
      END IF
C
C  Delete Fock matrix elements, forming modified Fock matrix in TRF:
C
C   A(N4) : 'ISET' Fock matrix           [input]
C   A(N5) : modified Fock matrix         [output]
C   A(N7) : scratch
C
      CALL NBDELE(A(N4),A(N5),NNAO,NDIM,A(N7),NSQ,DONE,ISPIN,ISET)
C
C  If no more deletions, exit program:
C
      IF(DONE) THEN
        IDONE = 1
        RETURN
      END IF
C
C  Diagonalize mofified Fock matrix in TRF:
C
C   A(N5) : modified Fock matrix, TRF    [input]
C   A(N2) : eigenvalues of TRF           [output]
C   A(N4) : eigenvectors of TRF          [output]
C
      CALL NBJACOBI(NNAO,A(N5),A(N2),A(N4),NDIM,NDIM,0)
C
C  Construct new density matrix from eigenvectors of TRF:
C
C   A(N5) : new density matrix           [output]
C   A(N4) : eigenvectors of TRF          [input]
C   A(N2) : eigenvalues of TRF           [input]
C           new occupancies              [output]
C   A(N1) : original occupancies         [input]
C   A(N7) : scratch
C
      CALL NEWDM(A(N5),A(N4),A(N2),A(N1),A(N7),NNAO,NDIM,ISPIN,ISET,
     +           IPOP)
      CALL SVNEWT(A(N4))
C
C  Prepare new AO to MO transformation:
C
C   A(N3) : AO to 'ISET' transformation  [input]
C   A(N4) : 'ISET' to MO transformation  [input]
C   A(N6) : AO to MO transformation      [output]
C   A(N7) : scratch
C
      CALL COPY(A(N3),A(N6),NDIM,NBAS,NNAO)
      CALL MATML1(A(N6),A(N4),A(N7),NDIM,NDIM,NDIM,NBAS,NNAO,NNAO)
      CALL SVTEDA(A(N6))
C
C  Transform the new density matrix to the AO basis:
C
C   A(N3) : AO to 'ISET' transformation  [input]
C   A(N5) : new density matrix           [input]
C   A(N4) : scratch
C   A(N6) : scratch
C
      CALL NBTRSP(A(N3),NDIM,NBAS)
      CALL UNPACK(A(N5),NDIM,NNAO)
      CALL SIMTR1(A(N5),A(N3),A(N4),NDIM,NNAO,NNAO,NBAS)
      CALL PACK(A(N5),NDIM,NBAS)
      CALL SVNEWD(A(N5))
C
C  Write details of the deletions:
C
      WRITE(LFNPR,910)
      IF(ISET.EQ.0) THEN
        DO 50 IBAS = 1,NNAO
          IB = IBXM(IBAS)
          LBL = LABEL(IB,1)
          NCTR = 1
          IF(LBL.EQ.LBD) NCTR = 2
          IF(LBL.EQ.L3C) NCTR = 3
          DO 40 I = 1,3
            IAT = LABEL(IB,I+3)
            CALL CONVRT2N(IAT,ICH(I,1),ICH(I,2))
            INAM(I) = LBLNK2
            IF(IAT.GT.0) INAM(I) = NAMEAT(IATNO(IAT))
            ISP(I) = LHYP
            IF(I.GE.NCTR) ISP(I) = LBLNK1
   40     CONTINUE
          I = N1 - 1 + IBAS
          II = N2 - 1 + IBAS
          OCCCHG = A(II) - A(I)
          WRITE(LFNPR,920) IBAS,(LABEL(IB,K),K=1,3),
     +                     (INAM(K),ICH(K,1),ICH(K,2),ISP(K),K=1,3),
     +                     A(I),A(II),OCCCHG
   50   CONTINUE
      ELSE
        DO 60 IBAS = 1,NNAO
          I  = N1 - 1 + IBAS
          II = N2 - 1 + IBAS
          OCCCHG = A(II) - A(I)
          IF(ISET.EQ.1) THEN
            WRITE(LFNPR,930) IBAS,(NHOLBL(K,IBAS),K=1,10),A(I),A(II),
     +                       OCCCHG
          ELSE IF(ISET.EQ.2) THEN
            WRITE(LFNPR,930) IBAS,(NAOLBL(K,IBAS),K=1,10),A(I),A(II),
     +                       OCCCHG
          ELSE
            WRITE(LFNPR,930) IBAS,(NBOLBL(K,IBAS),K=1,10),A(I),A(II),
     +                       OCCCHG
          END IF
   60   CONTINUE
      END IF
C
C  Count electrons on NEDA fragments:
C
      IF(NFRG.NE.0) THEN
        ICNT = 0
        DO 80 I = 1,NFRG
          SUM = ZERO
          II  = N2 - 1
          DO 70 IBAS = 1,NNAO
            II = II + 1
            IF(IFRG(NBOUNI(IBAS)).EQ.I) SUM = SUM + A(II)
   70     CONTINUE
          IF(ISPIN.NE.-2) THEN
            NFE(I) = INT(SUM + TENTH)
            DIFF = ABS(SUM - DFLOAT(NFE(I)))
          ELSE
            NFEB(I) = INT(SUM + TENTH)
            DIFF = ABS(SUM - DFLOAT(NFEB(I)))
          END IF
          IF(DIFF.GT.EPS) THEN
            ICNT = ICNT + 1
            WRITE(LFNPR,940) I,SUM
          END IF
   80   CONTINUE
        IF(ICNT.NE.0) CALL NBHALT('NBODEL: error counting electrons.')
      END IF
      IDONE = 0
      RETURN
C
  900 FORMAT(/1X,'Insufficient memory in subroutine NBODEL:',/5X,
     + 'Memory needed: ',I10,'   Memory available: ',I10,/1X,
     + 'Deletions halted!')
  910 FORMAT(/1X,'Orbital occupancies:',//7X,'Orbital',19X,
     + 'No deletions   This deletion   Change',/1X,78('-'))
  920 FORMAT(1X,I3,'. ',A2,A1,'(',I2,')',3(A2,3A1),9X,F7.5,8X,F7.5,3X,
     + F8.5)
  930 FORMAT(1X,I3,'. ',10A1,21X,F7.5,8X,F7.5,3X,F8.5)
  940 FORMAT(1X,'WARNING -- Fragment',I3,' does not have an integer ',
     + 'number of electrons:',F10.5)
  950 FORMAT(/1X,'NLMO deletions require that NLMO analysis be enable',
     + 'd via the $NBO keylist.')
      END
C***********************************************************************
      SUBROUTINE NBDELE(F,TRF,NNAO,NDIM,IDEL,LEN,DONE,ISPIN,ISET)
C***********************************************************************
C 10-Jun-98  EDG  NBO deletions uses full Fock matrix, no truncation
C 12-Jun-96  EDG  Add NAO and NHO deletions
C 17-Feb-96  FAW  MSP modifications and NHO deletions
C 13-Feb-93  EDG  Need to reference IBXM array for DESTAR/NOSTAR
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL UNPACK
      LOGICAL ERROR,DONE,EQUAL,DONOR,ACCPTR,LIST1,LIST2
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       IATNO(MAXBAS),IBXM(MAXBAS),ISCR1(2*MAXBAS),ISCR2(2*MAXBAS)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBEDA/KFRG,NFRG,IFRG(MAXBAS),NFE(MAXBAS),NFEB(MAXBAS)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
C
      DIMENSION KEYWD(6),F(*),TRF(NDIM,NDIM),IDEL(LEN)
      DIMENSION LORB(3),LELE(3),LBLO(3),LDEL(3),LZERO(4),LSAME(4),
     +          LEND(3),LDESTR(6),LDELOC(5),LNOSTR(6),LATOM(4),
     +          LNOGEM(5),LNOVIC(5),LALT(4),LNEDA(4)
C
      SAVE ZERO,ISTAR,LDEL,LZERO,LEND,LALPHA,LBETA,LSAME,LORB,LELE,LBLO
      SAVE LDESTR,LNOSTR,LDELOC,LATOM,LNOVIC,LNOGEM,LALT,LNEDA
      SAVE LG,LV,LL,LR
C
      DATA ZERO/0.0D0/,HUGE/1.0D6/,ISTAR/1H*/
      DATA LDEL/1HD,1HE,1HL/,LZERO/1HZ,1HE,1HR,1HO/,LEND/1HE,1HN,1HD/
      DATA LALPHA,LBETA/1HA,1HB/,LSAME/1HS,1HA,1HM,1HE/
      DATA LORB,LELE,LBLO/1HO,1HR,1HB,1HE,1HL,1HE,1HB,1HL,1HO/
      DATA LDESTR/1HD,1HE,1HS,1HT,1HA,1HR/
      DATA LNOSTR/1HN,1HO,1HS,1HT,1HA,1HR/
      DATA LDELOC/1HD,1HE,1HL,1HO,1HC/,LATOM/1HA,1HT,1HO,1HM/
      DATA LNOVIC/1HN,1HO,1HV,1HI,1HC/,LNOGEM/1HN,1HO,1HG,1HE,1HM/
      DATA LALT/1H$,1HE,1HN,1HD/,LNEDA/1HN,1HE,1HD,1HA/
      DATA LG,LV,LL,LR/1Hg,1Hv,1H(,1H)/
C
C  THIS SUBROUTINE IS CALLED AT THE START OF EACH DELETION AND READS
C  IN FROM LFNIN THE INSTRUCTIONS FOR THIS DELETION:
C
      WRITE(LFNPR,8700)
C
C  IF OPEN SHELL, LOOK FOR FIRST LETTER OF "ALPHA" OR "BETA" KEYWORD:
C
      IF(ISPIN.NE.0.AND.IWMSP.EQ.0) THEN
        LENG = 4
        CALL HFLD(KEYWD,LENG,DONE)
        IF(EQUAL(KEYWD,LALT,4)) DONE = .TRUE.
        IF(DONE) RETURN
        IF((ISPIN.EQ.2).AND.(KEYWD(1).NE.LALPHA)) GO TO 9300
        IF((ISPIN.EQ.-2).AND.(KEYWD(1).NE.LBETA)) GO TO 9400
        IF(ISPIN.EQ.2.AND.ISET.EQ.0) WRITE(LFNPR,8100)
        IF(ISPIN.EQ.2.AND.ISET.EQ.1) WRITE(LFNPR,8101)
        IF(ISPIN.EQ.2.AND.ISET.EQ.2) WRITE(LFNPR,8102)
        IF(ISPIN.EQ.2.AND.ISET.EQ.3) WRITE(LFNPR,8103)
        IF(ISPIN.EQ.-2.AND.ISET.EQ.0) WRITE(LFNPR,8200)
        IF(ISPIN.EQ.-2.AND.ISET.EQ.1) WRITE(LFNPR,8201)
        IF(ISPIN.EQ.-2.AND.ISET.EQ.2) WRITE(LFNPR,8202)
        IF(ISPIN.EQ.-2.AND.ISET.EQ.3) WRITE(LFNPR,8203)
      END IF
C
C  SEARCH FOR "DELETE", "ZERO", "SAME", "DESTAR",
C             "NOSTAR", "NOGEM", "NOVIC", OR "NEDA":
C
      LENG = 4
      CALL HFLD(KEYWD,LENG,DONE)
      IF(EQUAL(KEYWD,LEND,3)) DONE = .TRUE.
      IF(EQUAL(KEYWD,LALT,3)) DONE = .TRUE.
      IF(DONE) RETURN
      IF(EQUAL(KEYWD,LZERO,3)) GO TO 600
      IF(EQUAL(KEYWD,LNOVIC,3)) GO TO 3000
      IF(EQUAL(KEYWD,LNOGEM,3)) GO TO 3010
      IF(EQUAL(KEYWD,LDESTR,3)) GO TO 5000
      IF(EQUAL(KEYWD,LNOSTR,3)) GO TO 5500
      IF(EQUAL(KEYWD,LNEDA,4)) GO TO 6000
      IF(.NOT.EQUAL(KEYWD,LDEL,3)) GO TO 9000
C
C  IF BETA DELETIONS ARE THE SAME AS THE ALPHA DELETIONS, SKIP TO 100:
C
      IF((ISPIN.EQ.-2).AND.EQUAL(KEYWD,LSAME,4)) GO TO 100
C
C  READ IN NUMBER OF ITEMS TO DELETE, NDEL:
C
      CALL IFLD(NDEL,ERROR)
      IF(ERROR) GO TO 9100
C
C  READ IN TYPE OF DELETION AND DETERMINE IF IT IS ORBITAL, ELEMENT, OR BLOCK
C
      CALL HFLD(KEYWD,LENG,DONE)
      IF(LENG.LT.3) GO TO 9200
      ITYPE = 0
      IF(EQUAL(KEYWD,LORB,3)) ITYPE = 1
      IF(EQUAL(KEYWD,LELE,3)) ITYPE = 2
      IF(EQUAL(KEYWD,LBLO,3)) ITYPE = 4
      IF(ITYPE.EQ.0) GO TO 9200
C
C  NREAD: NUMBER OF ITEMS THAT MUST BE READ:
C
      NREAD = NDEL * ITYPE
C
C  READ IN ORBITALS, ELEMENTS, OR BLOCKS:
C
      DO 20 I = 1,NREAD
        CALL IFLD(IDEL(I),ERROR)
        IF(ERROR) GO TO 9500
   20 CONTINUE
C
  100 CONTINUE
      IF(ITYPE.NE.1) GO TO 200
C
C  DELETE NDEL ORBITALS:
C
C  ORDER THE ORBITAL NUMBERS:
C
      CALL NBORDR(ISCR1,IDEL,NDEL,NDIM,ISCR2)
      IF(ISET.EQ.0) WRITE(LFNPR,8610) (IDEL(I),I=1,NDEL)
      IF(ISET.EQ.1) WRITE(LFNPR,8611) (IDEL(I),I=1,NDEL)
      IF(ISET.EQ.2) WRITE(LFNPR,8612) (IDEL(I),I=1,NDEL)
      IF(ISET.EQ.3) WRITE(LFNPR,8613) (IDEL(I),I=1,NDEL)
C
C  FILL TRF WITH THE FOCK MATRIX, DELETING REQUESTED ORBITALS:
C
      NTRI = NNAO * (NNAO+1) / 2
      CALL COPY(F,TRF,NTRI,NTRI,1)
      CALL UNPACK(TRF,NDIM,NNAO)
      DO 120 I = 1,NDEL
        II = IDEL(I)
        DO 110 JJ = 1,NNAO
          TRF(JJ,II) = ZERO
          TRF(II,JJ) = ZERO
  110   CONTINUE
        TRF(II,II) = HUGE
  120 CONTINUE
      RETURN
C
C  ELEMENT OR BLOCK DELETIONS: START BY FILLING TRF WITH FULL NBO FOCK
C  MATRIX:
C
  200 NTRI = NNAO * (NNAO+1) / 2
      CALL COPY(F,TRF,NTRI,NTRI,1)
      CALL UNPACK(TRF,NDIM,NNAO)
C
C  ZERO REQUESTED MATRIX ELEMENTS:
C
      IF(ITYPE.EQ.2) THEN
        NDEL2 = NDEL * 2
        IF(ISET.EQ.0) WRITE(LFNPR,8620) (IDEL(I),I=1,NDEL2)
        IF(ISET.EQ.1) WRITE(LFNPR,8621) (IDEL(I),I=1,NDEL2)
        IF(ISET.EQ.2) WRITE(LFNPR,8622) (IDEL(I),I=1,NDEL2)
        IF(ISET.EQ.3) WRITE(LFNPR,8623) (IDEL(I),I=1,NDEL2)
        DO 240 I = 1,NDEL
          I2 = 2 * I
          ID = IDEL(I2-1)
          JD = IDEL(I2)
          TRF(ID,JD) = ZERO
          TRF(JD,ID) = ZERO
  240   CONTINUE
        RETURN
      END IF
C
C  ZERO REQUESTED MATRIX BLOCKS (SKIP DIAGONAL ELEMENTS):
C
      IF(ITYPE.NE.4) CALL NBHALT('NBDELE: Illegal type of deletion.')
      DO 400 ID = 1,NDEL
        IDST = (ID - 1) * 4
        J1 = IDEL(IDST+1)
        J2 = IDEL(IDST+2)
        I1 = IDEL(IDST+3)
        I2 = IDEL(IDST+4)
        IF(J1.GT.J2) THEN
          IDEL(IDST+2) = J1
          IDEL(IDST+1) = J2
          J1 = IDEL(IDST+1)
          J2 = IDEL(IDST+2)
        END IF
        IF(I1.GT.I2) THEN
          IDEL(IDST+4) = I1
          IDEL(IDST+3) = I2
          I1 = IDEL(IDST+3)
          I2 = IDEL(IDST+4)
        END IF
        DO 390 I = I1,I2
          DO 380 J = J1,J2
            IF(I.NE.J) THEN
              TRF(I,J) = ZERO
              TRF(J,I) = ZERO
            END IF
  380     CONTINUE
  390   CONTINUE
  400 CONTINUE
      NDEL4 = NDEL * 4
      IF(ISET.EQ.0) WRITE(LFNPR,8640) (IDEL(I),I=1,NDEL4)
      IF(ISET.EQ.1) WRITE(LFNPR,8641) (IDEL(I),I=1,NDEL4)
      IF(ISET.EQ.2) WRITE(LFNPR,8642) (IDEL(I),I=1,NDEL4)
      IF(ISET.EQ.3) WRITE(LFNPR,8643) (IDEL(I),I=1,NDEL4)
      RETURN
C
C  DELETE INTERSECTION IN FOCK MATRIX BETWEEN ORBITAL SETS:
C
  600 ITYPE = 3
C
C  START BY FILLING TRF WITH FULL NBO FOCK MATRIX:
C
      II = 0
      DO 620 I = 1,NNAO
        DO 610 J = 1,I
          II = II + 1
          TRF(I,J) = F(II)
          TRF(J,I) = F(II)
  610   CONTINUE
  620 CONTINUE
C
C  READ IN NUMBER OF ORBITAL SETS, NDEL:
C
      CALL IFLD(NDEL,ERROR)
      IF(ERROR) GO TO 9500
C
C  CHECK THE NEXT WORD TO SEE IF IT IS "DELOCALIZATION" INSTEAD OF
C  "BLOCK":
C  (IF SO, THE BLOCK WILL BE SPECIFIED BY MOLECULAR UNITS INSTEAD OF BY
C  BLOCKS)
C
      LENG = 5
      CALL HFLD(KEYWD,LENG,DONE)
      IF(EQUAL(KEYWD,LDELOC,5)) GO TO 1000
C
C  CHECK THE WORD TO SEE IF IT IS "ATOM" INSTEAD OF "BLOCK":
C  (IF SO, THE BLOCK WILL BE SPECIFIED BY ORBITALS ON GROUPS OF ATOMS)
C
      IF(EQUAL(KEYWD,LATOM,4)) GO TO 1200
C
C  READ IN THE NUMBER OF ORBITALS IN EACH SET, NSET1 AND NSET2:
C  (SKIP THE 'BY' BETWEEN NSET1 AND NSET2)
C
      NSTART = 0
      DO 800 K = 1,NDEL
        CALL IFLD(NSET1,ERROR)
        IF(ERROR) GO TO 9500
        CALL HFLD(KEYWD,LENG,DONE)
        CALL IFLD(NSET2,ERROR)
        IF(ERROR) GO TO 9500
        NSTART = NSTART + 2
        IDEL(NSTART-1) = NSET1
        IDEL(NSTART) = NSET2
C
C  READ IN THE ORBITALS OF BOTH SETS:
C
        NTOT = NSET1 + NSET2
        DO 630 I = 1,NTOT
          CALL IFLD(IDEL(NSTART+I),ERROR)
          IF(ERROR) GO TO 9500
  630   CONTINUE
C
C  NOW, ZERO ALL INTERSECTING ELEMENTS BETWEEN THE TWO SETS:
C
        NSTRT2 = NSTART + NSET1
        DO 710 I = 1,NSET1
          ID = IDEL(NSTART+I)
          DO 700 J = 1,NSET2
            JD = IDEL(NSTRT2+J)
            IF(ID.NE.JD) THEN
              TRF(ID,JD) = ZERO
              TRF(JD,ID) = ZERO
            END IF
  700     CONTINUE
  710   CONTINUE
        NSTART = NSTART + NTOT
  800 CONTINUE
      GO TO 4000
C
C  ZEROING OF DELOCALIZATION WITHIN OR BETWEEN MOLECULAR UNITS:
C
C  USE THE NBO MOLECULAR UNIT (NBOUNI) AND NBO TYPE (NBOTYP) LISTS:
C
 1000 CONTINUE
      NSTART = 0
      DO 1100 K = 1,NDEL
C
C  SKIP THE NEXT WORD ("FROM"):
C
        CALL HFLD(KEYWD,LENG,DONE)
C
C  READ IN THE NUMBER OF THE FIRST MOLECULAR UNIT, IUNIT1:
C
        CALL IFLD(IUNIT1,ERROR)
        IF(ERROR) GO TO 9500
C
C  SKIP THE "TO" AND READ IN IUNIT2:
C
        CALL HFLD(KEYWD,LENG,DONE)
        CALL IFLD(IUNIT2,ERROR)
        IF(ERROR) GO TO 9500
        WRITE(LFNPR,8300) IUNIT1,IUNIT2
        NSTART = NSTART + 2
C
C  FIND ALL OF THE NONSTARRED (CORE/"LONE PAIR"/BOND) NBOS ON UNIT
C  IUNIT1:
C
        NSET1 = 0
        DO 1020 IBAS = 1,NNAO
          IF(NBOUNI(IBAS).EQ.IUNIT1) THEN
            IB = IBXM(IBAS)
            IF(LABEL(IB,2).NE.ISTAR) THEN
              NSET1 = NSET1 + 1
              IDEL(NSTART+NSET1) = IBAS
            END IF
          END IF
 1020   CONTINUE
        IDEL(NSTART-1) = NSET1
C
C  FIND ALL OF THE STARRED (RYDBERG/ANTIBOND) NBOS ON UNIT IUNIT2:
C
        NSET2 = 0
        NSTRT2 = NSTART + NSET1
        DO 1040 IBAS = 1,NNAO
          IF(NBOUNI(IBAS).EQ.IUNIT2) THEN
            IB = IBXM(IBAS)
            IF(LABEL(IB,2).EQ.ISTAR) THEN
              NSET2 = NSET2 + 1
              IDEL(NSTRT2+NSET2) = IBAS
            END IF
          END IF
 1040   CONTINUE
        IDEL(NSTART) = NSET2
        NTOT = NSET1 + NSET2
C
C  NOW, ZERO ALL INTERSECTING ELEMENTS BETWEEN THE TWO SETS:
C
        DO 1060 I = 1,NSET1
          ID = IDEL(NSTART+I)
          DO 1050 J = 1,NSET2
            JD = IDEL(NSTRT2+J)
            IF(ID.NE.JD) THEN
              TRF(ID,JD) = ZERO
              TRF(JD,ID) = ZERO
            END IF
 1050     CONTINUE
 1060   CONTINUE
        NSTART = NSTART + NTOT
 1100 CONTINUE
      GO TO 4000
C
C  ZEROING OF DELOCALIZATION BETWEEN GROUPS OF ATOMS:
C
 1200 CONTINUE
      MSTART = 0
      NSTART = 0
C
C  SKIP THE 'BLOCKS' BEFORE NSET1:
C
      CALL HFLD(KEYWD,LENG,DONE)
      DO 1400 K = 1,NDEL
C
C  READ IN THE NUMBER OF ATOMS IN EACH SET OF THE PAIR, NSET1 AND NSET2:
C  (SKIP THE 'BY' BETWEEN NSET1 AND NSET2)
C
        CALL IFLD(MSET1,ERROR)
        IF(ERROR) GO TO 9500
        CALL HFLD(KEYWD,LENG,DONE)
        CALL IFLD(MSET2,ERROR)
        IF(ERROR) GO TO 9500
        MSTART = MSTART + 2
        ISCR1(MSTART-1) = MSET1
        ISCR1(MSTART) = MSET2
C
C  READ IN THE ATOMS OF BOTH SETS:
C
        MTOT = MSET1 + MSET2
        DO 1220 I = 1,MTOT
          CALL IFLD(ISCR1(MSTART+I),ERROR)
          IF(ERROR) GO TO 9500
 1220   CONTINUE
        MSTRT2 = MSTART + MSET1
        WRITE(LFNPR,8350)
        WRITE(LFNPR,8634) (ISCR1(MSTART+I),I=1,MSET1)
        WRITE(LFNPR,8360)
        WRITE(LFNPR,8634) (ISCR1(MSTRT2+I),I=1,MSET2)
        WRITE(LFNPR,8370)
C
C  CONSTRUCT THE LIST OF THE TWO SETS OF ORBITALS FROM THE ATOM LISTS,
C  PLACING THE ORBITAL LIST IN IDEL IN THE STANDARD MANNER FOR ITYPE=3:
C
        NSTART = NSTART + 2
        NSET1 = 0
        NSET2 = 0
        DO 1300 JBAS = 1,NNAO
          DONOR = .FALSE.
          ACCPTR = .FALSE.
          JB = IBXM(JBAS)
          IF(LABEL(JB,2).NE.ISTAR) DONOR = .TRUE.
          IF(LABEL(JB,2).EQ.ISTAR) ACCPTR = .TRUE.
          LIST1 = .FALSE.
          LIST2 = .FALSE.
          DO 1240 J = 4,6
            JAT = LABEL(JB,J)
            IF(JAT.EQ.0) GO TO 1240
            DO 1230 I = 1,MSET1
              IAT = ISCR1(MSTART+I)
              IF(IAT.EQ.JAT) GO TO 1240
 1230       CONTINUE
            GO TO 1250
 1240     CONTINUE
          LIST1 = .TRUE.
 1250     CONTINUE
          DO 1270 J = 4,6
            JAT = LABEL(JB,J)
            IF(JAT.EQ.0) GO TO 1270
            DO 1260 I = 1,MSET2
              IAT = ISCR1(MSTRT2+I)
              IF(IAT.EQ.JAT) GO TO 1270
 1260       CONTINUE
            GO TO 1280
 1270     CONTINUE
          LIST2 = .TRUE.
 1280     CONTINUE
          IF(LIST1.AND.LIST2) GO TO 1300
          IF(.NOT.LIST1.AND..NOT.LIST2) GO TO 1300
          IF(LIST1.AND..NOT.DONOR) GO TO 1300
          IF(LIST2.AND..NOT.ACCPTR) GO TO 1300
          IF(LIST2) GO TO 1290
C
C  LIST1.AND.DONOR=.TRUE. CASE:
C
            NSET1 = NSET1 + 1
            IDEL(NSTART+NSET1) = JBAS
            GO TO 1300
C
C  LIST2.AND.ACCPTR=.TRUE. CASE:
C
 1290     CONTINUE
            NSET2 = NSET2 + 1
            ISCR2(NSET2) = JBAS
 1300   CONTINUE
C
        IDEL(NSTART-1) = NSET1
        IDEL(NSTART) = NSET2
        NTOT = NSET1 + NSET2
C
C  PLACE ORBITAL SET 2 IN IDEL:
C
        NSTRT2 = NSTART + NSET1
        DO 1320 I = 1,NSET2
          IDEL(NSTRT2+I) = ISCR2(I)
 1320   CONTINUE
C
C  NOW, ZERO ALL INTERSECTING ELEMENTS BETWEEN THE TWO SETS OF ORBITALS:
C
        DO 1340 I = 1,NSET1
          ID = IDEL(NSTART+I)
          DO 1330 J = 1,NSET2
            JD = IDEL(NSTRT2+J)
            TRF(ID,JD) = ZERO
            TRF(JD,ID) = ZERO
 1330     CONTINUE
 1340   CONTINUE
        MSTART = MSTART + NTOT
        NSTART = NSTART + NTOT
 1400 CONTINUE
      GO TO 4000
C
C  DELETE ALL VICINAL OR GEMINAL DELOCALIZATIONS:
C
 3000 IVIC = 1
      IF(ISET.NE.0.AND.ISET.NE.3) GOTO 9800
      WRITE(LFNPR,8550)
      GOTO 3020
 3010 IVIC = 0
      IF(ISET.NE.0.AND.ISET.NE.3) GOTO 9800
      WRITE(LFNPR,8560)
 3020 CONTINUE
      ITYPE = 3
C
C  START BY FILLING TRF WITH FULL NBO FOCK MATRIX:
C
      II = 0
      DO 3040 I = 1,NNAO
        DO 3030 J = 1,I
          II = II + 1
          TRF(I,J) = F(II)
          TRF(J,I) = F(II)
 3030   CONTINUE
 3040 CONTINUE
C
C  FIND THE TOTAL NUMBER OF BLOCKS OF THE FOCK MATRIX TO DELETE:
C
      NDEL = 0
      NSTART = 0
      DO 3070 IBAS = 1,NNAO
        IB = IBXM(IBAS)
        IF(LABEL(IB,2).NE.ISTAR) THEN
          NACC = 0
          DO 3060 JBAS = 1,NNAO
            JB = IBXM(JBAS)
            IF(LABEL(JB,2).EQ.ISTAR) THEN
              ITMP = IHTYP(IBAS,JBAS)
C
C  VICINAL DELOCALIZATION:
C
              IF(IVIC.EQ.1.AND.ITMP.EQ.LV) THEN
                NACC = NACC + 1
                IDEL(NSTART+NACC+3) = JBAS
C
C  GEMINAL DELOCALIZATION:
C
              ELSE IF(IVIC.EQ.0.AND.ITMP.EQ.LG) THEN
                NACC = NACC + 1
                IDEL(NSTART+NACC+3) = JBAS
              END IF
            END IF
 3060     CONTINUE
          IF(NACC.GT.0) THEN
            NDEL = NDEL + 1
            IDEL(NSTART+1) = 1
            IDEL(NSTART+2) = NACC
            IDEL(NSTART+3) = IBAS
            DO 3065 JB = 1,NACC
              JBAS = IDEL(NSTART+JB+3)
              IF(JBAS.NE.IBAS) THEN
                TRF(IBAS,JBAS) = ZERO
                TRF(JBAS,IBAS) = ZERO
              END IF
 3065       CONTINUE
            NSTART = NSTART + NACC + 3
            IF(NSTART.GT.LEN)
     *         CALL NBHALT('NBDELE: Increase dimension of array IDEL.')
          END IF
        END IF
 3070 CONTINUE
      GOTO 4000
C
C  WRITE OUT INFORMATION FROM DELETION, FOR ITYPE=3 OR ITYPE=5:
C
 4000 CONTINUE
      INDX = 0
      DO 4050 K = 1,NDEL
        NSET1 = IDEL(INDX+1)
        NSET2 = IDEL(INDX+2)
        INDX = INDX + 2
        NL = INDX + 1
        NU = INDX + NSET1
        IF(ISET.EQ.0) WRITE(LFNPR,8630)
        IF(ISET.EQ.1) WRITE(LFNPR,8631)
        IF(ISET.EQ.2) WRITE(LFNPR,8632)
        IF(ISET.EQ.3) WRITE(LFNPR,8633)
        WRITE(LFNPR,8634) (IDEL(I),I=NL,NU)
        WRITE(LFNPR,8635)
        NL = INDX + NSET1 + 1
        NU = INDX + NSET1 + NSET2
        WRITE(LFNPR,8634) (IDEL(I),I=NL,NU)
        INDX = NU
 4050 CONTINUE
      RETURN
C
C  DELETE ALL THE "STAR" NBOS ON ONE OR MORE MOLECULES:
C  (SET ITYPE=1 FOR ORBITAL DELETIONS)
C
 5000 CONTINUE
      IF(ISET.NE.0.AND.ISET.NE.3) GOTO 9800
      ITYPE = 1
C
C  READ IN THE NUMBER OF MOLECULAR UNITS TO "DESTAR":
C
      CALL IFLD(NUNITS,ERROR)
      IF(ERROR) GO TO 9500
C
C  SKIP THE KEYWORD "UNITS":
C
      LENG = 3
      CALL HFLD(KEYWD,LENG,DONE)
C
C  READ IN THE NUMBERS OF THE UNITS TO DESTAR, FINDING THE STAR ORBITALS
C  FROM THE LISTS NBOUNI AND NBOTYP:
C
      NDEL = 0
      DO 5100 I = 1,NUNITS
        CALL IFLD(IUNIT,ERROR)
        IF(ERROR) GO TO 9500
        WRITE(LFNPR,8400) IUNIT
        DO 5050 IBAS = 1,NNAO
          IF(NBOUNI(IBAS).EQ.IUNIT) THEN
            IB = IBXM(IBAS)
            IF(LABEL(IB,2).EQ.ISTAR) THEN
              NDEL = NDEL + 1
              IDEL(NDEL) = IBAS
            END IF
          END IF
 5050   CONTINUE
 5100 CONTINUE
      GO TO 100
C
C  DELETE ALL STAR NBOS:
C
 5500 CONTINUE
      IF(ISET.NE.0.AND.ISET.NE.3) GOTO 9800
      ITYPE = 1
      NDEL = 0
      WRITE(LFNPR,8500)
      DO 5600 IBAS = 1,NNAO
        IB = IBXM(IBAS)
        IF(LABEL(IB,2).EQ.ISTAR) THEN
          NDEL = NDEL + 1
          IDEL(NDEL) = IBAS
        END IF
 5600 CONTINUE
      GO TO 100
C
C  NATURAL ENERGY DECOMPOSITION ANALYSIS:
C
 6000 CONTINUE
      IF(ISET.NE.0.AND.ISET.NE.3) GOTO 9900
      ITYPE = 5
      WRITE(LFNPR,8570)
C
C  COUNT UP NUMBER OF MOLECULAR UNITS, NUNIT, AND COPY NBOUNI TO
C  SCRATCH:
C
      NUNIT = 0
      DO 6010 I = 1,NNAO
        NUNIT = MAX(NUNIT,NBOUNI(I))
        ISCR1(I) = NBOUNI(I)
 6010 CONTINUE
C
C  INITIALIZE IFRG ARRAY:
C
      NFRG = 0
      DO 6020 I = 1,NUNIT
        IFRG(I) = 0
 6020 CONTINUE
C
C  READ FRAGMENTS UNTIL `END' IS ENCOUNTERED:
C
 6030 LENG = 6
      CALL HFLD(KEYWD,LENG,ERROR)
      IF(EQUAL(KEYWD,LEND,3)) GOTO 6040
      IL = 1
      IU = LENG
      IF(EQUAL(KEYWD(IL),LL,1)) THEN
        IL = IL + 1
        NFRG = NFRG + 1
      END IF
      IF(EQUAL(KEYWD(LENG),LR,1)) IU = LENG - 1
      IU = IU - IL + 1
      IF(IU.GT.0) THEN
        CALL CONVIN(KEYWD(IL),IU,IUNIT,ERROR)
        IF(ERROR) GOTO 9600
        IF(IUNIT.GT.NUNIT) GOTO 9700
        IFRG(IUNIT) = NFRG
      END IF
      GO TO 6030
C
 6040 CONTINUE
      DO 6050 I = 1,NUNIT
        IF(IFRG(I).EQ.0) THEN
          NFRG = NFRG + 1
          IFRG(I) = NFRG
        END IF
 6050 CONTINUE
      IF(NFRG.GT.NUNIT) CALL NBHALT('NBDELE: Too many fragments.')
      DO 6060 I = 1,NNAO
        ISCR1(I) = IFRG(ISCR1(I))
 6060 CONTINUE
C
C  START BY FILLING TRF WITH FULL NBO FOCK MATRIX:
C
      II = 0
      DO 6080 I = 1,NNAO
        DO 6070 J = 1,I
          II = II + 1
          TRF(I,J) = F(II)
          TRF(J,I) = F(II)
 6070   CONTINUE
 6080 CONTINUE
C
C  LOOP OVER FRAGMENTS, ZEROING OFF-DIAGONAL BLOCKS OF ELEMENTS:
C
      NDEL = NFRG
      IF(NDEL.EQ.2) NDEL = 1
      NSTART = 1
      DO 6110 IFRAG = 1,NDEL
        II = NSTART + 1
C
C  FORM A LIST OF ALL NBOS ON THE CURRENT FRAGMENT:
C
        DO 6090 IBAS = 1,NNAO
          IF(ISCR1(IBAS).EQ.IFRAG) THEN
            II = II + 1
            IDEL(II) = IBAS
          END IF
 6090   CONTINUE
        IDEL(NSTART) = II - NSTART - 1
C
C  FORM A LIST OF ALL NBOS ON OTHER FRAGMENTS:
C
        DO 6100 IBAS = 1,NNAO
          IF(ISCR1(IBAS).NE.IFRAG) THEN
            II = II + 1
            IDEL(II) = IBAS
          END IF
 6100   CONTINUE
        IDEL(NSTART+1) = II - NSTART - IDEL(NSTART) - 1
        NSTART = II + 1
 6110 CONTINUE
C
C  ZERO ELEMENTS IN FOCK MATRIX:
C
      NSTART = 1
      DO 6140 IFRAG = 1,NDEL
        IL = NSTART + 2
        IU = IL + IDEL(NSTART) - 1
        JL = IU + 1
        JU = JL + IDEL(NSTART+1) - 1
        DO 6130 I = IL,IU
          II = IDEL(I)
          DO 6120 J = JL,JU
            JJ = IDEL(J)
            TRF(II,JJ) = ZERO
            TRF(JJ,II) = ZERO
 6120     CONTINUE
 6130   CONTINUE
        NSTART = JU + 1
 6140 CONTINUE
      GO TO 4000
C
 8100 FORMAT(1X,' ----------- Alpha spin NBO deletions ----------- '/)
 8101 FORMAT(1X,' ----------- Alpha spin NHO deletions ----------- '/)
 8102 FORMAT(1X,' ----------- Alpha spin NAO deletions ----------- '/)
 8103 FORMAT(1X,' ----------- Alpha spin NLMO deletions ----------- '/)
 8200 FORMAT(1X,' ----------- Beta  spin NBO deletions ----------- '/)
 8201 FORMAT(1X,' ----------- Beta  spin NHO deletions ----------- '/)
 8202 FORMAT(1X,' ----------- Beta  spin NAO deletions ----------- '/)
 8203 FORMAT(1X,' ----------- Beta  spin NLMO deletions ----------- '/)
 8300 FORMAT(1X,'Zero delocalization from unit ',I2,' to unit ',I2)
 8350 FORMAT(1X,'Zero delocalization from NBOs localized on atoms:')
 8360 FORMAT(1X,'to NBOs localized on atoms:')
 8370 FORMAT(1X,'    (NBOs in common to the two groups of atoms ',
     *  'left out)')
 8400 FORMAT(1X,'DESTAR unit ',I2,': Delete all Rydberg/antibond',
     * ' NBOs from this unit')
 8500 FORMAT(1X,'NOSTAR: Delete all Rydberg/antibond NBOs')
 8550 FORMAT(1X,'NOVIC: Delete all vicinal delocalizations')
 8560 FORMAT(1X,'NOGEM: Delete all geminal delocalizations')
 8570 FORMAT(1X,'NEDA: Natural Energy Decomposition Analysis')
 8610 FORMAT(1X,'Deletion of the following orbitals ',
     * 'from the NBO Fock matrix:',(/1X,20I4))
 8611 FORMAT(1X,'Deletion of the following orbitals ',
     * 'from the NHO Fock matrix:',(/1X,20I4))
 8612 FORMAT(1X,'Deletion of the following orbitals ',
     * 'from the NAO Fock matrix:',(/1X,20I4))
 8613 FORMAT(1X,'Deletion of the following orbitals ',
     * 'from the NLMO Fock matrix:',(/1X,20I4))
 8620 FORMAT(1X,'Deletion of the following NBO Fock matrix ',
     * 'elements:',/(7(2X,' ',I3,',',I3,';')))
 8621 FORMAT(1X,'Deletion of the following NHO Fock matrix ',
     * 'elements:',/(7(2X,' ',I3,',',I3,';')))
 8622 FORMAT(1X,'Deletion of the following NAO Fock matrix ',
     * 'elements:',/(7(2X,' ',I3,',',I3,';')))
 8623 FORMAT(1X,'Deletion of the following NLMO Fock matrix ',
     * 'elements:',/(7(2X,' ',I3,',',I3,';')))
 8630 FORMAT(1X,'Deletion of the NBO Fock matrix elements ',
     * 'between orbitals:')
 8631 FORMAT(1X,'Deletion of the NHO Fock matrix elements ',
     * 'between orbitals:')
 8632 FORMAT(1X,'Deletion of the NAO Fock matrix elements ',
     * 'between orbitals:')
 8633 FORMAT(1X,'Deletion of the NLMO Fock matrix elements ',
     * 'between orbitals:')
 8634 FORMAT(1X,20I4)
 8635 FORMAT(1X,'and orbitals:')
 8640 FORMAT(1X,'Deletion of the following NBO Fock matrix ',
     * 'blocks:',/(2(2X,'(',I3,'-',I3,'/',I3,'-',I3,')')))
 8641 FORMAT(1X,'Deletion of the following NHO Fock matrix ',
     * 'blocks:',/(2(2X,'(',I3,'-',I3,'/',I3,'-',I3,')')))
 8642 FORMAT(1X,'Deletion of the following NAO Fock matrix ',
     * 'blocks:',/(2(2X,'(',I3,'-',I3,'/',I3,'-',I3,')')))
 8643 FORMAT(1X,'Deletion of the following NLMO Fock matrix ',
     * 'blocks:',/(2(2X,'(',I3,'-',I3,'/',I3,'-',I3,')')))
 8700 FORMAT(/)
C
C  ERROR MESSAGES:
C
 9000 WRITE(LFNPR,9010) (KEYWD(I),I=1,3)
 9010 FORMAT(1X,'First character string does not have the',
     * ' first three letters of DELETE or ZERO:',/1X,3A1)
      CALL NBHALT('Keyword DELETE or ZERO not found in $DEL keylist.')
 9100 CALL NBHALT('Non-integer input for number of items to delete.')
 9200 WRITE(LFNPR,9210) (KEYWD(I),I=1,3)
 9210 FORMAT(1X,'No match with first three letters of the keywords ',
     * 'for deletion type'/' (ORBITAL,ELEMENT,BLOCK) found: ',3A1)
      CALL NBHALT('No keyword ORBITAL, ELEMENT, or BLOCK found.')
 9300 CALL NBHALT('Keyword ALPHA (or A) not found for alpha deletion.')
 9400 CALL NBHALT('Keyword BETA (or B) not found for beta deletion.')
 9500 CALL NBHALT('Error in deletion input.')
 9600 WRITE(LFNPR,9610) (KEYWD(I),I=1,LENG)
 9610 FORMAT(1X,'Unrecognizable word in NEDA input: ',6A1)
      CALL NBHALT('Unrecognizable word in NEDA input.')
 9700 WRITE(LFNPR,9710) NUNIT,IUNIT
 9710 FORMAT(1X,'The NBO program only recognizes',I3,' molecular units',
     + ' in this calculation.',/1X,'Unit',I3,' was requested in the ',
     + 'NEDA input.')
      CALL NBHALT('Nonexistent molecular unit requested in NEDA input.')
 9800 WRITE(LFNPR,9810)
 9810 FORMAT(1X,'Only DELETE ELEMENTS, ORBITALS, or BLOCKS is allowed ',
     + 'for NAO/NHO deletions.')
      CALL NBHALT('Invalid NAO/NHO deletion.')
 9900 CALL NBHALT('NEDA can only be performed in NBO or NLMO basis.')
      END
C***********************************************************************
      SUBROUTINE NEWDM(DM,U,EIG,OCC,SCR,NNAO,NDIM,ISPIN,ISET,IPOP)
C***********************************************************************
C 27-Jul-06  EDG  Opt to populate orbitals by unstarred or energy
C 30-Aug-01  EDG  Treat linear dependence
C 12-Jun-98  EDG  Occupied MOs first in U for NWChem
C 10-Jun-98  EDG  Remove Fock matrix truncation
C 12-Jun-96  EDG  Use Fock matrix eigenvalues for NAO/NHO deletions
C  1-Dec-94  EDG  Occupy unstarred orbitals, if possible.  Otherwise,
C                 occupy according to the eigenvalues of the Fock matrix
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       IATNO(MAXBAS),IBXM(MAXBAS),NRANK(2*MAXBAS),LOCC(2*MAXBAS)
C
      DIMENSION DM(NDIM*(NDIM+1)/2),U(NDIM,NDIM),EIG(NDIM),OCC(NDIM),
     +          SCR(NDIM)
C
      SAVE ZERO,TENTH,ONE,TWO,ISTAR
      DATA ZERO/0.0D0/,TENTH/0.1D0/,ONE/1.0D0/,TWO/2.0D0/,ISTAR/1H*/
C
C  ETA:  (MO occupancy)
C
      ETA = TWO
      IF(ISPIN.NE.0) ETA = ONE
C
C  Determine number of occupied MOs:
C
      TOTE = ZERO
      DO 10 I = 1,NNAO
        TOTE = TOTE + OCC(I)
   10 CONTINUE
      NMOOCC = INT(TOTE/ETA + TENTH)
C
C  Prepare list (LOCC) of occupied MOs:
C
C  Populate unstarred orbitals (NBOs and NLMOs only, default):
C
      IF((ISET.EQ.0.OR.ISET.EQ.3).AND.(IPOP.NE.1)) THEN
        NOCC = 0
        DO 20 I = 1,NNAO
          IF(LABEL(IBXM(I),2).NE.ISTAR) THEN
            NOCC = NOCC + 1
            LOCC(NOCC) = I
          END IF
   20   CONTINUE
        IF(NMOOCC.NE.NOCC)
     +     CALL NBHALT('NEWDM: too many or few unstarred orbitals.')
        DO 25 I = 1,NNAO
          IF(LABEL(IBXM(I),2).EQ.ISTAR) THEN
            NOCC = NOCC + 1
            LOCC(NOCC) = I
          END IF
   25   CONTINUE
      ELSE
C
C  Otherwise, populate orbitals by energy:
C
        CALL RNKEIG(NRANK,EIG,NNAO,NDIM,LOCC)
      END IF
C
C  Reorder U so that the occupied MOs are first in the list:
C
      NOCC = NMOOCC
      DO 30 I = 1,NNAO
        NRANK(I) = I
   30 CONTINUE
      DO 50 I = 1,NNAO
        DO 40 J = 1,NNAO
          IF(NRANK(J).EQ.LOCC(I)) THEN
            NRANK(J) = NRANK(I)
            NRANK(I) = LOCC(I)
            IF(I.NE.J) THEN
              CALL COPY(U(1,I),SCR,NDIM,NNAO,1)
              CALL COPY(U(1,J),U(1,I),NDIM,NNAO,1)
              CALL COPY(SCR,U(1,J),NDIM,NNAO,1)
              IF(ISET.EQ.0.OR.ISET.EQ.3) THEN
                TMP    = EIG(I)
                EIG(I) = EIG(J)
                EIG(J) = TMP
              END IF
            END IF
            GOTO 50
          END IF
   40   CONTINUE
        CALL NBHALT('NEWDM: Error sorting MOs.')
   50 CONTINUE
      CALL SVEIG(EIG)
C
C  Construct the modified density matrix from the eigenvectors (U) of
C  the modified Fock matrix:
C
      II = 0
      IJ = 0
      DO 80 I = 1,NNAO
        II = II + 1
        JJ = 0
        DO 70 J = 1,I
          JJ = JJ + 1
          SUM = ZERO
          DO 60 K = 1,NOCC
            SUM = SUM + U(II,K) * U(JJ,K)
   60     CONTINUE
          IJ = IJ + 1
          DM(IJ) = SUM * ETA
          IF(I.EQ.J) EIG(I) = DM(IJ)
   70   CONTINUE
   80 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE RNKEIG(RANK,EIG,N,NDIM,ARCRNK)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  RANK EIGENVALUES IN 'EIG', LOWEST VALUES FIRST, IN 'RANK':
C
      INTEGER RANK,ARCRNK
      DIMENSION RANK(NDIM),EIG(NDIM),ARCRNK(NDIM)
      DO 10 I=1,N
   10   ARCRNK(I)=I
      DO 40 I=1,N
        IF(I.EQ.N) GO TO 30
         I1=I+1
         DO 20 J=I1,N
         IF(EIG(J).GE.EIG(I)) GO TO 20
           TEMP=EIG(I)
           EIG(I)=EIG(J)
           EIG(J)=TEMP
           ITEMP=ARCRNK(I)
           ARCRNK(I)=ARCRNK(J)
           ARCRNK(J)=ITEMP
   20     CONTINUE
   30    RANK(ARCRNK(I))=I
   40   CONTINUE
      RETURN
      END
C***********************************************************************
C NBO 5.G -- Natural Bond Orbital Analysis Programs
C (c) Copyright 1996-2008 Board of Regents of the University of Wisconsin System
C     on behalf of the Theoretical Chemistry Institute.  All Rights Reserved.
C***********************************************************************
C
C  NBO DIRECT ACCESS FILE (DAF) ROUTINES:
C
C      SUBROUTINE NBFILE(NEW,ERROR)
C      SUBROUTINE NBOPEN(NEW,ERROR)
C      SUBROUTINE NBWRIT(IX,NX,IDAR)
C      SUBROUTINE NBREAD(IX,NX,IDAR)
C      SUBROUTINE NBCLOS(SEQ)
C      SUBROUTINE NBINQR(IDAR)
C
C      SUBROUTINE FETITL(TITLE)
C      SUBROUTINE FEE0(EDEL,ETOT)
C      SUBROUTINE SVE0(EDEL)
C      SUBROUTINE FECOOR(ATCOOR)
C      SUBROUTINE FESRAW(S)
C      SUBROUTINE FEDRAW(DM,SCR)
C      SUBROUTINE FEFAO(F,IWFOCK)
C      SUBROUTINE FEAOMO(T,IT)
C      SUBROUTINE FEDXYZ(DXYZ,I)
C      SUBROUTINE FEKAO(T,IT)
C      SUBROUTINE FEVAO(V,IV)
C      SUBROUTINE SVCHK(T,IS)
C      SUBROUTINE FECHK(T,IS,IT)
C      SUBROUTINE SVNBO(T,OCC,ISCR)
C      SUBROUTINE FENBO(T,OCC,ISCR)
C      SUBROUTINE FETNBO(T)
C      SUBROUTINE SVPNAO(T)
C      SUBROUTINE FEPNAO(T)
C      SUBROUTINE SVSNAO(S)
C      SUBROUTINE FESNAO(S)
C      SUBROUTINE SVTNAB(T)
C      SUBROUTINE FETNAB(T)
C      SUBROUTINE SVTLMO(T)
C      SUBROUTINE FETLMO(T)
C      SUBROUTINE SVTNHO(T)
C      SUBROUTINE FETNHO(T)
C      SUBROUTINE SVTPAO(T)
C      SUBROUTINE FETPAO(T)
C      SUBROUTINE SVPPAO(DM)
C      SUBROUTINE FEPPAO(DM)
C      SUBROUTINE SVTNAO(T)
C      SUBROUTINE FETNAO(T)
C      SUBROUTINE SVNLMO(T)
C      SUBROUTINE FENLMO(T,ISCR)
C      SUBROUTINE SVDNAO(DM)
C      SUBROUTINE FEDNAO(DM)
C      SUBROUTINE SVFNBO(F)
C      SUBROUTINE FEFNBO(F)
C      SUBROUTINE SVNEWD(DM)
C      SUBROUTINE FENEWD(DM)
C      SUBROUTINE FEINFO(ICORE,ISWEAN)
C      SUBROUTINE FEBAS(NSHELL,NEXP,ISCR)
C      SUBROUTINE FENBLB(ISCR)
C      SUBROUTINE FESPIN(DM,SCR)
C      SUBROUTINE SVLBLS
C      SUBROUTINE FELBLS
C
C***********************************************************************
      SUBROUTINE NBFILE(NEW,ERROR)
C***********************************************************************
C 25-Jun-95  EDG  Prevent multiple OPENs of FILE.46
C 29-Aug-94  JKB  Added code to open FILE.46 with FILE.47 if ARCHIVE
C 10-Feb-93  EDG  Moved sequential file OPENs to SR SQFILE
C 28-Jan-93  JKB  Added code to support MO-, K-, and V- related I/O
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL NEW,ERROR,NEED
C
      PARAMETER (MAXFIL = 40)
C
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBNAME/FILENM,NFILE,IFILE(MAXFIL)
      CHARACTER*256 FILENM
C
      SAVE IREAD
      DATA IREAD/4HREAD/
C
C  Create a list IFILE of external LFNs.  First find the files that
C  will be written:
C
      ERROR = .FALSE.
      NFILE = 0
      DO 10 I = 1,999
        NEED = .FALSE.
        IF(IWPNAO.EQ.-I)     NEED = .TRUE.
        IF(IWTNAO.EQ.-I)     NEED = .TRUE.
        IF(IWTNAB.EQ.-I)     NEED = .TRUE.
        IF(IWTNBO.EQ.-I)     NEED = .TRUE.
        IF(IWNBBP.EQ.-I)     NEED = .TRUE.
        IF(JPRINT(7).EQ. I)  NEED = .TRUE.
        IF(JPRINT(9).EQ.-I)  NEED = .TRUE.
        IF(JPRINT(13).EQ.-I) NEED = .TRUE.
        IF(JPRINT(15).EQ.-I) NEED = .TRUE.
        IF(JPRINT(16).EQ.-I) NEED = .TRUE.
        IF(JPRINT(17).EQ.-I) NEED = .TRUE.
        IF(JPRINT(18).EQ.-I) NEED = .TRUE.
        IF(JPRINT(19).EQ.-I) NEED = .TRUE.
        IF(JPRINT(20).EQ.-I) NEED = .TRUE.
        IF(JPRINT(21).EQ.-I) NEED = .TRUE.
        IF(JPRINT(22).EQ. I) NEED = .TRUE.
        IF(JPRINT(23).EQ.-I) NEED = .TRUE.
        IF(JPRINT(24).EQ.-I) NEED = .TRUE.
        IF(JPRINT(25).EQ.-I) NEED = .TRUE.
        IF(JPRINT(26).EQ.-I) NEED = .TRUE.
        IF(JPRINT(27).EQ.-I) NEED = .TRUE.
        IF(JPRINT(28).EQ.-I) NEED = .TRUE.
        IF(JPRINT(29).EQ.-I) NEED = .TRUE.
        IF(JPRINT(30).EQ.-I) NEED = .TRUE.
        IF(JPRINT(31).EQ.-I) NEED = .TRUE.
        IF(JPRINT(33).EQ.-I) NEED = .TRUE.
        IF(JPRINT(34).EQ.-I) NEED = .TRUE.
        IF(JPRINT(35).EQ.-I) NEED = .TRUE.
        IF(JPRINT(37).EQ.-I) NEED = .TRUE.
        IF(JPRINT(38).EQ.-I) NEED = .TRUE.
        IF(JPRINT(39).EQ.-I) NEED = .TRUE.
        IF(JPRINT(40).EQ.-I) NEED = .TRUE.
        IF(JPRINT(41).EQ.-I) NEED = .TRUE.
        IF(JPRINT(42).EQ.-I) NEED = .TRUE.
        IF(JPRINT(43).EQ. I) NEED = .TRUE.
        IF(JPRINT(44).EQ.-I) NEED = .TRUE.
        IF(JPRINT(45).EQ.-I) NEED = .TRUE.
        IF(JPRINT(47).EQ.-I) NEED = .TRUE.
        IF(JPRINT(48).EQ.-I) NEED = .TRUE.
        IF(JPRINT(49).EQ.-I) NEED = .TRUE.
        IF(JPRINT(50).EQ.-I) NEED = .TRUE.
        IF(JPRINT(51).EQ.-I) NEED = .TRUE.
        IF(JPRINT(52).EQ.-I) NEED = .TRUE.
        IF(JPRINT(53).EQ.-I) NEED = .TRUE.
        IF(JPRINT(54).EQ.-I) NEED = .TRUE.
        IF(JPRINT(58).EQ.-I) NEED = .TRUE.
        IF(JPRINT(59).EQ.-I) NEED = .TRUE.
        IF(JPRINT(60).EQ.-I) NEED = .TRUE.
        IF(JPRINT(61).EQ.-I) NEED = .TRUE.
        IF(JPRINT(62).EQ.-I) NEED = .TRUE.
        IF(JPRINT(64).EQ.-I) NEED = .TRUE.
        IF(JPRINT(65).EQ.-I) NEED = .TRUE.
        IF(JPRINT(66).EQ.-I) NEED = .TRUE.
        IF(JPRINT(67).EQ.-I) NEED = .TRUE.
        IF(JPRINT(68).EQ.-I) NEED = .TRUE.
        IF(JPRINT(69).EQ.-I) NEED = .TRUE.
        IF(JPRINT(70).EQ.-I) NEED = .TRUE.
        IF(JPRINT(71).EQ.-I) NEED = .TRUE.
        IF(JPRINT(72).EQ.-I) NEED = .TRUE.
        IF(JPRINT(73).EQ.-I) NEED = .TRUE.
        IF(JPRINT(74).EQ.-I) NEED = .TRUE.
        IF(JPRINT(75).EQ.-I) NEED = .TRUE.
        IF(JPRINT(83).EQ.-I) NEED = .TRUE.
        IF(JPRINT(84).EQ. I) NEED = .TRUE.
        IF(JPRINT(84).EQ.-I) NEED = .TRUE.
        IF(NEED) THEN
          NFILE = NFILE + 1
          IF(NFILE.GT.MAXFIL) THEN
            WRITE(LFNPR,900) MAXFIL
            ERROR = .TRUE.
            RETURN
          END IF
          IFILE(NFILE) = I
        END IF
   10 CONTINUE
C
C  Add files that may be read:
C
      MFILE = NFILE
      IF(IOINQR(IWPNAO).EQ.IREAD) THEN
        MFILE = MFILE + 1
        IF(MFILE.GT.MAXFIL) THEN
          WRITE(LFNPR,900) MAXFIL
          ERROR = .TRUE.
          RETURN
        END IF
        IFILE(MFILE) = IWPNAO/1000
      END IF
      IF(IOINQR(IWTNAO).EQ.IREAD) THEN
        MFILE = MFILE + 1
        IF(MFILE.GT.MAXFIL) THEN
          WRITE(LFNPR,900) MAXFIL
          ERROR = .TRUE.
          RETURN
        END IF
        IFILE(MFILE) = IWTNAO/1000
      END IF
      IF(IOINQR(IWTNAB).EQ.IREAD) THEN
        MFILE = MFILE + 1
        IF(MFILE.GT.MAXFIL) THEN
          WRITE(LFNPR,900) MAXFIL
          ERROR = .TRUE.
          RETURN
        END IF
        IFILE(MFILE) = IWTNAB/1000
      END IF
C      IF(IOINQR(IWNBBP).EQ.IREAD) THEN
C        MFILE = MFILE + 1
C        IF(MFILE.GT.MAXFIL) THEN
C          WRITE(LFNPR,900) MAXFIL
C          ERROR = .TRUE.
C          RETURN
C        END IF
C        IFILE(MFILE) = IWNBBP/1000
C      END IF
C
C  Make sure that no files are both written and read:
C
      DO 30 I = NFILE+1,MFILE
        DO 20 J = 1,NFILE
          IF(ABS(IFILE(I)).EQ.IFILE(J)) THEN
            WRITE(LFNPR,910) IFILE(J)
            ERROR = .TRUE.
            RETURN
          END IF
   20   CONTINUE
   30 CONTINUE
      NFILE = MFILE
C
C  Also check that the NBO DAF has its own LFN:
C
      DO 40 I = 1,NFILE
        IF(ABS(IFILE(I)).EQ.ABS(LFNDAF)) THEN
          WRITE(LFNPR,910) IFILE(I)
          ERROR = .TRUE.
          RETURN
        END IF
   40 CONTINUE
C
C  Open sequential files:
C
      CALL SQFILE(NEW,ERROR)
      RETURN
C
  900 FORMAT(/1X,'I/O is limited to ',I2,' files.  Program abort.')
  910 FORMAT(/1X,'Illegal request for input and output with LFN',I3)
      END
C***********************************************************************
      SUBROUTINE NBOPEN(NEW,ERROR)
C***********************************************************************
C 12-Jun-96  EDG  Added COMMON /NBLBL/ and NAO-NHO transformations (62-65)
C 16-May-96  EDG  Moved ESS-dependent code to DAFILE
C 17-Jan-95  EDG  Add records 88-90 for extended NEDA
C 19-Aug-93  EDG  Add records for NBO trans and labels for NRT structures,
C                 Extend NBDAR to 300
C 17-Feb-93  FAW  Open files with filename of length NL instead of 256
C 22-Jan-93  EDG  Moved machine dependent portion to SR DAFILE
C 19-Jan-93  EDG  Records for checkpointing transformation matrices
C 14-Jan-93  EDG  Add records for kinetic energy and nuclear attraction ints
C----------------------
C
C  The following records of the NBO direct access file (DAF) are used:
C
C          1  ---   NBODAF common block
C          2  ---   Job title
C          3  ---   NATOMS,NDIM,NBAS,NNAO,MUNIT,flags,ISWEAN,NNAO
C          4  ---   IATNO,IZNUC,LCTR,LANG
C          5  ---   AO basis set information
C          8  ---   Deletion energy, total energy
C          9  ---   Atomic coordinates
C         10  ---   AO overlap matrix
C         11  ---   PNAO overlap matrix
C         18  ---   Kinetic energy integrals
C         19  ---   Nuclear attraction integrals
C         20  ---   AO density matrix (alpha)
C         21  ---   AO density matrix (beta)
C         22  ---   Pure AO density matrix
C         23  ---   NAO density matrix (alpha)
C         24  ---   NAO density matrix (beta)
C         25  ---   AO density matrix with NBO deletions (alpha)
C         26  ---   AO density matrix with NBO deletions (beta)
C         27  ---   NBO occupancies (alpha)
C         28  ---   NBO occupancies (beta)
C         30  ---   AO Fock matrix (alpha)
C         31  ---   AO Fock matrix (beta)
C         32  ---   NAO Fock matrix (alpha)
C         33  ---   NAO Fock matrix (beta)
C         34  ---   NBO Fock matrix (alpha)
C         35  ---   NBO Fock matrix (beta)
C         39  ---   AO to pure AO (PAO) tranformation
C         40  ---   AO to MO transformation matrix (alpha)
C         41  ---   AO to MO transformation matrix (beta)
C         42  ---   AO to PNAO transformation matrix
C         43  ---   AO to NAO transformation matrix
C         44  ---   AO to NBO transformation matrix  (alpha)
C         45  ---   AO to NBO transformation matrix  (beta)
C         46  ---   AO to NLMO transformation matrix (alpha)
C         47  ---   AO to NLMO transformation matrix (beta)
C         48  ---   NAO to NBO transformation matrix
C         49  ---   NBO to NLMO transformation matrix
C         50  ---   X dipole integrals
C         51  ---   Y dipole integrals
C         52  ---   Z dipole integrals
C         60  ---   NBO labels (alpha)
C         61  ---   NBO labels (beta)
C         62  ---   Orbital labels (COMMON /NBLBL/, alpha)
C         63  ---   Orbital labels (COMMON /NBLBL/, beta)
C         64  ---   NAO to NHO transformation matrix (alpha)
C         65  ---   NAO to NHO transformation matrix (beta)
C         70  ---   Deletion energies for NEDA
C         71  ---   MO transformation for NEDA/NBO deletions (alpha)
C         72  ---   MO transformation for NEDA/NBO deletions (beta)
C         75  ---   Scratch storage for NEDA (see DELSCF)
C         76  ---   Scratch storage for NEDA (see DELSCF)
C         77  ---   Scratch storage for NEDA (see DELSCF)
C         78  ---   Scratch storage for NEDA (see DELSCF)
C         80  ---   Checkpoint (alpha)
C         81  ---   Checkpoint (beta)
C         82  ---   MO energies for NEDA (alpha)
C         83  ---   MO energies for NEDA (beta)
C         84  ---   AO to MO transformation for NEDA (alpha)
C         85  ---   AO to MO transformation for NEDA (beta)
C         86  ---   Density matrixes for psi(def) (alpha)
C         87  ---   Density matrixes for psi(def) (beta)
C         88  ---   Density matrixes for psi(fld) (alpha)
C         89  ---   Density matrixes for psi(fld) (beta)
C         90  ---   Density matrixes for psi(cp) (alpha)
C         91  ---   Density matrixes for psi(cp) (beta)
C         92  ---   Nuclear attraction integrals (NEDA)
C    101-300  ---   NBO transformations and labels for NRT structures;
C                   transformations and labels stored on consecutive records
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL NEW,ERROR
      CHARACTER*256 NAME
C
      PARAMETER (LENGTH = 256)
      PARAMETER (NBDAR = 300)
C
      COMMON/NBODAF/INBO,NAV,IONBO(NBDAR)
      COMMON/NBONAV/IXDNBO(LENGTH),NBNAV,ISINGL
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION IX(NBDAR+2),IXSNBO(LENGTH/2)
C
      EQUIVALENCE (IXSNBO(1),IXDNBO(1))
      EQUIVALENCE (IX(1),INBO)
C
C     INBO   :  Fortran file number
C     IONBO  :  Indexing array mapping the logical records of the
C               NBO DAF onto the physical records of the disk file
C     NAV    :  Number of physical records currently on the DAF
C     NBDAR  :  Maximum number of logical records on the DAF
C
C  Obtain machine dependent details:
C
      CALL DAFILE(NAME,NL,INBO,ISINGL,LENREC,ERROR)
      IF(ERROR) THEN
        WRITE(LFNPR,900)
        RETURN
      END IF
C
C  If this is a new NBO DAF, write COMMON/NBODAF/ on the first record:
C
      IF(NEW) THEN
        OPEN(UNIT=INBO, FILE=NAME(1:NL), STATUS='UNKNOWN',
     +       ACCESS='DIRECT', RECL=LENREC, FORM='UNFORMATTED', ERR=40)
        NAV   = 1
        NBNAV = 1
        DO 10 I = 1,NBDAR
          IONBO(I) = 0
   10   CONTINUE
        NF = 1
        NX = (NBDAR + 2) / ISINGL
        CALL NBWRIT(IX,NX,NF)
C
C  Otherwise, open the old file and read in COMMON/NBODAF/ from the
C  first record:
C
      ELSE
        OPEN(UNIT=INBO, FILE=NAME(1:NL), STATUS='OLD',
     +       ACCESS='DIRECT', RECL=LENREC, FORM='UNFORMATTED', ERR=50)
        NBNAV = 1
        MAXIX = LENGTH * ISINGL/2
        LDAR  = NBDAR + 2
        MAX = 0
   20   MIN = MAX + 1
        MAX = MAX + MAXIX
        IF(MAX.GT.LDAR) MAX = LDAR
        IF(ISINGL.EQ.1) READ(INBO,REC=NBNAV) IXSNBO
        IF(ISINGL.EQ.2) READ(INBO,REC=NBNAV) IXDNBO
        DO 30 I = MIN,MAX
          IX(I) = IXDNBO(I-MIN+1)
   30   CONTINUE
        NBNAV = NBNAV + 1
        IF(MAX.LT.LDAR) GO TO 20
        INBO = ABS(LFNDAF)
      END IF
      ERROR = .FALSE.
      RETURN
C
C  Error encountered while opening this file:
C
   40 ERROR = .TRUE.
      WRITE(LFNPR,910) NL,(NAME(K:K),K=1,NL)
      RETURN
C
   50 ERROR = .TRUE.
      WRITE(LFNPR,920) NL,(NAME(K:K),K=1,NL)
      RETURN
C
  900 FORMAT(/1X,'Unknown working precision or record length in SR ',
     + 'NBOPEN.')
  910 FORMAT(/1X,'Error opening new NBODAF: NL =',I3,'  NAME = ',40A1)
  920 FORMAT(/1X,'Error opening old NBODAF: NL =',I3,'  NAME = ',40A1)
      END
C***********************************************************************
      SUBROUTINE NBWRIT(IX,NX,IDAR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER (LENGTH = 256)
      PARAMETER (NBDAR = 300)
C
      COMMON/NBODAF/INBO,NAV,IONBO(NBDAR)
      COMMON/NBONAV/IXDNBO(LENGTH),NBNAV,ISINGL
C
      DIMENSION IX(*),IXSNBO(LENGTH/2)
C
      EQUIVALENCE (IXSNBO(1),IXDNBO(1))
C
      IF(IDAR.LT.0.OR.IDAR.GT.NBDAR)
     +    CALL NBHALT('NBWRIT: Unknown record.')
      MAXIX = LENGTH * ISINGL / 2
      LDAR  = NX * ISINGL
      IF(IONBO(IDAR).NE.0) GO TO 100
C
C  If this is the first write to the NBO DAF:
C
      IONBO(IDAR) = NAV
      NBNAV = NAV
C
      MAX = 0
   10 MIN = MAX + 1
      MAX = MAX + MAXIX
      IF(MAX.GT.LDAR) MAX = LDAR
      DO 20 I = MIN,MAX
   20 IXDNBO(I-MIN+1) = IX(I)
      IF(ISINGL.EQ.1) WRITE(INBO,REC=NBNAV) IXSNBO
      IF(ISINGL.EQ.2) WRITE(INBO,REC=NBNAV) IXDNBO
      NBNAV = NBNAV + 1
      IF(MAX.LT.LDAR) GO TO 10
      NAV = NBNAV
      RETURN
C
C  Or if this is a rewrite:
C
  100 CONTINUE
      NBNAV = IONBO(IDAR)
      MAX = 0
  110 MIN = MAX + 1
      MAX = MAX + MAXIX
      IF(MAX.GT.LDAR) MAX = LDAR
      DO 120 I = MIN,MAX
  120 IXDNBO(I-MIN+1) = IX(I)
      IF(ISINGL.EQ.1) WRITE(INBO,REC=NBNAV) IXSNBO
      IF(ISINGL.EQ.2) WRITE(INBO,REC=NBNAV) IXDNBO
      NBNAV = NBNAV + 1
      IF(MAX.LT.LDAR) GO TO 110
      RETURN
      END
C***********************************************************************
      SUBROUTINE NBREAD(IX,NX,IDAR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER (LENGTH = 256)
      PARAMETER (NBDAR = 300)
C
      COMMON/NBODAF/INBO,NAV,IONBO(NBDAR)
      COMMON/NBONAV/IXDNBO(LENGTH),NBNAV,ISINGL
C
      DIMENSION IX(*),IXSNBO(LENGTH/2)
C
      EQUIVALENCE (IXSNBO(1),IXDNBO(1))
C
      IF(IDAR.LT.0.OR.IDAR.GT.NBDAR)
     +    CALL NBHALT('NBWRIT: Unknown record.')
      NBNAV = IONBO(IDAR)
      MAXIX = LENGTH * ISINGL / 2
      LDAR  = NX * ISINGL
C
      MAX = 0
   10 MIN = MAX + 1
      MAX = MAX + MAXIX
      IF(MAX.GT.LDAR) MAX = LDAR
      IF(ISINGL.EQ.1) READ(INBO,REC=NBNAV) IXSNBO
      IF(ISINGL.EQ.2) READ(INBO,REC=NBNAV) IXDNBO
      DO 20 I = MIN,MAX
   20 IX(I) = IXDNBO(I-MIN+1)
      NBNAV = NBNAV + 1
      IF(MAX.LT.LDAR) GO TO 10
      RETURN
      END
C***********************************************************************
      SUBROUTINE NBCLOS(DEL)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL DEL
C
      PARAMETER (LENGTH = 256)
      PARAMETER (NBDAR = 300)
      PARAMETER (MAXFIL = 40)
C
      COMMON/NBODAF/INBO,NAV,IONBO(NBDAR)
      COMMON/NBONAV/IXDNBO(LENGTH),NBNAV,ISINGL
      COMMON/NBNAME/FILENM,NFILE,IFILE(MAXFIL)
      CHARACTER*256 FILENM
C
      DIMENSION IX(NBDAR+2)
      EQUIVALENCE (IX(1),INBO)
C
C  First close the NBO direct access file, remembering to write
C  COMMON/NBODAF/ to the first logical record:
C
      NF = 1
      NX = (NBDAR + 2) / ISINGL
      CALL NBWRIT(IX,NX,NF)
      CALL DACLOS(INBO,DEL)
C
C  Then close the remainder of the files used by the NBO program:
C
      DO 10 I = 1,NFILE
        CLOSE(UNIT=ABS(IFILE(I)), STATUS='KEEP')
   10 CONTINUE
      NFILE = 0
      RETURN
      END
C***********************************************************************
      SUBROUTINE NBINQR(IDAR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER (NBDAR = 300)
      COMMON/NBODAF/INBO,NAV,IONBO(NBDAR)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      IF(IDAR.LT.1.OR.IDAR.GT.NBDAR) THEN
        WRITE(LFNPR,900) IDAR,NBDAR
        CALL NBHALT('NBO DAF record out of range.')
      END IF
C
      IF(IONBO(IDAR).EQ.0) IDAR = 0
      RETURN
C
  900 FORMAT(/1X,'NBO DAF record out of range: IDAR = ',I4,
     + '  NBDAR = ',I4)
      END
C***********************************************************************
      SUBROUTINE FETITL(TITLE)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION TITLE(10)
C
C  FETITL:  FETCHES THE JOB TITLE FROM THE NBODAF:
C
      NFILE = 2
      CALL NBREAD(TITLE,10,NFILE)
      RETURN
      END
C***********************************************************************
      SUBROUTINE FEE0(EDEL,ETOT)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION X(2)
C
C  FEE0:  FETCHES THE DELETION AND TOTAL SCF ENERGY
C
      NFILE = 8
      CALL NBREAD(X,2,NFILE)
      EDEL = X(1)
      ETOT = X(2)
      RETURN
      END
C***********************************************************************
      SUBROUTINE SVE0(EDEL)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION X(2)
C
C  SVE0:  SAVES THE DELETION ENERGY
C
      NFILE = 8
      CALL NBREAD(X,2,NFILE)
      X(1) = EDEL
      CALL NBWRIT(X,2,NFILE)
      RETURN
      END
C***********************************************************************
      SUBROUTINE FECOOR(ATCOOR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION ATCOOR(3*NATOMS)
C
C  FECOOR:  FETCH THE ATOMIC CARTESIAN COORDINATES IN ANGSTROMS.
C
      NFILE = 9
      CALL NBREAD(ATCOOR,3*NATOMS,NFILE)
      RETURN
      END
C***********************************************************************
      SUBROUTINE FESRAW(S)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL UNPACK
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
      DIMENSION S(NDIM,NDIM)
C
C  FESRAW:  FETCHES THE OVERLAP MATRIX (RAW AO BASIS)
C           INTO S(NDIM,NDIM) A FULL SQUARE MATRIX.
C
      NFILE = 10
      L2 = NBAS*(NBAS+1)/2
      CALL NBREAD(S,L2,NFILE)
      CALL UNPACK(S,NDIM,NBAS)
      RETURN
      END
C***********************************************************************
      SUBROUTINE SVDRAW(DM)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL PACK,UNPACK
C
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION DM(NDIM,NDIM)
C
      SAVE NFILEA,NFILEB
      DATA NFILEA,NFILEB/20,21/
C
C  SVDRAW:  SAVES THE DENSITY MATRIX (RAW AO BASIS) IN DM(NDIM,NDIM)
C           IF ALPHA =.TRUE.  SAVE ALPHA MATRIX
C           IF BETA  =.TRUE   SAVE BETA MATRIX.
C           IF OPEN .AND. .NOT.(ALPHA .OR. BETA) =.TRUE  SAVE THE TOTAL DM
C
      L2 = NBAS*(NBAS+1)/2
      NFILE = NFILEA
      IF(BETA) NFILE = NFILEB
      CALL PACK(DM,NDIM,NBAS)
      CALL NBWRIT(DM,L2,NFILE)
      CALL UNPACK(DM,NDIM,NBAS)
      RETURN
      END
C***********************************************************************
      SUBROUTINE FEDRAW(DM,SCR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL UNPACK
      DIMENSION DM(*),SCR(*)
C
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
      SAVE NFILEA,NFILEB
      DATA NFILEA,NFILEB/20,21/
C
C  FEDRAW:  FETCHES THE DENSITY MATRIX (RAW AO BASIS) IN DM(NDIM,NDIM)
C           IF ALPHA =.TRUE.  FETCH ALPHA MATRIX
C           IF BETA  =.TRUE   FETCH BETA MATRIX.
C           IF OPEN .AND. .NOT.(ALPHA .OR. BETA) =.TRUE  FETCH THE TOTAL DM
C
      L2 = NBAS*(NBAS+1)/2
      NFILE = NFILEA
      IF(BETA) NFILE = NFILEB
      CALL NBREAD(DM,L2,NFILE)
C
      IF(.NOT.OPEN) GOTO 300
      IF(ALPHA.OR.BETA) GOTO 300
      CALL NBREAD(SCR,L2,NFILEB)
C
C  FORM THE TOTAL DENSITY MATRIX:
C
      DO 100 I = 1,L2
        DM(I) = DM(I) + SCR(I)
  100 CONTINUE
C
  300 CALL UNPACK(DM,NDIM,NBAS)
      RETURN
      END
C***********************************************************************
      SUBROUTINE FEFAO(F,IWFOCK)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL UNPACK
      DIMENSION F(*)
C
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
      SAVE NFILEA,NFILEB
      DATA NFILEA,NFILEB/30,31/
C
C  FEFAO:  FETCHES THE AO FOCK MATRIX
C          IF ALPHA .EQ. .TRUE.  WE WANT THE ALPHA FOCK MATRIX
C          IF BETA .EQ. .TRUE.  WE WANT THE BETA FOCK MATRIX.
C          IF THE REQUESTED MATRIX DOES NOT EXIST THEN IWFOCK = 0
C
      L2 = NBAS*(NBAS+1)/2
      NFILE = NFILEA
      IF(BETA) NFILE = NFILEB
      CALL NBINQR(NFILE)
      IF(NFILE.GT.0) THEN
        CALL NBREAD(F,L2,NFILE)
        CALL UNPACK(F,NDIM,NBAS)
      ELSE
        IWFOCK = 0
      END IF
      RETURN
      END
C***********************************************************************
      SUBROUTINE FEAOMO(T,IT)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION T(*)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
C
      SAVE NFILEA,NFILEB
      DATA NFILEA,NFILEB/40,41/
C
C FEAOMO:  FETCH THE AO TO MO TRANSFORMATION MATRIX:
C          (IT = 1, AO TO MO TRANSFORM IS ON NBO DAF)
C          (IT = 0, AO TO MO TRANSFORM IS NOT ON NBO DAF)
C
      NFILE = NFILEA
      IF (BETA) NFILE = NFILEB
      CALL NBINQR(NFILE)
      IF(NFILE.GT.0) THEN
        IT = 1
        L3 = NDIM*NDIM
        CALL NBREAD(T,L3,NFILE)
      ELSE
        IT = 0
      END IF
      RETURN
      END
C***********************************************************************
      SUBROUTINE FEDXYZ(DXYZ,I)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL UNPACK
      DIMENSION DXYZ(*)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
      SAVE NFILEX,NFILEY,NFILEZ
      DATA NFILEX,NFILEY,NFILEZ/50,51,52/
C
C  FEDXYZ:    FETCH THE AO DIPOLE MOMENT MATRICES (IN ANGSTROMS)
C      I=1:  X       I=2:    Y           I=3:   Z
C
      IF(I.EQ.1) NFILE = NFILEX
      IF(I.EQ.2) NFILE = NFILEY
      IF(I.EQ.3) NFILE = NFILEZ
C
      CALL NBINQR(NFILE)
      IF(NFILE.GT.0) THEN
        L2 = NBAS*(NBAS+1)/2
        CALL NBREAD(DXYZ,L2,NFILE)
        CALL UNPACK(DXYZ,NDIM,NBAS)
      ELSE
        I = 0
      END IF
      RETURN
      END
C***********************************************************************
      SUBROUTINE FEKAO(T,IT)
C***********************************************************************
C 14-Jan-93  EDG  New subroutine
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL UNPACK
      DIMENSION T(*)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
C FEKAO:   FETCH THE KINETIC ENERGY INTEGRALS:
C          (IT = 1, INTEGRALS ON NBO DAF)
C          (IT = 0, INTEGRALS NOT ON NBO DAF)
C
      NFILE = 18
      CALL NBINQR(NFILE)
      IF(NFILE.GT.0) THEN
        IT = 1
        L2 = NBAS*(NBAS+1)/2
        CALL NBREAD(T,L2,NFILE)
        CALL UNPACK(T,NDIM,NBAS)
      ELSE
        IT = 0
      END IF
      RETURN
      END
C***********************************************************************
      SUBROUTINE FEVAO(V,IV)
C***********************************************************************
C 14-Jan-93  EDG  New subroutine
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL UNPACK
      DIMENSION V(*)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
C FEVAO:   FETCH THE NUCLEAR ATTRACTION INTEGRALS:
C          (IV = 1, INTEGRALS ON NBO DAF)
C          (IV = 0, INTEGRALS NOT ON NBO DAF)
C
      NFILE = 19
      CALL NBINQR(NFILE)
      IF(NFILE.GT.0) THEN
        IV = 1
        L2 = NBAS*(NBAS+1)/2
        CALL NBREAD(V,L2,NFILE)
        CALL UNPACK(V,NDIM,NBAS)
      ELSE
        IV = 0
      END IF
      RETURN
      END
C***********************************************************************
      SUBROUTINE SVCHK(T,IS)
C***********************************************************************
C 19-Jan-93  EDG  New subroutine
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION T(NDIM,NDIM)
C
C  SVCHK:  SAVE TRANSFORMATION MATRIX FOR CHECKPOINTING
C          IS =  2  ALPHA SPIN
C          IS =  0  CLOSED SHELL
C          IS = -2  BETA SPIN
C
      NFILE = 80
      IF(IS.EQ.-2) NFILE = 81
      L3 = NDIM*NDIM
      CALL NBWRIT(T,L3,NFILE)
      RETURN
      END
C***********************************************************************
      SUBROUTINE FECHK(T,IS,IT)
C***********************************************************************
C 19-Jan-93  EDG  New subroutine
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION T(NDIM,NDIM)
C
C  FECHK:  FETCH TRANSFORMATION MATRIX FOR CHECKPOINTING
C          IS =  2 ALPHA SPIN
C             =  0 CLOSED SHELL
C             = -2 BETA SPIN
C          IT =  1 IF TRANSFORMATION IS ON DAF
C             =  0 OTHERWISE
C
      NFILE = 80
      IF(IS.EQ.-2) NFILE = 81
      CALL NBINQR(NFILE)
      IF(NFILE.GT.0) THEN
        IT = 1
        L3 = NDIM*NDIM
        CALL NBREAD(T,L3,NFILE)
      ELSE
        IT = 0
      END IF
      RETURN
      END
C***********************************************************************
      SUBROUTINE SVNBO(T,OCC,ISCR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORB(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
C
      DIMENSION T(NDIM,NDIM),OCC(NDIM),ISCR(*)
C
C  SVNBO:  SAVES NBO INFORMATION (TRANSFORMATION, OCCUPANCIES, LABELS, ETC.)
C          IF ALPHA .EQ. .TRUE.  SAVE THE ALPHA INFORMATION
C          IF BETA .EQ. .TRUE.  SAVE THE BETA INFORMATION.
C
C  SAVE THE AO TO NBO TRANSFORMATION MATRIX:
C
      L1 = NDIM
      L3 = NDIM*NDIM
      L4 = 10*NDIM
      NFILE = 44
      IF (BETA) NFILE = 45
      CALL NBWRIT(T,L3,NFILE)
C
C  SAVE NBO ORBITAL OCCUPANCIES:
C
      NFILE = 27
      IF (BETA) NFILE = 28
      CALL NBWRIT(OCC,L1,NFILE)
C
C  SAVE THE LISTS OF NBO INFORMATION FOR LATER USE IN THE DELETIONS.
C  PACK THE INFORMATION INTO ISCR(10*NDIM):
C
      II = 0
      DO 40 K = 1,6
        DO 30 I = 1,NNAO
          II = II + 1
          ISCR(II) = LABEL(I,K)
   30   CONTINUE
   40 CONTINUE
      DO 50 I = 1,NNAO
        II = II + 1
        ISCR(II) = IBXM(I)
   50 CONTINUE
      DO 60 I = 1,NATOMS
        II = II + 1
        ISCR(II) = IATNO(I)
   60 CONTINUE
      DO 70 I = 1,NNAO
        II = II + 1
        ISCR(II) = NBOUNI(I)
   70 CONTINUE
      DO 80 I = 1,NNAO
        II = II + 1
        ISCR(II) = NBOTYP(I)
   80 CONTINUE
C
      NFILE = 60
      IF (BETA) NFILE = 61
      CALL NBWRIT(ISCR,L4,NFILE)
C
      RETURN
      END
C***********************************************************************
      SUBROUTINE FENBO(T,OCC,SCR,ISCR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       IATNO(MAXBAS),IBXM(MAXBAS),ISCR1(2*MAXBAS),ISCR2(2*MAXBAS)
C
      DIMENSION T(NDIM,NDIM),OCC(NDIM),SCR(*),ISCR(*)
C
C  NOTE: SCR AND ISCR REFER TO THE SAME BIT OF MEMORY
C
C  FENBO:  FETCHES NBO INFORMATION (TRANSFORMATION, OCCUPANCIES, LABELS, ETC.)
C          IF ALPHA .EQ. .TRUE.  FETCH THE ALPHA INFORMATION
C          IF BETA .EQ. .TRUE.  FETCH THE BETA INFORMATION.
C
C  FETCH THE AO TO NBO TRANSFORMATION MATRIX:
C
      L1 = NDIM
      L3 = NDIM*NDIM
      L4 = NDIM*10
      NFILE = 44
      IF (BETA) NFILE = 45
      CALL NBREAD(T,L3,NFILE)
C
C  FETCH NBO ORBITAL OCCUPANCIES:
C
      NFILE = 27
      IF (BETA) NFILE = 28
      CALL NBREAD(OCC,L1,NFILE)
C
C  FETCH THE VARIOUS LISTS OF NBO INFORMATION FOR USE IN THE DELETIONS.
C  UNPACK THE INFORMATION INTO LABEL(MAXBAS,6),IBXM(MAXBAS),IATNO(MAXBAS),
C  NBOUNI(MAXBAS) AND NBOTYP(MAXBAS) FROM ISCR(10*NDIM):
C
      NFILE = 60
      IF (BETA) NFILE = 61
      CALL NBREAD(SCR,L4,NFILE)
C
      II = 0
      DO 40 K = 1,6
        DO 30 I = 1,NNAO
          II = II + 1
          LABEL(I,K) = ISCR(II)
   30   CONTINUE
   40 CONTINUE
      DO 50 I = 1,NNAO
        II = II + 1
        IBXM(I) = ISCR(II)
   50 CONTINUE
      DO 60 I = 1,NATOMS
        II = II + 1
        IATNO(I) = ISCR(II)
   60 CONTINUE
      DO 70 I = 1,NNAO
        II = II + 1
        NBOUNI(I) = ISCR(II)
   70 CONTINUE
      DO 80 I = 1,NNAO
        II = II + 1
        NBOTYP(I) = ISCR(II)
   80 CONTINUE
C
      RETURN
      END
C***********************************************************************
      SUBROUTINE FETNBO(T)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION T(*)
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
C
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
C  FETNBO: FETCH THE AO TO NBO TRANSFORMATION MATRIX
C
      L3 = NDIM*NDIM
      NFILE = 44
      IF (BETA) NFILE = 45
      CALL NBREAD(T,L3,NFILE)
      RETURN
      END
C***********************************************************************
      SUBROUTINE SVPNAO(T)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION T(*)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
C  SVPNAO:  SAVES THE AO TO PNAO TRANSFORMATION MATRIX.
C
      NFILE = 42
      L3 = NDIM*NDIM
      CALL NBWRIT(T,L3,NFILE)
      RETURN
      END
C***********************************************************************
      SUBROUTINE FEPNAO(T)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION T(*)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
C  FEPNAO:  FETCHES THE AO TO PNAO TRANSFORMATION MATRIX.
C
      NFILE = 42
      L3 = NDIM*NDIM
      CALL NBREAD(T,L3,NFILE)
      RETURN
      END
C***********************************************************************
      SUBROUTINE SVSNAO(S)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL PACK,UNPACK
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION S(NDIM,NDIM)
C
C   SVSNAO:  SAVE THE OVERLAP MATRIX IN THE PNAO OR RPNAO BASIS SET.
C
      NFILE = 11
      L2 = NNAO*(NNAO+1)/2
      CALL PACK(S,NDIM,NNAO)
      CALL NBWRIT(S,L2,NFILE)
      CALL UNPACK(S,NDIM,NNAO)
      RETURN
      END
C***********************************************************************
      SUBROUTINE FESNAO(S)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL UNPACK
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
      DIMENSION S(NDIM,NDIM)
C
C   FESNAO:   FETCH THE OVERLAP MATRIX IN THE PNAO OR RPNAO BASIS SET.
C
      NFILE = 11
      L2 = NNAO*(NNAO+1)/2
      CALL NBREAD(S,L2,NFILE)
      CALL UNPACK(S,NDIM,NNAO)
      RETURN
      END
C***********************************************************************
      SUBROUTINE SVTNAB(T)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION T(NDIM,NDIM)
C
C  SVTNAB:  SAVE THE NAO TO NBO TRANSFORMATION MATRIX.
C
      NFILE = 48
      L3 = NDIM*NDIM
      CALL NBWRIT(T,L3,NFILE)
      RETURN
      END
C***********************************************************************
      SUBROUTINE FETNAB(T)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION T(NDIM,NDIM)
C
C  FETNAB:  FETCH THE NAO TO NBO TRANSFORMATION MATRIX
C
      NFILE = 48
      L3 = NDIM*NDIM
      CALL NBREAD(T,L3,NFILE)
      RETURN
      END
C***********************************************************************
      SUBROUTINE SVTLMO(T)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION T(NDIM,NDIM)
C
C  SVTLMO:  SAVE THE NBO TO NLMO TRANSFORMATION MATRIX.
C
      NFILE = 49
      L3 = NDIM*NDIM
      CALL NBWRIT(T,L3,NFILE)
      RETURN
      END
C***********************************************************************
      SUBROUTINE FETLMO(T)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION T(NDIM,NDIM)
C
C  FETLMO:  FETCH THE NBO TO NLMO TRANSFORMATION MATRIX
C
      NFILE = 49
      L3 = NDIM*NDIM
      CALL NBREAD(T,L3,NFILE)
      RETURN
      END
C***********************************************************************
      SUBROUTINE SVTNHO(T)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
C
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION T(NDIM,NDIM)
C
C  SVTNHO:   TEMPORARILY SAVE THE NAO TO NHO TRANSFORMATION
C
      NFILE = 64
      IF(BETA) NFILE = 65
      L3 = NDIM*NDIM
      CALL NBWRIT(T,L3,NFILE)
      RETURN
      END
C***********************************************************************
      SUBROUTINE FETNHO(T)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
C
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION T(NDIM,NDIM)
C
C  FETNHO:   FETCH THE NAO TO NHO TRANSFORMATION
C
      NFILE = 64
      IF(BETA) NFILE = 65
      L3 = NDIM*NDIM
      CALL NBREAD(T,L3,NFILE)
      RETURN
      END
C***********************************************************************
      SUBROUTINE SVTPAO(T)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
      DIMENSION T(NDIM,NDIM)
C
C  SVTPAO:  SAVE THE AO TO PAO TRANSFORMATION MATRIX.
C
      NFILE = 39
      L3 = NDIM * NDIM
      CALL NBWRIT(T,L3,NFILE)
      RETURN
      END
C***********************************************************************
      SUBROUTINE FETPAO(T)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
      DIMENSION T(NDIM,NDIM)
C
C  FETPAO:  FETCHES THE AO TO PAO TRANSFORMATION MATRIX.
C
      NFILE = 39
      L3 = NDIM * NDIM
      CALL NBREAD(T,L3,NFILE)
      RETURN
      END
C***********************************************************************
      SUBROUTINE SVPPAO(DM)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL PACK,UNPACK
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION DM(NDIM,NDIM)
C
C  SVPPAO:  TEMPORARILY SAVES THE PURE AO (PAO) DENSITY MATRIX.
C           (THIS IS NOT THE RAW AO BASIS, BUT THE BASIS AFTER THE
C           TRANSFORMATION FROM CARTESIAN TO PURE D,F,G FUNCTIONS).
C
      NFILE = 22
      L2 = NBAS*(NBAS+1)/2
      CALL PACK(DM,NDIM,NBAS)
      CALL NBWRIT(DM,L2,NFILE)
      CALL UNPACK(DM,NDIM,NBAS)
      RETURN
      END
C***********************************************************************
      SUBROUTINE FEPPAO(DM)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL UNPACK
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION DM(NDIM,NDIM)
C
C  FEPPAO:  FETCHES THE PURE AO (PAO) DENSITY MATRIX.
C           (THIS IS NOT THE RAW AO BASIS, BUT THE BASIS AFTER THE
C           TRANSFORMATION FROM CARTESIAN TO PURE D,F,G FUNCTIONS).
C
      NFILE = 22
      L2 = NBAS*(NBAS+1)/2
      CALL NBREAD(DM,L2,NFILE)
      CALL UNPACK(DM,NDIM,NBAS)
      RETURN
      END
C***********************************************************************
      SUBROUTINE SVTNAO(T)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION T(NDIM,NDIM)
C
C  SVTNAO:  SAVE THE AO TO NAO TRANSFORMATION MATRIX.
C
      IF(.NOT.ORTHO) THEN
        NFILE = 43
        L3 = NDIM*NDIM
        CALL NBWRIT(T,L3,NFILE)
      END IF
      RETURN
      END
C***********************************************************************
      SUBROUTINE FETNAO(T)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
C
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION T(NDIM,NDIM)
C
      SAVE ZERO,ONE
      DATA ZERO,ONE/0.0D0,1.0D0/
C
C  FETNAO:  FETCHES THE AO TO NAO TRANSFORMATION MATRIX.
C
      IF(ORTHO) THEN
        DO 20 J = 1,NBAS
          DO 10 I = 1,NBAS
            T(I,J) = ZERO
   10     CONTINUE
          T(J,J) = ONE
   20   CONTINUE
      ELSE
        NFILE = 43
        L3 = NBAS*NBAS
        CALL NBREAD(T,L3,NFILE)
      END IF
      RETURN
      END
C***********************************************************************
      SUBROUTINE SVNLMO(T)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION T(NDIM,NDIM)
C
C  SVNLMO:  SAVE THE AO TO NLMO TRANSFORMATION MATRIX
C
      NFILE = 46
      IF(ISPIN.EQ.-2) NFILE = 47
      L3 = NDIM*NDIM
      CALL NBWRIT(T,L3,NFILE)
      RETURN
      END
C***********************************************************************
      SUBROUTINE FENLMO(T,SCR,ISCR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       IATNO(MAXBAS),IBXM(MAXBAS),ISCR1(2*MAXBAS),ISCR2(2*MAXBAS)
C
      DIMENSION T(NDIM,NDIM),SCR(*),ISCR(*)
C
C  NOTE:  SCR AND ISCR REFER TO THE SAME LOCATION IN MEMORY
C
C  FENLMO:  FETCH THE AO TO NLMO TRANSFORMATION MATRIX
C
      NFILE = 46
      IF(ISPIN.EQ.-2) NFILE = 47
      L3 = NDIM*NDIM
      CALL NBREAD(T,L3,NFILE)
C
C  FETCH THE VARIOUS LISTS OF NLMO INFORMATION FOR USE IN THE DELETIONS.
C  UNPACK THE INFORMATION INTO LABEL(MAXBAS,6),IBXM(MAXBAS),IATNO(MAXBAS),
C  NBOUNI(MAXBAS) AND NBOTYP(MAXBAS) FROM ISCR(10*NDIM):
C
      NFILE = 60
      IF(ISPIN.EQ.-2) NFILE = 61
      L4 = 10*NDIM
      CALL NBREAD(SCR,L4,NFILE)
C
      II = 0
      DO 40 K = 1,6
        DO 30 I = 1,NNAO
          II = II + 1
          LABEL(I,K) = ISCR(II)
   30   CONTINUE
   40 CONTINUE
      DO 50 I = 1,NNAO
        II = II + 1
        IBXM(I) = ISCR(II)
   50 CONTINUE
      DO 60 I = 1,NATOMS
        II = II + 1
        IATNO(I) = ISCR(II)
   60 CONTINUE
      DO 70 I = 1,NNAO
        II = II + 1
        NBOUNI(I) = ISCR(II)
   70 CONTINUE
      DO 80 I = 1,NNAO
        II = II + 1
        NBOTYP(I) = ISCR(II)
   80 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE SVDNAO(DM)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL PACK,UNPACK
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
C
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION DM(NDIM,NDIM)
C
C  SVDNAO:  SAVE THE NAO DENSITY MATRIX
C
      IF(.NOT.ORTHO) THEN
        NFILE = 23
        IF(BETA) NFILE = 24
        L2 = NNAO*(NNAO+1)/2
        CALL PACK(DM,NDIM,NNAO)
        CALL NBWRIT(DM,L2,NFILE)
        CALL UNPACK(DM,NDIM,NNAO)
      END IF
      RETURN
      END
C***********************************************************************
      SUBROUTINE FEDNAO(DM)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL UNPACK
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
C
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION DM(NDIM,NDIM)
C
C  FEDNAO:  FETCHES THE NAO DENSITY MATRIX (AO DM FOR ORTHOGONAL BASIS SETS)
C
      IF(ORTHO) THEN
        CALL FEDRAW(DM,DM)
      ELSE
        NFILE = 23
        IF(BETA) NFILE = 24
        L2 = NNAO*(NNAO+1)/2
        CALL NBREAD(DM,L2,NFILE)
        CALL UNPACK(DM,NDIM,NNAO)
      END IF
      RETURN
      END
C***********************************************************************
      SUBROUTINE SVFNBO(F)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL PACK,UNPACK
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      DIMENSION F(NDIM,NDIM)
C
C  SVFNBO:  SAVES THE NBO FOCK MATRIX
C
      NFILE = 34
      IF (BETA) NFILE = 35
      L2 = NNAO*(NNAO+1)/2
      CALL PACK(F,NDIM,NNAO)
      CALL NBWRIT(F,L2,NFILE)
      CALL UNPACK(F,NDIM,NNAO)
      RETURN
      END
C***********************************************************************
      SUBROUTINE FEFNBO(F)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      DIMENSION F(*)
C
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
C  FEFNBO:  FETCHES THE NBO FOCK MATRIX, LEAVING IT IN TRIANGULAR FORM!!
C           IF ALPHA.EQ.TRUE.  WE WANT THE ALPHA FOCK MATRIX
C           IF BETA.EQ.TRUE.   WE WANT THE BETA FOCK MATRIX.
C
      NFILE = 34
      IF (BETA) NFILE = 35
      L2 = NNAO*(NNAO+1)/2
      CALL NBREAD(F,L2,NFILE)
      RETURN
      END
C***********************************************************************
      SUBROUTINE SVNEWD(DM)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      DIMENSION DM(*)
C
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
C SVNEWD:  SAVE THE NEW DENSITY MATRIX (RAW AO BASIS) FROM NBO DELETION
C
      NFILE = 25
      IF (BETA) NFILE = 26
      L2 = NBAS*(NBAS+1)/2
      CALL NBWRIT(DM,L2,NFILE)
      RETURN
      END
C***********************************************************************
      SUBROUTINE FENEWD(DM)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      DIMENSION DM(*)
C
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
C FENEWD:  FETCH THE NEW DENSITY MATRIX (RAW AO BASIS)
C
      NFILE = 25
      IF (BETA) NFILE = 26
      L2 = NBAS*(NBAS+1)/2
      CALL NBREAD(DM,L2,NFILE)
      RETURN
      END
C***********************************************************************
      SUBROUTINE FEINFO(ICORE,ISWEAN)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      DIMENSION ICORE(13)
C
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
C  Restore wavefunction information from the NBO DAF:
C
C  Restore NATOMS, NDIM, NBAS, MUNIT, wavefunction flags, ISWEAN, NNAO:
C
      NFILE = 3
      CALL NBREAD(ICORE,13,NFILE)
      NATOMS = ICORE(1)
      NDIM   = ICORE(2)
      NBAS   = ICORE(3)
      MUNIT  = ICORE(4)
      ROHF   = .FALSE.
      IF(ICORE(5).EQ.1)  ROHF  = .TRUE.
      UHF    = .FALSE.
      IF(ICORE(6).EQ.1)  UHF   = .TRUE.
      CI     = .FALSE.
      IF(ICORE(7).EQ.1)  CI    = .TRUE.
      OPEN   = .FALSE.
      IF(ICORE(8).EQ.1)  OPEN  = .TRUE.
      MCSCF  = .FALSE.
      IF(ICORE(9).EQ.1)  MCSCF = .TRUE.
      AUHF   = .FALSE.
      IF(ICORE(10).EQ.1) AUHF  = .TRUE.
      ORTHO  = .FALSE.
      IF(ICORE(11).EQ.1) ORTHO = .TRUE.
      ISWEAN = ICORE(12)
      NNAO   = ICORE(13)
C
C  IF ISWEAN IS 1, SET ICORE(12) TO 0 AND WRITE TO NBO DAF.  NOTE, ISWEAN IS
C  SET TO 1 BY THE FEAOIN DRIVER ROUTINE.  THIS TELLS THE ENERGETIC ANALYSIS
C  ROUTINES TO SEARCH FOR THE $DEL KEYLIST.  ISWEAN IS RESET TO 0 HERE SO
C  THAT MULTIPLE DELETIONS CAN BE READ FROM A SINGLE $DEL KEYLIST:
C
      IF(ISWEAN.EQ.1) THEN
        ICORE(12) = 0
        CALL NBWRIT(ICORE,12,NFILE)
      END IF
      RETURN
      END
C***********************************************************************
      SUBROUTINE FEBAS(NSHELL,NEXP,ISCR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION ISCR(*)
C
C  FEBAS:  FETCHES THE BASIS SET INFO
C
      NFILE = 5
      CALL NBINQR(NFILE)
      IF(NFILE.GT.0) THEN
        CALL NBREAD(ISCR,2,NFILE)
        II = 0
        II = II + 1
        NSHELL = ISCR(II)
        II = II + 1
        NEXP   = ISCR(II)
        LEN    = 2 + 3*NSHELL + 6*NEXP
        CALL NBREAD(ISCR,LEN,NFILE)
      ELSE
        NSHELL = 0
      END IF
      RETURN
      END
C***********************************************************************
      SUBROUTINE FENBLB(ISCR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +      LSTOCC(MAXBAS),IBXM(MAXBAS),LOCC(MAXBAS),IATNO(MAXBAS),
     +      ITMP(2*MAXBAS)
C
      DIMENSION ISCR(*)
C
C  FENBLB: FETCH THE NBO LABELS FROM THE NBODAF:
C
C  UNPACK THE INFORMATION INTO LABEL(MAXBAS,6),IBXM(MAXBAS),IATNO(MAXBAS),
C  NBOUNI(MAXBAS) AND NBOTYP(MAXBAS) FROM ISCR(10*NDIM):
C
      L4 = 10 * NDIM
      NFILE = 60
      IF(ISPIN.EQ.-2) NFILE = 61
      CALL NBREAD(ISCR,L4,NFILE)
C
      II = 0
      DO 40 K = 1,6
        DO 30 I = 1,NNAO
          II = II + 1
          LABEL(I,K) = ISCR(II)
   30   CONTINUE
   40 CONTINUE
      DO 50 I = 1,NNAO
        II = II + 1
        IBXM(I) = ISCR(II)
   50 CONTINUE
      DO 60 I = 1,NATOMS
        II = II + 1
        IATNO(I) = ISCR(II)
   60 CONTINUE
      DO 70 I = 1,NNAO
        II = II + 1
        NBOUNI(I) = ISCR(II)
   70 CONTINUE
      DO 80 I = 1,NNAO
        II = II + 1
        NBOTYP(I) = ISCR(II)
   80 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE FESPIN(DM,SCR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL UNPACK
      DIMENSION DM(*),SCR(*)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
      SAVE NFILEA,NFILEB
      DATA NFILEA,NFILEB/20,21/
C
C  FESPIN:  FETCHES THE SPIN DENSITY MATRIX (RAW AO BASIS) IN DM(NDIM,NDIM)
C
      L2 = NBAS*(NBAS+1)/2
      CALL NBREAD(DM,L2,NFILEA)
      CALL NBREAD(SCR,L2,NFILEB)
C
C  FORM THE SPIN DENSITY MATRIX:
C
      DO 100 I = 1,L2
        DM(I) = DM(I) - SCR(I)
  100 CONTINUE
C
      CALL UNPACK(DM,NDIM,NBAS)
      RETURN
      END
C***********************************************************************
      SUBROUTINE SVLBLS
C***********************************************************************
C 12-Jun-96  EDG  New subroutine
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBLBL/LBL(2+10*MAXBAS*5)
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
C
C  SVLBLS:   SAVE COMMON /NBLBL/ ON DAF:
C
      NFILE = 62
      IF(BETA) NFILE = 63
      LEN = (2 + 10*MAXBAS*5) / 2
      CALL NBWRIT(LBL,LEN,NFILE)
      RETURN
      END
C***********************************************************************
      SUBROUTINE FELBLS
C***********************************************************************
C 12-Jun-96  EDG  New subroutine
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBLBL/LBL(2+10*MAXBAS*5)
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
C
C  FELBLS:   FETCH COMMON /NBLBL/ FROM DAF:
C
      NFILE = 62
      IF(BETA) NFILE = 63
      LEN = (2 + 10*MAXBAS*5) / 2
      CALL NBREAD(LBL,LEN,NFILE)
      RETURN
      END
C***********************************************************************
      SUBROUTINE SVNNAO(ICORE,NNAO)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION ICORE(13)
C
C  Store NNAO on record 3 of the NBO DAF:
C
      NFILE = 3
      CALL NBREAD(ICORE,13,NFILE)
      ICORE(13) = NNAO
      CALL NBWRIT(ICORE,13,NFILE)
      RETURN
      END
C***********************************************************************
C NBO 5.G -- Natural Bond Orbital Analysis Programs
C (c) Copyright 1996-2008 Board of Regents of the University of Wisconsin System
C     on behalf of the Theoretical Chemistry Institute.  All Rights Reserved.
C***********************************************************************
C
C  FREE FORMAT INPUT ROUTINES:
C
C      SUBROUTINE STRTIN(LFNIN)
C      SUBROUTINE NXTCRD
C      SUBROUTINE IFLD(INTGR,ERROR)
C      SUBROUTINE RFLD(REAL,ERROR)
C      SUBROUTINE HFLD(KEYWD,LENG,ENDD)
C      SUBROUTINE FNDFLD
C      SUBROUTINE RTNFLD
C      FUNCTION EQUAL(IA,IB,L)
C
C***********************************************************************
C
C  USER  INSTRUCTIONS:
C
C     1. THE CHARACTER STRING "END" IS THE FIELD TERMINATING MARK:
C
C     2. COMMAS AND EQUAL SIGNS ARE TREATED AS EQUIVALENT TO BLANKS.
C          COMMAS, EQUAL SIGNS, AND BLANKS DELIMIT INPUT ITEMS.
C
C     3. ALL CHARACTERS TO THE RIGHT OF AN EXCLAMATION MARK ! ARE TREATED AS
C          COMMENTS, AND THE NEXT CARD IS READ IN WHEN THESE ARE ENCOUNTERED.
C
C     4. UPPER AND LOWER CASE CHARACTERS CAN BE READ BY THESE ROUTINES.
C          HOWEVER, LOWER CASE CHARACTERS ARE CONVERTED TO UPPER CASE
C          WHEN ENCOUNTERED (EXCEPT FOR FILE KEYWORD FILENAMES, WHICH
C          ARE LEFT ALONE).
C
C     5. TO READ IN DATA FOR THE FIRST TIME FROM LFN "LFNIN" (PERHAPS
C          AFTER USING THESE SUBROUTINES TO READ IN DATA FROM ANOTHER LFN),
C          OR TO CONTINUE READING IN DATA FROM LFNIN AFTER ENCOUNTERING
C          A FIELD TERMINATING MARK, CALL STRTIN(LFNIN)  (START INPUT)
C
C     6. TO FETCH THE NEXT NON-BLANK STRING OF CHARACTERS FROM LFN LFNIN,
C           CALL HFLD(KEYWD,LENGTH,END),
C            WHERE KEYWD   IS A VECTOR OF DIMENSION "LENGTH"  OR LONGER,
C                  LENGTH  IS THE MAXIMUM NUMBER OF CHARACTERS TO FETCH,
C                  END     MUST BE A DECLARED LOGICAL VARIABLE.
C           UPON RETURN,
C            END=.TRUE. IF A FIELD TERMINATING MARK WAS FOUND TO BE THE NEXT
C                 NON-BLANK CHARACTER STRING.  OTHERWISE, END=.FALSE.
C            END=.TRUE. AND LENGTH=0 MEANS THE END-OF-FILE WAS FOUND.
C            LENGTH IS CHANGED TO THE ACTUAL NUMBER OF CHARACTERS IN STRING
C                 IF THIS IS LESS THAN THE VALUE OF LENGTH SET BY THE CALLING
C                 PROGRAM.
C            KEYWD(1) THROUGH KEYWD(LENGTH) CONTAIN THE CHARACTER STRING,
C                 ONE CHARACTER PER ELEMENT OF KEYWD.
C
C     7. TO FETCH THE INTEGER VALUE OF THE NEXT CHARACTER STRING,
C           CALL IFLD(INT,ERROR),
C            WHERE INT     IS THE VARIABLE TO BE READ,
C                  ERROR   MUST BE A DECLARED LOGICAL VARIABLE.
C            UPON RETURN,
C             IF ERROR=.FALSE., AN INTEGER WAS FOUND AND PLACED IN "INT".
C             IF ERROR=.TRUE. AND INT.GT.0, A FIELD TERMINATING MARK WAS
C                 FOUND AS THE NEXT CHARACTER STRING.
C             IF ERROR=.TRUE. AND INT.LT.0, THE NEXT CHARACTER STRING FOUND
C                 WAS NEITHER AN INTEGER NOR A FIELD TERMINATING MARK.
C
C     8. TO FETCH THE REAL VALUE OF THE NEXT CHARACTER STRING,
C           (AN EXPONENT IS ALLOWED, WITH OR WITHOUT AN "E" OR "F".
C             IF NO LETTER IS PRESENT TO SIGNIFY THE EXPONENT FIELD,
C             A + OR - SIGN MUST START THE EXPONENT.  IF NO MANTISSA IS
C             PRESENT, THE EXPONENT FIELD MUST START WITH A LETTER, AND
C             THE MANTISSA IS SET TO ONE.)
C           CALL RFLD(REAL,ERROR),
C            WHERE REAL    IS THE VARIABLE TO BE READ,
C                  ERROR   MUST BE A DECLARED LOGICAL VARIABLE.
C            UPON RETURN,
C             IF ERROR=.FALSE., A REAL NUMBER WAS FOUND AND PLACED IN "REAL".
C             IF ERROR=.TRUE. AND REAL.GT.1, A FIELD TERMINATING MARK WAS
C                 FOUND AS THE NEXT CHARACTER STRING.
C             IF ERROR=.TRUE. AND REAL.LT.-1, THE NEXT CHARACTER STRING FOUND
C                 WAS NEITHER A REAL NUMBER NOR A FIELD TERMINATING MARK.
C
C     9. TO COMPARE THE CORRESPONDING FIRST L ELEMENTS OF EACH OF TWO VECTORS
C          IA(L) AND IB(L) TO SEE IF THE VECTORS ARE EQUIVALENT,
C           USE THE FUNCTION EQUAL(IA,IB,L).
C           EQUAL MUST BE DECLARED LOGICAL IN THE CALLING PROGRAM,
C            AND THE FUNCTION VALUE (.TRUE. OR .FALSE.) WILL TELL IF THE
C            VECTORS IA AND IB ARE EQUAL UP TO ELEMENT L.
C        NOTE: THIS FUNCTION IS USEFUL FOR DETERMINING IF A CHARACTER STRING
C          READ BY A CALL TO HFLD MATCHES A CERTAIN KEYWORD WHICH IS STORED
C          IN A VECTOR, ONE CHARACTER PER ELEMENT.
C
C
C***********************************************************************
      SUBROUTINE STRTIN(LFNIN)
C***********************************************************************
C 22-Jan-95  EDG  Change END to LEND in /NBCRD2/ for avoid confusion with
C                 FORTRAN END
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBCRD1/ICD(256),LOOK(256),LENGTH,IPT,LFN,NEXP
      COMMON/NBCRD2/POINT,LEND,NEXT,EXP
      LOGICAL POINT,LEND,NEXT,EXP
C
C  INITIALIZE INPUT FROM LFN LFNIN:
C
      LFN  = LFNIN
      LEND = .FALSE.
      NEXT = .TRUE.
      CALL NXTCRD
C
      RETURN
      END
C***********************************************************************
      SUBROUTINE NXTCRD
C***********************************************************************
C 13-Feb-93  EDG  Name changed from RDCARD or RDCRD due to conflict
C                    with GAMESS
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      COMMON/NBCRD1/ICD(256),LOOK(256),LENGTH,IPT,LFN,NEXP
      COMMON/NBCRD2/POINT,LEND,NEXT,EXP
      LOGICAL POINT,LEND,NEXT,EXP,SFIL,SNAM
      DIMENSION ICFU(4),ICFL(4)
C
      SAVE IA,ICHARA,ICHARZ,IBLNK,IQ,II,ICFU,ICFL
      DATA IA,ICHARA,ICHARZ/1HA,1Ha,1Hz/
      DATA IBLNK,IQ,II/1H ,1H`,1HI/
      DATA ICFU/1HF,1HI,1HL,1HE/,ICFL/1Hf,1Hi,1Hl,1He/
C
C  READ IN THE NEXT CARD AT LFN:
C
      READ(LFN,1000,END=800,ERR=800) ICD
C
C  CHANGE ALL LOWER CASE CHARACTERS TO UPPER CASE
C   EXCEPT IF "FILE" KEYWORD FOUND, THEN FILENAME SKIPPED - JKB
C
      SFIL = .FALSE.
      SNAM = .FALSE.
      DO 10 I = 1,256
C
C  TREAT TABS AS SPACES:
C
        ITAB = IBLNK + II - IQ
        IF(ICD(I).EQ.ITAB) ICD(I) = IBLNK
C
        IF(I.GT.4) THEN
          SFIL = .TRUE.
          DO 15 J = 1,4
            IF(ICD(I-5+J).NE.ICFU(J).AND.ICD(I-5+J).NE.ICFL(J))
     +        SFIL = .FALSE.
   15     CONTINUE
        END IF
        IF(SFIL) THEN
          DO 18 J = 1,4
   18     ICD(I-5+J)=ICFU(J)
          SFIL = .FALSE.
          SNAM = .TRUE.
        END IF
        IF(.NOT.SFIL.AND..NOT.SNAM) THEN
          IF(ICD(I).GE.ICHARA.AND.ICD(I).LE.ICHARZ) THEN
            ICD(I) = ICD(I) - ICHARA + IA
          END IF
        END IF
        IF(SNAM.AND.ICD(I).EQ.IBLNK) SNAM = .FALSE.
   10 CONTINUE
C
C  RESET COLUMN POINTER, IPT:
C
      IPT = 1
      RETURN
C
C  END OF FILE ENCOUNTERED
C
  800 CONTINUE
      LEND = .TRUE.
      RETURN
C
 1000 FORMAT(256A1)
      END
C***********************************************************************
      SUBROUTINE IFLD(INTGR,ERROR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL ERROR
C
      COMMON/NBCRD1/ICD(256),LOOK(256),LENGTH,IPT,LFN,NEXP
      COMMON/NBCRD2/POINT,LEND,NEXT,EXP
      LOGICAL POINT,LEND,NEXT,EXP
C
      SAVE ZERO,ONE,SMALL
      DATA ZERO,ONE,SMALL/0.0D0,1.0D0,1.0D-3/
C
C  SEARCH LFN FOR THE NEXT STRING OF NON-BLANK CHARACTERS, SEE IF THEY
C  FORM AN INTEGER (IF NOT, ERROR=.TRUE.) AND, IF SO, PLACE ITS NUMERICAL
C  VALUE IN "INTGR":
C
      INTGR = 0
      CALL RFLD(REAL,ERROR)
C
C  IF DECIMAL POINT OR AN EXPONENT.LT.0, ERROR = .TRUE.:
C
      IF(EXP) GO TO 100
      IF(POINT) GO TO 100
      IF(NEXP.LT.0) GO TO 100
      IF(LENGTH.EQ.0) GO TO 100
      SIGN = ONE
      IF(REAL.LT.ZERO) SIGN = -ONE
      REAL = REAL + SMALL * SIGN
      INTGR = INT(REAL)
      RETURN
C
  100 ERROR = .TRUE.
      NEXT = .FALSE.
      RETURN
      END
C***********************************************************************
      SUBROUTINE RFLD(REAL,ERROR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL ERROR,EXPSGN,MANTIS
C
      COMMON/NBCRD1/ICD(256),LOOK(256),LENGTH,IPT,LFN,NEXP
      COMMON/NBCRD2/POINT,LEND,NEXT,EXP
      LOGICAL POINT,LEND,NEXT,EXP
C
      DIMENSION NCHAR(15)
C
      SAVE NCHAR,ZERO,ONE,TEN
      DATA NCHAR/1H0,1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9,1H.,1H+,1H-,
     +  1HD,1HE/
      DATA ZERO,ONE,TEN/0.0D0,1.0D0,10.0D0/
C
C  SEARCH LFN FOR THE NEXT STRING OF NON-BLANK CHARACTERS, SEE IF THEY FORM
C  A REAL NUMBER (EXPONENT IS OPTIONAL) (IF NOT, ERROR=.TRUE.) AND, IF SO,
C  PLACE ITS NUMERICAL VALUE IN "REAL":
C
      REAL   = ZERO
      SIGN   = ONE
      NDEC   = 0
      ISEXP  = 1
      NEXP   = 0
      EXPSGN = .FALSE.
      EXP    = .FALSE.
      POINT  = .FALSE.
      ERROR  = .FALSE.
      MANTIS = .FALSE.
      LEND   = .FALSE.
C
C  FIND THE NEXT STRING OF NON-BLANK CHARACTERS, "LOOK", OF LENGTH "LENGTH":
C
      IF(NEXT) CALL FNDFLD
      IF(LEND) GO TO 300
      IF(LENGTH.EQ.0) GO TO 300
C
C  FIND THE NUMERICAL VALUE OF THE CHARACTERS IN "LOOK":
C
      DO 200 J = 1,LENGTH
        LK = LOOK(J)
        DO 20 I = 1,15
          IF(LK.EQ.NCHAR(I)) GO TO 40
   20   CONTINUE
        GO TO 300
   40   K = I - 11
        IF(K) 60,80,100
C
C  THIS CHARACTER IS A NUMBER:
C
   60     CONTINUE
          IF(EXP) GO TO 70
C
C  ADD DIGIT TO MANTISSA:
C
          MANTIS = .TRUE.
          REAL = REAL * TEN + DFLOAT(I - 1)
C
C  IF WE ARE TO THE RIGHT OF A DECIMAL POINT, INCREMENT THE DECIMAL COUNTER:
C
          IF(POINT) NDEC = NDEC + 1
          GO TO 200
C
C  ADD DIGIT TO EXPONENT:
C
   70     NEXP = NEXP * 10 + (I - 1)
          GO TO 200
C
C  DECIMAL POINT:
C
   80     IF(POINT) GO TO 300
          POINT = .TRUE.
          GO TO 200
C
C  EXPONENT (+,-,D,E):
C
  100     CONTINUE
          GO TO (110,130,150,150), K
C
C  PLUS SIGN: IF NOT FIRST CHARACTER, COUNT AS PART OF EXPONENT:
C
  110       IF(J.EQ.1) GO TO 200
              IF(EXPSGN) GO TO 200
              EXPSGN = .TRUE.
              EXP = .TRUE.
              GO TO 200
C
C  MINUS SIGN: IF NOT FIRST CHARACTER, COUNT AS PART OF EXPONENT:
C
  130       IF(J.NE.1) GO TO 140
              SIGN = -ONE
              GO TO 200
  140         ISEXP = -1
              IF(EXPSGN) GO TO 200
              EXPSGN = .TRUE.
              EXP = .TRUE.
              GO TO 200
C
C  D OR E: START OF EXPONENT:
C
  150       IF(EXP) GO TO 300
            EXP = .TRUE.
  200  CONTINUE
C
C  SET FINAL VALUE OF REAL (IF NO MANTISSA, BUT EXPONENT PRESENT,
C  SET MANTISSA TO ONE):
C
      IF(EXP.AND..NOT.MANTIS) REAL = ONE
      REAL = REAL * SIGN * (TEN**(-NDEC+ISEXP*NEXP))
      NEXT = .TRUE.
      RETURN
C
C  NO REAL NUMBER FOUND, OR FIELD TERMINATING MARK:
C
  300 CONTINUE
      ERROR = .TRUE.
      REAL  = -TEN
      IF(LEND) REAL = TEN
      RETURN
      END
C***********************************************************************
      SUBROUTINE HFLD(KEYWD,LENG,ENDD)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL ENDD,EQUAL
C
      COMMON/NBCRD1/ICD(256),LOOK(256),LENGTH,IPT,LFN,NEXP
      COMMON/NBCRD2/POINT,LEND,NEXT,EXP
      LOGICAL POINT,LEND,NEXT,EXP
C
      DIMENSION KEYWD(LENG),KEND(3)
C
      SAVE NBLA,KEND
      DATA NBLA/1H /
      DATA KEND/1HE,1HN,1HD/
C
C  SEARCH LFN AND FIND NEXT NON-BLANK STRING OF CHARACTERS AND PLACE
C  IN THE VECTOR "KEYWD".  LENG, FROM THE CALLING PROGRAM, IS MAXIMUM
C  LENGTH OF STRING TO PUT IN THE VECTOR KEYWD.  IF "LENGTH" IS LESS
C  THAN "LENG", LENG IS SET TO LENGTH UPON RETURN:
C
      IF(NEXT) CALL FNDFLD
      ENDD  = LEND
      LENG1 = LENG
      LENG  = MIN0(LENGTH,LENG)
C
C  PLACE LENG CHARACTERS INTO KEYWD:
C
      DO 10 I = 1,LENG
        KEYWD(I) = LOOK(I)
   10 CONTINUE
C
C  FILL THE REST OF KEYWD WITH BLANKS:
C
      DO 20 I = LENG+1,LENG1
        KEYWD(I) = NBLA
   20 CONTINUE
      NEXT = .TRUE.
C
C  CHECK FOR END OF INPUT:
C
      IF(EQUAL(LOOK,KEND,3)) ENDD = .TRUE.
      RETURN
      END
C***********************************************************************
      SUBROUTINE FNDFLD
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBCRD1/ICD(256),LOOK(256),LENGTH,IPT,LFN,NEXP
      COMMON/NBCRD2/POINT,LEND,NEXT,EXP
      LOGICAL POINT,LEND,NEXT,EXP
C
      SAVE NBLA,NCOM,NEQ,NEXC
      DATA NBLA/1H /,NCOM/1H,/,NEQ/1H=/,NEXC/1H!/
C
C  FIND NEXT NON-BLANK STRING OF CHARACTERS IN LFN.  READ IN ANOTHER LINE
C  OF LFN UNTIL NON-BLANK CHARACTERS ARE FOUND AND PLACE THEM IN "LOOK",
C  OF LENGTH "LENGTH":
C
      IF(LEND) GO TO 35
      IF(IPT.GE.256) CALL NXTCRD
      IF(LEND) GO TO 35
C
C  LOOK FOR START OF FIELD.  SKIP TO NEXT CARD IF "!" IS ENCOUNTERED
C  (COMMENT FIELD):
C
   10 CONTINUE
      DO 20 NCOL = IPT,256
        ICARD = ICD(NCOL)
        IF(ICARD.EQ.NEXC) GO TO 30
        IF(ICARD.NE.NBLA.AND.ICARD.NE.NCOM.AND.ICARD.NE.NEQ) GO TO 40
   20 CONTINUE
C
C  NOTHING ADDITIONAL FOUND ON THIS CARD, CONTINUE WITH THE NEXT CARD:
C
   30 CALL NXTCRD
      IF(.NOT.LEND) GO TO 10
C
C  END OF FILE FOUND:
C
   35 LENGTH = 0
      RETURN
C
C  LOOK FOR THE END OF THIS FIELD, COUNTING CHARACTERS AS WE GO AND
C  STORING THESE CHARACTER IN LOOK:
C
   40 M = 0
      DO 80 MCOL = NCOL,256
        ICHAR = ICD(MCOL)
        IF(ICHAR.EQ.NBLA.OR.ICHAR.EQ.NCOM.OR.ICHAR.EQ.NEQ) GO TO 100
        M = M + 1
        LOOK(M) = ICHAR
   80 CONTINUE
C
C  SET LENGTH TO THE LENGTH OF THE NEW STRING IN LOOK AND RESET IPT TO
C  THE NEXT SPACE AFTER THIS STRING:
C
  100 LENGTH = M
      IPT = MCOL
      NEXT = .FALSE.
      RETURN
      END
C***********************************************************************
      SUBROUTINE RTNFLD
C***********************************************************************
C 12-Jun-96  EDG  New subroutine
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBCRD2/POINT,LEND,NEXT,EXP
      LOGICAL POINT,LEND,NEXT,EXP
C
C  RETURN CURRENT FIELD FOR NEXT CALL TO INPUT ROUTINES:
C
      NEXT = .FALSE.
      RETURN
      END
C***********************************************************************
      FUNCTION EQUAL(IA,IB,L)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL EQUAL
C
      DIMENSION IA(L),IB(L)
C
C  TEST IF THE FIRST L ELEMENTS OF VECTORS IA AND IB ARE EQUAL:
C
      EQUAL = .FALSE.
      DO 10 I = 1,L
        IF(IA(I).NE.IB(I)) GO TO 20
   10 CONTINUE
      EQUAL = .TRUE.
   20 RETURN
      END
C***********************************************************************
C NBO 5.G -- Natural Bond Orbital Analysis Programs
C (c) Copyright 1996-2008 Board of Regents of the University of Wisconsin System
C     on behalf of the Theoretical Chemistry Institute.  All Rights Reserved.
C***********************************************************************
C
C  OTHER SYSTEM-INDEPENDENT I/O ROUTINES:
C
C      SUBROUTINE GENINP(NEWDAF)
C      SUBROUTINE NBOINP(NBOOPT,IDONE)
C      SUBROUTINE CORINP(IESS,ICOR)
C      SUBROUTINE CHSINP(IESS,ICHS)
C      SUBROUTINE DELINP(NBOOPT,IDONE)
C
C      SUBROUTINE RDCORE(JCORE)
C      SUBROUTINE WRPPNA(T,OCC,IFLG)
C      SUBROUTINE RDPPNA(T,OCC,IFLG)
C      SUBROUTINE WRTNAO(T,IFLG)
C      SUBROUTINE RDTNAO(DM,T,SCR,IFLG)
C      SUBROUTINE WRTNAB(T,IFLG)
C      SUBROUTINE RDTNAB(T,DM,BNDOCC,SCR,IFLG)
C      SUBROUTINE WRTNBO(T,BNDOCC,IFLG)
C      SUBROUTINE WRNLMO(T,DM,IFLG)
C      SUBROUTINE WRBAS(SCR,ISCR,LFN)
C      SUBROUTINE WRARC(SCR,ISCR,LFN)
C      SUBROUTINE WRLBL(LFNLBL)
C      SUBROUTINE WRSP(F,T,LFN)
C
C      SUBROUTINE AOUT(A,MR,NR,NC,TITLE,INDEX,IFLG)
C      SUBROUTINE APRINT(A,MR,NR,NC,TITLE,INDEX,MCOL)
C      SUBROUTINE AWRITE(A,MR,NR,NC,TITLE,LFN)
C      SUBROUTINE AREAD(A,MR,NR,NC,JOB,LFN,ERROR)
C      SUBROUTINE ALTOUT(A,MR,MC,NR,NC)
C      SUBROUTINE KEYPAR(STRING,LEN,IFLG,ICHKPT,LFN,READ,ERROR)
C      FUNCTION IOINQR(IFLG)
C      SUBROUTINE LBLAO
C      SUBROUTINE LBLNAO
C      SUBROUTINE LBLNBO
C      SUBROUTINE LBLNHO(INHO,INBO,ICTR,NCTR)
C      SUBROUTINE LBLPAO
C
C***********************************************************************
      SUBROUTINE GENINP(NEWDAF)
C***********************************************************************
C 25-Nov-96  EDG  Add keyword FORMAT for formatted matrix input
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL NEWDAF,END,ERROR,EQUAL
C
      DIMENSION KEYWD(6),KGEN(4),KEND(4),KREUSE(5),KNBAS(4),KNATOM(6),
     +      KUPPER(5),KOPEN(4),KORTHO(5),KBOHR(4),KBODM(4),KEV(2),
     +      KCUBF(6),KFORM(4)
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBGEN/REUSE,UPPER,BOHR,DENOP,FORM
      LOGICAL REUSE,UPPER,BOHR,DENOP,FORM
C
      SAVE KGEN,KEND,KREUSE,KNBAS,KNATOM,KUPPER,KOPEN,KORTHO,KBOHR,
     +  KBODM,KEV,KCUBF,KFORM
      DATA KGEN/1H$,1HG,1HE,1HN/,KEND/1H$,1HE,1HN,1HD/,
     + KREUSE/1HR,1HE,1HU,1HS,1HE/,KNBAS/1HN,1HB,1HA,1HS/,
     + KNATOM/1HN,1HA,1HT,1HO,1HM,1HS/,KUPPER/1HU,1HP,1HP,1HE,1HR/,
     + KOPEN/1HO,1HP,1HE,1HN/,KORTHO/1HO,1HR,1HT,1HH,1HO/,
     + KBOHR/1HB,1HO,1HH,1HR/,KBODM/1HB,1HO,1HD,1HM/,
     + KEV/1HE,1HV/KCUBF/1HC,1HU,1HB,1HI,1HC,1HF/,
     + KFORM/1HF,1HO,1HR,1HM/
C
C  Initialize variables:
C
      NBAS   = 0
      NATOMS = 0
      MUNIT  = 0
      REUSE  = .FALSE.
      UPPER  = .FALSE.
      BOHR   = .FALSE.
      DENOP  = .TRUE.
      FORM   = .FALSE.
C
C  Search LFNIN for $GEN:
C
      REWIND(LFNIN)
   10 CALL STRTIN(LFNIN)
      LEN = 6
      CALL HFLD(KEYWD,LEN,END)
      IF(LEN.EQ.0.AND.END)
     +    CALL NBHALT('No $GEN keylist in the input file.')
      IF(.NOT.EQUAL(KEYWD,KGEN,4)) GOTO 10
C
C  $GEN has been found, now read keywords:
C
   20 LEN = 6
      CALL HFLD(KEYWD,LEN,END)
      IF(EQUAL(KEYWD,KEND,4)) GOTO 700
C
C  Keyword REUSE -- reuse data already stored on the NBO DAF:
C
      IF(EQUAL(KEYWD,KREUSE,5)) THEN
        REUSE = .TRUE.
        GOTO 20
      END IF
C
C  Keyword NBAS -- Specify the number of basis functions:
C
      IF(EQUAL(KEYWD,KNBAS,4)) THEN
        CALL IFLD(NBAS,ERROR)
        IF(ERROR)
     +   CALL NBHALT('Error reading in number of basis functions NBAS')
        GOTO 20
      END IF
C
C  Keyword NATOMS -- Specify the number of atoms:
C
      IF(EQUAL(KEYWD,KNATOM,4)) THEN
        CALL IFLD(NATOMS,ERROR)
        IF(ERROR) CALL NBHALT('Error reading in number of atoms NATOMS')
        GOTO 20
      END IF
C
C  Keyword UPPER -- Read only upper triangular portions of matrices:
C
      IF(EQUAL(KEYWD,KUPPER,5)) THEN
        UPPER = .TRUE.
        GOTO 20
      END IF
C
C  Keyword OPEN -- Open shell species (alpha and beta matrices read):
C
      IF(EQUAL(KEYWD,KOPEN,4)) THEN
        OPEN = .TRUE.
        GOTO 20
      END IF
C
C  Keyword ORTHO -- Orthogonal basis set (Skip NAO analysis):
C
      IF(EQUAL(KEYWD,KORTHO,5)) THEN
        ORTHO = .TRUE.
        GOTO 20
      END IF
C
C  Keyword BOHR -- Atomic coordinates, dipole integrals in bohr:
C
      IF(EQUAL(KEYWD,KBOHR,4)) THEN
        BOHR = .TRUE.
        GOTO 20
      END IF
C
C  Keyword BODM -- Input bond order matrix:
C
      IF(EQUAL(KEYWD,KBODM,4)) THEN
        DENOP = .FALSE.
        GOTO 20
      END IF
C
C  Keyword EV -- Expectation values of the Fock operator are in eV:
C
      IF(EQUAL(KEYWD,KEV,2)) THEN
        MUNIT = 1
        GOTO 20
      END IF
C
C  Keyword CUBICF -- Use set of cubic f functions:
C
      IF(EQUAL(KEYWD,KCUBF,6)) THEN
        IWCUBF = 1
        GOTO 20
      END IF
C
C  Keyword FORM -- Expect formatted matrix input:
C
      IF(EQUAL(KEYWD,KFORM,4)) THEN
        FORM = .TRUE.
        GOTO 20
      END IF
C
C  Unknown keyword -- halt program:
C
      WRITE(LFNPR,900) KEYWD
      CALL NBHALT('Unrecognized keyword encountered.')
C
C  End of $GEN input encountered, make sure GENNBO has all info needed:
C
  700 CONTINUE
      IF(REUSE) THEN
        NEWDAF = .FALSE.
        RETURN
      ELSE
        NEWDAF = .TRUE.
      ENDIF
C
      NDIM = NBAS
      IF(NBAS.LE.0)
     +    CALL NBHALT('NBAS must be specified in $GEN keylist.')
      IF(NBAS.GT.MAXBAS) CALL NBHALT('Increase parameter MAXBAS.')
      IF(NATOMS.LE.0)
     +    CALL NBHALT('NATOMS must be specified in $GEN keylist.')
      IF(NATOMS.GT.MAXATM) CALL NBHALT('Increase parameter MAXATM.')
      RETURN
C
  900 FORMAT(1X,'Unrecognized keyword >',6A1,'<')
      END
C***********************************************************************
      SUBROUTINE NBOINP(NBOOPT,IDONE)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL END,EQUAL
      DIMENSION NBOOPT(10)
      DIMENSION KEYWD(6),KNBO(4)
C
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      SAVE KNBO
      DATA KNBO/1H$,1HN,1HB,1HO/
C
C  If NBOOPT(1) = 1 or -1, don't search for keywords, just continue with
C  default options:
C
      IF(NBOOPT(1).EQ.1.OR.NBOOPT(1).EQ.-1) THEN
        IDONE = 0
        RETURN
      END IF
C
C  If this is the GAMESS, HONDO, or general version of the NBO program,
C  rewind the input file before searching for $NBO:
C
      IREP = 1
      IF(NBOOPT(10).EQ.0) IREP = 0
      IF(NBOOPT(10).EQ.6) IREP = 0
      IF(NBOOPT(10).EQ.7) IREP = 0
      IF(IREP.EQ.0) REWIND(LFNIN)
C
C  Search input file for $NBO:
C
   10 CALL STRTIN(LFNIN)
      LEN = 6
      CALL HFLD(KEYWD,LEN,END)
      IF(EQUAL(KEYWD,KNBO,4)) GOTO 50
      IF(LEN.EQ.0.AND.END) GOTO 60
      GOTO 10
C
C  $NBO found -- continue with the NBO analysis:
C
   50 CONTINUE
      IDONE = 0
      RETURN
C
C  End of file encountered:
C
   60 CONTINUE
C
C  Rewind and repeat search for $NBO for GAUSSIAN and AMPAC versions:
C
      IF(IREP.EQ.1) THEN
        REWIND(LFNIN)
        IREP = IREP + 1
        GOTO 10
C
C  For GENNBO, continue with default NBO options:
C
      ELSE IF(NBOOPT(10).EQ.0) THEN
        NBOOPT(1) = 1
        IDONE = 0
C
C  Otherwise, halt NBO analysis:
C
      ELSE
        IDONE = 1
        NBOOPT(10) = -NBOOPT(10)
      END IF
      RETURN
      END
C***********************************************************************
      SUBROUTINE CORINP(IESS,ICOR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL END,EQUAL
C
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
C
      DIMENSION KEYWD(6),KCOR(4),KCHS(4),KDEL(4),KNBO(4),KNRT(4),
     +   KCRD(6)
C
      SAVE KCOR,KCHS,KDEL,KNBO,KNRT,KCRD
      DATA KCOR/1H$,1HC,1HO,1HR/,KCHS/1H$,1HC,1HH,1HO/,
     +     KDEL/1H$,1HD,1HE,1HL/,KNBO/1H$,1HN,1HB,1HO/,
     +     KNRT/1H$,1HN,1HR,1HT/,KCRD/1H$,1HC,1HO,1HO,1HR,1HD/
C
C  If ICOR is set to -1, do not read in the $CORE keylist:
C
      IF(ICOR.EQ.-1) RETURN
C
C  If this is the GAMESS, HONDO, or general version of the NBO program,
C  rewind the input file before searching for $CORE:
C
      IREP = 1
      IF(IESS.EQ.0) IREP = 0
      IF(IESS.EQ.6) IREP = 0
      IF(IESS.EQ.7) IREP = 0
      IF(IREP.EQ.0) REWIND(LFNIN)
C
C  Search input file for $CORE:
C
   10 CALL STRTIN(LFNIN)
      LEN = 6
      CALL HFLD(KEYWD,LEN,END)
      IF(EQUAL(KEYWD,KCOR,4)) GOTO 50
      IF(EQUAL(KEYWD,KNBO,4)) GOTO 60
      IF(EQUAL(KEYWD,KCHS,4)) GOTO 60
      IF(EQUAL(KEYWD,KDEL,4)) GOTO 60
      IF(EQUAL(KEYWD,KNRT,4)) GOTO 60
      IF(EQUAL(KEYWD,KCRD,6)) GOTO 70
      IF(LEN.EQ.0.AND.END) GOTO 80
      GOTO 10
C
C  $CORE found:
C
   50 CONTINUE
      ICOR = 1
      RETURN
C
C  $NBO, $CHOOSE, $DEL -- discontinue the search for $CORE (GAUSSIAN, AMPAC)
C       or $NRT,    continue searching for $CORE (GENNBO, GAMESS, HONDO)
C
   60 CONTINUE
      IF(IREP.EQ.0) GOTO 10
      BACKSPACE(LFNIN)
      ICOR = 0
      RETURN
C
C  $COORD -- discontinue search for $CORE (GENNBO)
C
   70 CONTINUE
      IF(IESS.EQ.0) THEN
        ICOR = 0
        RETURN
      END IF
      GOTO 10
C
C  End of file encountered:
C
   80 CONTINUE
      ICOR = 0
C
C  Turn off the $CHOOSE keylist for GAUSSIAN and AMPAC to avoid reading
C  the EOF a second time:
C
      IF(IREP.EQ.1) ICHOOS = -1
      RETURN
      END
C***********************************************************************
      SUBROUTINE CHSINP(IESS,ICHS)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL END,EQUAL
C
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION KEYWD(6),KCHS(4),KDEL(4),KNBO(4),KNRT(4),KCRD(6)
C
      SAVE KCHS,KDEL,KNBO,KNRT,KCRD
C
      DATA KCHS/1H$,1HC,1HH,1HO/,KDEL/1H$,1HD,1HE,1HL/,
     +     KNBO/1H$,1HN,1HB,1HO/,KNRT/1H$,1HN,1HR,1HT/,
     +     KCRD/1H$,1HC,1HO,1HO,1HR,1HD/
C
C  If ICHS is set to -1, do not search for the $CHOOSE keylist:
C
      IF(ICHS.EQ.-1) RETURN
C
C  If this is the GAMESS, HONDO, or general version of the NBO program,
C  rewind the input file before searching for $CHOOSE:
C
      IREP = 1
      IF(IESS.EQ.0) IREP = 0
      IF(IESS.EQ.6) IREP = 0
      IF(IESS.EQ.7) IREP = 0
      IF(IREP.EQ.0) REWIND(LFNIN)
C
C  Search input file for $CHOOSE:
C
   10 CALL STRTIN(LFNIN)
      LEN = 6
      CALL HFLD(KEYWD,LEN,END)
      IF(EQUAL(KEYWD,KCHS,4)) GOTO 50
      IF(EQUAL(KEYWD,KNBO,4)) GOTO 60
      IF(EQUAL(KEYWD,KDEL,4)) GOTO 60
      IF(EQUAL(KEYWD,KNRT,4)) GOTO 60
      IF(EQUAL(KEYWD,KCRD,6)) GOTO 70
      IF(LEN.EQ.0.AND.END) GOTO 80
      GOTO 10
C
C  $CHOOSE found:
C
   50 CONTINUE
      WRITE(LFNPR,1000)
      ICHS = 1
      RETURN
C
C  $NBO, $DEL found -- discontinue the search for $CHOOSE (GAUSSIAN, AMPAC)
C     or $NRT,   continue searching for $CHOOSE (GENNBO, GAMESS, HONDO)
C
   60 CONTINUE
      IF(IREP.EQ.0) GOTO 10
      BACKSPACE(LFNIN)
      ICHS = 0
      RETURN
C
C  $COORD -- discontinue search for $CHOOSE (GENNBO)
C
   70 CONTINUE
      IF(IESS.EQ.0) THEN
        ICHS = 0
        RETURN
      END IF
      GOTO 10
C
C  End of file encountered:
C
   80 CONTINUE
      ICHS = 0
      RETURN
 1000 FORMAT(1X,'Reading $CHOOSE input list.')
      END
C***********************************************************************
      SUBROUTINE DELINP(NBOOPT,IDONE)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL END,EQUAL
      DIMENSION NBOOPT(10)
      DIMENSION KEYWD(6),KDEL(4),KNBO(4)
C
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      SAVE KDEL,KNBO
      DATA KDEL/1H$,1HD,1HE,1HL/,KNBO/1H$,1HN,1HB,1HO/
C
C  If this is the GAMESS, HONDO, or general version of the NBO program,
C  rewind the input file before searching for $DEL:
C
      IREP = 1
      IF(NBOOPT(10).EQ.0) IREP = 0
      IF(NBOOPT(10).EQ.6) IREP = 0
      IF(NBOOPT(10).EQ.7) IREP = 0
      IF(IREP.EQ.0) REWIND(LFNIN)
C
C  Search input file for $DEL:
C
   10 CALL STRTIN(LFNIN)
      LEN = 6
      CALL HFLD(KEYWD,LEN,END)
      IF(EQUAL(KEYWD,KDEL,4)) GOTO 50
      IF(EQUAL(KEYWD,KNBO,4)) GOTO 60
      IF(LEN.EQ.0.AND.END) GOTO 70
      GOTO 10
C
C  $DEL found -- continue with the NBO energetic analysis:
C
   50 CONTINUE
      IDONE = 0
      RETURN
C
C  $NBO found -- discontinue the search for $DEL (GAUSSIAN, AMPAC)
C                continue searching for $DEL (GENNBO, GAMESS, HONDO)
C
   60 CONTINUE
      IF(IREP.EQ.0) GOTO 10
      BACKSPACE(LFNIN)
      IDONE = 1
      RETURN
C
C  End of file encountered -- Abort NBO energetic analysis
C
   70 CONTINUE
      IF(IREP.EQ.1) THEN
        REWIND(LFNIN)
        IREP = IREP + 1
        GOTO 10
      ELSE
        IDONE = 1
      END IF
      RETURN
      END
C***********************************************************************
      SUBROUTINE RDCORE(JCORE)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL ERROR
C
      PARAMETER(MAXATM = 200)
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
C  Initialize the atomic core array:
C
      DO 10 I = 1,NATOMS
        IATCR(I) = -1
   10 CONTINUE
C
C  Read in modifications to the nominal core table:
C
      IF(JCORE.EQ.1) THEN
        WRITE(LFNPR,900)
   30   CALL IFLD(II,ERROR)
        IF(ERROR) GOTO 40
        IF(II.LT.1.OR.II.GT.NATOMS) GOTO 810
        CALL IFLD(JJ,ERROR)
        IF(ERROR) GOTO 820
        IF(JJ.LT.0) GOTO 830
        IATCR(II) = JJ
        GOTO 30
      END IF
   40 CONTINUE
      RETURN
C
  810 WRITE(LFNPR,910) II
      CALL NBHALT('Specified atom not found on molecule.')
C
  820 WRITE(LFNPR,920) II
      CALL NBHALT('No core orbitals selected on atom.')
C
  830 WRITE(LFNPR,930) JJ,II
      CALL NBHALT('Incorrect number of core orbitals on atom.')
C
  900 FORMAT(/1X,'Modified core list read from the $CORE keylist')
  910 FORMAT(/1X,'ATOM ',I4,' not found on this molecule')
  920 FORMAT(/1X,'No core orbitals selected for atom ',I4)
  930 FORMAT(/1X,I4,' core orbitals on atom ',I4,' does not make sense')
      END
C***********************************************************************
      SUBROUTINE WRPPNA(T,OCC,IFLG)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),LSTEMT(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
C
      DIMENSION T(NDIM,NNAO),OCC(NNAO)
      CHARACTER*80 TITLE
C
C  Write the PNAO information to the external file ABS(IFLG):
C
C  NOTE: This is the pure-AO to PNAO transformation, not the raw AO
C        to PNAO transform.
C
      LFN = ABS(IFLG)
      WRITE(LFN,'(I8)') NNAO
      TITLE = 'PNAOs in the PAO basis:'
      CALL AOUT(T,NDIM,NBAS,NNAO,TITLE,-1,IFLG)
C
C  Write the NAO orbital labels to the external file:
C
      WRITE(LFN,900) (NAOCTR(J),J=1,NNAO)
      WRITE(LFN,900) (NAOL(J),J=1,NNAO)
      WRITE(LFN,900) (LSTOCC(J),J=1,NNAO)
C
C  Write the PNAO orbital occupancies:
C
      WRITE(LFN,910) (OCC(J),J=1,NNAO)
      RETURN
C
  900 FORMAT(1X,20I4)
  910 FORMAT(1X,5F15.9)
      END
C***********************************************************************
      SUBROUTINE RDPPNA(T,OCC,IFLG)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),LSTEMT(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION T(NDIM,NDIM),OCC(NDIM),JOB(20)
      LOGICAL ERROR
C
C  Read the PNAO information from the external file ABS(IFLG/1000)
C
C  NOTE: This is the pure-AO to PNAO transformation, not the raw AO
C        to PNAO transform.
C
      LFN = ABS(IFLG/1000)
      WRITE(LFNPR,900) LFN
C
      READ(LFN,'(I8)') NNAO
      CALL AREAD(T,NDIM,NBAS,NNAO,JOB,LFN,ERROR)
      IF(ERROR) GOTO 800
      IF(ISPIN.GE.0) WRITE(LFNPR,910) JOB
      IF(ISPIN.LT.0) WRITE(LFNPR,920)
C
C  Read in orbital labels from LFN:
C
      READ(LFN,1000,END=810) (NAOCTR(J),J=1,NNAO)
      READ(LFN,1000,END=810) (NAOL(J),J=1,NNAO)
      READ(LFN,1000,END=810) (LSTOCC(J),J=1,NNAO)
C
C  Read orbital occupancies:
C
      READ(LFN,1010,END=820) (OCC(J),J=1,NNAO)
      RETURN
C
  800 CALL NBHALT('Error reading PAO to PNAO transformation.')
  810 CALL NBHALT('Error reading PNAO orbital labels.')
  820 CALL NBHALT('Error reading PNAO orbital occupancies.')
C
  900 FORMAT(/1X,'PNAO basis set from a previous calculation read',
     +   ' from LFN',I3,'.')
  910 FORMAT(1X,20A4)
  920 FORMAT(/1X,'See alpha NBO output for title of the transformation')
 1000 FORMAT(1X,20I4)
 1010 FORMAT(1X,5F15.9)
      END
C***********************************************************************
      SUBROUTINE WRTNAO(T,IFLG)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),LSTEMT(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
      DIMENSION T(NDIM,NDIM)
      CHARACTER*80 TITLE
C
C  NOTE: T is the PNAO overlap matrix on return to the calling routine
C
C  Fetch the AO to NAO transformation from the NBO DAF, and write
C  it to the external file ABS(IFLG):
C
      CALL FETNAO(T)
      TITLE = 'NAOs in the AO basis:'
      CALL AOUT(T,NDIM,NBAS,NNAO,TITLE,1,IFLG)
C
C  Write the NAO orbital labels to the external file:
C
      LFN = ABS(IFLG)
      WRITE(LFN,900) (NAOCTR(J),J=1,NNAO)
      WRITE(LFN,900) (NAOL(J),J=1,NNAO)
      WRITE(LFN,900) (LSTOCC(J),J=1,NNAO)
C
C  Fetch the PNAO overlap matrix from the NBO DAF, and store only the
C  upper triangular portion on the external file:
C
      CALL FESNAO(T)
      TITLE = 'PNAO overlap matrix:'
      CALL AOUT(T,NDIM,-NNAO,NNAO,TITLE,2,IFLG)
      RETURN
C
  900 FORMAT(1X,20I4)
      END
C***********************************************************************
      SUBROUTINE RDTNAO(DM,T,SCR,IFLG)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),LSTEMT(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION T(NDIM,NDIM),DM(NDIM,NDIM),SCR(NDIM)
      DIMENSION JOB(20)
      LOGICAL ERROR
C
C  NOTE: T is the PNAO overlap matrix on return to the calling routine
C        DM is the NAO density matrix on return
C
C  Read in AO to NAO transformation from the external file ABS(IFLG/1000),
C  and store it on the NBO DAF:
C
      LFN = ABS(IFLG/1000)
      WRITE(LFNPR,900) LFN
C
      REWIND(LFN)
      CALL AREAD(T,NDIM,NBAS,NNAO,JOB,LFN,ERROR)
      IF(ERROR) GOTO 800
      WRITE(LFNPR,910) JOB
      CALL SVTNAO(T)
C
C  Transform the AO density matrix, presently in DM, to the NAO basis:
C
      CALL SIMTR1(DM,T,SCR,NDIM,NBAS,NBAS,NNAO)
C
C  Read in orbital labels from LFN:
C
      READ(LFN,1000,END=810) (NAOCTR(J),J=1,NNAO)
      READ(LFN,1000,END=810) (NAOL(J),J=1,NNAO)
      READ(LFN,1000,END=810) (LSTOCC(J),J=1,NNAO)
C
C  Read the PNAO overlap from LFN, and save this matrix on the NBO DAF:
C
      CALL AREAD(T,NDIM,-NNAO,NNAO,JOB,LFN,ERROR)
      IF(ERROR) GOTO 820
      CALL SVSNAO(T)
      RETURN
C
  800 CALL NBHALT('Error reading AO to NAO transformation.')
  810 CALL NBHALT('Error reading NAO orbital labels.')
  820 CALL NBHALT('Error reading PNAO overlap matrix.')
C
  900 FORMAT(/1X,'NAO basis set from a previous calculation read',
     +   ' from LFN',I3,'.')
  910 FORMAT(1X,20A4)
 1000 FORMAT(1X,20I4)
      END
C***********************************************************************
      SUBROUTINE WRTNAB(T,IFLG)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXBAS = 2000)
      LOGICAL TALPHA
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
C
      DIMENSION T(NDIM,NDIM)
      CHARACTER*80 TITLE
C  MSPNBO's?  Write file to look like open-shell output.
      IF(IWMSP.NE.0) THEN
        TALPHA = ALPHA
        ALPHA = .TRUE.
        TITLE = 'NBOs in the NAO basis:'
        CALL AOUT(T,NDIM,NNAO,NNAO,TITLE,2,IFLG)
        LFN = ABS(IFLG)
        DO I = 1,NNAO
          WRITE(LFN,900) (LABEL(I,J),J=1,6),IBXM(I)
        ENDDO
        ALPHA = .FALSE.
        CALL AOUT(T,NDIM,NNAO,NNAO,TITLE,2,IFLG)
        DO I = 1,NNAO
          WRITE(LFN,900) (LABEL(I,J),J=1,6),IBXM(I)
        ENDDO
        ALPHA = TALPHA
        RETURN
      ENDIF
C
C  Write the NAO to NBO transformation and NBO info to external file
C  ABS(IFLG):
C
      TITLE = 'NBOs in the NAO basis:'
      CALL AOUT(T,NDIM,NNAO,NNAO,TITLE,2,IFLG)
C
C  Write the NBO labels:
C
      LFN = ABS(IFLG)
      DO 10 I = 1,NNAO
        WRITE(LFN,900) (LABEL(I,J),J=1,6),IBXM(I)
   10 CONTINUE
      RETURN
C
  900 FORMAT(1X,A2,A1,4I3,3X,I3)
      END
C***********************************************************************
      SUBROUTINE RDTNAB(T,DM,BNDOCC,SCR,IFLG)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION T(NDIM,NDIM),DM(NDIM,NDIM),BNDOCC(NDIM),SCR(NDIM)
      DIMENSION JOB(20)
      LOGICAL ERROR
C
C  Read the NAO to NBO transformation matrix from the external file
C  ABS(IFLG/1000).  Also read the NBO labels, the NBO occupancies,
C  and transform the input NAO density matrix to the NBO basis:
C
      LFN = ABS(IFLG/1000)
      WRITE(LFNPR,900) LFN
C
      IF(ISPIN.GE.0) REWIND(LFN)
      CALL AREAD(T,NDIM,NNAO,NNAO,JOB,LFN,ERROR)
      IF(ERROR) GOTO 800
      IF(ISPIN.GE.0) WRITE(LFNPR,910) JOB
      IF(ISPIN.LT.0) WRITE(LFNPR,920)
C
C  Read the NBO labels:
C
      DO 10 I = 1,NNAO
        READ(LFN,1000,END=810) (LABEL(I,J),J=1,6),IBXM(I)
   10 CONTINUE
C
C  Transform the NAO density matrix, DM, to the NBO basis, and store the
C  NBO occupancies in BNDOCC:
C
      CALL SIMTRS(DM,T,SCR,NDIM,NNAO)
      DO 20 I = 1,NNAO
        BNDOCC(I) = DM(I,I)
   20 CONTINUE
      RETURN
C
  800 CALL NBHALT('Error reading NAO to NBO transformation.')
  810 CALL NBHALT('Error reading NBO orbital labels.')
C
  900 FORMAT(/1X,'NAO to NBO transformation from a previous ',
     + 'calculation will be read from LFN',I3,'.')
  910 FORMAT(1X,20A4)
  920 FORMAT(/1X,'See alpha NBO output for title of the transformation')
 1000 FORMAT(1X,A2,A1,4I3,3X,I3)
      END
C***********************************************************************
      SUBROUTINE WRTNBO(T,BNDOCC,IFLG)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
C
      DIMENSION T(NDIM,NDIM),BNDOCC(*)
      CHARACTER*80 TITLE
C
C  Write the AO to NBO transformation matrix and NBO info to the external
C  file ABS(IFLG):
C
      TITLE = 'NBOs in the AO basis:'
      CALL AOUT(T,NDIM,NBAS,NNAO,TITLE,1,IFLG)
C
C  Write out the NBO occupancies:
C
      LFN = ABS(IFLG)
      WRITE(LFN,900) (BNDOCC(J),J=1,NNAO)
C
C  Write out NBOUNI, NBOTYP, LABEL, IBXM, and IATNO:
C
      WRITE(LFN,910) (NBOUNI(J),J=1,NNAO)
      WRITE(LFN,910) (NBOTYP(J),J=1,NNAO)
      WRITE(LFN,920) (LABEL(J,1),J=1,NNAO)
      WRITE(LFN,920) (LABEL(J,2),J=1,NNAO)
      WRITE(LFN,910) (LABEL(J,3),J=1,NNAO)
      WRITE(LFN,910) (LABEL(J,4),J=1,NNAO)
      WRITE(LFN,910) (LABEL(J,5),J=1,NNAO)
      WRITE(LFN,910) (LABEL(J,6),J=1,NNAO)
      WRITE(LFN,910) (IBXM(J),J=1,NNAO)
      WRITE(LFN,910) (IATNO(J),J=1,NATOMS)
      RETURN
C
  900 FORMAT(1X,5F15.9)
  910 FORMAT(1X,20I3)
  920 FORMAT(1X,20A3)
      END
C***********************************************************************
      SUBROUTINE WRNLMO(T,DM,IFLG)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
C
      DIMENSION T(NDIM,NDIM),DM(NDIM,NDIM)
      CHARACTER*80 TITLE
C
C  Write the AO to NLMO transformation matrix and NLMO info to the external
C  file ABS(IFLG):
C
      TITLE = 'NLMOs in the AO basis:'
      CALL AOUT(T,NDIM,NBAS,NNAO,TITLE,1,IFLG)
C
C  Write out the NLMO occupancies:
C
      LFN = ABS(IFLG)
      WRITE(LFN,900) (DM(J,J),J=1,NNAO)
C
C  Write out NBOUNI, NBOTYP, LABEL, IBXM, and IATNO:
C
      WRITE(LFN,910) (NBOUNI(J),J=1,NNAO)
      WRITE(LFN,910) (NBOTYP(J),J=1,NNAO)
      WRITE(LFN,920) (LABEL(J,1),J=1,NNAO)
      WRITE(LFN,920) (LABEL(J,2),J=1,NNAO)
      WRITE(LFN,910) (LABEL(J,3),J=1,NNAO)
      WRITE(LFN,910) (LABEL(J,4),J=1,NNAO)
      WRITE(LFN,910) (LABEL(J,5),J=1,NNAO)
      WRITE(LFN,910) (LABEL(J,6),J=1,NNAO)
      WRITE(LFN,910) (IBXM(J),J=1,NNAO)
      WRITE(LFN,910) (IATNO(J),J=1,NATOMS)
      RETURN
C
  900 FORMAT(1X,5F15.9)
  910 FORMAT(1X,20I3)
  920 FORMAT(1X,20A3)
      END
C***********************************************************************
      SUBROUTINE WRBAS(SCR,ISCR,LFN)
C***********************************************************************
C
C  Save the AO basis set information on an external file:
C
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBAO/LCTR(MAXBAS),LANG(MAXBAS)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION SCR(*),ISCR(*)
C
C  Fetch the number of shells NSHELL, the number of exponents NEXP,
C  the NCOMP, NPRIM, and NPTR arrays, and the orbital exponents and
C  coefficients from the NBO DAF:
C
      CALL FEBAS(NSHELL,NEXP,ISCR)
C
C  If NSHELL is zero, then no basis set info has been stored in the
C  DAF:
C
      IF(NSHELL.EQ.0) THEN
        WRITE(LFNPR,900)
        RETURN
      END IF
C
C  Partition the scratch arrays:  (Note that SCR and ISCR occupy the same
C  space in memory)
C
C  ISCR: (integer)
C
C   NSHELL NEXP  NCOMP  NPRIM  NPTR
C  +------+-----+------+------+-----+-----------------------------------
C               I1     I2     I3
C
C  SCR: (real)
C                                                                    ATCOOR
C                                     EXP   CS   CP   CD   CF   CG   TITLE
C  ---------------------------------+-----+----+----+----+----+----+--------
C                                   I4    I5   I6   I7   I8   I9   I10
C
C  ISCR(I1) : NCOMP(1..NSHELL)
C  ISCR(I2) : NPRIM(1..NSHELL)
C  ISCR(I3) : NPTR(1..NSHELL)
C  SCR(I4)  : EXP(1..NEXP)
C  SCR(I5)  : CS(1..NEXP)
C  SCR(I6)  : CP(1..NEXP)
C  SCR(I7)  : CD(1..NEXP)
C  SCR(I8)  : CF(1..NEXP)
C  SCR(I9)  : CG(1..NEXP)
C  SCR(I10) : TITLE(10) or ATCOOR(3*NATOMS)
C
      I1   = 3
      I2   = I1 + NSHELL
      I3   = I2 + NSHELL
      I4   = I3 + NSHELL
      I5   = I4 + NEXP
      I6   = I5 + NEXP
      I7   = I6 + NEXP
      I8   = I7 + NEXP
      I9   = I8 + NEXP
      I10  = I9 + NEXP
C     IEND = I10 + MAX0(3*NATOMS,10)
C
C  Fetch job title and write it to the AOINFO external file:
C
      CALL FETITL(SCR(I10))
C
C  Begin writing to the AOINFO external file:
C
      WRITE(LFN,910) (SCR(I10+I),I=0,9)
      WRITE(LFN,920) NATOMS,NSHELL,NEXP
C
C  Fetch the atomic coordinates:
C
      CALL FECOOR(SCR(I10))
C
C  Write atomic numbers and coordinates to external file:
C
      J = 0
      DO 10 I = 1,NATOMS
        WRITE(LFN,930) IATNO(I),(SCR(I10+J+K),K=0,2)
        J = J + 3
   10 CONTINUE
      WRITE(LFN,940)
C
C  Write out information about each shell in the basis set:
C
C     NCTR(I)  --  atomic center of the Ith shell
C
C     NCOMP(I) --  number of components in the Ith shell
C
C     NPTR(I)  --  pointer for the Ith shell into the primitive parameters
C                  of EXP, CS, CP, CD, CF, and CG
C
C     NPRIM(I) --  number of primitive functions in the Ith shell
C
C     LABEL(1..NCOMP(I)) -- symmetry labels for the orbitals of this shell
C
      J1 = 1
      J2 = I1
      J3 = I3
      J4 = I2
      DO 20 I = 1,NSHELL
        NCOMP = ISCR(J2)
        NPRIM = ISCR(J3)
        NPTR  = ISCR(J4)
        WRITE(LFN,950) LCTR(J1),NCOMP,NPRIM,NPTR
        WRITE(LFN,950) (LANG(J1+J),J=0,NCOMP-1)
        J1 = J1 + NCOMP
        J2 = J2 + 1
        J3 = J3 + 1
        J4 = J4 + 1
   20 CONTINUE
      WRITE(LFN,940)
C
C  Write out the primitive parameters:
C
      WRITE(LFN,960) (SCR(I4+I),I=0,NEXP-1)
      WRITE(LFN,970)
      WRITE(LFN,960) (SCR(I5+I),I=0,NEXP-1)
      WRITE(LFN,970)
      WRITE(LFN,960) (SCR(I6+I),I=0,NEXP-1)
      WRITE(LFN,970)
      WRITE(LFN,960) (SCR(I7+I),I=0,NEXP-1)
      WRITE(LFN,970)
      WRITE(LFN,960) (SCR(I8+I),I=0,NEXP-1)
      WRITE(LFN,970)
      WRITE(LFN,960) (SCR(I9+I),I=0,NEXP-1)
      RETURN
C
  900 FORMAT(/1X,'No basis set information is stored on the NBO direct',
     + ' access file.',/1X,'Thus, no `AOINFO'' file can be written.')
  910 FORMAT(1X,9A8,A7,/1X,'Basis set information needed for plotting ',
     + 'orbitals',/1X,75('-'))
  920 FORMAT(1X,3I6,/1X,75('-'))
  930 FORMAT(1X,I4,3(2X,F12.9))
  940 FORMAT(1X,75('-'))
  950 FORMAT(1X,10I6)
  960 FORMAT(2X,4E18.9)
  970 FORMAT(1X)
      END
C***********************************************************************
      SUBROUTINE WRARC(SCR,ISCR,LFN)
C***********************************************************************
C 25-Nov-96  EDG  Add FORMAT to $GENNBO for formatted matrices
C 12-Oct-93  JKB  Add FILE=filename to $NBO keylist
C 14-Jan-93  EDG  Add $KINETIC and $NUCLEAR datalists
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL PACK
      CHARACTER*11 IDENT
      CHARACTER*6 TERM
C
      PARAMETER (MAXD = 4)
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      PARAMETER (MAXFIL = 40)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBAO/LCTR(MAXBAS),LANG(MAXBAS)
      COMMON/NBNAME/FILENM,NFILE,IFILE(MAXFIL)
      CHARACTER*256 FILENM
C
      DIMENSION SCR(*),ISCR(*),IK(MAXD)
      DIMENSION KGEN(7),KNAT(6),KBAS(4),KOPEN(4),KORTHO(5),KUPPER(5),
     + KBODM(4),KEV(2),KCUBF(6),KEND(4),KCAL(4),KFORM(6)
C
      SAVE KGEN,KBAS,KNAT,KOPEN,KORTHO,KUPPER,KBODM,KEV,KEND,KCUBF,KCAL,
     +  KFORM,KBLNK,KEQ,ABLNKS,ACENTR,ALABEL,ANSHLL,ANEXP,ANCOMP,ANPRIM,
     +  ANPTR,AEXP,ACS,ACP,ACD,ACF,ACG,ZERO,IDENT,TERM
C
      DATA KGEN/1H$,1HG,1HE,1HN,1HN,1HB,1HO/,KBAS/1HN,1HB,1HA,1HS/,
     +     KNAT/1HN,1HA,1HT,1HO,1HM,1HS/,KOPEN/1HO,1HP,1HE,1HN/,
     +     KORTHO/1HO,1HR,1HT,1HH,1HO/,KUPPER/1HU,1HP,1HP,1HE,1HR/,
     +     KBODM/1HB,1HO,1HD,1HM/,KEV/1HE,1HV/,KEND/1H$,1HE,1HN,1HD/,
     +     KCUBF/1HC,1HU,1HB,1HI,1HC,1HF/,KCAL/1HK,1HC,1HA,1HL/,
     +     KFORM/1HF,1HO,1HR,1HM,1HA,1HT/
      DATA KBLNK,KEQ/1H ,1H=/
      DATA ABLNKS,ACENTR,ALABEL/8H        ,8HCENTER =,8H LABEL =/
      DATA ANSHLL,ANEXP ,ANCOMP/8HNSHELL =,8H  NEXP =,8H NCOMP =/
      DATA ANPRIM,ANPTR ,AEXP  /8H NPRIM =,8H  NPTR =,8H   EXP =/
      DATA ACS,ACP,ACD,ACF/8H    CS =,8H    CP =,8H    CD =,8H    CF =/
      DATA ACG/8H    CG =/
      DATA ZERO/0.0D0/
      DATA IDENT,TERM/'$NBO  FILE=','  $END'/
C
C  Write the ARCHIVE file to LFN:
C
C  This routine has been written assuming NBAS = NDIM.  Skip if
C  this condition is not satisfied:
C
      IF(NBAS.NE.NDIM) THEN
        WRITE(LFNPR,890)
        RETURN
      END IF
C
C  Form the $GENNBO keylist in ISCR:
C
      NC = 0
      DO 10 I = 1,7
        NC = NC + 1
        ISCR(NC) = KGEN(I)
   10 CONTINUE
      NC = NC + 1
      ISCR(NC) = KBLNK
      NC = NC + 1
      ISCR(NC) = KBLNK
C
C  Add the number of atoms and basis functions:
C
      DO 20 I = 1,6
        NC = NC + 1
        ISCR(NC) = KNAT(I)
   20 CONTINUE
      NC = NC + 1
      ISCR(NC) = KEQ
      CALL IDIGIT(NATOMS,IK,ND,MAXD)
      DO 30 I = 1,ND
        NC = NC + 1
        ISCR(NC) = IK(I)
   30 CONTINUE
      NC = NC + 1
      ISCR(NC) = KBLNK
      NC = NC + 1
      ISCR(NC) = KBLNK
C
      DO 40 I = 1,4
        NC = NC + 1
        ISCR(NC) = KBAS(I)
   40 CONTINUE
      NC = NC + 1
      ISCR(NC) = KEQ
      CALL IDIGIT(NBAS,IK,ND,MAXD)
      DO 50 I = 1,ND
        NC = NC + 1
        ISCR(NC) = IK(I)
   50 CONTINUE
      NC = NC + 1
      ISCR(NC) = KBLNK
      NC = NC + 1
      ISCR(NC) = KBLNK
C
C  If OPEN shell, add the OPEN keyword:
C
      IF(OPEN) THEN
        DO 60 I = 1,4
          NC = NC + 1
          ISCR(NC) = KOPEN(I)
   60   CONTINUE
        NC = NC + 1
        ISCR(NC) = KBLNK
        NC = NC + 1
        ISCR(NC) = KBLNK
      END IF
C
C  If the AO basis is orthogonal, add the ORTHO keyword:
C
      IF(ORTHO) THEN
        DO 70 I = 1,5
          NC = NC + 1
          ISCR(NC) = KORTHO(I)
   70   CONTINUE
        NC = NC + 1
        ISCR(NC) = KBLNK
        NC = NC + 1
        ISCR(NC) = KBLNK
      END IF
C
C  Only UPPER triangular portions of symmetric matrices will be given:
C
      DO 80 I = 1,5
        NC = NC + 1
        ISCR(NC) = KUPPER(I)
   80 CONTINUE
      NC = NC + 1
      ISCR(NC) = KBLNK
      NC = NC + 1
      ISCR(NC) = KBLNK
C
C  Enter the bond-order matrix, BODM, if possible:
C
      IF(IWDM.EQ.1) THEN
        DO 90 I = 1,4
          NC = NC + 1
          ISCR(NC) = KBODM(I)
   90   CONTINUE
        NC = NC + 1
        ISCR(NC) = KBLNK
        NC = NC + 1
        ISCR(NC) = KBLNK
      END IF
C
C  Add EV if the energy units are in electron volts:
C
      IF(MUNIT.EQ.1) THEN
        NC = NC + 1
        ISCR(NC) = KEV(1)
        NC = NC + 1
        ISCR(NC) = KEV(2)
        NC = NC + 1
        ISCR(NC) = KBLNK
        NC = NC + 1
        ISCR(NC) = KBLNK
      END IF
C
C  Add KCAL if the energy units are in kcal/mol:
C
      IF(MUNIT.EQ.1) THEN
        NC = NC + 1
        ISCR(NC) = KCAL(1)
        NC = NC + 1
        ISCR(NC) = KCAL(2)
        NC = NC + 1
        ISCR(NC) = KCAL(3)
        NC = NC + 1
        ISCR(NC) = KCAL(4)
        NC = NC + 1
        ISCR(NC) = KBLNK
        NC = NC + 1
        ISCR(NC) = KBLNK
      END IF
C
C  Add CUBICF if these types of orbitals are being used:
C
      IF(IWCUBF.NE.0) THEN
        DO 100 I = 1,6
          NC = NC + 1
          ISCR(NC) = KCUBF(I)
  100   CONTINUE
        NC = NC + 1
        ISCR(NC) = KBLNK
        NC = NC + 1
        ISCR(NC) = KBLNK
      END IF
C
C  Add FORM; formatted matrices will be written:
C
      DO 105 I = 1,6
        NC = NC + 1
        ISCR(NC) = KFORM(I)
  105 CONTINUE
      NC = NC + 1
      ISCR(NC) = KBLNK
      NC = NC + 1
      ISCR(NC) = KBLNK
C
C  Add $END:
C
      DO 110 I = 1,4
        NC = NC + 1
        ISCR(NC) = KEND(I)
  110 CONTINUE
C
C  Write the $GENNBO keylist to the archive file:
C
      WRITE(LFN,900) (ISCR(I),I=1,NC)
C
C  Write the $NBO keylist to the archive file:
C
      IF(FILENM(1:4).EQ.'FILE') THEN
        WRITE(LFN,910)
      ELSE
        LEN = LENNB(FILENM)
        WRITE(LFN,915) (IDENT(I:I),I=1,11),(FILENM(I:I),I=1,LEN),
     +                 (TERM(I:I),I=1,6)
      END IF
C
C  Write the $COORD data list to the archive file:
C
      WRITE(LFN,920)
      CALL FETITL(SCR)
      WRITE(LFN,930) (SCR(I),I=1,10)
      CALL FECOOR(SCR)
      J = 1
      DO 120 I = 1,NATOMS
        WRITE(LFN,940) IATNO(I),IZNUC(I),SCR(J),SCR(J+1),SCR(J+2)
        J = J + 3
  120 CONTINUE
      WRITE(LFN,950)
C
C  Write the $BASIS datalist to the archive file (info from /NBAO/):
C
      WRITE(LFN,960)
      NINT = 13
      STR = ACENTR
      DO 130 I = 1,(NBAS-1)/NINT+1
        NL  = (I - 1) * NINT + 1
        NU  = MIN0(NL+NINT-1,NBAS)
        WRITE(LFN,970) STR,(LCTR(J),J=NL,NU)
        STR = ABLNKS
  130 CONTINUE
      STR = ALABEL
      DO 140 I = 1,(NBAS-1)/NINT+1
        NL  = (I - 1) * NINT + 1
        NU  = MIN0(NL+NINT-1,NBAS)
        WRITE(LFN,970) STR,(LANG(J),J=NL,NU)
        STR = ABLNKS
  140 CONTINUE
      WRITE(LFN,950)
C
C  Write the $CONTRACT datalist to the archive file:
C
C  Fetch the basis set info from the NBO DAF:
C
      CALL FEBAS(NSHELL,NEXP,ISCR)
C
C  Partition the scratch vector:
C
C  ISCR(I1) : NCOMP(1..NSHELL)
C  ISCR(I2) : NPRIM(1..NSHELL)
C  ISCR(I3) : NPTR(1..NSHELL)
C  SCR(I4)  : EXP(1..NEXP)
C  SCR(I5)  : CS(1..NEXP)
C  SCR(I6)  : CP(1..NEXP)
C  SCR(I7)  : CD(1..NEXP)
C  SCR(I8)  : CF(1..NEXP)
C  SCR(I9)  : CG(1..NEXP)
C
      I1   = 3
      I2   = I1 + NSHELL
      I3   = I2 + NSHELL
      I4   = I3 + NSHELL
      I5   = I4 + NEXP
      I6   = I5 + NEXP
      I7   = I6 + NEXP
      I8   = I7 + NEXP
      I9   = I8 + NEXP
C     IEND = I9 + NEXP
C
C  If NSHELL is zero, then no basis set info was ever stored on
C  the DAF:
C
      IF(NSHELL.GT.0) THEN
C
C  Write out numbers of shells and orbital exponents:
C
        WRITE(LFN,980)
        WRITE(LFN,970) ANSHLL,NSHELL
        WRITE(LFN,970) ANEXP,NEXP
C
C  Write out the number of components in each shell:
C
        NINT = 13
        STR = ANCOMP
        DO 150 I = 1,(NSHELL-1)/NINT+1
          NL  = (I - 1) * NINT + 1
          NU  = MIN0(NL+NINT-1,NSHELL)
          WRITE(LFN,970) STR,(ISCR(J),J=I1+NL-1,I1+NU-1)
          STR = ABLNKS
  150   CONTINUE
C
C  Write out the number of primitives in each shell:
C
        STR = ANPRIM
        DO 160 I = 1,(NSHELL-1)/NINT+1
          NL  = (I - 1) * NINT + 1
          NU  = MIN0(NL+NINT-1,NSHELL)
          WRITE(LFN,970) STR,(ISCR(J),J=I2+NL-1,I2+NU-1)
          STR = ABLNKS
  160   CONTINUE
C
C  Write out pointer array which maps orbital exponents and coefficients
C  onto each shell:
C
        STR = ANPTR
        DO 170 I = 1,(NSHELL-1)/NINT+1
          NL  = (I - 1) * NINT + 1
          NU  = MIN0(NL+NINT-1,NSHELL)
          WRITE(LFN,970) STR,(ISCR(J),J=I3+NL-1,I3+NU-1)
          STR = ABLNKS
  170   CONTINUE
C
C  Write out orbital exponents:
C
        NREAL = 4
        STR   = AEXP
        DO 180 I = 1,(NEXP-1)/NREAL+1
          NL  = (I - 1) * NREAL + 1
          NU  = MIN0(NL+NREAL-1,NEXP)
          WRITE(LFN,990) STR,(SCR(J),J=I4+NL-1,I4+NU-1)
          STR = ABLNKS
  180   CONTINUE
C
C  Write out the orbital coefficients for each angular symmetry type
C  unless there are no basis functions of that type:
C
        DO 210 I = 1,5
          IF(I.EQ.1) THEN
            STR = ACS
            II  = I5
          ELSE IF(I.EQ.2) THEN
            STR = ACP
            II  = I6
          ELSE IF(I.EQ.3) THEN
            STR = ACD
            II  = I7
          ELSE IF(I.EQ.4) THEN
            STR = ACF
            II  = I8
          ELSE IF(I.EQ.5) THEN
            STR = ACG
            II  = I9
          END IF
          IFLG = 0
          DO 190 J = II,II+NEXP-1
            IF(SCR(J).NE.ZERO) IFLG = 1
  190     CONTINUE
          IF(IFLG.EQ.1) THEN
            DO 200 J = 1,(NEXP-1)/NREAL+1
              NL  = (J - 1) * NREAL + 1
              NU  = MIN0(NL+NREAL-1,NEXP)
              WRITE(LFN,990) STR,(SCR(K),K=II+NL-1,II+NU-1)
              STR = ABLNKS
  200       CONTINUE
          END IF
  210   CONTINUE
        WRITE(LFN,950)
      END IF
C
C  Write the $OVERLAP datalist unless the AO basis is orthogonal:
C
      L2 = NBAS * (NBAS + 1) / 2
      IF(.NOT.ORTHO) THEN
        WRITE(LFN,1000)
        CALL FESRAW(SCR)
        CALL PACK(SCR,NDIM,NBAS)
        WRITE(LFN,1010) (SCR(I),I=1,L2)
        WRITE(LFN,950)
      END IF
C
C  Write the $DENSITY datalist:
C
      WRITE(LFN,1020)
      IF(OPEN) THEN
        ALPHA = .TRUE.
        BETA  = .FALSE.
        CALL FEDRAW(SCR,SCR)
        CALL PACK(SCR,NDIM,NBAS)
        WRITE(LFN,1010) (SCR(I),I=1,L2)
        ALPHA = .FALSE.
        BETA  = .TRUE.
        CALL FEDRAW(SCR,SCR)
        CALL PACK(SCR,NDIM,NBAS)
        WRITE(LFN,1010) (SCR(I),I=1,L2)
      ELSE
        ALPHA = .FALSE.
        BETA  = .FALSE.
        CALL FEDRAW(SCR,SCR)
        CALL PACK(SCR,NDIM,NBAS)
        WRITE(LFN,1010) (SCR(I),I=1,L2)
      END IF
      WRITE(LFN,950)
C
C  Write the $FOCK datalist:
C
      IF(OPEN) THEN
        ALPHA = .TRUE.
        BETA  = .FALSE.
        IWFOCK = 1
        CALL FEFAO(SCR,IWFOCK)
        IF(IWFOCK.NE.0) THEN
          WRITE(LFN,1030)
          CALL PACK(SCR,NDIM,NBAS)
          WRITE(LFN,1010) (SCR(I),I=1,L2)
          ALPHA = .FALSE.
          BETA  = .TRUE.
          CALL FEFAO(SCR,IWFOCK)
          CALL PACK(SCR,NDIM,NBAS)
          WRITE(LFN,1010) (SCR(I),I=1,L2)
          WRITE(LFN,950)
        END IF
      ELSE
        ALPHA = .FALSE.
        BETA  = .FALSE.
        IWFOCK = 1
        CALL FEFAO(SCR,IWFOCK)
        IF(IWFOCK.NE.0) THEN
          WRITE(LFN,1030)
          CALL PACK(SCR,NDIM,NBAS)
          WRITE(LFN,1010) (SCR(I),I=1,L2)
          WRITE(LFN,950)
        END IF
      END IF
C
C  Write the $LCAOMO datalist:
C
      IF(OPEN) THEN
        ALPHA = .TRUE.
        BETA  = .FALSE.
        CALL FEAOMO(SCR,IAOMO)
        IF(IAOMO.EQ.1) THEN
          WRITE(LFN,1040)
          WRITE(LFN,1010) (SCR(I),I=1,NDIM*NDIM)
          ALPHA = .FALSE.
          BETA  = .TRUE.
          CALL FEAOMO(SCR,IAOMO)
          WRITE(LFN,1010) (SCR(I),I=1,NDIM*NDIM)
          WRITE(LFN,950)
        END IF
      ELSE
        ALPHA = .FALSE.
        BETA  = .FALSE.
        CALL FEAOMO(SCR,IAOMO)
        IF(IAOMO.EQ.1) THEN
          WRITE(LFN,1040)
          WRITE(LFN,1010) (SCR(I),I=1,NDIM*NDIM)
          WRITE(LFN,950)
        END IF
      END IF
C
C  Write the $KINETIC datalist:
C
      CALL FEKAO(SCR,IT)
      IF(IT.EQ.1) THEN
        CALL PACK(SCR,NDIM,NBAS)
        WRITE(LFN,1060)
        WRITE(LFN,1010) (SCR(I),I=1,L2)
        WRITE(LFN,950)
      END IF
C
C  Write the $NUCLEAR datalist:
C
      CALL FEVAO(SCR,IV)
      IF(IV.EQ.1) THEN
        CALL PACK(SCR,NDIM,NBAS)
        WRITE(LFN,1070)
        WRITE(LFN,1010) (SCR(I),I=1,L2)
        WRITE(LFN,950)
      END IF
C
C  Write the $DIPOLE datalist:
C
      IDIP = 1
      CALL FEDXYZ(SCR,IDIP)
      IF(IDIP.NE.0) THEN
        WRITE(LFN,1050)
        CALL PACK(SCR,NDIM,NBAS)
        WRITE(LFN,1010) (SCR(I),I=1,L2)
        IDIP = 2
        CALL FEDXYZ(SCR,IDIP)
        CALL PACK(SCR,NDIM,NBAS)
        WRITE(LFN,1010) (SCR(I),I=1,L2)
        IDIP = 3
        CALL FEDXYZ(SCR,IDIP)
        CALL PACK(SCR,NDIM,NBAS)
        WRITE(LFN,1010) (SCR(I),I=1,L2)
        WRITE(LFN,950)
      END IF
      CLOSE(LFN)
C
C  Reset logicals ALPHA and BETA:
C
      ALPHA = ISPIN.EQ.2
      BETA  = ISPIN.EQ.-2
      RETURN
C
  890 FORMAT(/1X,'The routine which writes the ARCHIVE file assumes ',
     + 'NBAS = NDIM.  Since',/1X,'this condition is not satisfied, ',
     + 'the ARCHIVE file will not be written.')
  900 FORMAT(1X,78A1)
  910 FORMAT(1X,'$NBO  $END')
  915 FORMAT(1X,78A1)
  920 FORMAT(1X,'$COORD')
  930 FORMAT(1X,9A8,A6)
  940 FORMAT(1X,2I5,3F15.6)
  950 FORMAT(1X,'$END')
  960 FORMAT(1X,'$BASIS')
  970 FORMAT(1X,1X,A8,1X,13(I4,1X))
  980 FORMAT(1X,'$CONTRACT')
  990 FORMAT(1X,1X,A8,1X,4(E15.7,1X))
 1000 FORMAT(1X,'$OVERLAP')
 1010 FORMAT(1X,1X,5E15.7)
 1020 FORMAT(1X,'$DENSITY')
 1030 FORMAT(1X,'$FOCK')
 1040 FORMAT(1X,'$LCAOMO')
 1050 FORMAT(1X,'$DIPOLE')
 1060 FORMAT(1X,'$KINETIC')
 1070 FORMAT(1X,'$NUCLEAR')
      END
C***********************************************************************
      SUBROUTINE WRLBL(LFNLBL)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER SPIN*5
      PARAMETER(MAXBAS = 2000)
      COMMON/NBLBL/NLEW,NVAL,LBL(10,MAXBAS,5)
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION BASIS(6)
C
      SAVE BASIS
      DATA BASIS/4H AO ,4H NAO,4H NHO,4H NBO,4HNLMO,4HPAO /
C
C    Write the label information to LFNLBL for PLOT keyword
C
C          IBAS -- Index selecting appropriate output labels
C                   1 : AO   labels
C                   2 : NAO  labels
C                   3 : NHO  labels
C                   4 : NBO  labels
C                   5 : NLMO labels  (skip)
C                   6 : PAO  labels  (not implemented)
C
      IF(ALPHA) THEN
        SPIN='ALPHA'
      ELSEIF(BETA) THEN
        SPIN='BETA '
      ELSE
        SPIN='     '
      END IF
C
      DO 20 IBAS = 1,4
        N = NNAO
        IF(IBAS.EQ.1) N = NBAS
        ILABEL = IBAS
        WRITE(LFNLBL,1000) BASIS(IBAS),SPIN,N
        N2=0
   10   N1=N2+1
          N2=N2+7
          IF(N2.GT.N) N2 = N
          WRITE(LFNLBL,1100) ((LBL(J,I,ILABEL),J=1,10),I=N1,N2)
        IF(N2.LT.N) GOTO 10
   20 CONTINUE
      RETURN
C
 1000 FORMAT(1X,A4,1X,A5,I4)
 1100 FORMAT(1X,7(10A1))
      END
C***********************************************************************
      SUBROUTINE WRSP(F,T,LFN)
C***********************************************************************
C  2-Jul-96  EDG  New subroutine
C 31-Oct-00  FAW  Inverted DIMENSION and COMMON statements
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      DIMENSION F(NDIM,NDIM),T(NDIM,NDIM)
C
C  Write orbital energies and vectors to Spartan archive file:
C
      IF(LFN.GT.0) WRITE(    LFN ,900)
      IF(LFN.LT.0) WRITE(ABS(LFN),910)
      WRITE(ABS(LFN),920) (F(I,I),I=1,NNAO)
      DO 10 I = 1,NNAO
        WRITE(ABS(LFN),920) (T(J,I),J=1,NBAS)
   10 CONTINUE
      RETURN
C
  900 FORMAT('NBO energies and vectors in Spartan archive format',/,
     +       'WAVEFUNC')
  910 FORMAT('NLMO energies and vectors in Spartan archive format',/,
     +       'WAVEFUNC')
  920 FORMAT(4E19.10)
      END
C***********************************************************************
      SUBROUTINE AOUT(A,MR,NR,NC,TITLE,INDEX,IFLG)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION A(MR,*)
      CHARACTER*80 TITLE
      DIMENSION ISHELL(4)
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBLBL/NLEW,NVAL,LBL(10,MAXBAS,5)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
      SAVE KFULL,KVAL,KLEW
      DATA KFULL,KVAL,KLEW/4HFULL,3HVAL,3HLEW/
C
C  Either write A to an external file, or print it in the output file:
C
C  Input:  A     -- matrix to be printed or written out
C
C          MR    -- row dimension of matrix A in calling routine
C
C          NR    -- ABS(NR) is the actual number of rows to be output
C                   [if NR is negative, IFLG is negative (write), and
C                    ABS(NR).EQ.NC (square matrix), only the upper
C                    triangular portion is written out]
C
C          NC    -- actual number of columns in matrix A
C                   [used to determine if A is square, and as an upper
C                    limit on IFLG]
C
C          TITLE -- CHARACTER*80 variable containing a matrix title
C
C          INDEX -- Index selecting appropriate output labels
C                  -2 : VEC  labels
C                  -1 : MO   labels
C                   0 : Atom labels
C                   1 : AO   labels
C                   2 : NAO  labels
C                   3 : NHO  labels
C                   4 : NBO  labels
C                   5 : NLMO labels
C                   6 : PAO  labels
C
C          IFLG  -- print/write flag
C                   negative : write to LFN ABS(IFLG)
C                   positive : print IFLG columns of A
C                   'FULL'   : print the full matrix
C                   'VAL'    : print N columns of A, where N is the
C                              number of core + valence orbitals and
C                              is determined by this routine
C                   'LEW'    : print N columns of A, where N is the
C                              number of occupied orbitals and is
C                              determined by this routine
C
      JFLG = IFLG
      IF(JFLG.EQ.0) RETURN
C
C  If JFLG is FULL, then output the total number of columns:
C
      IF(JFLG.EQ.KFULL) JFLG = ABS(NC)
C
C  If JFLG = VAL, output only the valence orbitals, determined from the
C  core and valence tables:
C
      IF(JFLG.EQ.KVAL) THEN
        IF(NVAL.LT.0) THEN
          IECP = 0
          JFLG = 0
          DO 30 IAT = 1,NATOMS
            CALL CORTBL(IAT,ISHELL,IECP)
            DO 10 I = 1,4
              MULT = 2 * (I-1) + 1
              JFLG = JFLG + ISHELL(I)*MULT
   10       CONTINUE
            CALL VALTBL(IAT,ISHELL,0)
            DO 20 I = 1,4
              MULT = 2 * (I-1) + 1
              JFLG = JFLG + ISHELL(I)*MULT
   20       CONTINUE
   30     CONTINUE
        ELSE
          JFLG = NVAL
        END IF
      END IF
C
C  If JFLG is LEW, only output the occupied orbitals:
C
      IF(JFLG.EQ.KLEW) JFLG = NLEW
C
C  If JFLG is positive, print the matrix A in the output file:
C
      IF(JFLG.GT.0) CALL APRINT(A,MR,NR,NC,TITLE,INDEX,JFLG)
C
C  If JFLG is negative but greater than -1000, write matrix A to the external
C  file ABS(JFLG):
C
      IF(JFLG.LT.0.AND.JFLG.GT.-1000) CALL AWRITE(A,MR,NR,NC,TITLE,JFLG)
C
      RETURN
      END
C***********************************************************************
      SUBROUTINE APRINT(A,MR,NR,NC,TITLE,INDEX,MCOL)
C***********************************************************************
C 14-Jan-93  EDG  Added support for MO basis (INDEX=-1)
C 23-Feb-01  FAW  Print user-selected elements from COMMON/NBELEM/
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION A(MR,*)
      CHARACTER*80 TITLE
      DIMENSION BASIS(6)
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBLBL/NLEW,NVAL,LBL(10,MAXBAS,5)
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBELEM/IJELEM(2,100),NELEM
C
      SAVE BASIS,ATOM,DASHES,TENTH
      DATA BASIS/4H AO ,4H NAO,4H NHO,4H NBO,4HNLMO,4HPAO /
      DATA ATOM,DASHES/4HAtom,8H--------/
      DATA TENTH/0.1D0/
C  Are user-requested elements stored in COMMON/NBELEM/ ?
      IF(NELEM.GT.0) THEN
        ILABEL = INDEX
        IF(ILABEL.GT.4) ILABEL = INDEX - 1
        WRITE(LFNPR,1000) TITLE(1:78)
        IF(ILABEL.GT.0) THEN
          WRITE(LFNPR,800) NELEM
        ELSE
          WRITE(LFNPR,805) NELEM
        ENDIF
        DO IELEM = 1,NELEM
          I = IJELEM(1,IELEM)
          J = IJELEM(2,IELEM)
          IF(I.GE.1.AND.I.LE.ABS(NR).AND.J.GE.1.AND.J.LE.ABS(NC)) THEN
            IF(ILABEL.GT.0) THEN
              WRITE(LFNPR,810) I,J,A(I,J),(LBL(K,I,ILABEL),K=1,10),
     +                      (LBL(K,J,ILABEL),K=1,10)
            ELSE
              WRITE(LFNPR,815) I,J,A(I,J)
            ENDIF
          ELSE
            WRITE(LFNPR,820) I,J
          ENDIF
        ENDDO
        IF(ILABEL.GT.0) THEN
          WRITE(LFNPR,830)
        ELSE
          WRITE(LFNPR,835)
        ENDIF
        NELEM = 0
        RETURN
      ENDIF
C
C  Determine the number of columns of matrix A to print in the output file:
C
      NCOL = MCOL
      IF(NCOL.GT.ABS(NC)) NCOL = ABS(NC)
C
      NN = ABS(NR)
      ILABEL = INDEX
      IF(ILABEL.GT.4) ILABEL = INDEX - 1
C
      TMAX = ABS(A(1,1))
      DO 20 J = 1,NCOL
        DO 10 I = 1,NN
          IF(ABS(A(I,J)).GT.TMAX) TMAX = ABS(A(I,J))
   10   CONTINUE
   20 CONTINUE
      IF(TMAX.LT.TENTH) THEN
        ND = 1
      ELSE
        ND = INT(LOG10(TMAX)) + 1
      END IF
C
C  Print the matrix title:
C
      WRITE(LFNPR,1000) TITLE(1:78)
C
C  Print the matrix A: (basis function labels)
C
      IF(ILABEL.GE.1.AND.ILABEL.LE.5) THEN
        MAXCOL = MIN(10-ND,8)
        IF(MAXCOL.LT.6) THEN
          CALL ALTOUT(A,MR,NCOL,NN,NCOL)
        ELSE
          NCL = 1
          NCU = MAXCOL
          NLOOPS = (NCOL - 1) / MAXCOL + 1
          DO 60 L = 1,NLOOPS
            IF(NCU.GT.NCOL) NCU = NCOL
            IF(MAXCOL.EQ.8) THEN
              WRITE(LFNPR,900) BASIS(INDEX),(J,J=NCL,NCU)
              WRITE(LFNPR,910) (DASHES,J=NCL,NCU)
              DO 30 I = 1,NN
                WRITE(LFNPR,920) I,(LBL(J,I,ILABEL),J=1,10),
     +                           (A(I,K),K=NCL,NCU)
   30         CONTINUE
            ELSE IF(MAXCOL.EQ.7) THEN
              WRITE(LFNPR,901) BASIS(INDEX),(J,J=NCL,NCU)
              WRITE(LFNPR,911) (DASHES,J=NCL,NCU)
              DO 40 I = 1,NN
                WRITE(LFNPR,921) I,(LBL(J,I,ILABEL),J=1,10),
     +                           (A(I,K),K=NCL,NCU)
   40         CONTINUE
            ELSE
              WRITE(LFNPR,902) BASIS(INDEX),(J,J=NCL,NCU)
              WRITE(LFNPR,912) (DASHES,DASHES,J=NCL,NCU)
              DO 50 I = 1,NN
                WRITE(LFNPR,922) I,(LBL(J,I,ILABEL),J=1,10),
     +                           (A(I,K),K=NCL,NCU)
   50         CONTINUE
            END IF
            NCL = NCU + 1
            NCU = NCU + MAXCOL
   60     CONTINUE
        END IF
C
C  Print the matrix A: (atom labels)
C
      ELSE IF(ILABEL.EQ.0) THEN
        MAXCOL = MIN(10-ND,9)
        IF(MAXCOL.LT.7) THEN
          CALL ALTOUT(A,MR,NCOL,NN,NCOL)
        ELSE
          NCL = 1
          NCU = MAXCOL
          NLOOPS = (NCOL - 1) / MAXCOL + 1
          DO 160 L = 1,NLOOPS
            IF(NCU.GT.NCOL) NCU = NCOL
            IF(MAXCOL.EQ.9) THEN
              WRITE(LFNPR,1900) ATOM,(J,J=NCL,NCU)
              WRITE(LFNPR,1910) (DASHES,J=NCL,NCU)
              DO 130 I = 1,NN
                WRITE(LFNPR,1920) I,NAMEAT(IATNO(I)),
     +                            (A(I,K),K=NCL,NCU)
  130         CONTINUE
            ELSE IF(MAXCOL.EQ.8) THEN
              WRITE(LFNPR,1901) ATOM,(J,J=NCL,NCU)
              WRITE(LFNPR,1911) (DASHES,J=NCL,NCU)
              DO 140 I = 1,NN
                WRITE(LFNPR,1921) I,NAMEAT(IATNO(I)),
     +                            (A(I,K),K=NCL,NCU)
  140         CONTINUE
            ELSE
              WRITE(LFNPR,1902) ATOM,(J,J=NCL,NCU)
              WRITE(LFNPR,1912) (DASHES,J=NCL,NCU)
              DO 150 I = 1,NN
                WRITE(LFNPR,1922) I,NAMEAT(IATNO(I)),
     +                            (A(I,K),K=NCL,NCU)
  150         CONTINUE
            END IF
            NCL = NCU + 1
            NCU = NCU + MAXCOL
  160     CONTINUE
        END IF
C
C  Print the matrix A: (MO basis)
C
      ELSE IF(ILABEL.EQ.-1) THEN
        MAXCOL = MIN(10-ND,9)
        IF(MAXCOL.LT.7) THEN
          CALL ALTOUT(A,MR,NCOL,NN,NCOL)
        ELSE
          NCL = 1
          NCU = MAXCOL
          NLOOPS = (NCOL - 1) / MAXCOL + 1
          DO 260 L = 1,NLOOPS
            IF(NCU.GT.NCOL) NCU = NCOL
            IF(MAXCOL.EQ.9) THEN
              WRITE(LFNPR,2900) (J,J=NCL,NCU)
              WRITE(LFNPR,2910) (DASHES,J=NCL,NCU)
              DO 230 I = 1,NN
                WRITE(LFNPR,2920) I,(A(I,K),K=NCL,NCU)
  230         CONTINUE
            ELSE IF(MAXCOL.EQ.8) THEN
              WRITE(LFNPR,2901) (J,J=NCL,NCU)
              WRITE(LFNPR,2911) (DASHES,J=NCL,NCU)
              DO 240 I = 1,NN
                WRITE(LFNPR,2921) I,(A(I,K),K=NCL,NCU)
  240         CONTINUE
            ELSE
              WRITE(LFNPR,2902) (J,J=NCL,NCU)
              WRITE(LFNPR,2912) (DASHES,J=NCL,NCU)
              DO 250 I = 1,NN
                WRITE(LFNPR,2922) I,(A(I,K),K=NCL,NCU)
  250         CONTINUE
            END IF
            NCL = NCU + 1
            NCU = NCU + MAXCOL
  260     CONTINUE
        END IF
C
C  Print the matrix A: (eigenvector labels)
C
      ELSE IF(ILABEL.EQ.-2) THEN
        MAXCOL = 7
        NCL = 1
        NCU = MAXCOL
        NLOOPS = (NCOL - 1) / MAXCOL + 1
        DO 280 L = 1,NLOOPS
          IF(NCU.GT.NCOL) NCU = NCOL
          WRITE(LFNPR,2903) (J,J=NCL,NCU)
          WRITE(LFNPR,2913) DASHES,(DASHES,J=NCL,NCU),(DASHES,J=NCL,NCU)
          DO 270 I = 1,NN
            WRITE(LFNPR,2923) (A(I,K),K=NCL,NCU)
  270     CONTINUE
          NCL = NCU + 1
          NCU = NCU + MAXCOL
  280   CONTINUE
C
C  Print matrix A: (anything else)
C
      ELSE
        CALL ALTOUT(A,MR,NCOL,NN,NCOL)
      END IF
      RETURN
C
  800 FORMAT(/,5X,I3,' user-requested elements:',/,5X,52('-'),/,
     + 8X,'i',4X,'j',7X,'matrix(i,j)',4X,'label(i)   label(j)',
     + /,5X,52('-'))
  805 FORMAT(/,5X,I3,' user-requested elements:',/,5X,30('-'),/,
     + 8X,'i',4X,'j',7X,'matrix(i,j)',/,5X,30('-'))
  810 FORMAT(5X,I4,I5,D20.10,2(1X,10A1))
  815 FORMAT(5X,I4,I5,D20.10)
  820 FORMAT(5X,'[invalid indices:',2I6,']')
  830 FORMAT(5X,52('-'))
  835 FORMAT(5X,30('-'))
  900 FORMAT(/9X,A4,3X,8(3X,I3,2X))
  901 FORMAT(/9X,A4,3X,7(4X,I3,2X))
  902 FORMAT(/9X,A4,3X,6(4X,I3,3X))
  910 FORMAT(6X,'----------',8(1X,A7))
  911 FORMAT(6X,'----------',7(1X,A8))
  912 FORMAT(6X,'----------',6(1X,A8,A1))
  920 FORMAT(I4,'. ',10A1,8F8.4)
  921 FORMAT(I4,'. ',10A1,7F9.4)
  922 FORMAT(I4,'. ',10A1,6F10.4)
 1000 FORMAT(//1X,A78)
 1900 FORMAT(/5X,A4,9(2X,I3,3X))
 1901 FORMAT(/5X,A4,8(3X,I3,3X))
 1902 FORMAT(/5X,A4,7(3X,I3,4X))
 1910 FORMAT(5X,'----',1X,9(A6,2X))
 1911 FORMAT(5X,'----',1X,8(A7,2X))
 1912 FORMAT(5X,'----',1X,7(A8,2X))
 1920 FORMAT(I4,'. ',A2,9F8.4)
 1921 FORMAT(I4,'. ',A2,8F9.4)
 1922 FORMAT(I4,'. ',A2,7F10.4)
 2900 FORMAT(/5X,' MO ',9(2X,I3,3X))
 2901 FORMAT(/5X,' MO ',8(3X,I3,3X))
 2902 FORMAT(/5X,' MO ',7(3X,I3,4X))
 2903 FORMAT(/1X,'Vector',7(3X,I4,3X))
 2910 FORMAT(5X,'----',1X,9(A6,2X))
 2911 FORMAT(5X,'----',1X,8(A7,2X))
 2912 FORMAT(5X,'----',1X,7(A8,2X))
 2913 FORMAT(1X,A6,1X,7(A8,A1,1X))
 2920 FORMAT(I4,'.   ',9F8.4)
 2921 FORMAT(I4,'.   ',8F9.4)
 2922 FORMAT(I4,'.   ',7F10.4)
 2923 FORMAT(8X,7(E9.2,1X))
      END
C***********************************************************************
      SUBROUTINE AWRITE(A,MR,NR,NC,TITLE,LFN)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION A(MR,*)
      CHARACTER*80 TITLE
      LOGICAL HEADER
      DIMENSION XJOB(10)
C
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
C  Write the matrix A to the external file ABS(LFN).  Include job title,
C  matrix title, and specify the spin if needed:
C
      LFNOUT = ABS(LFN)
      IF(LFNOUT.EQ.LFNPR) WRITE(LFNOUT,890)
C  MSPNBO output?  Make it look like open-shell.
C     IF(IWMSP.NE.0) THEN
C       IF(ALPHA) THEN
C         CALL FETITL(XJOB)
C         WRITE(LFNOUT,900) XJOB
C         WRITE(LFNOUT,910) TITLE(1:79)
C         WRITE(LFNOUT,920)
C       ELSE
C         WRITE(LFNOUT,930)
C       ENDIF
C       IF(ABS(NR).EQ.ABS(NC).AND.NR.LT.0) THEN
C         WRITE(LFNOUT,1000) ((A(I,J),I=1,J),J=1,ABS(NR))
C       ELSE
C         DO J = 1,ABS(NC)
C           WRITE(LFNOUT,1000) (A(I,J),I=1,ABS(NR))
C         ENDDO
C       END IF
C       RETURN
C     ENDIF
C
      HEADER = .FALSE.
      IF(.NOT.OPEN)                         HEADER = .TRUE.
      IF(ALPHA)                             HEADER = .TRUE.
      IF(LFNOUT.EQ.LFNPR)                   HEADER = .TRUE.
      IF(OPEN.AND..NOT.ALPHA.AND..NOT.BETA) HEADER = .TRUE.
      IF(HEADER) THEN
        CALL FETITL(XJOB)
        WRITE(LFNOUT,900) XJOB
        WRITE(LFNOUT,910) TITLE(1:79)
      END IF
      IF(ALPHA) WRITE(LFNOUT,920)
      IF(BETA)  WRITE(LFNOUT,930)
C
C  If this is a square matrix and NR is negative, only write the upper
C  triangular portion.  Otherwise, write out the full matrix:
C
      IF(ABS(NR).EQ.ABS(NC).AND.NR.LT.0) THEN
        WRITE(LFNOUT,1000) ((A(I,J),I=1,J),J=1,ABS(NR))
      ELSE
        DO 10 J = 1,ABS(NC)
          WRITE(LFNOUT,1000) (A(I,J),I=1,ABS(NR))
   10   CONTINUE
      END IF
      RETURN
C
  890 FORMAT(/1X)
  900 FORMAT(1X,9A8,A7)
  910 FORMAT(1X,A79,/1X,79('-'))
  920 FORMAT(1X,'ALPHA SPIN')
  930 FORMAT(1X,'BETA  SPIN')
 1000 FORMAT(1X,5F15.9)
      END
C***********************************************************************
      SUBROUTINE AREAD(A,MR,NR,NC,JOB,LFN,ERROR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION A(MR,*),JOB(20)
      DIMENSION ITEMP(20)
      LOGICAL ERROR
C
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
C
      SAVE IDASH,IALFA,IBETA
      DATA IDASH,IALFA,IBETA/4H----,4HALPH,4HBETA/
C
C  Read the matrix A to the external file LFN:
C
C  Input:  MR    -- row dimension of matrix A in calling routine
C
C          NR    -- ABS(NR) is the actual number of rows to be read
C                   [if NR is negative and ABS(NR).EQ.NC (square matrix),
C                    only the upper triangular portion is stored in the
C                    input file.  This routine will read the upper triangular
C                    portion and unpack it.]
C
C          NC    -- actual number of columns in matrix A
C                   [used to determine if A is square]
C
C          LFN   -- input file
C
C  Output: JOB   -- INTEGER array containing the job title
C                   [closed shell or alpha spin only]
C
C          ERROR -- set to .true. if the end-of-file was encountered while
C                   reading
C
      IF(ALPHA.OR..NOT.OPEN) READ(LFN,1000,END=800) JOB
      IF(.NOT.OPEN) ISTR = IDASH
      IF(ALPHA)     ISTR = IALFA
      IF(BETA)      ISTR = IBETA
C
   10 READ(LFN,1000,END=800) ITEMP
      IF(ITEMP(1).NE.ISTR) GOTO 10
C
C  If this is a square matrix and NR is negative, only read the upper
C  triangular portion.  Otherwise, read the full matrix:
C
      IF(ABS(NR).EQ.ABS(NC).AND.NR.LT.0) THEN
        READ(LFN,900,END=800) ((A(I,J),I=1,J),J=1,ABS(NR))
        DO 30 J = 1,ABS(NR)-1
          DO 20 I = J+1,ABS(NR)
            A(I,J) = A(J,I)
   20     CONTINUE
   30   CONTINUE
      ELSE
        DO 40 J = 1,ABS(NC)
          READ(LFN,900,END=800) (A(I,J),I=1,ABS(NR))
   40   CONTINUE
      END IF
      ERROR = .FALSE.
      RETURN
C
  800 ERROR = .TRUE.
      RETURN
C
  900 FORMAT(1X,5F15.9)
 1000 FORMAT(1X,20A4)
      END
C***********************************************************************
      SUBROUTINE ALTOUT(A,MR,MC,NR,NC)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION A(MR,MC)
C
C  FOR 80 COLUMN OUTPUT:
C  LIST ELEMENTS OF ARRAY A (MATRIX OR VECTOR).
C     MR,MC DECLARED ROW AND COLUMN DIMENSIONALITY,
C     NR,NC ACTUAL ROW AND COLUMN DIMENSIONALITY,
C
      NCL=1
      NCU=6
      NLOOPS=NC/6+1
      DO 20 L=1,NLOOPS
        IF(NCU.GT.NC) NCU=NC
        WRITE(LFNPR,1100) (J,J=NCL,NCU)
        DO 10 I=1,NR
   10     WRITE(LFNPR,1200) I,(A(I,J),J=NCL,NCU)
        IF(NCU.GE.NC) RETURN
        NCL=NCU+1
   20   NCU=NCU+6
      RETURN
 1100 FORMAT(/10X,10(I4,8X))
 1200 FORMAT(I4,10F12.5)
      END
C***********************************************************************
      SUBROUTINE KEYPAR(STRING,LEN,IFLG,ICHKPT,LFN,READ,ERROR)
C***********************************************************************
C 14-Jan-93  EDG  Added checkpointing option
C 14-Aug-01  FAW  Added 'E' check in PLEW (avoid conflict with PLOT)
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      INTEGER STRING(LEN)
      LOGICAL READ,ERROR
C
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      SAVE IW,IR,IP,IC,IV,IL,IS,KFULL,KVAL,KLEW
      DATA IW,IR,IP,IC,IV,IL,IS,IE/1HW,1HR,1HP,1HC,1HV,1HL,1HS,1HE/
      DATA KFULL,KVAL,KLEW/4HFULL,3HVAL,3HLEW/
C
C  Interpret the KEYword PARameter STRING, storing the result in IFLG.
C  (The default IFLG should be passed to this routine through IFLG)
C
C  The following STRINGs are acceptable:
C
C    STRING = Wnnn     means write to the external file nnn (IFLG = -nnn)
C                      (if nnn is omitted, IFLG = -LFN)
C
C    STRING = Rnnn     means read from the external file nnn (IFLG = -nnn*1000)
C                      (if nnn is omitted, IFLG = -LFN)
C                      (READ must be true to allow reading)
C
C    STRING = PnnnC    means print nnn columns to the output file (IFLG = nnn)
C                      (if nnn is omitted, print full matrix, IFLG = 'FULL')
C                      (the C is optional, it means columns)
C
C    STRING = PVAL     means print val columns to output file (IFLG = 'VAL')
C                      (val is the number of core + valence orbitals)
C                      (only the V is necessary)
C
C
C    STRING = PLEW     means print lew columns to output file (IFLG = 'LEW'
C                      (lew is the number of occupied orbitals)
C                      (only the LE is necessary)
C
C    STRING = CS       means checkpoint with optional sort 'S' (IFLG = 'CHK')
C
C    STRING = other    IFLG is left untouched
C
      ERROR = .FALSE.
      ICHKPT = 0
C
C  Process STRING = W..:
C
      IF(STRING(1).EQ.IW) THEN
        IF(LEN.EQ.1) THEN
          IFLG = -LFN
          RETURN
        END IF
        IF(LEN.GT.1) THEN
          CALL CONVIN(STRING(2),LEN-1,IFLG,ERROR)
          IF(ERROR) RETURN
          IF(IFLG.GT.1000) THEN
            WRITE(LFNPR,900) IFLG
            CALL NBHALT('Attempt to write to invalid file number.')
          END IF
          IFLG = -IFLG
        END IF
C
C  Process STRING = R..:
C
      ELSE IF(STRING(1).EQ.IR) THEN
        IF(.NOT.READ) THEN
          ERROR = .TRUE.
          RETURN
        END IF
        IF(LEN.EQ.1) THEN
          IFLG = -LFN * 1000
          RETURN
        END IF
        IF(LEN.GT.1) THEN
          CALL CONVIN(STRING(2),LEN-1,IFLG,ERROR)
          IF(ERROR) RETURN
          IF(IFLG.GT.1000) THEN
            WRITE(LFNPR,900) IFLG
            CALL NBHALT('Attempt to read from invalid file number.')
          END IF
          IFLG = -IFLG * 1000
        END IF
C
C  Process STRING = P..:
C
      ELSE IF(STRING(1).EQ.IP) THEN
        IF(STRING(2).EQ.IV) THEN
          IFLG = KVAL
          RETURN
        END IF
        IF(STRING(2).EQ.IL.AND.STRING(3).EQ.IE) THEN
          IFLG = KLEW
          RETURN
        END IF
        IF(LEN.EQ.1) THEN
          IFLG = KFULL
          RETURN
        END IF
        IF(LEN.GT.1) THEN
          IF(STRING(LEN).NE.IC) THEN
            CALL CONVIN(STRING(2),LEN-1,IFLG,ERROR)
          ELSE
            CALL CONVIN(STRING(2),LEN-2,IFLG,ERROR)
          END IF
        END IF
C
C  Process STRING = C..:
C
      ELSE IF(STRING(1).EQ.IC) THEN
        IFLG = KFULL
        ICHKPT = 1
        IF(STRING(LEN).EQ.IS) ICHKPT = -1
      ELSE
        ERROR = .TRUE.
      END IF
      RETURN
C
  900 FORMAT(/1X,'The NBO program will only communicate with external ',
     + 'files 0 thru 999.',/,'Cannot use file number ',I6,'.')
      END
C***********************************************************************
      FUNCTION IOINQR(IFLG)
C***********************************************************************
C 14-Jan-93  EDG  Add checkpointing
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      SAVE KFULL,KVAL,KLEW,KCHK
      SAVE KBLNK,KPRNT,KWRIT,KREAD
      DATA KFULL,KVAL,KLEW,KCHK/4HFULL,3HVAL,3HLEW,3HCHK/
      DATA KBLNK,KPRNT,KWRIT,KREAD/4H    ,4HPRNT,4HWRIT,4HREAD/
C
C  Interpret IFLG, determining whether the corresponding matrix should be
C  printed, written out, or read:
C
      IF(IFLG.EQ.KFULL) THEN
        IOINQR = KPRNT
      ELSE IF(IFLG.EQ.KVAL) THEN
        IOINQR = KPRNT
      ELSE IF(IFLG.EQ.KLEW) THEN
        IOINQR = KPRNT
      ELSE IF(IFLG.EQ.KCHK) THEN
        IOINQR = KCHK
      ELSE IF(IFLG.GT.0) THEN
        IOINQR = KPRNT
      ELSE IF(IFLG.LT.0.AND.IFLG.GT.-1000) THEN
        IOINQR = KWRIT
      ELSE IF(IFLG.LT.0) THEN
        IOINQR = KREAD
      ELSE
        IOINQR = KBLNK
      END IF
      RETURN
      END
C***********************************************************************
      SUBROUTINE LBLAO
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER(MAXD = 2)
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBAO/LCTR(MAXBAS),LANG(MAXBAS)
      COMMON/NBLBL/NLEW,NVAL,IAOLBL(10,MAXBAS),NAOLBL(10,MAXBAS),
     +                       NHOLBL(10,MAXBAS),NBOLBL(10,MAXBAS),
     +                       IPOLBL(10,MAXBAS)
C
      DIMENSION ISTR(MAXD),IANG(5),IXYZ(3),IBYTE(4),NUM(15)
C
      SAVE IBLNK,IANG,IXYZ,ILEFT,IRIGHT,NUM
      DATA IBLNK/1H /
      DATA IANG/1Hs,1Hp,1Hd,1Hf,1Hg/
      DATA IXYZ/1Hx,1Hy,1Hz/
      DATA ILEFT,IRIGHT/1H(,1H)/
      DATA NUM/1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9,
     +         1Ha,1Hb,1Hc,1Hd,1He,1Hf/
C
      DO 20 IAO = 1,NBAS
        DO 10 I = 1,10
          IAOLBL(I,IAO) = IBLNK
   10   CONTINUE
        LBL = NAMEAT(IATNO(LCTR(IAO)))
        CALL DEBYTE(LBL,IBYTE)
        IAOLBL(1,IAO) = IBYTE(1)
        IAOLBL(2,IAO) = IBYTE(2)
        CALL IDIGIT(LCTR(IAO),ISTR,ND,MAXD)
        IF(ND.EQ.1) THEN
          IAOLBL(4,IAO) = ISTR(1)
        ELSE
          IAOLBL(3,IAO) = ISTR(1)
          IAOLBL(4,IAO) = ISTR(2)
        END IF
        IAOLBL(6,IAO) = ILEFT
        L = LANG(IAO)/100
        IAOLBL(7,IAO) = IANG(L+1)
        IF(L.EQ.0) THEN
          IAOLBL(8,IAO) = IRIGHT
        ELSE IF(L.EQ.1) THEN
          M = MOD(LANG(IAO),10)
          IAOLBL(8,IAO) = IXYZ(M)
          IAOLBL(9,IAO) = IRIGHT
        ELSE IF(L.EQ.2.OR.L.EQ.3.OR.L.EQ.4) THEN
          IAOLBL(8,IAO) = NUM(MOD(LANG(IAO),50))
          IAOLBL(9,IAO) = IRIGHT
        END IF
   20 CONTINUE
      CALL SVLBLS
      RETURN
      END
C***********************************************************************
      SUBROUTINE LBLNAO
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER(MAXD = 2)
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBNAO/NAOCTR(MAXBAS),NAOL(MAXBAS),LTYP(MAXBAS),
     +       IPRIN(MAXBAS)
      COMMON/NBLBL/NLEW,NVAL,IAOLBL(10,MAXBAS),NAOLBL(10,MAXBAS),
     +                       NHOLBL(10,MAXBAS),NBOLBL(10,MAXBAS),
     +                       IPOLBL(10,MAXBAS)
C
      DIMENSION ISTR(MAXD),IANG(5),IXYZ(3),IBYTE(4),NUM(9)
C
      SAVE IBLNK,IANG,IXYZ,ILEFT,IRIGHT,NUM
      DATA IBLNK/1H /
      DATA IANG/1Hs,1Hp,1Hd,1Hf,1Hg/
      DATA IXYZ/1Hx,1Hy,1Hz/
      DATA ILEFT,IRIGHT/1H(,1H)/
      DATA NUM/1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9/
C
      DO 20 INAO = 1,NNAO
        DO 10 I = 1,10
          NAOLBL(I,INAO) = IBLNK
   10   CONTINUE
        LBL = NAMEAT(IATNO(NAOCTR(INAO)))
        CALL DEBYTE(LBL,IBYTE)
        NAOLBL(1,INAO) = IBYTE(1)
        NAOLBL(2,INAO) = IBYTE(2)
        CALL IDIGIT(NAOCTR(INAO),ISTR,ND,MAXD)
        IF(ND.EQ.1) THEN
          NAOLBL(4,INAO) = ISTR(1)
        ELSE
          NAOLBL(3,INAO) = ISTR(1)
          NAOLBL(4,INAO) = ISTR(2)
        END IF
        NAOLBL(5,INAO) = ILEFT
        CALL IDIGIT(IPRIN(INAO),ISTR,ND,MAXD)
        IF(ND.EQ.1) THEN
          NAOLBL(7,INAO) = ISTR(1)
        ELSE
          NAOLBL(6,INAO) = ISTR(1)
          NAOLBL(7,INAO) = ISTR(2)
        END IF
        L = NAOL(INAO)/100
        NAOLBL(8,INAO) = IANG(L+1)
        IF(L.EQ.1) THEN
          M = MOD(NAOL(INAO),10)
          NAOLBL(9,INAO) = IXYZ(M)
        ELSE IF(L.EQ.2.OR.L.EQ.3.OR.L.EQ.4) THEN
          NAOLBL(9,INAO) = NUM(MOD(NAOL(INAO),100)-50)
        END IF
        NAOLBL(10,INAO) = IRIGHT
   20 CONTINUE
      CALL SVLBLS
      RETURN
      END
C***********************************************************************
      SUBROUTINE LBLNBO
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER(MAXD = 2)
      INTEGER ISTR(MAXD),IBYTE(4)
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),LBL1(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBLBL/NLEW,NVAL,IAOLBL(10,MAXBAS),NAOLBL(10,MAXBAS),
     +                       NHOLBL(10,MAXBAS),NBOLBL(10,MAXBAS),
     +                       IPOLBL(10,MAXBAS)
C
      SAVE IBLNK,IC,IL,IP,IR,IY,ISTAR,IHYP
      SAVE ICR,ILP,ILEFT,IRIGHT
      DATA IBLNK,IC,IL,IP,IR,IY,ISTAR,IHYP/1H ,1Hc,1Hl,1Hp,1Hr,1Hy,1H*,
     +                                     1H-/
      DATA ICR,ILP/2HCR,2HLP/
      DATA ILEFT,IRIGHT/1H(,1H)/
C
      DO 20 INBO = 1,NNAO
        DO 10 I = 1,10
          NBOLBL(I,INBO) = IBLNK
   10   CONTINUE
        IB = IBXM(INBO)
        NCTR = 1
        IF(LABEL(IB,5).NE.0) NCTR = 2
        IF(LABEL(IB,6).NE.0) NCTR = 3
C
C  One-center labels:
C
        IF(NCTR.EQ.1) THEN
          LBL = NAMEAT(IATNO(LABEL(IB,4)))
          CALL DEBYTE(LBL,IBYTE)
          NBOLBL(1,INBO) = IBYTE(1)
          NBOLBL(2,INBO) = IBYTE(2)
          CALL IDIGIT(LABEL(IB,4),ISTR,ND,MAXD)
          IF(ND.EQ.1) THEN
            NBOLBL(4,INBO) = ISTR(1)
          ELSE
            NBOLBL(3,INBO) = ISTR(1)
            NBOLBL(4,INBO) = ISTR(2)
          END IF
          NBOLBL(5,INBO) = ILEFT
          IF(LABEL(IB,1).EQ.ICR) THEN
            NBOLBL(6,INBO) = IC
            NBOLBL(7,INBO) = IR
            NBOLBL(8,INBO) = IRIGHT
          ELSE IF(LABEL(IB,1).EQ.ILP) THEN
            NBOLBL(6,INBO) = IL
            NBOLBL(7,INBO) = IP
            IF(LABEL(IB,2).EQ.ISTAR) THEN
              NBOLBL(8,INBO) = ISTAR
              NBOLBL(9,INBO) = IRIGHT
            ELSE
              NBOLBL(8,INBO) = IRIGHT
            END IF
          ELSE
            NBOLBL(6,INBO) = IR
            NBOLBL(7,INBO) = IY
            NBOLBL(8,INBO) = ISTAR
            NBOLBL(9,INBO) = IRIGHT
          END IF
C
C  Two-center labels:
C
        ELSE IF(NCTR.EQ.2) THEN
          LBL = NAMEAT(IATNO(LABEL(IB,4)))
          CALL DEBYTE(LBL,IBYTE)
          NBOLBL(1,INBO) = IBYTE(1)
          NBOLBL(2,INBO) = IBYTE(2)
          CALL IDIGIT(LABEL(IB,4),ISTR,ND,MAXD)
          IF(ND.EQ.1) THEN
            NBOLBL(4,INBO) = ISTR(1)
          ELSE
            NBOLBL(3,INBO) = ISTR(1)
            NBOLBL(4,INBO) = ISTR(2)
          END IF
          NBOLBL(5,INBO) = IHYP
          LBL = NAMEAT(IATNO(LABEL(IB,5)))
          CALL DEBYTE(LBL,IBYTE)
          NBOLBL(6,INBO) = IBYTE(1)
          NBOLBL(7,INBO) = IBYTE(2)
          CALL IDIGIT(LABEL(IB,5),ISTR,ND,MAXD)
          IF(ND.EQ.1) THEN
            NBOLBL(9,INBO) = ISTR(1)
          ELSE
            NBOLBL(8,INBO) = ISTR(1)
            NBOLBL(9,INBO) = ISTR(2)
          END IF
          NBOLBL(10,INBO) = LABEL(IB,2)
C
C  Three-center labels:
C
        ELSE
          CALL IDIGIT(LABEL(IB,4),ISTR,ND,MAXD)
          IF(ND.EQ.1) THEN
            NBOLBL(2,INBO) = ISTR(1)
          ELSE
            NBOLBL(1,INBO) = ISTR(1)
            NBOLBL(2,INBO) = ISTR(2)
          END IF
          NBOLBL(3,INBO) = IHYP
          CALL IDIGIT(LABEL(IB,5),ISTR,ND,MAXD)
          IF(ND.EQ.1) THEN
            NBOLBL(5,INBO) = ISTR(1)
          ELSE
            NBOLBL(4,INBO) = ISTR(1)
            NBOLBL(5,INBO) = ISTR(2)
          END IF
          NBOLBL(6,INBO) = IHYP
          CALL IDIGIT(LABEL(IB,6),ISTR,ND,MAXD)
          IF(ND.EQ.1) THEN
            NBOLBL(8,INBO) = ISTR(1)
          ELSE
            NBOLBL(7,INBO) = ISTR(1)
            NBOLBL(8,INBO) = ISTR(2)
          END IF
          NBOLBL(9,INBO) = LABEL(IB,2)
        END IF
   20 CONTINUE
      CALL SVLBLS
      RETURN
      END
C***********************************************************************
      SUBROUTINE LBLNHO(INHO,INBO,ICTR,NCTR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER(MAXD = 2)
      INTEGER ISTR(MAXD),IBYTE(4)
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),LBL1(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBLBL/NLEW,NVAL,IAOLBL(10,MAXBAS),NAOLBL(10,MAXBAS),
     +                       NHOLBL(10,MAXBAS),NBOLBL(10,MAXBAS),
     +                       IPOLBL(10,MAXBAS)
C
      SAVE IBLNK,IC,IL,IP,IR,IY,I3,ISTAR,IHYP
      SAVE ICR,ILP,ILEFT,IRIGHT
      DATA IBLNK,IC,IL,IP,IR,IY,I3,ISTAR,IHYP/1H ,1Hc,1Hl,1Hp,1Hr,1Hy,
     +                                        1H3,1H*,1H-/
      DATA ICR,ILP/2HCR,2HLP/
      DATA ILEFT,IRIGHT/1H(,1H)/
C
      DO 10 I = 1,10
        NHOLBL(I,INHO) = IBLNK
   10 CONTINUE
      IB = IBXM(INBO)
C
C  One-center labels:
C
      IF(NCTR.EQ.1) THEN
        LBL = NAMEAT(IATNO(LABEL(IB,4)))
        CALL DEBYTE(LBL,IBYTE)
        NHOLBL(1,INHO) = IBYTE(1)
        NHOLBL(2,INHO) = IBYTE(2)
        CALL IDIGIT(LABEL(IB,4),ISTR,ND,MAXD)
        IF(ND.EQ.1) THEN
          NHOLBL(4,INHO) = ISTR(1)
        ELSE
          NHOLBL(3,INHO) = ISTR(1)
          NHOLBL(4,INHO) = ISTR(2)
        END IF
        NHOLBL(5,INHO) = ILEFT
        IF(LABEL(IB,1).EQ.ICR) THEN
          NHOLBL(6,INHO) = IC
          NHOLBL(7,INHO) = IR
          NHOLBL(8,INHO) = IRIGHT
        ELSE IF(LABEL(IB,1).EQ.ILP) THEN
          NHOLBL(6,INHO) = IL
          NHOLBL(7,INHO) = IP
          IF(LABEL(IB,2).EQ.ISTAR) THEN
            NHOLBL(8,INHO) = ISTAR
            NHOLBL(9,INHO) = IRIGHT
          ELSE
            NHOLBL(8,INHO) = IRIGHT
          END IF
        ELSE
          NHOLBL(6,INHO) = IR
          NHOLBL(7,INHO) = IY
          NHOLBL(8,INHO) = ISTAR
          NHOLBL(9,INHO) = IRIGHT
        END IF
C
C  Two-center and three-center labels:
C
      ELSE
        LBL = NAMEAT(IATNO(LABEL(IB,3+ICTR)))
        CALL DEBYTE(LBL,IBYTE)
        NHOLBL(1,INHO) = IBYTE(1)
        NHOLBL(2,INHO) = IBYTE(2)
        CALL IDIGIT(LABEL(IB,3+ICTR),ISTR,ND,MAXD)
        IF(ND.EQ.1) THEN
          NHOLBL(4,INHO) = ISTR(1)
        ELSE
          NHOLBL(3,INHO) = ISTR(1)
          NHOLBL(4,INHO) = ISTR(2)
        END IF
        NHOLBL(5,INHO) = ILEFT
        IF(NCTR.EQ.2) THEN
          LBL = NAMEAT(IATNO(LABEL(IB,6-ICTR)))
          CALL DEBYTE(LBL,IBYTE)
          NHOLBL(6,INHO) = IBYTE(1)
          NHOLBL(7,INHO) = IBYTE(2)
          CALL IDIGIT(LABEL(IB,6-ICTR),ISTR,ND,MAXD)
          IF(ND.EQ.1) THEN
            NHOLBL(9,INHO) = ISTR(1)
          ELSE
            NHOLBL(8,INHO) = ISTR(1)
            NHOLBL(9,INHO) = ISTR(2)
          END IF
          NHOLBL(10,INHO) = IRIGHT
        ELSE
          NHOLBL(6,INHO) = I3
          NHOLBL(7,INHO) = IHYP
          NHOLBL(8,INHO) = IC
          NHOLBL(9,INHO) = IRIGHT
        END IF
      END IF
      CALL SVLBLS
      RETURN
      END
C***********************************************************************
      SUBROUTINE LBLPAO
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER(MAXD = 2)
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBAO/LCTR(MAXBAS),LANG(MAXBAS)
      COMMON/NBBAS/LIST(6,MAXBAS),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),LSTEMT(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBLBL/NLEW,NVAL,IAOLBL(10,MAXBAS),NAOLBL(10,MAXBAS),
     +                       NHOLBL(10,MAXBAS),NBOLBL(10,MAXBAS),
     +                       IPOLBL(10,MAXBAS)
C
      DIMENSION ISTR(MAXD),IANG(5),IXYZ(3),IBYTE(4),NUM(15)
C
      SAVE IBLNK,IANG,IXYZ,ILEFT,IRIGHT,NUM
      DATA IBLNK/1H /
      DATA IANG/1Hs,1Hp,1Hd,1Hf,1Hg/
      DATA IXYZ/1Hx,1Hy,1Hz/
      DATA ILEFT,IRIGHT/1H(,1H)/
      DATA NUM/1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9,
     +         1Ha,1Hb,1Hc,1Hd,1He,1Hf/
C
      DO 20 IPO = 1,NBAS
        DO 10 I = 1,10
          IPOLBL(I,IPO) = IBLNK
   10   CONTINUE
        LABEL = NAMEAT(IATNO(LCTR(IPO)))
        CALL DEBYTE(LABEL,IBYTE)
        IPOLBL(1,IPO) = IBYTE(1)
        IPOLBL(2,IPO) = IBYTE(2)
        CALL IDIGIT(LCTR(IPO),ISTR,ND,MAXD)
        IF(ND.EQ.1) THEN
          IPOLBL(4,IPO) = ISTR(1)
        ELSE
          IPOLBL(3,IPO) = ISTR(1)
          IPOLBL(4,IPO) = ISTR(2)
        END IF
        IPOLBL(6,IPO) = ILEFT
        L = LORB(IPO)/100
        IPOLBL(7,IPO) = IANG(L+1)
        IF(L.EQ.0) THEN
          IPOLBL(8,IPO) = IRIGHT
        ELSE IF(L.EQ.1) THEN
          M = MOD(LORB(IPO),10)
          IPOLBL(8,IPO) = IXYZ(M)
          IPOLBL(9,IPO) = IRIGHT
        ELSE IF(L.EQ.2.OR.L.EQ.3.OR.L.EQ.4) THEN
          IPOLBL(8,IPO) = NUM(MOD(LORB(IPO),50))
          IPOLBL(9,IPO) = IRIGHT
        END IF
   20 CONTINUE
      CALL SVLBLS
      RETURN
      END
C***********************************************************************
C NBO 5.G -- Natural Bond Orbital Analysis Programs
C (c) Copyright 1996-2008 Board of Regents of the University of Wisconsin System
C     on behalf of the Theoretical Chemistry Institute.  All Rights Reserved.
C***********************************************************************
C
C  GENERAL UTILITY ROUTINES:
C
C      SUBROUTINE ANGLES(X,Y,Z,THETA,PHI)
C      FUNCTION BDFIND(IAT,JAT)
C      SUBROUTINE CHEM(NAT,NATOMS,LISTA,NL,ISTR)
C      SUBROUTINE CONSOL(AUT,ALT,NDIM,N)
C      SUBROUTINE CONVIN(IJ,LEN,IK,ERROR)
C      SUBROUTINE CONVRT2N(N,NC1,NC2)
C      SUBROUTINE CONVRT3(N,NC1,NC2,NC3)
C      SUBROUTINE CONVRT3S(N,S1,S2,S3)
C      SUBROUTINE COPY(A,B,NDIM,NR,NC)
C      SUBROUTINE CORTBL(IAT,ICORE,IECP)
C      SUBROUTINE IDIGIT(KINT,IK,ND,MAXD)
C      FUNCTION IHTYP(IBO,JBO)
C      SUBROUTINE NBJACOBI(N,A,EIVU,EIVR,NDIM,NVDIM,ICONTR)
C      SUBROUTINE KEYERR(WORD)
C      SUBROUTINE LIMTRN(T,M,A,B,NDIM,NBAS,NCDIM,NC,IOPT)
C      SUBROUTINE MATMLT(A,B,V,NDIM,N)
C      SUBROUTINE MATML2(A,B,V,NDIM,N)
C      FUNCTION NAMEAT(IZ)
C      SUBROUTINE NBHALT(WORD)
C      SUBROUTINE NORMLZ(A,S,M,N,NC)
C      SUBROUTINE NBORDR(RANK,LIST,N,NDIM,ARCRNK)
C      SUBROUTINE PACK(T,NDIM,NBAS,NTRI)
C      SUBROUTINE RANK(EIG,N,NDIM,ARCRNK)
C      SUBROUTINE SCNVRT(IVEC,STR,NL,IERR)
C      SUBROUTINE SIMTRS(A,S,V,NDIM,N)
C      SUBROUTINE SRTCHK(DM,T,S,SCR,IRNK)
C      SUBROUTINE NBTRSP(A,NDIM,N)
C      SUBROUTINE UNPACK(T,NDIM,NBAS)
C      SUBROUTINE VALTBL(IAT,IVAL,IFLG)
C      FUNCTION VECLEN(X,N,NDIM)
C
C***********************************************************************
      SUBROUTINE ANGLES(X,Y,Z,THETA,PHI)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      SAVE ZERO,CUTOFF,ONE
      DATA ZERO,CUTOFF,ONE/0.0D0,1.0D-8,1.0D0/
C
      CONV = 180.0D0/(4.0D0*ATAN(ONE))
      IF(X.EQ.ZERO.AND.Y.EQ.ZERO) THEN
        IF(Z.GE.ZERO) THEN
          THETA = ZERO
        ELSE
          THETA = 180.0D0
        END IF
        PHI = ZERO
      ELSE
        IF(ABS(Z-ONE).LT.CUTOFF) THEN
          THETA = ZERO
        ELSE IF(ABS(Z+ONE).LT.CUTOFF) THEN
          THETA = 180.0D0
        ELSE IF(Z.LT.ONE.AND.Z.GT.-ONE) THEN
          THETA = ACOS(Z) * CONV
          IF(THETA.GT.180.0D0) THETA = 360.0D0 - THETA
        ELSE
          CALL NBHALT('ArcCosine out of bounds in SR ANGLES.')
        END IF
        PHI   = ATAN2(Y,X) * CONV
        IF(PHI.LT.ZERO) PHI = PHI + 360.0D0
        IF(ABS(PHI-360.0D0).LT.0.05D0) PHI = ZERO
        IF(ABS(THETA).LT.0.05D0) PHI = ZERO
        IF(ABS(THETA-180.0D0).LT.0.05D0) PHI = ZERO
      END IF
      RETURN
      END
C***********************************************************************
      FUNCTION BDFIND(IAT,JAT)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL BDFIND,IFOUND,JFOUND
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
C
      SAVE LSTAR
      DATA LSTAR/1H*/
C
C  SET BDFIND=.TRUE. IF THERE IS AT LEAST ONE BOND BETWEEN ATOMS IAT AND JAT
C
      DO 100 IBAS = 1,NNAO
        IB = IBXM(IBAS)
        IF(LABEL(IB,2).EQ.LSTAR) GO TO 100
        IF(LABEL(IB,3).NE.1) GO TO 100
        IFOUND = .FALSE.
        JFOUND = .FALSE.
        DO 50 K = 4,6
          IF(LABEL(IB,K).EQ.IAT) IFOUND = .TRUE.
          IF(LABEL(IB,K).EQ.JAT) JFOUND = .TRUE.
   50   CONTINUE
        IF(IFOUND.AND.JFOUND) GO TO 200
  100 CONTINUE
      BDFIND = .FALSE.
      RETURN
  200 BDFIND = .TRUE.
      RETURN
      END
C***********************************************************************
      SUBROUTINE CHEM(NAT,NATOMS,LISTA,NL,ISTR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION LISTA(NATOMS,2),ISTR(80)
C
      PARAMETER (MAXD = 4)
      DIMENSION INUM(MAXD),IBYTE(4)
C
      SAVE IC,IH,IBLNK,ILEFT,IRIGHT
      DATA IC,IH,IBLNK,ILEFT,IRIGHT/1HC,1HH,1H ,1H(,1H)/
C
C  Build the chemical formula from the list of atoms in LISTA:
C
C  Get chemical symbols:
C
      DO 10 IAT = 1,NAT
        LISTA(IAT,1) = NAMEAT(LISTA(IAT,1))
   10 CONTINUE
C
C  Alphabetize these symbols:
C
      DO 30 IAT = 1,NAT-1
        DO 20 JAT = 1,NAT-IAT
          IF(LISTA(JAT,1).GT.LISTA(JAT+1,1)) THEN
            ITEMP = LISTA(JAT,1)
            LISTA(JAT,1) = LISTA(JAT+1,1)
            LISTA(JAT+1,1) = ITEMP
            ITEMP = LISTA(JAT,2)
            LISTA(JAT,2) = LISTA(JAT+1,2)
            LISTA(JAT+1,2) = ITEMP
          END IF
   20   CONTINUE
   30 CONTINUE
C
C  Build chemical formula in ISTR:
C
C  First carbon...
C
      NL = 1
      ISTR(NL) = ILEFT
      DO 50 IAT = 1,NAT
        CALL DEBYTE(LISTA(IAT,1),IBYTE)
        IF(IBYTE(1).EQ.IBLNK.AND.IBYTE(2).EQ.IC) THEN
          NL = NL + 1
          ISTR(NL) = IC
          IF(LISTA(IAT,2).NE.1) THEN
            CALL IDIGIT(LISTA(IAT,2),INUM,ND,MAXD)
            DO 40 IL = 1,ND
              NL = NL + 1
              ISTR(NL) = INUM(IL)
   40       CONTINUE
          END IF
          LISTA(IAT,2) = 0
        END IF
   50 CONTINUE
C
C  then hydrogen...
C
      DO 70 IAT = 1,NAT
        CALL DEBYTE(LISTA(IAT,1),IBYTE)
        IF(IBYTE(1).EQ.IBLNK.AND.IBYTE(2).EQ.IH) THEN
          NL = NL + 1
          ISTR(NL) = IH
          IF(LISTA(IAT,2).NE.1) THEN
            CALL IDIGIT(LISTA(IAT,2),INUM,ND,MAXD)
            DO 60 IL = 1,ND
              NL = NL + 1
              ISTR(NL) = INUM(IL)
   60       CONTINUE
          END IF
          LISTA(IAT,2) = 0
        END IF
   70 CONTINUE
C
C  and now the rest...
C
      DO 90 IAT = 1,NAT
        IF(LISTA(IAT,2).NE.0) THEN
          CALL DEBYTE(LISTA(IAT,1),IBYTE)
          IF(IBYTE(1).NE.IBLNK) THEN
            NL = NL + 1
            ISTR(NL) = IBYTE(1)
          END IF
          IF(IBYTE(2).NE.IBLNK) THEN
            NL = NL + 1
            ISTR(NL) = IBYTE(2)
          END IF
          IF(LISTA(IAT,2).NE.1) THEN
            CALL IDIGIT(LISTA(IAT,2),INUM,ND,MAXD)
            DO 80 IL = 1,ND
              NL = NL + 1
              ISTR(NL) = INUM(IL)
   80       CONTINUE
          END IF
          LISTA(IAT,2) = 0
        END IF
   90 CONTINUE
      NL = NL + 1
      ISTR(NL) = IRIGHT
      RETURN
      END
C***********************************************************************
      SUBROUTINE CONSOL(AUT,ALT,NDIM,N)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  CONSOLIDATE AUT, ALT TO A SINGLE MATRIX, WITH AUT AS UPPER TRIANGLE
C  (INCLUDING DIAGONAL) AND ALT AS LOWER TRIANGLE.  STORE RESULT IN AUT.
C
      DIMENSION AUT(NDIM,NDIM),ALT(NDIM,NDIM)
      NM1=N-1
      DO 10 J=1,NM1
        JP1=J+1
        DO 10 I=JP1,N
   10     AUT(I,J)=ALT(I,J)
      RETURN
      END
C***********************************************************************
      SUBROUTINE CONVIN(IJ,LEN,IK,ERROR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION IJ(*)
      DIMENSION INT(10)
      LOGICAL ERROR
C
      SAVE INT
      DATA INT/1H0,1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9/
C
C  Convert the array IJ(LEN) into an integer IK:
C
      ERROR = .FALSE.
      IF(LEN.LE.0) THEN
        ERROR = .TRUE.
        RETURN
      END IF
C
C  Make sure all elements of IJ are integers:
C
      IL   = 0
      MULT = 1
      DO 30 I = LEN,1,-1
        DO 10 J = 1,10
          JJ = J - 1
          IF(IJ(I).EQ.INT(J)) GOTO 20
   10   CONTINUE
        ERROR = .TRUE.
        RETURN
C
   20   IL = IL + JJ * MULT
        MULT = MULT * 10
   30 CONTINUE
      IK = IL
      RETURN
      END
C***********************************************************************
      SUBROUTINE CONVRT2N(N,NC1,NC2)
C***********************************************************************
C 9-May-02  FAW  Alphabetical codes for numbers > 99
      INTEGER ALPHUC,ALPHLC,CURSE,UNPRNT
C
C  CONVERT 2-DIGIT INTEGER 'N' TO TWO LITERAL CHARACTERS 'NC1','NC2'.
C
      DIMENSION INT(10),ALPHUC(26),ALPHLC(26),CURSE(31),UNPRNT(6)
      SAVE ISP,INT,ALPHUC,ALPHLC,CURSE,UNPRNT
      DATA ISP,INT/1H ,1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9,1H0/
      DATA ALPHUC/1HA,1HB,1HC,1HD,1HE,1HF,1HG,1HH,1HI,1HJ,1HK,1HL,1HM,
     + 1HN,1HO,1HP,1HQ,1HR,1HS,1HT,1HU,1HV,1HW,1HX,1HY,1HZ/
      DATA ALPHLC/1Ha,1Hb,1Hc,1Hd,1He,1Hf,1Hg,1Hh,1Hi,1Hj,1Hk,1Hl,1Hm,
     + 1Hn,1Ho,1Hp,1Hq,1Hr,1Hs,1Ht,1Hu,1Hv,1Hw,1Hx,1Hz,1HZ/
      DATA CURSE/1H!,1H",1H#,1H$,1H%,1H&,1H',1H(,1H),1H*,1H+,1H,,1H-,
     + 1H.,1H?,1H:,1H;,1H<,1H=,1H>,1H@,1H[,1H?,1H],1H^,1H_,1H`,
     + 1H{,1H|,1H},1H~/
      DATA UNPRNT/1H?,1H?,1H?,1H?,1H?,1H?/
C
      NC1=ISP
      NC2=ISP
      IF(N.LE.0) RETURN
      IF(N.GE.10) GO TO 10
        NC2=INT(N)
        GOTO 20
   10 N1=N/10
      IF(N1.LE.9) THEN 
        NC1=INT(N1)
        N2=N-N1*10
        IF(N2.EQ.0) N2=10
        NC2=INT(N2)
        GOTO 20
      ENDIF
C Number exceeds 99; use alphabetical codes for N1
C
C N1 = 10-35; use upper-case alphabeticals A-Z
      IF(N1.GE.10.AND.N1.LT.36) THEN
        NC1=ALPHUC(N1-9)
C N1 = 36-61; use lower-case alphabeticals a-z
      ELSE IF(N1.GE.36.AND.N1.LT.62) THEN
        NC1=ALPHLC(N1-35)
C N1 = 62-92; use remaining printable characters in ascii order !"#$...
C (but be careful with "/" and skip "\" for g77 compiler)
      ELSE IF(N1.GE.63.AND.N1.LT.93) THEN
        NC1=CURSE(N1-62)
        IF(N1.EQ.77) NC1=1H/
C N1 = 93-99; use unprintable or ? character
      ELSE IF(N1.GE.93.AND.N1.LT.100) THEN
        NC1=UNPRNT(N1-92)
      ELSE IF(N1.GT.99) THEN
        CALL NBHALT('Attempted use of invalid character in SR CONVRT.')
      ENDIF
      N2=N-N1*10
      IF(N2.EQ.0) N2=10
      NC2=INT(N2)
   20 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE CONVRT3(N,NC1,NC2,NC3)
C***********************************************************************
C 10-May-02  FAW  New routine.
C  5-Jul-02  FAW  Fixed "/" and "\" CURSE entries for g77 compiler
C
C  CONVERT 3-DIGIT INTEGER 'N' TO THREE HOLLERITH CHARACTERS 'NC1','NC2','NC3'.
C
      DIMENSION INT(10)
      SAVE ISP,INT
      DATA ISP,INT/1H ,1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9,1H0/
C
      NC1=ISP
      NC2=ISP
      NC3=ISP
      IF(N.LE.0) RETURN
      IF(N.LE.9) THEN
        NC3=INT(N)
        RETURN
      ENDIF
      N1=N/10
      IF(N1.LE.9) THEN
        N0=N-10*N1
        IF(N0.EQ.0) N0=10
        NC3=INT(N0)
        NC2=INT(N1)
        RETURN
      ENDIF
      N2=N1/10
      IF(N2.LE.9) THEN
        NREM=N-N2*100
        N1=NREM/10
        N0=NREM-N1*10
        IF(N0.EQ.0) N0=10
        IF(N1.EQ.0) N1=10
        NC3=INT(N0)
        NC2=INT(N1)
        NC1=INT(N2)
        RETURN
      ELSE
        CALL NBHALT('SR CONVRT3 encountered N > 999')
      ENDIF
      END
C***********************************************************************
      SUBROUTINE CONVRT3S(N,SC1,SC2,SC3)
C***********************************************************************
C 10-May-02  FAW  New routine.
C
C  CONVERT 3-DIGIT INTEGER 'N' TO THREE STRING CHARACTERS 'SC1','SC2','SC3'.
C
      CHARACTER INT*1,ISP*1,SC1*1,SC2*1,SC3*1
      DIMENSION INT(10)
      SAVE ISP,INT
      DATA ISP,INT/' ','1','2','3','4','5','6','7','8','9','0'/
C
      SC1=ISP
      SC2=ISP
      SC3=ISP
      IF(N.LE.0) RETURN
      IF(N.LE.9) THEN
        SC3=INT(N)
        RETURN
      ENDIF
      N1=N/10
      IF(N1.LE.9) THEN
        N0=N-10*N1
        IF(N0.EQ.0) N0=10
        SC3=INT(N0)
        SC2=INT(N1)
        RETURN
      ENDIF
      N2=N1/10
      IF(N2.LE.9) THEN
        NREM=N-N2*100
        N1=NREM/10
        N0=NREM-N1*10
        IF(N0.EQ.0) N0=10
        IF(N1.EQ.0) N1=10
        SC3=INT(N0)
        SC2=INT(N1)
        SC1=INT(N2)
        RETURN
      ELSE
        CALL NBHALT('SR CONVRT3S encountered N > 999')
      ENDIF
      END
C***********************************************************************
      SUBROUTINE COPY(A,B,NDIM,NR,NC)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION A(NDIM,*),B(NDIM,*)
C
C  COPY A TO B:
C
      DO 20 J = 1,NC
        DO 10 I = 1,NR
          B(I,J) = A(I,J)
   10   CONTINUE
   20 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE CORTBL(IAT,ICORE,IECP)
C***********************************************************************
C
C   CORE TABLE:
C
C     Determine the number of subshells of core orbitals of each angular
C     symmetry for atom number IAT.  ICORE is an integer array LMAX+1
C     long which returns the number of subshells to the calling subroutine:
C     the number of `s' subshells in ICORE(1), the number of `p' subshells
C     in ICORE(2), etc...
C
C     If the CORE option has been used, the core orbitals stored in the array
C     IATCR are used rather than the core orbitals of the nominal core table.
C
C     If IECP = 0 return the number of subshells, excluding subshells of
C                 an effective core potential.
C     IF IECP = 1 return the number of subshells, including subshells of
C                 an effective core potential.
C
C     Note: It is possible for a negative number of core orbitals be found
C     if effective core potentials are employed.  This happens when the
C     number of core electrons in the effective core potential is either
C     greater than the nominal number of core electrons or is greater than the
C     number of core electrons requested when using the CORE option.
C
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (LMAX = 3)
      INTEGER CORE(57),ICORE(4),ITEMP(4),IORD(16),JORD(20),KORD(20)
C
      PARAMETER(MAXATM = 200)
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
C
      SAVE IORD,JORD,KORD,CORE
      DATA IORD/1,1,3,1,3,5,1,3,5,1,3,7,5,1,3,7/
      DATA JORD/1,1,3,1,3,1,5,3,1,5,3,1,7,5,3,1,7,5,3,1/
      DATA KORD/1,2,1,3,2,4,1,3,5,2,4,6,1,3,5,7,2,4,6,8/
      DATA CORE/2,0,8,1,1,8,2,2,1,12,2,3,2,6,3,3,2,1,12,3,4,3,1,6,3,4,3,
     +  2,16,3,5,4,2,10,4,5,4,2,1,6,4,5,4,3,1,16,4,6,5,3,1,10,4,6,5,3,2/
C
C  Initialize arrays.  If there is no nuclear charge at this center,
C  return to calling routine:
C
      DO 10 L = 0,LMAX
        ICORE(L+1) = 0
        ITEMP(L+1) = 0
   10 CONTINUE
      IF(IATNO(IAT).LE.0) RETURN
C
C  If the CORE option has not been used for this atom, use the nominal
C  set of core orbitals:
C
      IF(JCORE.NE.1.OR.IATCR(IAT).LT.0) THEN
        JAT = IATNO(IAT)
        II  = 0
   20   II  = II + 1
          JAT = JAT - CORE(II)
          II = II + 1
          IF(JAT.LE.0) THEN
            DO 30 L = 1,CORE(II)
              ICORE(L) = CORE(II+L)
   30       CONTINUE
          ELSE
            II = II + CORE(II)
          END IF
        IF(JAT.GT.0) GOTO 20
      ELSE
C
C  If the CORE option has been used, determine the number of core
C  orbitals on this atom:
C
        II = IATCR(IAT)
        IF(II.GT.0) THEN
          ICT = 0
   40     ICT = ICT + 1
          L = IORD(ICT)/2
          ICORE(L+1) = ICORE(L+1) + 1
          II = II - IORD(ICT)
          IF(II.GT.0) GOTO 40
        END IF
      END IF
C
C  If effective core potentials were used and IECP = 0, remove
C  the core orbitals of the ECP:
C
      IF(IPSEUD.NE.0.AND.IECP.EQ.0) THEN
        II = IATNO(IAT)
        ICT = 0
   50   ICT = ICT + 1
          II = II - 2 * JORD(ICT)
        IF(II.GT.0) GOTO 50
        II = IZNUC(IAT) - II
        IF(II.LE.0) CALL NBHALT('Zero or negative IZNUC entry?')
        ICT = ICT + 1
   60   ICT = ICT - 1
          IF(ICT.LE.0) CALL NBHALT('Error in SR CORTBL.')
          II = II - 2 * JORD(ICT)
          IF(II.GE.0) THEN
            L = JORD(ICT)/2
            IF(ICORE(L+1).GE.KORD(ICT)) ITEMP(L+1) = ITEMP(L+1) + 1
          ELSE
            II = II + 2 * JORD(ICT)
          END IF
        IF(II.NE.0) GOTO 60
        DO 70 L = 0,LMAX
          ICORE(L+1) = ITEMP(L+1)
   70   CONTINUE
      END IF
      RETURN
      END
C***********************************************************************
      SUBROUTINE DALIST(VAL,ID,IA,IATD,IATA,IUND,IUNA)
C***********************************************************************
C 20-Jun-01  FAW  Store ordered list of intermolecular interactions
C                 in COMMON/DAINT/ table of intermolecular
C                 donor-acceptor (coordination) interactions
      IMPLICIT REAL*8 (A-H,O-Z)
C Intermolecular donor-acceptor interactions
      PARAMETER(NMXDA=100)
      COMMON/DAINT/EDA(NMXDA),NDA,INBOD(NMXDA),INBOA(NMXDA),
     +       IATMD(NMXDA),IATMA(NMXDA),IMOLD(NMXDA),IMOLA(NMXDA)
C List already filled?
      IF(NDA.GE.NMXDA) THEN
        IF(VAL.LT.EDA(NMXDA)) RETURN
        DO IB = 1,NMXDA
          IF(VAL.GT.EDA(IB)) THEN
            IF(IB.LT.NMXDA) THEN
              DO IR = NMXDA,IB+1,-1
                EDA(IR) = EDA(IR-1)
                INBOD(IR) = INBOD(IR-1)
                INBOA(IR) = INBOA(IR-1)
                IATMD(IR) = IATMD(IR-1)
                IATMA(IR) = IATMA(IR-1)
                IMOLD(IR) = IMOLD(IR-1)
                IMOLA(IR) = IMOLA(IR-1)
              ENDDO
            ENDIF
            EDA(IB) = VAL
            INBOD(IB) = ID
            INBOA(IB) = IA
            IATMD(IB) = IATD
            IATMA(IB) = IATA
            IMOLD(IB) = IUND
            IMOLA(IB) = IUNA
            GOTO 10
          ENDIF
        ENDDO
      ELSE
C Add the new value in proper order
        IF(NDA.EQ.0.OR.VAL.LT.EDA(NDA)) THEN
          NDA = NDA + 1
          IB = NDA
          EDA(IB) = VAL
          INBOD(IB) = ID
          INBOA(IB) = IA
          IATMD(IB) = IATD
          IATMA(IB) = IATA
          IMOLD(IB) = IUND
          IMOLA(IB) = IUNA
          GOTO 10
        ELSE
          DO IB = 1,NDA
            IF(VAL.GT.EDA(IB)) THEN
              DO IR = NDA+1,IB+1,-1
                EDA(IR) = EDA(IR-1)
                INBOD(IR) = INBOD(IR-1)
                INBOA(IR) = INBOA(IR-1)
                IATMD(IR) = IATMD(IR-1)
                IATMA(IR) = IATMA(IR-1)
                IMOLD(IR) = IMOLD(IR-1)
                IMOLA(IR) = IMOLA(IR-1)
              ENDDO
              EDA(IB) = VAL
              INBOD(IB) = ID
              INBOA(IB) = IA
              IATMD(IB) = IATD
              IATMA(IB) = IATA
              IMOLD(IB) = IUND
              IMOLA(IB) = IUNA
              NDA = NDA + 1
              GOTO 10
            ENDIF
          ENDDO
        ENDIF
      ENDIF
   10 RETURN
      END
C***********************************************************************
      SUBROUTINE IDIGIT(KINT,IK,ND,MAXD)
C***********************************************************************
C 9-May-02  FAW  Correction for atom numbers > 99 (MAXD=2 but KINT > 99)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION IK(MAXD),INT(10)
C
      SAVE IBLNK,INT
      DATA IBLNK,INT/1H ,1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9,1H0/
C
C  CONVERTS THE INTEGER KINT INTO THE FIRST ND ELEMENTS OF HOLLERITH ARRAY
C  IK(MAXD):
C
      IF(MAXD.EQ.2.AND.KINT.GT.99) THEN
        CALL CONVRT2N(KINT,IK(1),IK(2))
        ND=2
        RETURN
      ENDIF
      JINT = KINT
      ND   = MAXD
      DO 10 ID = MAXD,1,-1
        II = MOD(JINT,10)
        IF(II.EQ.0) II = 10
        IK(ID) = INT(II)
        IF(II.NE.10) ND = ID
        JINT = JINT/10
   10 CONTINUE
      ND = MAXD - ND + 1
C
C  SHIFT INTEGER REP IN IK SO THAT THE NUMBER OCCUPIES THE FIRST ND
C  ELEMENTS:
C
      DO 20 ID = 1,ND
        IK(ID) = IK(ID+MAXD-ND)
   20 CONTINUE
      DO 30 ID = ND+1,MAXD
        IK(ID) = IBLNK
   30 CONTINUE
      RETURN
      END
C***********************************************************************
      FUNCTION IHTYP(IBO,JBO)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL BDFIND
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),IATHY(MAXBAS,3)
C
      SAVE IV,IG,IR
      DATA IV,IG,IR/1Hv,1Hg,1Hr/
C
C  Determine whether the IBO->JBO delocalization is vicinal (IHTYP='v'),
C  geminal (IHTYP='g'), or remote (IHTYP='r'):
C
      IHTYP = IR
      IF(NBOUNI(IBO).EQ.NBOUNI(JBO)) THEN
        ICTR = MOD(NBOTYP(IBO),10)
        IB   = IBXM(IBO)
        JCTR = MOD(NBOTYP(JBO),10)
        JB   = IBXM(JBO)
        DO 20 I = 1,ICTR
          IAT = LABEL(IB,I+3)
          DO 10 J = 1,JCTR
            JAT = LABEL(JB,J+3)
            IF(IAT.EQ.JAT) THEN
              IHTYP = IG
              RETURN
            ELSE IF(BDFIND(IAT,JAT)) THEN
              IHTYP = IV
            END IF
   10     CONTINUE
   20   CONTINUE
      END IF
      RETURN
      END
C***********************************************************************
      SUBROUTINE NBJACOBI(N,A,EIVU,EIVR,NDIM,NVDIM,ICONTR)
C***********************************************************************
C  8-Mar-02  FAW  Change "JACOBI" to "NBJACOBI" throughout (GAMESS conflict)
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  DIAGONALIZE REAL SYMMETRIC MATRIX A BY JACOBI ROTATIONS:
C        N: ACTUAL DIMENSION OF A,EIVR
C     NDIM: DECLARED DIMENSION OF A,EIVR
C   ICONTR: CONTROL OPTION
C
C
C       ********  MODIFIED VERSION, MARCH 1986  *************
C
C
C     ICONTR = 0: REDUCE ALL OFF-DIAGONAL ELEMENTS TO "DONE" OR SMALLER
C                                       -- THIS SETS FULMIX=.TRUE.
C
C     ICONTR = 1: DO THE SAME AS FOR ICONTR=0 EXCEPT DO NOT MIX ORBITALS THAT
C       ARE DEGENERATE TO WITHIN "DIFFER" IF THE OFFDIAGONAL ELEMENT CONNECTING
C       THEM IS LESS THAN "DIFFER".
C                                       -- THIS SETS FULMIX=.FALSE.
C
C  FOR THE PURPOSES OF THE NAO AND NBO PROGRAMS, THESE VALUES ARE SET:
C
C     DIFFER = 1.0D-5
C          THRESHOLD FOR CONSIDERING TWO VECTORS NONDEGENERATE IF
C                         ICONTR=1
C     DONE   = 1.0D-13
C          THIS IS THE PARAMETER FOR CONVERGENCE OF THE OFF-DIAGONAL
C             MATRIX ELEMENTS.  (ABSOLUTE)  --- Reduced from 1.0D-10
C             on 8/31/88.  A more converged Fock matrix was required
C             for the NBO deletions with symmetry to work properly
C             (EDG) ---
C
C     EPS    = 0.5D-13
C          THIS PARAMETER HAS TO DO WITH THE MACHINE PRECISION AND SHOULD
C             BE SET TO A VALUE BETWEEN "DONE" AND THE MACHINE PRECISION.
C             --- Reduced from 1.0D-11.  8/31/88 (EDG) ---
C
      LOGICAL FULMIX
      DIMENSION A(NDIM,*),EIVR(NVDIM,*),EIVU(*)
C
C  IMPORTANT PARAMETERS:
C
      SAVE DIFFER,DONE,EPS,PT99
      SAVE ZERO,QUARTR,HALF,ONE,TWO,FIVE
      DATA DIFFER,DONE,EPS,PT99/1.0D-5,1.0D-13,0.5D-13,0.99D0/
      DATA ZERO,QUARTR,HALF,ONE,TWO,FIVE/0.0D0,0.25D0,0.50D0,1.0D0,
     +  2.0D0,5.0D0/
C
      FULMIX = .TRUE.
      IF(ICONTR.EQ.1) FULMIX = .FALSE.
      IF(N.LE.0) CALL NBHALT('NBJACOBI: Dimension error.')
C
C  One dimensional matrices:
C
      IF(N.EQ.1) THEN
        EIVR(1,1) = ONE
        EIVU(1) = A(1,1)
        RETURN
      END IF
C
C  Initialize the eigenvectors:
C
      DO J = 1,N
        DO I = 1,N
          EIVR(I,J) = ZERO
        END DO
        EIVR(J,J) = ONE
      END DO
C
C  Find the element of largest magnitude:
C
      ATOP = ZERO
      DO J = 2,N
        DO I = 1,J-1
          ATOP = MAX(ATOP,ABS(A(I,J)))
        END DO
      END DO
      OFFTOP = ATOP
      DO J = 1,N
        ATOP = MAX(ATOP,ABS(A(J,J)))
      END DO
C
C  Is the matrix already effectively diagonal?
C
      IF(ATOP.LT.DONE) GO TO 30
      IF(OFFTOP.LT.DONE) GO TO 30
C
C  Calculate the stopping criterion and threshold -- DSTOP and THRSH:
C
      AVGF = DFLOAT(N*(N-1)/2)
      D = ZERO
      DO J = 2,N
        DO I = 1,J-1
          S = A(I,J) / ATOP
          D = S*S + D
        END DO
      END DO
      DSTOP = (1.0D-7) * D
      THRSH = SQRT(D/AVGF) * ATOP
      THRSH = THRSH * PT99
      IF(THRSH.LT.DONE) THRSH = DONE
C
C  Start a sweep:
C
   10 IFLAG = 0
      DO JCOL = 2,N
        DO IROW = 1,JCOL-1
          AIJ = A(IROW,JCOL)
C
C  Compare the off-diagonal element with THRSH:
C
C
          ABSAIJ = ABS(AIJ)
          IF(ABSAIJ.LT.THRSH) GO TO 20
          AII = A(IROW,IROW)
          AJJ = A(JCOL,JCOL)
          S = AJJ - AII
          ABSS = ABS(S)
C
C  Don't rotate the vectors IROW and JCOL if degenerate within DIFFER:
C
          IF(.NOT.FULMIX) THEN
            IF((ABSS.LT.DIFFER).AND.(ABSAIJ.LT.DIFFER)) GO TO 20
          END IF
C
C  Will the rotation be less than rounding error?  If so, do not rotate:
C
          TEST = EPS * ABSS
          IF(ABSAIJ.LT.TEST) GO TO 20
          IFLAG = 1
C
C  If the rotation is essentially 45 degress, set sin and cos to 1/(root2):
C
          TEST = EPS * ABSAIJ
          IF (ABSS.LE.TEST) THEN
            S = 0.707106781D0
            C = S
          ELSE
            T = AIJ / S
            S = QUARTR / SQRT(QUARTR + T*T)
            C = SQRT(HALF + S)
            S = TWO * T*S/C
          END IF
C
C  Evaluate new elements of matrix A:
C
          DO I = 1,IROW
            T = A(I,IROW)
            U = A(I,JCOL)
            A(I,IROW) = C*T - S*U
            A(I,JCOL) = S*T + C*U
          END DO
          I2 = IROW + 2
          IF(I2.LE.JCOL) THEN
            DO I = I2-1,JCOL-1
              T = A(I,JCOL)
              U = A(IROW,I)
              A(I,JCOL) = S*U + C*T
              A(IROW,I) = C*U - S*T
            END DO
          END IF
          A(JCOL,JCOL) = S*AIJ + C*AJJ
          A(IROW,IROW) = C*A(IROW,IROW) - S*(C*AIJ-S*AJJ)
          DO J = JCOL,N
            T = A(IROW,J)
            U = A(JCOL,J)
            A(IROW,J) = C*T - S*U
            A(JCOL,J) = S*T + C*U
          END DO
C
C  Rotation complete:
C
          DO I = 1,N
            T = EIVR(I,IROW)
            EIVR(I,IROW) = C*T - EIVR(I,JCOL)*S
            EIVR(I,JCOL) = S*T + EIVR(I,JCOL)*C
          END DO
C
C  Calculate the new norm D and compare with DSTOP:
C
          S = AIJ / ATOP
          D = D - S*S
          IF(D.LE.DSTOP) THEN
C
C  Reevaluate DSTOP and THRSH to discard rounding errors:
C
            D = ZERO
            DO J = 2,N
              DO I = 1,J-1
                S = A(I,J) / ATOP
                D = S*S + D
              END DO
            END DO
            DSTOP = (1.D-7) * D
          END IF

          OLDTHR = THRSH
          THRSH = SQRT(D/AVGF) * ATOP * PT99
          IF(THRSH.LT.DONE) THRSH = DONE * PT99
          IF(THRSH.GT.OLDTHR) THRSH = OLDTHR
   20     CONTINUE
        END DO
      END DO
      IF(THRSH.LT.DONE) GO TO 30
      IF(IFLAG.EQ.1) GO TO 10
      THRSH = THRSH / FIVE
      GO TO 10
C
C  Finish:
C
   30 CONTINUE
      DO J = 1,N
        EIVU(J) = A(J,J)
      END DO
      RETURN
      END
C***********************************************************************
      SUBROUTINE KEYERR(WORD)
C***********************************************************************
C 16-Nov-93  JKB  SR name HALT changed to KEYERR; routine altered to
C                     print error message and return, not just STOP
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER*(*) WORD
C
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      WRITE(LFNPR,1000) WORD
C
 1000 FORMAT(' Non-integer encountered when trying to read variable ',
     + '/',A,'/',/,1X,'Keyword ignored.')
      RETURN
      END
C***********************************************************************
      SUBROUTINE LIMTRN(T,M,A,B,NDIM,NBAS,NCDIM,NC,IOPT)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  DO A LIMITED TRANSFORMATION OF T, INCLUDING ONLY THE "NC" ROWS AND
C  COLUMNS SPECIFIED IN THE VECTOR "M":
C
C   IOPT= 1 :  TAKE T=T*A
C   IOPT= 0 :  TAKE T=A(TRANSPOSE)*T*A
C   IOPT=-1 :  TAKE T=A(TRANSPOSE)*T
C
      DIMENSION T(NDIM,NDIM),M(NCDIM),A(NCDIM,NCDIM),B(NCDIM)
C
      SAVE ZERO
      DATA ZERO/0.0D0/
C
C  FIRST, TAKE T=A(TRANSPOSE)*T, WHERE T=S,DM:
C
      IF(IOPT.NE.1) THEN
        DO 40 J = 1,NBAS
          DO 10 K = 1,NC
            B(K) = T(M(K),J)
   10     CONTINUE
          DO 30 I = 1,NC
            SUM = ZERO
            DO 20 K = 1,NC
              SUM = SUM + A(K,I) * B(K)
   20       CONTINUE
            T(M(I),J) = SUM
   30     CONTINUE
   40   CONTINUE
      END IF
C
C  NOW, TAKE T=T*A:
C
      IF(IOPT.NE.-1) THEN
        DO 80 I = 1,NBAS
          DO 50 K = 1,NC
            B(K) = T(I,M(K))
   50     CONTINUE
          DO 70 J = 1,NC
            SUM = ZERO
            DO 60 K = 1,NC
              SUM = SUM + B(K) * A(K,J)
   60       CONTINUE
            T(I,M(J)) = SUM
   70     CONTINUE
   80   CONTINUE
      END IF
      RETURN
      END
C***********************************************************************
      SUBROUTINE MATMLT(A,B,V,NDIM,N)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION A(*),B(*),V(NDIM)
C
      SAVE ZERO
      DATA ZERO/0.0D0/
C
C  MULTIPLY A*B (USING SCRATCH VECTOR V), STORE RESULT IN A:
C
      NDIF=NDIM-N
      DO 30 I=1,N
        KJ=0
        IKK=I-NDIM
        DO 20 J=1,N
          IK=IKK
          TEMP=ZERO
          DO 10 K=1,N
            IK=IK+NDIM
            KJ=KJ+1
   10       TEMP=TEMP+A(IK)*B(KJ)
          KJ=KJ+NDIF
   20   V(J)=TEMP
        IJ=I-NDIM
        DO 30 J=1,N
          IJ=IJ+NDIM
   30     A(IJ)=V(J)
      RETURN
      END
C***********************************************************************
      SUBROUTINE MATML1(A,B,V,ND1,ND2,ND3,NR,N,NC)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  Multiply rectangular matrices A*B, storing result in A:
C
C  Dimensions:  A(ND1,ND2)    B(ND3,NC)     V(N) is scratch
C  Input:       A(NR,N)       B(N,NC)
C  Output:      A(NR,NC)
C
C  Note: ND2 must equal or exceed NC:
C
      LOGICAL FAIL
      DIMENSION A(ND1,ND2),B(ND3,NC),V(N)
C
      SAVE ZERO
      DATA ZERO/0.0D0/
C
      FAIL = .FALSE.
      FAIL = NR.GT.ND1 .OR. N.GT.ND2 .OR. NC.GT.ND2 .OR. N.GT.ND3
      IF(FAIL) CALL NBHALT('Check dimensions in MATML1.')
C
      DO I = 1,NR
        DO J = 1,NC
          TEMP = ZERO
          DO K = 1,N
            TEMP = TEMP + A(I,K) * B(K,J)
          END DO
          V(J) = TEMP
        END DO
        DO J = 1,NC
          A(I,J) = V(J)
        END DO
      END DO
      RETURN
      END
C***********************************************************************
      SUBROUTINE MATML2(A,B,V,NDIM,N)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION A(*),B(*),V(NDIM)
C
      SAVE ZERO
      DATA ZERO/0.0D0/
C                       B=A(TRANSPOSE)*B
C  MULTIPLY A(TRANSPOSE)*B (USING SCRATCH VECTOR V), STORE RESULT IN B:
C    ASSUME A*B IS A SYMMETRIC MATRIX, SO ALMOST HALF THE WORK IS SAVED.
C    THIS CAN BE THE SECOND STEP IN A SIMILARITY TRANSFORMATION OF B BY A.
C
      IJ=0
      IJJ=-NDIM
      KJJ=-NDIM
      DO 50 J=1,N
        KII=-NDIM
        KJJ=KJJ+NDIM
        DO 20 I=1,J
          KII=KII+NDIM
          KI=KII
          KJ=KJJ
          TEMP=ZERO
          DO 10 K=1,N
            KI=KI+1
            KJ=KJ+1
   10       TEMP=TEMP+A(KI)*B(KJ)
   20   V(I)=TEMP
        IJJ=IJJ+NDIM
        IJ=IJJ
        JI=J-NDIM
        JM1=J-1
        DO 30 I=1,JM1
          IJ=IJ+1
          JI=JI+NDIM
          VV=V(I)
          B(IJ)=VV
   30     B(JI)=VV
        IJ=IJ+1
   50   B(IJ)=V(J)
      RETURN
      END
C***********************************************************************
      SUBROUTINE MATML3(A,B,V,ND1,ND2,ND3,NR,N)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  Multiply rectangular matrices A(transpose)*B, storing result in B:
C
C  Dimensions:  A(ND1,ND2)    B(ND3,N)     V(NR) is scratch
C  Input:       A(NR,N)       B(NR,N)
C  Output:                    B(N,N)
C
C  Assume result is a symmetric, square matrix:
C
      LOGICAL FAIL
      DIMENSION A(ND1,ND2),B(ND3,N),V(NR)
C
      SAVE ZERO
      DATA ZERO/0.0D0/
C
      FAIL = .FALSE.
      FAIL = NR.GT.ND1 .OR. N.GT.ND1 .OR. N.GT.ND2 .OR. NR.GT.ND3
      IF(FAIL) CALL NBHALT('Check dimensions in MATML3.')
C
      DO J = 1,N
        DO I = 1,J
          TEMP = ZERO
          DO K = 1,NR
            TEMP = TEMP + A(K,I) * B(K,J)
          END DO
          V(I) = TEMP
        END DO
        DO I = 1,J-1
          VV = V(I)
          B(I,J) = VV
          B(J,I) = VV
        END DO
        B(J,J) = V(J)
      END DO
      RETURN
      END
C***********************************************************************
      FUNCTION NAMEAT(IZ)
C***********************************************************************
C 25-May-2005  EDG  Atomic symbols to Z=118
C-----------------------------------------------------------------------
C
C  RETURN ATOMIC SYMBOL FOR NUCLEAR CHARGE IZ (.LE. 118):
C
      DIMENSION NAME(118)
C
      SAVE IGHOST,IBLANK,NAME
C
      DATA IGHOST/2Hgh/,IBLANK/2H  /
      DATA NAME/2H H,2HHe,2HLi,2HBe,2H B,2H C,2H N,2H O,2H F,2HNe,
     + 2HNa,2HMg,2HAl,2HSi,2H P,2H S,2HCl,2HAr,2H K,2HCa,2HSc,2HTi,
     + 2H V,2HCr,2HMn,2HFe,2HCo,2HNi,2HCu,2HZn,2HGa,2HGe,2HAs,
     + 2HSe,2HBr,2HKr,2HRb,2HSr,2H Y,2HZr,2HNb,2HMo,2HTc,2HRu,
     + 2HRh,2HPd,2HAg,2HCd,2HIn,2HSn,2HSb,2HTe,2H I,2HXe,2HCs,
     + 2HBa,2HLa,2HCe,2HPr,2HNd,2HPm,2HSm,2HEu,2HGd,2HTb,2HDy,
     + 2HHo,2HEr,2HTm,2HYb,2HLu,2HHf,2HTa,2H W,2HRe,2HOs,2HIr,
     + 2HPt,2HAu,2HHg,2HTl,2HPb,2HBi,2HPo,2HAt,2HRn,2HFr,2HRa,
     + 2HAc,2HTh,2HPa,2H U,2HNp,2HPu,2HAm,2HCm,2HBk,2HCf,2HEs,
     + 2HFm,2HMd,2HNo,2HLr,2HRf,2HDb,2HSg,2HBh,2HHs,2HMt,2H10,
     + 2H11,2H12,2H13,2H14,2H15,2H16,2H17,2H18/
C
      IF(IZ.LT.0.OR.IZ.GT.118) NAMEAT = IBLANK
      IF(IZ.GT.0) NAMEAT = NAME(IZ)
      IF(IZ.EQ.0) NAMEAT = IGHOST
      RETURN
      END
C***********************************************************************
      SUBROUTINE NBHALT(WORD)
C***********************************************************************
C 16-Nov-93  JKB  Routine to print error message and return control
C                    to host program/package or STOP
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      CHARACTER*(*) WORD
C
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      WRITE(LFNPR,1000) WORD
 1000 FORMAT(/1X,A)
*     STOP                                                              GENDRV
*     CALL GAUERR('Error: NBHALT')                                      G03DRV
*     CALL GAUERR('Error: NBHALT')                                      G98DRV
*     CALL GAUERR('Error: NBHALT')                                      G94DRV
*     STOP                                                              GMSDRV
*     CALL ERRQUIT('NBO: Call to NBHALT', 0)                            NWCDRV
*     STOP                                                              AMPDRV
      END
C***********************************************************************
      SUBROUTINE NORMLZ(A,S,M,N,NC)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  Normalize NC columns of A:
C
      DIMENSION A(M,NC),S(M,M)
C
      SAVE ZERO,ONE
      DATA ZERO,ONE /0.0D0,1.0D0/
C
      DO 40 I = 1,NC
        TEMP = ZERO
        DO 20 J = 1,N
          DO 10 K = 1,N
            TEMP = TEMP + A(J,I)*A(K,I)*S(J,K)
   10     CONTINUE
   20   CONTINUE
        FACTOR = ONE/SQRT(TEMP)
        DO 30 J = 1,N
          A(J,I) = FACTOR * A(J,I)
   30   CONTINUE
   40 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE NBORDR(RANK,LIST,N,NDIM,ARCRNK)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  RANK POSITIVE ELEMENTS OF INTEGER 'LIST', LOWEST VALUES FIRST.
C
      INTEGER RANK,ARCRNK,TEMP
      DIMENSION RANK(NDIM),LIST(NDIM),ARCRNK(NDIM)
      DO 10 I=1,N
   10   ARCRNK(I)=I
      DO 40 I=1,N
        IF(I.EQ.N)GO TO 30
        I1=I+1
        DO 20 J=I1,N
          IF(LIST(J).GE.LIST(I))GO TO 20
          TEMP=LIST(I)
          LIST(I)=LIST(J)
          LIST(J)=TEMP
          TEMP=ARCRNK(I)
          ARCRNK(I)=ARCRNK(J)
          ARCRNK(J)=TEMP
   20     CONTINUE
   30   RANK(ARCRNK(I))=I
        IF(LIST(I).LE.0) GO TO 50
   40   CONTINUE
      RETURN
   50 DO 60 K=I,N
        RANK(ARCRNK(K))=0
   60   CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE PACK(T,ND,N)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION T(*)
C
      SAVE ZERO
      DATA ZERO/0.0D0/
C
C  PACK:  packs a symmetric matrix T into upper triangular form.  Note
C         that T(N,N) should be dimension T(ND,ND) in the calling routine:
C
C  Dimensions reasonable?
C
      IF(N.GT.ND) CALL NBHALT('N is greater than ND in SR PACK.')
C
C  Pack the array:
C
      II = 0
      DO J = 1,N
        JPTR = (J-1) * ND
        DO I = 1,J
          IPTR = JPTR + I
          II = II + 1
          T(II) = T(IPTR)
        END DO
      END DO
C
C  Clear remainder of T:
C
      DO I = II+1,ND*ND
        T(I) = ZERO
      END DO
      RETURN
      END
C***********************************************************************
      SUBROUTINE RANK(EIG,N,NDIM,ARCRNK)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  Order the numbers in EIG, highest values first, and construct ARCRNK:
C
C  ARCRNK(I) is the old location of the I-th highest value in the
C  original EIG.
C
      INTEGER ARCRNK
      DIMENSION EIG(NDIM),ARCRNK(NDIM)
C
C  Initialize ARCRNK:
C
      DO I = 1,N
        ARCRNK(I) = I
      END DO
C
C  Sort:
C
      ISW = 1
      DO I = 1,N-1
        IF(ISW.EQ.1) THEN
          ISW = 0
          DO J = 1,N-I
            K = J + 1
            IF(EIG(K).GT.EIG(J)) THEN
              ISW = 1
              TEMP   = EIG(K)
              EIG(K) = EIG(J)
              EIG(J) = TEMP
              ITEMP     = ARCRNK(K)
              ARCRNK(K) = ARCRNK(J)
              ARCRNK(J) = ITEMP
            END IF
          END DO
        END IF
      END DO
      RETURN
      END
C***********************************************************************
      SUBROUTINE SCNVRT(IVEC,STR,NL,IERR)
C***********************************************************************
C 15-Feb-93  FAW  New subroutine to convert Hollerith to character
C 14-Jul-93  EDG  Use internal write to character string
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
C Convert vector [IVEC(IL), IL=1,NL] of Hollerith values to STR(1:NL)
C
      CHARACTER STR*(*)
      DIMENSION IVEC(NL)
C
      IERR = 0
      DO 10 IL = 1,NL
        WRITE(STR(IL:IL),'(A1)') IVEC(IL)
   10 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE SIMTRS(A,S,V,NDIM,N)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  Similarity transform A ==> S(transpose)*A*S using scratch vector V:
C
C  Assumes result (returned in A) is a symmetric matrix and that A,S
C  are square matrices.
C
      DIMENSION A(NDIM,NDIM),S(NDIM,NDIM),V(NDIM)
C
      CALL MATMLT(A,S,V,NDIM,N)
      CALL MATML2(S,A,V,NDIM,N)
      RETURN
      END
C***********************************************************************
      SUBROUTINE SIMTR1(A,S,V,ND,NA,NR,NC)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  Similarity transform A ==> S(transpose)*A*S using scratch vector V:
C
C  Assumes result (returned in A) is a symmetric matrix and that S is
C  a rectangular transformation matrix.
C
      LOGICAL FAIL
      DIMENSION A(ND,ND),S(ND,NC),V(ND)
C
      FAIL = .FALSE.
      FAIL = NC.GT.ND
      IF(FAIL) CALL NBHALT('Check dimensions in SIMTR1.')
C
      CALL MATML1(A,S,V,ND,ND,ND,NA,NR,NC)
      CALL MATML3(S,A,V,ND,ND,ND,NR,NC)
      RETURN
      END
C***********************************************************************
      SUBROUTINE NBTRSP(A,NDIM,N)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION A(NDIM,NDIM)
C
C  TRANSPOSE MATRIX A, STORE RESULT IN A.
C
      DO 10 I=1,N
        DO 10 J=1,I
          TEMP=A(I,J)
          A(I,J)=A(J,I)
   10     A(J,I)=TEMP
      RETURN
      END
C***********************************************************************
      SUBROUTINE UNPACK(T,ND,N)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION T(*)
C
C  UNPACK:  Unpacks an upper triangular matrix into a symmetric
C           matrix T(N,N).  Note that T should be dimensioned T(ND,ND)
C           in the calling routine.
C
C  Distribute elements into upper triangular portion:
C
      J = 0
      K = 1
      IPTR = (ND+1)*(N-K) + 1
      NTRI = N*(N+1)/2
      DO I = NTRI,1,-1
        T(IPTR-J) = T(I)
        IF(J.LT.N-K) THEN
          J = J + 1
        ELSE
          J = 0
          K = K + 1
          IPTR = (ND+1)*(N-K) + 1
        END IF
      END DO
C
C  Complete remainder of array:
C
      DO J = 1,N-1
        ICOL = (J-1)*ND
        DO I = J+1,N
          IPTR = ICOL + I
          JPTR = (I-1)*ND + J
          T(IPTR) = T(JPTR)
        END DO
      END DO
      RETURN
      END
C***********************************************************************
      SUBROUTINE VALTBL(IAT,IVAL,IFLG)
C***********************************************************************
C 25-May-2005  EDG  La and Ac basis sets may be missing valence f shell
C 23-May-2005  EDG  Elements 57-70, 89-102 get extra valence d shell
C-----------------------------------------------------------------------
C
C   VALENCE TABLE:
C
C     Determine the number of sets of valence orbitals of each angular
C     symmetry for atom number IAT.  IVAL is an integer array LMAX+1
C     long which returns the number of sets to the calling subroutine:
C     the number of `s' subshells in IVAL(1), the number of `p' subshells
C     in IVAL(2), etc...
C
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (LMAX = 3)
      DIMENSION IVAL(4),ICORE(4),IORD(20),ISW(118)
C
      PARAMETER(MAXATM = 200)
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
C
      SAVE IORD,ISW
      DATA IORD/1,1,3,1,3,1,5,3,1,5,3,1,7,5,3,1,7,5,3,1/
      DATA ISW/118*0/
C
      II = IATNO(IAT)
      IF(IFLG.NE.0) ISW(II) = IFLG
      DO 10 L = 0,LMAX
        IVAL(L+1) = 0
   10 CONTINUE
C
C  Count the number of filled or partially filled subshells:
C
      IF(II.GT.0) THEN
        ICT = 0
   20   ICT = ICT + 1
        L = IORD(ICT)/2
        IVAL(L+1) = IVAL(L+1) + 1
        II = II - 2*IORD(ICT)
        IF(II.GT.0) GOTO 20
      END IF
C
C  Extra filled d shell for elements 57-70 and 89-102:
C
      II = IATNO(IAT)
      IF(II.GE.57.AND.II.LE.70.OR.II.GE.89.AND.II.LE.102)
     +  IVAL(3) = IVAL(3) + 1
C
C  Exceptions:
C
      IF(ISW(II).NE.0) THEN
        IS = ABS(ISW(II))
        IVAL(IS) = IVAL(IS) + SIGN(1,ISW(II))
      END IF
C
C  Remove the core subshells.  Note: if there are more core orbitals
C  in the effective core potential than in the nominal core table or
C  from the CORE option, remove these extra core orbitals from the
C  set of valence orbitals:
C
      IECP = 1
      CALL CORTBL(IAT,ICORE,IECP)
      DO 50 L = 0,LMAX
        IVAL(L+1) = IVAL(L+1) - ICORE(L+1)
   50 CONTINUE
      IECP = 0
      CALL CORTBL(IAT,ICORE,IECP)
      DO 60 L = 0,LMAX
        IF(ICORE(L+1).LT.0) THEN
          IVAL(L+1) = IVAL(L+1) + ICORE(L+1)
        END IF
   60 CONTINUE
      RETURN
      END
C***********************************************************************
      FUNCTION VECLEN(X,N,NDIM)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION X(NDIM)
C
      SAVE ZERO
      DATA ZERO/0.0D0/
C
      SUM = ZERO
      DO 10 I = 1,N
        SUM = SUM + X(I)*X(I)
   10 CONTINUE
      VECLEN = SQRT(SUM)
      RETURN
      END
C***********************************************************************
C NBO 5.G -- Natural Bond Orbital Analysis Programs
C (c) Copyright 1996-2008 Board of Regents of the University of Wisconsin System
C     on behalf of the Theoretical Chemistry Institute.  All Rights Reserved.
C***********************************************************************
C  NRT - NATURAL RESONANCE THEORY    Version 2.6
C***********************************************************************
C
C  NRT MODULE ROUTINES:
C
C  MAIN DRIVER ROUTINE:
C
C      SUBROUTINE NRTDRV(DM,T,WIBERG,RHOSTR,KPAR,NRES,IRESET,A,MAXRES,
C     +                  MAXREF,NLOW,NAO,LEN,NELEC,MEMORY,IVALSP)
C
C  SECONDARY NRT ROUTINES:
C
C      SUBROUTINE VALDM(DM,GAMMA,SCR,V,U,IOCC,NVAL,LVAL)
C      SUBROUTINE NRTSTR(NRES,IDXRES,MAXRES,MAXREF,LSTRES,LEN,NELEC)
C      SUBROUTINE LEWIS(DM,WIBERG,NRES,IDXRES,MAXRES,MAXREF,LSTRES,
C     +                 LEN,IVALSP)
C      SUBROUTINE LEWATM(IAT,JAT,KDX,LEFTBD,ICNT,NATOMS)
C      SUBROUTINE LEWBDS(IAT,JAT,IDX,JDX,WIBERG,LEFTBD,NATOMS,
C     +                  THR1,THR2,THR3,IALARM)
C      SUBROUTINE LEWDIS(ICH,N,IATNO,NATOMS,IERR,INIT)
C      SUBROUTINE LEWTOP(JAT,JDX,KDX,LEFTBD,ICNT,NATOMS)
C      SUBROUTINE NBORES(NRES,IDXRES,MAXRES,MAXREF,LSTRES,LEN,ISCR,
C     +                  IVALSP)
C      SUBROUTINE HBRES(NRES,IDXRES,MAXRES,MAXREF,LSTRES,LEN,NRTCTL)
C      SUBROUTINE KEKULE(ILIST,IDXRES,IRESET,MAXRES,NREF,MAXREF,LSTRES,
C     +                  LEN)
C      SUBROUTINE PARENT(IREF,RHOST,RHOT,DM,T,WIBERG,BNDOCC,POL,Q,V,BLK,
C     +                  C,EVAL,BORB,P,TA,HYB,VA,VB,TOPO,SCR,IDON,IACC,
C     +                  IDXRES,KPAR,MAXRES,MAXREF,IBDRES,ISRCH,NRTCTL)
C      SUBROUTINE SHREWD(DM,T,BNDOCC,POL,Q,V,BLK,C,EVAL,BORB,P,TA,HYB,
C     +                  VA,VB,IREF,IDON,IACC,IFLG)
C      SUBROUTINE NBSLCT(RHOSTR,NRES,IRESET,KPTR,IDXRES,MAXRES,NREF,
C     +                  MAXREF,NRTCTL)
C      SUBROUTINE REFRS(IREF,T,BNDOCC,OCCR,TR,SCR1,SCR2,SCR3,GAMMA,
C     +                 GAMMAW,IST,IOCC,NREF,NAO,IVALSP)
C      SUBROUTINE EXPECT(IRES,T,BNDOCC,OCC,OCCR,TR,SCR,IPTR,MAXRES,IREF,
C     +                  NREF,NELEC)
C      SUBROUTINE IONIC(IRES,T,XION,NLOW,MAXRES,IREF,NREF)
C      SUBROUTINE NBPREP(DM,TNBO,HYB,T,THYB,SCR)
C      SUBROUTINE ARROWS(DM,T,DELOC,SCR,NRES,IRESET,IDON,IACC,IDXRES,
C     +                  MAXRES,IREF,NREF,LSTRES,LEN,IAT1,IAT2,IDXCOV,
C     +                  IIONC,NRTCTL)
C      SUBROUTINE NEWLBL
C      SUBROUTINE IONTST(IRES,IREF,IAT1,IAT2,IDXRES,MAXRES,NREF,LSTRES,
C     +                  LEN,IDEL)
C      SUBROUTINE CONDNS(IREF,XION,KPAR,NRES,IRESET,IDXRES,MAXRES,NREF,
C     +                  NLOW,IAT1,IAT2,IDXCOV,IIONC)
C      SUBROUTINE SECRES(IRES,DM,T,RHOSTR,BNDOCC,TNBO,SCR,IDON,IACC,
C     +                  IDXRES,LSTRES,MAXRES,IREF,NREF,LEN)
C      SUBROUTINE SETAPP(NUMRES,NRES,ILIST,IDXRES,MAXRES,IREF,NREF)
C      SUBROUTINE APPEND(IRES,DM,T,RHOSTR,DELOC,BNDOCC,TNBO,SCR,ICTR,
C     +                  IMAKE,IBRAK,IDN,QDN,IAC,QAC,IPAR,IHYB,IDON,
C     +                  IACC,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
C      SUBROUTINE INITWT(ERRREF,ERR,RHOSTR,OCC,WGT,Q,IST,IRANK,NRES,IRESET,
C     +                  MAXRES,NREF)
C      SUBROUTINE WGTOPT(ERRREF,ERR,RHOSTR,OCC,WGT,T,SCR1,SCR2,SCR3,SCR4,
C     +                  SCR5,SCR6,SCR7,SCR8,SCR9,Q,IST,IPTR,KPAR,NRES,
C     +                  IRESET,MAXRES,NREF,NRTCTL)
C      SUBROUTINE HESSIN(RHOSTR,OCC,WGT,Q,T,HESS,EVEC,EVAL,DER,G,
C     +                  IPTR,NRES,MAXRES,IREF,NREF,IND)
C      SUBROUTINE SUPPL(FW,WGT,WGTM,MAP,WGTP,IDXRES,KPAR,NRES,IRESET,
C     +                 IPTR,MAXRES,ICNT,NREF,MAXREF,NRTCTL,IVALSP)
C      SUBROUTINE RESWGT(RHOSTR,WGT,WGTP,WGTM,ISCR,MAP,IRANK,NRES,IRESET,
C     +                  IDXRES,MAXRES,ICNT,NREF)
C      SUBROUTINE SYMWGT(RHOSTR,WGTP,WGTM,MAP,NRES,IRESET,IDXRES,MAXRES,
C     +                  ICNT,NREF,NRTCTL)
C      SUBROUTINE NRTOUT(RHOSTR,OCC,WGT,WGTP,SCR,WGTM,Q,MAP,IST,NRES,
C     +                  IRESET,IDXRES,LSTRES,MAXRES,ICNT,NREF,LEN)
C      SUBROUTINE NBDORD(BORDER,VALENZ,TOPO,WGT,XION,WGTP,NRES,IRESET,
C     +                  IDXRES,MAXRES,NREF,LSTRES,LEN,NLOW)
C      SUBROUTINE NRTLST(MAP,WGTM,ICNT,NRES,IRESET,IDXRES,MAXRES,NREF,
C     +                  LSTRES,LEN)
C
C  NRT OPTIMIZATION ROUTINES
C
C      SUBROUTINE SETOPT(RHOSTR,WGT,T,IPTR,NRES,MAXRES,IREF,NREF,NVAR)
C      SUBROUTINE BFGS(FRET,FREF,OCC,WGT,Q,P,HESS,XT,XIT,G,DG,HDG,DF,W,
C     +                SCR,IPTR,NRES,MAXRES,IREF,NREF,NVAR,ITER)
C      SUBROUTINE NBPWLL(FRET,FREF,WGT,Q,P,XI,PT,XIT,PTT,W,WP,IPTR,
C     +                  NRES,MAXRES,IREF,NREF,NVAR,ITER)
C      SUBROUTINE NLINMN(FRET,WGT,Q,XT,P,XIT,IPTR,NRES,MAXRES,IREF,
C     +                  NREF,NVAR)
C      SUBROUTINE DLINMN(FRET,OCC,WGT,Q,XT,P,XIT,DF,SCR,IPTR,NRES,
C     +                  MAXRES,IREF,NREF,NVAR)
C      SUBROUTINE NBMNBK(AX,BX,CX,FA,FB,FC,WGT,Q,XT,P,XIT,IPTR,
C     +                  NRES,MAXRES,IREF,NREF,NVAR)
C      SUBROUTINE NBRENT(FRET,AX,BX,CX,FB,TOL,XMIN,WGT,Q,XT,PT,XIT,IPTR,
C     +                  NRES,MAXRES,IREF,NREF,NVAR)
C      SUBROUTINE DBRENT(FRET,AX,BX,CX,FB,TOL,XMIN,OCC,WGT,Q,XT,P,XIT,DF,
C     +                  SCR,IPTR,NRES,MAXRES,IREF,NREF,NVAR)
C      SUBROUTINE NBFDIM(FX,X,WGT,Q,XT,P,XIT,IPTR,NRES,MAXRES,IREF,
C     +                 NREF,NVAR)
C      SUBROUTINE DF1DIM(DX,X,OCC,WGT,Q,XT,P,XIT,DF,SCR,IPTR,NRES,
C     +                  MAXRES,IREF,NREF,NVAR)
C      SUBROUTINE NBPHI(FT,T,WGT,Q,IPTR,NRES,MAXRES,IREF,NREF,NVAR)
C      SUBROUTINE NBDPHI(DER,T,OCC,WGT,Q,SCR,IPTR,NRES,MAXRES,IREF,
C     +                  NREF,NVAR)
C
C  SIMULATED ANNEALING ROUTINES:
C
C      SUBROUTINE ANNEAL(XLAM,YLAM,ERRREF,ERR,RHOSTR,WGT,T,SCR,Q,
C     +                  IPTR,NRES,MAXRES,IREF,NREF,ISEED,NVAR,ITT)
C      SUBROUTINE SETANN(RHOSTR,WGT,T,IPTR,NRES,MAXRES,IREF,NREF,NVAR)
C      SUBROUTINE ADJUST(T,IT,NVAR,SSIZE,STEP,ISEED)
C      SUBROUTINE METROP(NSUC,FW2,FW1,FT,ISEED)
C      SUBROUTINE RESTOR(T,IT,NVAR,SSIZE)
C
C  NRT BRANCHING ROUTINES:
C
C      SUBROUTINE IDCTRL(IREF)
C      SUBROUTINE IDINIT(ICNT,NC,NH,NUM)
C      SUBROUTINE IDINCR(ICNT,NC,NH,NUM)
C      FUNCTION IDTEST(JDXT,IC,NUM)
C      SUBROUTINE IDCLR
C      SUBROUTINE IDCOPY
C      SUBROUTINE IDREST
C
C  NRT UTILITY ROUTINES:
C
C      SUBROUTINE ATMORD(WIBERG,NRT)
C      CHARACTER*2 FUNCTION CHARAT(IZ)
C      SUBROUTINE CMPFW(FW,XLAM,YLAM,ERRREF,ERR,T,WGT,Q,IPTR,NRES,
C     +                 MAXRES,IREF,NREF)
C      SUBROUTINE EXPWGT(RHOW,RHOSTR,WGT,IRANK,NRES,MAXRES,IREF,NREF,N)
C      SUBROUTINE FETREF(T,LABEL,IBXM,IREF)
C      SUBROUTINE FORMQ(Q,OCC,IST,NRES,MAXRES,IREF,NREF,ICTRL)
C      SUBROUTINE GETDM(T,DM,TR,SCR1,SCR2,SCR3,IST,IOCC,NVAL,IERR)
C      SUBROUTINE GETDW(DW,GAMMAW,WGT,LVAL,NREF,NVAL)
C      SUBROUTINE GETERR(ERROR,WGT,Q,NRES,MAXRES,IREF,NREF)
C      SUBROUTINE GETFDM(DM,DELOC,TNAO,TBO,SCR)
C      SUBROUTINE GETGRD(DER,T,WGT,Q,OCC,G,IPTR,NRES,MAXRES,IREF,NREF,
C     +                  NVAR)
C      SUBROUTINE GETHES(HESS,DER,T,WGT,Q,OCC,G,IPTR,NRES,MAXRES,
C     +                  IREF,NREF,NVAR,IFLG)
C      SUBROUTINE GETREL(IBO,IBOP,IUNIT1,IUNIT2,IREL,IA,IB,IC,ID)
C      FUNCTION INTRN(ILLIM,IULIM,ISEED)
C      SUBROUTINE MULTI(FW,GAMMAW,WGT,SCR,IRESET,LVAL,NREF,NVAL)
C      SUBROUTINE NRTINP(IESS,INRT)
C      SUBROUTINE PRTWGT(IRES,IR,NUM,WGT,II,IAT,JJ,JAT,IFLG)
C      FUNCTION RANNB(IDUM)
C      FUNCTION REALRN(XLLIM,XULIM,ISEED)
C      SUBROUTINE SVTREF(T,LABEL,IBXM,IREF)
C      SUBROUTINE TOPCMP(IDUP,IRES,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
C      SUBROUTINE TOPGET(IRES,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
C      SUBROUTINE TOPOUT
C      SUBROUTINE TOPSTR(IRES,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
C      SUBROUTINE TOPZER(NATOMS)
C      SUBROUTINE WGTOUT(WGT,NRES,MAXRES,IREF,NREF)
C      SUBROUTINE WGTPR(WGTM,MAP,NWGT)
C      SUBROUTINE WNORM(WGT,IRESET,IW,IP,SKIP)
C
C***********************************************************************
      SUBROUTINE NRTDRV(DM,T,WIBERG,RHOSTR,KPAR,NRES,IRESET,A,MAXRES,
     +                  MAXREF,NLOW,NAO,LEN,NELEC,MEMORY,IVALSP)
C***********************************************************************
C 29-Oct-01  CMM  Always call NBORES to include NBO structure
C                 Exit gently when no reference structures are found
C 19-Apr-01  CMM  Extra call to HBRES to find 3CHB reference structures
C                 Reduce/restore THRESH to pare down references faster.
C  2-Jun-98  EDG  Delete reference structure if orthogonalization error
C 21-Oct-94  JKB  Backspace to $NRTSTR keylist to reread if 2nd pass
C 31-Jan-94  JKB  Append NBO structure to LEWIS structures if JPRINT(77)=1
C 28-Jan-94  JKB  Added flag IVALSP, set if valence space inadequate;
C                 Control passed to back NBODRV for complete restart
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  NBO COMMON blocks:
C
      PARAMETER (NBDAR = 300)
      PARAMETER(MAXBAS = 2000)
      PARAMETER (LPLPS = 1000)
      CHARACTER KSTR*80,KNBO*4,KNRT*4
C
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBTHR/THRSET,PRJSET,ACCTHR,CRTSET,E2THR,ATHR,PTHR,ETHR,
     +             DTHR,DLTHR,CHSTHR,REFTHR,STTHR,PRTHR,THRNCS,THRNJC
      COMMON/IOCWAR/IOCWAR
C
      DIMENSION DM(NDIM,NDIM),T(NDIM,NDIM),WIBERG(NATOMS,NATOMS),
     +          RHOSTR(MAXRES,MAXREF),NRES(MAXREF),IRESET(MAXREF),
     +          A(MEMORY),KPAR(MAXRES,MAXREF),NRTCTL(10)
      DIMENSION IAT1(LPLPS),IAT2(LPLPS),IDXCOV(LPLPS)
C
      SAVE ZERO,EPS,ONE,THR,FOUR,TEN,THRESH,TWO
      DATA ZERO,EPS,ONE,THR,FOUR,TEN/0.D0,1.D-5,1.D0,1.5D0,4.D0,1.D1/
      DATA THRESH,TWO/0.6D0,2.0D0/
      DATA KNRT/'$NRT'/KNBO/'$NBO'/
C
C  ======================================================================
C           I N I T I A L I Z E     N R T     P R O G R A M
C  ======================================================================
C
C  No monatomics:
C
      IF(NATOMS.EQ.1) THEN
        WRITE(LFNPR,990)
        RETURN
      END IF
C
C  Set threshold for NBO search:
C
      HOLD = THRSET
      IF(THRSET.LT.ZERO) THRSET = THR
C
C  Set print parameters:
C
      IHOLD = JPRINT(5)
      IF(IWDETL.NE.0) JPRINT(57) = 1
      IF(JPRINT(57).EQ.0) JPRINT(5) = 0
C
C  NRT currently limited to 100 reference structures:
C
      IF(MAXREF.GT.(NBDAR-100)/2)
     +    CALL NBHALT('NRTDRV: Increase NBDAR in I/O routines.')
C
C  Initialize arrays:
C
      NRES(1) = 0
      DO 5 IREF = 1,MAXREF
        NRES(IREF) = 0
        IRESET(IREF) = -1
        KPAR(1,IREF) = 0
    5 CONTINUE
C
C  ENote/JNote:  IAT1, IAT2, IDXCOV are only dimensioned 100.  Set at
C     compatible value when multiple LP-LP* interactions allowed
C
      DO 8 KION=1,LPLPS
      IAT1(KION) = 0
      IAT2(KION) = 0
    8 IDXCOV(KION) = 0
C
C  Initialize NRT control flags:
C
C  NRTCTL(1) : Multi-reference iterations over the reference list
C              -3 : lost all reference structures, restart from NBORES
C              -2 : single pass, no iterations
C              -1 : initialize SUPPL routine
C               0 : multi-reference complete
C               1 : continue iterations
C
C  NRTCTL(2) : Symmetry control
C               0 : satisfactory NRT expansion
C               1 : symmetry broken solution encountered, repeat NRT
C               2 : unable to determine a satisfactory solution
C
C  NRTCTL(3) : Source of reference structures:
C               0 : $NRTSTR
C               1 : LEWIS
C               2 : NBORES
C               3 : LEWIS and NBORES
C
C  IVALSP : Valence orbital space/error condition
C           -1 : Second pass (after error) with full valence AO space
C            0 : Minimal valence space accepted and at least one covalent
C                   reference structure found
C            1 : Symmetric orthogonalization problem detected in SYMORT;
C                   structure removed but NRT analysis continuing
C            2 : No covalent structures could be calculated within
C                   truncated valence space
C            3 : No covalent structures could be calculated within
C                   full AO space; force use of ionic NBO structure
C            4 : Hypervalency detected in SR LEWIS or SR NBORES
C                   (truncated matrix)
C            5 : Inconsistent valence orbital count in SR REFRS due to
C                   hypervalency
C
      DO 6 I = 1,10
        NRTCTL(I) = 0
    6 CONTINUE
      NRTCTL(1) = -1
      NRTCTL(3) = -1
C
      IF(ISPIN.EQ.0.AND.IVALSP.EQ.0) WRITE(LFNPR,900)
      IF(ISPIN.GT.0.AND.IVALSP.EQ.0) WRITE(LFNPR,910)
      IF(ISPIN.LT.0.AND.IVALSP.EQ.0) WRITE(LFNPR,920)
      IF(IOCWAR.GT.0.AND.IVALSP.EQ.0) WRITE(LFNPR,925)
C
C  Partition the scratch vector:
C
C  A(I1)  : DELOC(NDIM,NDIM)
C  A(I2)  : BNDOCC(NDIM)
C  A(I3)  : POL(NDIM,3),IATOMS(NATOMS),ICTR(NATOMS)
C  A(I4)  : Q(MXAO,NDIM),IMAKE(2,NATOMS)
C  A(I5)  : V(NDIM),SCR(NDIM),IBRAK(2,NATOMS)
C  A(I6)  : BLK(MXBO,MXBO)
C  A(I7)  : C(MXBO,MXBO)
C  A(I8)  : EVAL(MXBO)
C  A(I9)  : BORB(MXBO)
C  A(I10) : P(MXAO,MXAO)
C  A(I11) : TA(MXAO,MXAO)
C  A(I12) : HYB(MXAO)
C  A(I13) : VA(MXAO)
C  A(I14) : VB(MXAO)
C  A(I15) : TOPO(NATOMS,NATOMS)
C  A(I16) : OCC(NDIM,MAXRES,MAXREF)
C  A(I17) : OCCR(NDIM,MAXREF)
C  A(I18) : TR(NDIM,NDIM),SCR(NDIM)
C  A(I19) : ERR(MAXREF)
C  A(I20) : ERRREF(MAXREF)
C  A(I21) : WGT(MAXRES,MAXREF)
C  A(I22) : XION(NLOW,MAXRES,MAXREF)
C  A(I23) : T(MAXRES),SCR(NDIM,NDIM),SCR(NDIM),SCR(MAXRES)
C  A(I24) : SCR(NDIM,NDIM),XI(MAXRES,MAXRES),HESS(MAXRES,MAXRES),IRANK
C  A(I25) : XT(MAXRES),PT(MAXRES),EVAL(MAXRES,MAXRES),SCR(NDIM,NDIM)
C  A(I26) : XIT(MAXRES),IDN(NATOMS)
C  A(I27) : G(MAXRES),PTT(MAXRES),QDN(NATOMS)
C  A(I28) : DG(MAXRES),W(MAXRES),IAC(NATOMS)
C  A(I29) : HDG(MAXRES),WP(MAXRES),QAC(NATOMS)
C  A(I30) : DF(MAXRES),WGTM(MAXRES*MAXREF),IPAR(NATOMS)
C  A(I31) : W(MAXRES),ICOV(MAXRES),ISCR(MAXRES*MAXREF),IHYB(NATOMS)
C  A(I32) : SCR(MAXRES),IION(MAXRES),ISCR(MAXRES),MAP(MAXRES*MAXREF)
C  A(I33) : WGTP(MAXREF)
C  A(I34) : GAMMA(LNAO)
C  A(I35) : GAMMAW(LNAO,MAXREF)
C  A(I36) : Q(MAXRES,MAXRES)
C  A(J0)  : IST(NDIM,MAXREF)
C  A(J1)  : ILIST(MAXRES)
C  A(J2)  : IRNK(NDIM),ISCR(NDIM),ISCR(NDIM*10)
C  A(J3)  : IRNK1(MAXRES),NBONDS(MAXRES),IRANK(MAXRES),IPTR(MAXREF),KPTR
C  A(J4)  : IDON(MAXRES,MAXREF)
C  A(J5)  : IACC(MAXRES,MAXREF)
C  A(J6)  : IDXRES(MAXRES,MAXREF)
C  A(J7)  : LSTRES(LEN)
C
      LNAO = NAO * (NAO + 1) /2
      I1   = 1
      I2   = I1  + NDIM * NDIM
      I3   = I2  + NDIM
      I4   = I3  + 3 * NDIM
      I5   = I4  + MXAO * NDIM
      I6   = I5  + NDIM
      I7   = I6  + MXBO * MXBO
      I8   = I7  + MXBO * MXBO
      I9   = I8  + MXBO
      I10  = I9  + MXBO
      I11  = I10 + MXAO * MXAO
      I12  = I11 + MXAO * MXAO
      I13  = I12 + MXAO
      I14  = I13 + MXAO
      I15  = I14 + MXAO
      I16  = I15 + NATOMS * NATOMS
      I17  = I16 + NDIM * MAXRES * MAXREF
      I18  = I17 + NDIM * MAXREF
      I19  = I18 + NDIM * NDIM
      I20  = I19 + MAXREF
      I21  = I20 + MAXREF
      I22  = I21 + MAXRES * MAXREF
      I23  = I22 + MAXRES * NLOW * MAXREF
      I24  = I23 + MAX(NDIM*NDIM,MAXRES)
      I25  = I24 + MAX(NDIM*NDIM,MAXRES*MAXRES)
      I26  = I25 + MAX(NDIM*NDIM,MAXRES*MAXRES)
      I27  = I26 + MAXRES
      I28  = I27 + MAXRES
      I29  = I28 + MAXRES
      I30  = I29 + MAXRES
      I31  = I30 + MAXRES*MAXREF
      I32  = I31 + MAXRES*MAXREF
      I33  = I32 + MAXRES*MAXREF
      I34  = I33 + MAXREF
      I35  = I34 + LNAO
      I36  = I35 + LNAO*MAXREF
      J0   = I36 + MAXRES*MAXRES
      J1   = J0  + NDIM * MAXREF
      J2   = J1  + MAXRES
      J3   = J2  + NDIM*10
      J4   = J3  + MAXRES
      J5   = J4  + MAXRES*MAXREF
      J6   = J5  + MAXRES*MAXREF
      J7   = J6  + MAXRES*MAXREF
      JEND = J7  + LEN
      IF(IVALSP.EQ.0) WRITE(LFNPR,940) MAXREF,MAXRES,JEND-1,MEMORY
      IF(JEND.GT.MEMORY) THEN
        WRITE(LFNPR,930) JEND - MEMORY
        CALL NBHALT('NRTDRV: Error in memory partitioning.')
      END IF
C
C  Modify the Wiberg bond indices for open shell wave functions:
C
      IF(ISPIN.NE.0) THEN
        DO 20 JAT = 1,NATOMS
          DO 10 IAT = 1,NATOMS
            WIBERG(IAT,JAT) = FOUR * WIBERG(IAT,JAT)
   10     CONTINUE
   20   CONTINUE
      END IF
C
C  Form the valence NAO density matrix for the full wavefunction:
C
      CALL VALDM(DM,A(I34),A(I23),A(I24),A(I25),A(J2),NAO,LNAO)
C
C  Initialize the IDXRES and LSTRES arrays
C
      CALL TOPSTR(-1,A(J6),MAXRES,1,MAXREF,A(J7),LEN)
C
C  ======================================================================
C       P R E P A R E     R E F E R E N C E     S T R U C T U R E S
C  ======================================================================
C
C  Temporarily, store information about the reference structures in
C  the first column of IDXRES, RHOSTR, etc.  Later, in SR SELECT,
C  this information will be moved into the first row of these arrays.
C
C  Find a set of reference (parent) resonance structures that will
C  initiate the search for secondary structures.
C
C  Search for the $NRTSTR list in the input deck.  If any structures
C  are provided, disable the automatic NRT selection of reference
C  structures in SUPPL:  (First backspace to $NRTSTR/$NBO if 2nd pass.)
C
      IF(IVALSP.NE.0) THEN
   22   BACKSPACE(LFNIN)
        BACKSPACE(LFNIN)
        READ(LFNIN,1070) KSTR
        DO 23 I = 1,74
          I2 = I + 3
          IF(KSTR(I:I2).EQ.KNRT(1:4)) THEN
            BACKSPACE(LFNIN)
            GO TO 24
          END IF
          IF(KSTR(I:I2).EQ.KNBO(1:4)) GO TO 24
   23   CONTINUE
        GO TO 22
      END IF
   24 CALL NRTSTR(NRES,A(J6),MAXRES,MAXREF,A(J7),LEN,NELEC)
      IF(NRES(1).NE.0) THEN
        WRITE(LFNPR,1010) NRES(1)
        IF(JPRINT(57).NE.0) WRITE(LFNPR,*)
        NRTCTL(1) = -2
        NRTCTL(3) =  0
      END IF
C
C  Obtain a list of candidate reference structures from the Wiberg bond
C  indices and from the regular NBO search:
C
      IF(NRES(1).EQ.0) THEN
        NTMP = 0
        CALL LEWIS(DM,WIBERG,NRES,A(J6),MAXRES,MAXREF,A(J7),LEN,IVALSP)
        IF(IVALSP.EQ.4) GOTO 200
        NTMP = NRES(1)
        IF(NRES(1).NE.0) NRTCTL(3) = 1
        WRITE(LFNPR,1020) NRES(1)
        IF(NRES(1).NE.0.OR.JPRINT(77).EQ.1) THEN
          IF(JPRINT(57).NE.0) WRITE(LFNPR,*)
        END IF
C        IF(JPRINT(77).EQ.1) THEN
C          CALL NBORES(NRES,A(J6),MAXRES,MAXREF,A(J7),LEN,A(J2),IVALSP)
C          IF(IVALSP.EQ.4) GOTO 200
C        END IF
      END IF
C   25 IF(NRES(1).EQ.0.OR.NRTCTL(1).EQ.-3) THEN
   25 IF(NRTCTL(3).NE.0) THEN
        NTMP = NRES(1)
        CALL NBORES(NRES,A(J6),MAXRES,MAXREF,A(J7),LEN,A(J2),IVALSP)
        IF(IVALSP.EQ.4) GOTO 200
        IF(NRES(1).NE.0) THEN
          IF(NRTCTL(3).EQ.1) THEN
            IF(NRES(1).GT.NTMP) THEN
              NRTCTL(3) = 3
              WRITE(LFNPR,1025)
            END IF
          ELSE
            NRTCTL(3) = 2
            WRITE(LFNPR,1030)
          END IF
        ELSE
          WRITE(LFNPR,950)
          GOTO 200
        END IF
      END IF
C
C  Extra call to HBRES added 4/01 for 3CHB resonance structures - CMM
C
        IF(IW3CHB.EQ.1) THEN
          CALL HBRES(NRES,A(J6),MAXRES,MAXREF,A(J7),LEN,NRTCTL)
          WRITE(LFNPR,1080) NRES(1)
        END IF
C
C  Compute rho* for each of the candidate reference structures using
C  the directed NBO search:
C
      NCNT = 0
      DIV = ONE
      IF(ISPIN.NE.0) DIV = TWO
C
      THRESH = EPS
C      IF(NRTCTL(3).EQ.0) THRESH = EPS
C  The variation above for TM's to reduce clutter. CMM 3/28/01
C
      MRES = NRES(1)
      RHOMIN = TEN
      DO 40 IRES = 1,MRES
        JRES = IRES
        CALL IDCLR
        CALL TOPGET(IRES,A(J6),MAXRES,1,MAXREF,A(J7),LEN)
        CALL ATMORD(WIBERG,1)
        RHOT = TEN
   30   CALL PARENT(JRES,RHOST,RHOT,DM,T,WIBERG,A(I2),A(I3),A(I4),A(I5),
     +              A(I6),A(I7),A(I8),A(I9),A(I10),A(I11),A(I12),A(I13),
     +              A(I14),A(I15),A(I25),A(J4),A(J5),A(J6),KPAR,MAXRES,
     +              MAXREF,IBDRES,0,NRTCTL)
C
C  Should this structure be considered a reference?
C
        NCNT = NCNT + 1
        IF(IBDRES.EQ.0) THEN
          NRES(1) = MAX(JRES,NRES(1))
          CALL TOPSTR(JRES,A(J6),MAXRES,1,MAXREF,A(J7),LEN)
          CALL TOPCMP(IDUP,JRES,A(J6),MAXRES,1,MAXREF,A(J7),LEN)
          RHOSTR(JRES,1) = RHOST
          IF(RHOST.LT.RHOMIN) RHOMIN = RHOST
          IF(NRTCTL(3).NE.0) RHOT = MIN(RHOT,RHOST+THRESH/DIV)
          JRES = NRES(1) + 1
        ELSE
          RHOSTR(JRES,1) = -ONE
        END IF
C
C  Consider other structures with identical TOPO matrices:
C
        CALL IDCTRL(JRES)
        IF(JRES.GT.0) GOTO 30
   40 CONTINUE
C
      IF(NRTCTL(3).NE.0) THRESH = 0.6D0
      IF(ISPIN.EQ.0) THEN
        RHOT = RHOT+(THRESH-EPS)
      ELSE
        RHOT = RHOT+((THRESH-EPS)/DIV)
      END IF
C
C  The variation above for TM's to reset THRESH, RHOT. CMM 3/28/01
C
C      IF(IVALSP.EQ.3) GO TO 110
C
C  Select the reference structures that have lowest rho*, and
C  reorganize the IDXRES and RHOSTR arrays:
C
      CALL NBSLCT(RHOSTR,NRES,IRESET,A(J3),A(J6),MAXRES,NREF,MAXREF,
     +            NRTCTL)
      WRITE(LFNPR,955) NCNT,NREF
      IF(IVALSP.EQ.3) GO TO 110
C
C  ======================================================================
C       P R E P A R E     S E C O N D A R Y     S T R U C T U R E S
C  ======================================================================
C
C  Find resonance structures that are related by concerted bond shifts:
C
      RHOT = TEN
   35 CALL KEKULE(A(J1),A(J6),IRESET,MAXRES,NREF,MAXREF,A(J7),LEN)
C
C  Loop over reference structures, generating new structures with SR
C  ARROWS and SR SECRES:
C
      DO 80 IREF = 1,NREF
        IF(IRESET(IREF).GT.0) THEN
          CALL IDCLR
          CALL TOPGET(1,A(J6),MAXRES,IREF,NREF,A(J7),LEN)
          CALL ATMORD(WIBERG,1)
   50     CALL PARENT(IREF,RHOST,RHOT,DM,T,WIBERG,A(I2),A(I3),A(I4),
     +                A(I5),A(I6),A(I7),A(I8),A(I9),A(I10),A(I11),
     +                A(I12),A(I13),A(I14),A(I15),A(I25),A(J4),A(J5),
     +                A(J6),KPAR,MAXRES,MAXREF,IBDRES,1,NRTCTL)
C
C  If necessary, repeat the search until we find the reference structure
C  we want:
C
          IF(ABS(RHOST-RHOSTR(1,IREF)).GT.EPS) THEN
            JREF = IREF
            CALL IDCTRL(JREF)
            IF(JREF.GT.0) GOTO 50
            WRITE(LFNPR,960) IREF,RHOSTR(1,IREF)
            CALL NBHALT('SR PARENT cannot find reference structure.')
          END IF
          IF(IBDRES.EQ.1) THEN
            WRITE(LFNPR,960) IREF,RHOSTR(1,IREF)
            CALL NBHALT('SR PARENT cannot find reference structure.')
          END IF
C
C  Dump the NAO-NBO transformation and labels to disk:
C
          CALL SVTREF(T,LABEL,IBXM,IREF)
C
C  Place a copy of the NAO-NBO transformation in temporary storage:
C
          CALL COPY(T,A(I18),NDIM,NNAO,NNAO)
C
C  Keep a copy of the NBO occupancies for this reference structure
C  in OCCR and calculate the valence NAO density difference:
C
          CALL REFRS(IREF,T,A(I2),A(I17),A(I23),A(I24),A(I25),A(I5),
     +               A(I34),A(I35),A(J0),A(J2),NREF,NAO,IVALSP)
          IF(IVALSP.EQ.1) THEN
            IF(JPRINT(57).NE.0) WRITE(LFNPR,*)
            WRITE(LFNPR,1060) IREF,RHOSTR(1,IREF)
            IF(JPRINT(57).NE.0) WRITE(LFNPR,*)
            IRESET(IREF) = -1
            GOTO 80
          ELSE IF(IVALSP.EQ.5) THEN
            GOTO 200
          END IF
C
C  Compute the expectation values of the density operator for this
C  resonance structure in the NBO basis of its reference structure
C  (that is itself, so these values will be either 0 or 2):
C
          CALL EXPECT(1,T,A(I2),A(I16),A(I17),A(I18),A(I23),A(J2),
     +                MAXRES,IREF,NREF,NELEC)
C
C  Compute the bond ionicities for this structure:
C
          CALL IONIC(1,T,A(I22),NLOW,MAXRES,IREF,NREF)
C
C  Prepare to generate new resonance structures:
C
          CALL FNDMOL(A(I3))
          CALL NBOCLA(A(I2),ACCTHR)
          CALL GETFDM(DM,A(I1),A(I23),T,A(I24))
C
C  Prepare the density matrix, transformation matrices, and NBO labels:
C
          CALL NBPREP(DM,T,A(I12),A(I18),A(I23),A(I25))
C
C  The contents of the following arrays are:
C
C    DM     : NHO density matrix
C    T      : NHO-NBO transformation for the reference structure
C    A(I18) : NAO-NBO transformation for the reference structure
C    A(I23) : NAO-NHO transformation
C
C  Generate new resonance structures with SR ARROWS and delete ionic
C  structures with SR CONDNS:
C
          IF(JPRINT(57).NE.0) WRITE(LFNPR,970) IREF
          CALL ARROWS(DM,T,A(I1),A(I24),NRES,IRESET,A(J4),A(J5),A(J6),
     +             MAXRES,IREF,NREF,A(J7),LEN,IAT1,IAT2,IDXCOV,IIONC,
     +             NRTCTL)
          CALL CONDNS(IREF,A(I22),KPAR,NRES,IRESET,A(J6),MAXRES,NREF,
     +                NLOW,IAT1,IAT2,IDXCOV,IIONC)
          IF(IRESET(IREF).GT.0) THEN
            IF(JPRINT(57).NE.0) WRITE(LFNPR,980) NRES(IREF) - 1
          END IF
C
C  Loop over secondary resonance structures:
C
          DO 60 IRES = 2,NRES(IREF)
            KPAR(IRES,IREF) = 0
C
C  Place a new copy of the NBO labels in COMMON/NBBAS/:
C
            CALL NEWLBL
C
C  Compute the NBOs for this secondary structure:
C
            CALL SECRES(IRES,DM,T,RHOSTR,A(I2),A(I24),A(I25),A(J4),
     +                  A(J5),A(J6),A(J7),MAXRES,IREF,NREF,LEN)
C
C  A(I24) now contains the NHO-NBO transformation for the IRESth
C  resonance structure:
C
C  Form the NAO-NBO transformation for this resonance structure:
C
            CALL COPY(A(I23),A(I25),NDIM,NNAO,NNAO)
            CALL MATMLT(A(I25),A(I24),A(I26),NDIM,NNAO)
C
C  A(I25) now contains the NAO-NBO transformation:
C
C  Compute the expectation values of the density operator for this
C  resonance structure in the NBO basis of its reference structure
C
            CALL EXPECT(IRES,A(I25),A(I2),A(I16),A(I17),A(I18),A(I24),
     +                  A(J2),MAXRES,IREF,NREF,NELEC)
C
C  Compute the bond ionicities for this structure:
C
            CALL IONIC(IRES,A(I25),A(I22),NLOW,MAXRES,IREF,NREF)
   60     CONTINUE
C
C  Append additional Kekule structures, when available:
C
          CALL SETAPP(NUMRES,NRES,A(J1),A(J6),MAXRES,IREF,NREF)
          DO 70 IRES = NRES(IREF)-NUMRES+1,NRES(IREF)
            KPAR(IRES,IREF) = 0
            CALL NEWLBL
            CALL APPEND(IRES,DM,T,RHOSTR,A(I1),A(I2),A(I24),A(I25),
     +                  A(I3),A(I4),A(I5),A(I26),A(I27),A(I28),A(I29),
     +                  A(I30),A(I31),A(J4),A(J5),A(J6),MAXRES,IREF,
     +                  NREF,A(J7),LEN)
            IF(RHOSTR(IRES,IREF).GE.ZERO) THEN
              CALL COPY(A(I23),A(I25),NDIM,NNAO,NNAO)
              CALL MATMLT(A(I25),A(I24),A(I26),NDIM,NNAO)
              CALL EXPECT(IRES,A(I25),A(I2),A(I16),A(I17),A(I18),A(I24),
     +                    A(J2),MAXRES,IREF,NREF,NELEC)
              CALL IONIC(IRES,A(I25),A(I22),NLOW,MAXRES,IREF,NREF)
            END IF
   70     CONTINUE
        END IF
   80 CONTINUE
C
C  If there are no resonance structures at all at this point, only ionic
C     structures were found and no corresponding covalent structure
C     could be generated.  Try restarting with full AO matrix if not
C     done already, else abandon NRT.
C
      ICHK = 0
      DO 82 K=1,MAXREF
        IF(NRES(K).GT.0) ICHK = 1
   82 CONTINUE
      IF(ICHK.EQ.0) THEN
        IF(JPRINT(77).EQ.0) THEN
          WRITE(LFNPR,1040)
          IF(JPRINT(57).NE.0) WRITE(LFNPR,*)
          IVALSP = 2
          GOTO 200
        ELSE
          WRITE(LFNPR,1050)
          IF(JPRINT(57).NE.0) WRITE(LFNPR,*)
          IVALSP = 3
C          GOTO 200
          GO TO 25
        END IF
      END IF
C
C  ======================================================================
C       C A L C U L A T E     R E S O N A N C E     W E I G H T S
C  ======================================================================
C
C  Filter out resonance structures that lead to increased density error,
C  and compute the exponential resonance weights:
C
  110 CALL INITWT(A(I20),A(I19),RHOSTR,A(I16),A(I21),A(I36),A(J0),A(J3),
     +            NRES,IRESET,MAXRES,NREF)
C
C  Variationally optimize the resonance weights:
C
      CALL WGTOPT(A(I20),A(I19),RHOSTR,A(I16),A(I21),A(I23),A(I24),
     +     A(I25),A(I26),A(I27),A(I28),A(I29),A(I30),A(I31),A(I32),
     +     A(I36),A(J0),A(J3),KPAR,NRES,IRESET,MAXRES,NREF,NRTCTL)
C
C  Compute multi-reference resonance weights:
C
      CALL MULTI(FW,A(I35),A(I33),A(I18),IRESET,LNAO,NREF,NAO)
      CALL RESWGT(RHOSTR,A(I21),A(I33),A(I30),A(I31),A(I32),A(I24),NRES,
     +            IRESET,A(J6),MAXRES,ICNT,NREF)
C
C  Count reference structures:
C
      NREF = 0
      DO 85 IREF = 1,MAXREF
        IF(IRESET(IREF).GE.0.OR.IRESET(IREF).EQ.-3) NREF = IREF
   85 CONTINUE
C
C  Return to NBORES if no reference structure at this point:
C
      IF(NREF.EQ.0.AND.NRTCTL(3).EQ.1) THEN
        WRITE(LFNPR,1000)
        NRTCTL(1) = -3
        NRES(1) = 0
        GOTO 25
      END IF
C
C  Supplement list of reference structures with secondary structures
C  having weight greater than threshold (1%).  Also, delete any
C  reference structures having weight less than threshold:
C
      CALL SUPPL(FW,A(I21),A(I30),A(I32),A(I33),A(J6),KPAR,NRES,IRESET,
     +           A(J3),MAXRES,ICNT,NREF,MAXREF,NRTCTL,IVALSP)
      IF(IVALSP.EQ.2) THEN
        GOTO 200
      ELSE IF(IVALSP.EQ.3) THEN
        NRES(1) = 0
        GO TO 25
      END IF
      IF(NRTCTL(1).GT.0) THEN
        DO 100 IREF = 1,NREF
          IF(IRESET(IREF).GT.0) THEN
            RHO = TEN
            CALL IDCLR
            CALL TOPGET(1,A(J6),MAXRES,IREF,NREF,A(J7),LEN)
            CALL ATMORD(WIBERG,1)
   90       CALL PARENT(IREF,RHOST,RHOT,DM,T,WIBERG,A(I2),A(I3),A(I4),
     +                  A(I5),A(I6),A(I7),A(I8),A(I9),A(I10),A(I11),
     +                  A(I12),A(I13),A(I14),A(I15),A(I25),A(J4),A(J5),
     +                  A(J6),KPAR,MAXRES,MAXREF,IBDRES,1,NRTCTL)
            IF(RHOST.GE.ZERO.AND.RHOST.LT.RHO) RHO = RHOST
            JREF = IREF
            CALL IDCTRL(JREF)
            IF(JREF.GT.0) GOTO 90
            IF(RHO.EQ.TEN) THEN
              IRESET(IREF) = -1
            ELSE
              NRES(IREF) = 1
              RHOSTR(1,IREF) = RHO
            END IF
          END IF
  100   CONTINUE
        GOTO 35
      END IF
C
C  Check for symmetry:
C
      CALL SYMWGT(RHOSTR,A(I33),A(I30),A(I32),NRES,IRESET,A(J6),MAXRES,
     +            ICNT,NREF,NRTCTL)
      IF(NRTCTL(2).GT.0) GOTO 35
C
C  Write results of the NRT analysis:
C
      CALL NRTOUT(RHOSTR,A(I16),A(I21),A(I33),A(I24),A(I30),A(I36),
     +    A(I32),A(J0),NRES,IRESET,A(J6),A(J7),MAXRES,ICNT,NREF,LEN)
C
C  Compute natural bond orders and natural atomic valencies:
C
      CALL NBDORD(A(I24),A(I2),A(I15),A(I21),A(I22),A(I33),NRES,IRESET,
     +            A(J6),MAXRES,NREF,A(J7),LEN,NLOW)
C
C  Punch $NRTSTR keylist:
C
      CALL NRTLST(A(I32),A(I30),ICNT,NRES,IRESET,A(J6),MAXRES,NREF,
     +            A(J7),LEN)
C
C  Return to calling program:
C
      IVALSP = 0
  200 CONTINUE
      JPRINT(5) = IHOLD
      THRSET = HOLD
      RETURN
C
  900 FORMAT(//1X,'NATURAL RESONANCE THEORY ANALYSIS:')
  910 FORMAT(//1X,'NATURAL RESONANCE THEORY ANALYSIS, alpha spin:')
  920 FORMAT(//1X,'NATURAL RESONANCE THEORY ANALYSIS, beta spin:')
  925 FORMAT(/1X,'WARNING:  Non-physical occupancies were found in ',
     + 'NAO or NBO search.',/11X,'NRT will attempt to continue.')
  930 FORMAT(/1X,'Apparent problems with the memory partitioning for ',
     + 'the NRT analysis.',/1X,'The scratch vector is too short, by ',
     + 'roughly',I8,' words.  Check',/1X,'the calculation of the ',
     + 'MAXRES variable in SR NBODRV.')
  940 FORMAT(/1X,'Maximum reference structures :',I6,/1X,
     + 'Maximum resonance structures :',I6,/1X,'Memory ',
     + 'requirements : ',I10,' words of',I10,' available',/)
  950 FORMAT(1X,'No reference structures available to the NRT',
     + ' routines.')
  955 FORMAT(1X,'Initial loops searched',I5,' bonding pattern(s); all ',
     + 'but ',I2,' were discarded')
  960 FORMAT(/1X,'SR PARENT cannot find the desired reference ',
     + 'structure',I3,' (Rho* =',F8.5,').')
  970 FORMAT(/1X,'ARROWS is searching reference structure ',I4,' for ',
     + 'secondary structures.')
  980 FORMAT(/1X,'      ',I4,' secondary structures generated')
  990 FORMAT(1X,'No NRT analysis for atoms.')
 1000 FORMAT(1X,'Unable to calculate a satisfactory reference.  ',
     + 'Restart with NBO structure.')
 1010 FORMAT(1X,I3,' reference structure(s) read from $NRTSTR keylist')
 1020 FORMAT(1X,I3,' candidate reference structure(s) calculated by ',
     + 'SR LEWIS')
 1025 FORMAT(1X,'Additional reference structure taken from NBO search')
 1030 FORMAT(1X,'Candidate reference structure taken from NBO search')
 1040 FORMAT(/1X,'No covalent structures available within minimal ',
     +   'valence space.',/1X,'Reallocate scratch vector and restart',
     +   ' using full AO density matrix.')
 1050 FORMAT(/1X,'No covalent reference structures found; ',
     +   'accept ionic structure.')
C1060 FORMAT(1X,'Reference',I4,':  rho*=',F7.5,'; SYMORT error, ',
C    + 'restart with full density matrix')
 1060 FORMAT(1X,'Reference',I4,':  rho*=',F7.5,', SYMORT error; ',
     + 'deleted')
 1070 FORMAT(A)
C New FORMAT statement 1080 added by CMM
 1080 FORMAT(1X,'Total of ',I3,' candidate reference structures.')
      END
C***********************************************************************
      SUBROUTINE VALDM(DM,GAMMA,SCR,V,U,IOCC,NVAL,LVAL)
C***********************************************************************
C  Extract valence NAO density matrix elements from DM, place in GAMMA,
C  and renormalize to maintain idempotency:
C
      IMPLICIT REAL*8 (A-H,O-Z)
      EXTERNAL UNPACK
C
      PARAMETER(MAXBAS = 2000)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBNAO/NAOC(MAXBAS),NAOA(MAXBAS),LTYP(MAXBAS),IPRIN(MAXBAS)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION DM(NDIM,NDIM),GAMMA(LVAL),SCR(NVAL,NVAL),V(NVAL,NVAL),
     +          U(NVAL),IOCC(NVAL)
C
      SAVE ISTR,ZERO,ONE,TWO
      DATA ISTR/3HVal/
      DATA ZERO,ONE,TWO/0.0D0,1.0D0,2.0D0/
C
C  Retrieve the NAO density matrix from disk:
C
      CALL FEDNAO(DM)
C
C  Use the full density?
C
      IF(JPRINT(77).NE.0) THEN
        IJ = 0
        DO 5 I = 1,NNAO
          DO 4 J = 1,I
            IJ = IJ + 1
            GAMMA(IJ) = DM(I,J)
    4     CONTINUE
    5   CONTINUE
        RETURN
      END IF
C
C  Use valence NAO density only:
C
      IJ   = 0
      VALE = ZERO
      DO 20 I = 1,NNAO
        IF(LTYP(I).EQ.ISTR) THEN
          DO 10 J = 1,I
            IF(LTYP(J).EQ.ISTR) THEN
              IJ = IJ + 1
              GAMMA(IJ) = DM(I,J)
              IF(I.EQ.J) VALE = VALE + DM(I,J)
            END IF
   10     CONTINUE
        END IF
   20 CONTINUE
      IF(IJ.NE.LVAL)
     +    CALL NBHALT('Incorrect valence electron count in SR VALDM.')
      NELE = NINT(VALE)
      IF(ISPIN.EQ.0.AND.MOD(NELE,2).NE.0.AND.IWMSP.EQ.0)
     +    WRITE(LFNPR,900)
C
C  Diagonalize valence density matrix:
C
      CALL COPY(GAMMA,SCR,LVAL,LVAL,1)
      CALL UNPACK(SCR,NVAL,NVAL)
      CALL NBJACOBI(NVAL,SCR,U,V,NVAL,NVAL,0)
C
C  Rank eigenvectors by occupancy:
C
      CALL RANK(U,NVAL,NVAL,IOCC)
C
C  Reconstruct the valence density matrix (now idempotent):
C
      NOCC = NELE
      IF(ISPIN.EQ.0) NOCC = NOCC / 2
      ETA = ONE
      IF(ISPIN.EQ.0) ETA = TWO
      IJ = 0
      DO 50 J = 1,NVAL
        DO 40 I = 1,J
          IJ = IJ + 1
          GIJ = ZERO
          DO 30 K = 1,NOCC
            L = IOCC(K)
            GIJ = GIJ + ETA * V(I,L) * V(J,L)
   30     CONTINUE
          GAMMA(IJ) = GIJ
   40   CONTINUE
   50 CONTINUE
      RETURN
C
  900 FORMAT(1X,'Warning: Low valence density detected in VALDM;',
     + ' Consider using NRTFDM option')
      END
C***********************************************************************
      SUBROUTINE NRTSTR(NRES,IDXRES,MAXRES,MAXREF,LSTRES,LEN,NELEC)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL END,EQUAL,ERROR
C
      PARAMETER(MAXATM = 200)
      COMMON/NBSTR/ITOPO(MAXATM,MAXATM)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION NRES(MAXREF),IDXRES(MAXRES,MAXREF),LSTRES(LEN)
      DIMENSION ICORE(4),KEYWD(6),KLONE(4),KBOND(4),KALT(4),KSTR(3)
C
      SAVE KLONE,KBOND,KALT,KSTR,KS,KD,KT,KQ,KP,KH
      DATA KLONE/1HL,1HO,1HN,1HE/,KBOND/1HB,1HO,1HN,1HD/
      DATA KALT/1H$,1HE,1HN,1HD/,KSTR/1HS,1HT,1HR/
      DATA KS,KD,KT,KQ,KP,KH/1HS,1HD,1HT,1HQ,1HP,1HH/
C
C  Determine whether the $NRTSTR keylist is available:
C
      CALL NRTINP(JPRINT(2),INRT)
      IF(INRT.EQ.0) RETURN
C
C  Determine the number of electron pairs that should be found in
C  each resonance structure:
C
      IECP = 0
      NEP = NELEC
      IF(ISPIN.EQ.0) NEP = NEP / 2
      DO 5 IAT = 1,NATOMS
        CALL CORTBL(IAT,ICORE,IECP)
        DO 4 L = 0,3
          NEP = NEP - ICORE(L+1) * (2 * L + 1)
    4   CONTINUE
    5 CONTINUE
C
C  Prepare to read the next structure in the list:
C
      ISTR = 0
   10 LENG = 6
      CALL HFLD(KEYWD,LENG,END)
      IF(EQUAL(KEYWD,KALT,4)) RETURN
      IF(EQUAL(KEYWD,KSTR,3)) GOTO 20
      WRITE(LFNPR,960) (KEYWD(I),I=1,6),ISTR
      CALL NBHALT('Unrecognizable word found in $NRTSTR keylist.')
C
C  Read in the list of specified lone pairs and bonds:
C
   20 ISTR = ISTR + 1
      CALL TOPZER(NATOMS)
   40 CONTINUE
        LENG = 6
        CALL HFLD(KEYWD,LENG,END)
        IF(END) GOTO 100
        IF(EQUAL(KEYWD,KLONE,4)) GOTO 60
        IF(EQUAL(KEYWD,KBOND,4)) GOTO 80
        WRITE(LFNPR,900) (KEYWD(I),I=1,6),ISTR
        CALL NBHALT('Unrecognizable orbital type in $NRTSTR keylist.')
C
C  LONE specification:
C
   60   CONTINUE
          CALL IFLD(IAT,ERROR)
          IF(ERROR) THEN
            LENG = 6
            CALL HFLD(KEYWD,LENG,END)
            IF(END) GOTO 40
            WRITE(LFNPR,910) (KEYWD(I),I=1,6),ISTR
            CALL NBHALT('Unrecognizable word found in $NRTSTR keylist.')
          END IF
          CALL IFLD(ITOPO(IAT,IAT),ERROR)
        IF(.NOT.ERROR) GOTO 60
        LENG = 6
        CALL HFLD(KEYWD,LENG,END)
        WRITE(LFNPR,920) (KEYWD(I),I=1,6),ISTR
        CALL NBHALT('Error reading $NRTSTR keylist.')
C
C  BOND specification:
C
   80   CONTINUE
          LENG = 6
          CALL HFLD(KEYWD,LENG,END)
          IF(END) GOTO 40
          NUM = 0
          IF(EQUAL(KEYWD,KS,1)) NUM = 1
          IF(EQUAL(KEYWD,KD,1)) NUM = 2
          IF(EQUAL(KEYWD,KT,1)) NUM = 3
          IF(EQUAL(KEYWD,KQ,1)) NUM = 4
          IF(EQUAL(KEYWD,KP,1)) NUM = 5
          IF(EQUAL(KEYWD,KH,1)) NUM = 6
          IF(NUM.EQ.0) GOTO 90
          CALL IFLD(IAT,ERROR)
          IF(ERROR) GOTO 90
          CALL IFLD(JAT,ERROR)
          IF(ERROR) GOTO 90
          ITOPO(IAT,JAT) = NUM
          ITOPO(JAT,IAT) = NUM
        GOTO 80
C
   90   WRITE(LFNPR,930) ISTR
        CALL NBHALT('Error reading bond orbitals in $NRTSTR keylist.')
C
C  END encountered.  This terminates the specification of this resonance
C  structure:
C
C  Check that this structure has the proper number of electron pairs:
C
  100 CONTINUE
      IEP = 0
      DO 140 JAT = 1,NATOMS
        DO 130 IAT = 1,JAT
           IEP = IEP + ITOPO(IAT,JAT)
  130   CONTINUE
  140 CONTINUE
      IEP = IEP - NEP
      IF(IEP.EQ.0) GOTO 200
      IF(IEP.GT.0) WRITE(LFNPR,940) ISTR,IEP
      IF(IEP.LT.0) WRITE(LFNPR,950) ISTR,ABS(IEP)
      CALL NBHALT('Wrong number of lone pairs in $NRTSTR structure.')
C
C  Satisfactory resonance structure.  Store it in LSTRES:
C
  200 IRES = NRES(1) + 1
      CALL TOPSTR(IRES,IDXRES,MAXRES,1,MAXREF,LSTRES,LEN)
      CALL TOPCMP(IDUP,IRES,IDXRES,MAXRES,1,MAXREF,LSTRES,LEN)
      IF(IDUP.EQ.0) NRES(1) = NRES(1) + 1
      GOTO 10
C
  900 FORMAT(/1X,'Unrecognizable orbital type (',6A1,') for structure',
     + I3,' in the $NRTSTR keylist.')
  910 FORMAT(/1X,'Unrecognizable word (',6A1,') in structure',I3,' of',
     + ' the $NRTSTR keylist.')
  920 FORMAT(/1X,'Error reading near word ',6A1,' in structure',I3,
     + ' of the $NRTSTR keylist.')
  930 FORMAT(/1X,'Error reading bond orbitals for structure',I3,' of',
     + ' the $NRTSTR keylist.')
  940 FORMAT(/1X,'Structure',I3,' of the $NRTSTR keylist has',I3,
     + ' extra electron pairs.')
  950 FORMAT(/1X,'Structure',I3,' of the $NRTSTR keylist has',I3,
     + ' missing electron pairs.')
  960 FORMAT(/1X,'Unrecognizable word (',6A1,') after structure',I3,
     + ' of the $NRTSTR keylist.')
      END
C***********************************************************************
      SUBROUTINE LEWIS(DM,WIBERG,NRES,IDXRES,MAXRES,MAXREF,LSTRES,
     +                 LEN,IVALSP)
C***********************************************************************
C 21-Jun-01  FAW  Added MAXBND parameter for coordination > 6
C 19-Apr-01  CMM  Modified TOPO construction, hypervalency checks
C                 to include 12,16-e rules for d,f block elements
C                 and accomodate ghost atoms
C 28-Apr-94  JKB  Expanded to allow all elements
C  1-Feb-94  JKB  If hypervalent and no structures found, increment
C                     NPAIRS by 1 and check again (e.g. SF6)
C 31-Jan-94  JKB  Added check for hypervalency (octet but e-deficient)
C 30-Jan-94  JKB  Expanded to include all Group A elements through Xe
C 10-Jan-94  JKB  Added check of formal charge also against THR3
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXATM = 200)
      COMMON/NBSTR/ITOPO(MAXATM,MAXATM)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
C
      DIMENSION DM(NDIM,NDIM),WIBERG(NATOMS,NATOMS),
     +          NRES(MAXREF),IDXRES(MAXRES,MAXREF),LSTRES(LEN)
      PARAMETER(MAXBND = 12)
      DIMENSION IDX(MAXATM),JDX(MAXBND,MAXATM),KDX(MAXATM),
     +          LEFTBD(MAXATM),IZ(MAXATM),ICH(MAXATM,2)
      DIMENSION NOMBDS(118),NOMLPS(118),NPRIN(118),NVALPR(118)
C
      SAVE NOMBDS,NOMLPS,NPRIN,ZERO,ONE,ONEH,TWO,THR1,THR2,THR3,NPAIRS
C
C  CMM Data tables below modified to include d blocks 1/01
C      Hypothesized f-block data included below in comment lines.
C      Please do not use hypothesized data unless you are sure it works!
C
      DATA NOMBDS/1,                                0,
     +            1,2,                    3,4,3,2,1,0,
     +            1,2,                    3,4,3,2,1,0,
     +            1,2,3,4,5,6,5,4,3,2,1,0,3,4,3,2,1,0,
     +            1,2,3,4,5,6,5,4,3,2,1,0,3,4,3,2,1,0,
     +            1,2,                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,
     +                3,4,5,6,5,4,3,2,1,0,3,4,5,6,7,8,
     +            1,2,                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,
     +                3,4,5,6,5,4,3,2,1,0,3,4,5,6,7,8/
      DATA NOMLPS/0,                                1,
     +            0,0,                    0,0,1,2,3,4,
     +            0,0,                    0,0,1,2,3,4,
     +            0,0,0,0,0,0,1,2,3,4,5,6,0,0,1,2,3,4,
     +            0,0,0,0,0,0,1,2,3,4,5,6,0,0,1,2,3,4,
     +            0,0,                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,
     +                0,0,0,0,1,2,3,4,5,6,0,0,1,2,3,4,
     +            0,0,                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,
     +                0,0,0,0,1,2,3,4,5,6,3,4,5,6,7,8/
C  CMM NPRIN corrected for d,f block principal quantum numbers 1-30-01
      DATA  NPRIN/1,                                1,
     +            2,2,                    2,2,2,2,2,2,
     +            3,3,                    3,3,3,3,3,3,
     +            4,4,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,
     +            5,5,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,
     +            6,6,                    4,4,4,4,4,4,4,4,4,4,4,4,4,4,
     +                5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,
     +            7,7,                    5,5,5,5,5,5,5,5,5,5,5,5,5,5,
     +                6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7/
C  Below is the old NPRIN array.
C      DATA  NPRIN/1,                                1,
C     +            2,2,                    2,2,2,2,2,2,
C     +            3,3,                    3,3,3,3,3,3,
C     +            4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
C     +            5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
C     +            6,6,                    6,6,6,6,6,6,6,6,6,6,6,6,6,6,
C     +                6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
C     +            7,7,                    7,7,7,7,7,7,7,7,7,7,7,7,7,7,
C     +                7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7/
C  CMM NVALPR below is the number of valence electrons 1-17-01
      DATA  NVALPR/1,                                1,
     +            4,4,                    4,4,4,4,4,4,
     +            4,4,                    4,4,4,4,4,4,
     +            4,4,6,6,6,6,6,6,6,6,6,6,4,4,4,4,4,4,
     +            4,4,6,6,6,6,6,6,6,6,6,6,4,4,4,4,4,4,
     +            4,4,                    8,8,8,8,8,8,8,8,8,8,8,8,8,8,
     +                6,6,6,6,6,6,6,6,6,6,4,4,4,4,4,4,
     +            4,4,                    8,8,8,8,8,8,8,8,8,8,8,8,8,8,
     +                6,6,6,6,6,6,6,6,6,6,4,4,4,4,4,4/
      DATA ZERO,ONE,ONEH,TWO/0.0D0,1.0D0,1.5D0,2.0D0/
      DATA THR1,THR2,THR3/0.3D0,0.1D0,-0.3D0/
      NPAIRS = ABS(JPRINT(80))
C
C  Calculate molecular charge:
C
   10 ETA  = ONE
      IF(OPEN) ETA = ONE / TWO
      CHARGE = ZERO
      DO 15 IAT = 1,NATOMS
C
C  CMM Previously bypassed all d,f-block elements. Commented out 1-01
C        IF((IATNO(IAT).GT.20.AND.IATNO(IAT).LT.31).OR.
C     +     (IATNO(IAT).GT.38.AND.IATNO(IAT).LT.49).OR.
C     +     (IATNO(IAT).GT.56.AND.IATNO(IAT).LT.81).OR.
C     +     (IATNO(IAT).GT.88.AND.IATNO(IAT).LT.113)) THEN
C          WRITE(LFNPR,910)
C          RETURN
C        ENDIF
        CHARGE = CHARGE + ETA * DFLOAT(IZNUC(IAT))
   15 CONTINUE
      DO 20 IBAS = 1,NNAO
        CHARGE = CHARGE - DM(IBAS,IBAS)
   20 CONTINUE
      IF(OPEN) CHARGE = TWO * CHARGE
      ICHRG = NINT(CHARGE)
C
C  Initialize charges:
C
      IP = MAX(ICHRG,0) + NPAIRS
      CALL LEWDIS(ICH(1,1),IP,IATNO,NATOMS,IERR,1)
      IF(IERR.GT.0) GO TO 160
      IM = MAX(-ICHRG,0) + NPAIRS
      CALL LEWDIS(ICH(1,2),IM,IATNO,NATOMS,IERR,1)
      IF(IERR.GT.0) GO TO 160
C
C  Initialize arrays:
C
   25 CONTINUE
      DO 30 IA = 1,NATOMS
        IZ(IA)  = IATNO(IA)
        IDX(IA) = 0
        KDX(IA) = 0
   30 CONTINUE
C
C  Modify IZ array to reflect formal charges:
C
      DO 40 I = 1,IP
        IZ(ICH(I,1)) = IZ(ICH(I,1)) - 1
   40 CONTINUE
      DO 50 I = 1,IM
        IZ(ICH(I,2)) = IZ(ICH(I,2)) + 1
   50 CONTINUE
C
C  Do the Wiberg bond indices reflect these formal charges?  If not,
C  let's skip to the next one:
C
      DO 70 IA = 1,NATOMS
        ICNT = 0
        DO 60 JA = 1,NATOMS
          IF(WIBERG(IA,JA).LT.ONEH) THEN
            ICNT = ICNT + INT(WIBERG(IA,JA) + ONE - THR2)
          ELSE
            ICNT = ICNT + INT(WIBERG(IA,JA) + ONE - THR3)
          ENDIF
   60   CONTINUE
C  CMM Bypass ghost atoms
        IF(IZ(IA).EQ.0) GOTO 70
C
        IF(ICNT.LT.NOMBDS(IZ(IA))) GOTO 150
   70 CONTINUE
C
C  Initialize TOPO matrices:
C
      ICNT = 0
   80 CALL TOPZER(NATOMS)
      DO 90 IA = 1,NATOMS
C  CMM Below is a condition for zeroing out ghost atoms. 02/07/01
        IF (IZ(IA).EQ.0) THEN
          ITOPO(IA,IA) = 0
          LEFTBD(IA) = 0
          GOTO 90
        END IF
C
        LEFTBD(IA)   = NOMBDS(IZ(IA))
        ITOPO(IA,IA) = NOMLPS(IZ(IA))
C
C  CMM The IZ arrays will be used to determine numbers of bonds, lone
C      pairs available to each atom.  However, in the cases where formal
C      charge pushes an atom out of its original valence shell, special
C      conditions apply to correct for the apparent discontinuity.
C
        NZ = NPRIN(IZ(IA))
        NA = NPRIN(IATNO(IA))
C  CMM Changed following conditional to include d,f block. 1-17-01
C  CMM NVIZ and NVIA indicate main-group, d or f block and #valence pairs.
        NVIZ = NVALPR(IZ(IA))
        NVIA = NVALPR(IATNO(IA))
C  Is there an apparent discontinuity for the atom in consideration?
        IF(NZ.NE.NA) THEN
C  Is this atom a cation?
          IF(NZ.LT.NA) THEN
C  If the loss of electrons pushes us from the d-block back into the next
C  higher quantum number s-block, no discontinuity is implied.
            IF(IZ(IA).LT.IATNO(IA)) THEN
C  CMM If we are pushed from the p-block to the previous shell d-block,
C      we skip over instead into the s-block in the SAME shell as the p.
              IF(NVIZ.EQ.6) THEN
                LEFTBD(IA)= NOMBDS(IZ(IA)-10)
                ITOPO(IA,IA) = NOMLPS(IZ(IA)-10)
C  CMM Below would be my guess for falling into the f-block.
C             ELSE IF(NVIZ.EQ.8) THEN
C               LEFTBD(IA)= NOMBDS(IZ(IA)-14)
C               ITOPO(IA,IA) = NOMLPS(IZ(IA)-14)
C  Below are the original corrections for pushing into an s-block or a
C  p-block of the previous quantum number, from the s-block.
              ELSE IF(NZ.EQ.1) THEN
                ITOPO(IA,IA) = ITOPO(IA,IA) - 1
              ELSE IF(NZ.GT.1) THEN
                ITOPO(IA,IA) = ITOPO(IA,IA) - 4
              END IF
            END IF
C  What if this atom is an anion?
          ELSE
C  If we went from an s-block to the previous shell d-block, no problem.
            IF(IZ(IA).GT.IATNO(IA)) THEN
C  Otherwise, we want to restore the lone pairs from the original shell.
            ITOPO(IA,IA) = ITOPO(IA,IA) + NVIA
C  And if we started with d-block, correct the number of bonds.
            IF(NVIA.EQ.6) THEN
              LEFTBD(IA)=LEFTBD(IA)-2
C  CMM Below would be my guess for a bond correction for the f-block.
C           ELSE IF(NVIA.EQ.8) THEN
C             LEFTBD(IA)=LEFTBD(IA)-2
            END IF
          END IF
        END IF
C  CMM Below is the original code for the previous section.
C       IF(NZ.NE.NA) THEN
C         IF(NZ.LT.NA) THEN
C           IF(NZ.EQ.1) THEN
C             ITOPO(IA,IA) = ITOPO(IA,IA) - 1
C           ELSE IF(NZ.GT.1) THEN
C             ITOPO(IA,IA) = ITOPO(IA,IA) - 4
C           END IF
C         ELSE
C           IF(NZ.EQ.2) THEN
C             ITOPO(IA,IA) = ITOPO(IA,IA) + 1
C           ELSE IF(NZ.GT.2) THEN
C             ITOPO(IA,IA) = ITOPO(IA,IA) + 4
C           END IF
C         END IF
          IF(ITOPO(IA,IA).LT.0) GOTO 150
        END IF
C  CMM Below is a condition for zeroing out ghost atoms. 02/07/01
        IF (IZ(IA).EQ.0) THEN
          ITOPO(IA,IA) = 0
          LEFTBD(IA) = 0
        END IF
   90 CONTINUE
C
C  Loop over atoms:
C
      DO 100 IA = 1,NATOMS
C
C  Choose the next atom (JA) in the search:
C
        CALL LEWATM(IA,JA,KDX,LEFTBD,ICNT,NATOMS)
C
C  Select a set of bonds (in JDX(MAXBND,JA)) to adjacent atoms (if there
C  are problems doing so, set the alarm IALARM):
C
        CALL LEWBDS(IA,JA,IDX,JDX,WIBERG,LEFTBD,NATOMS,
     +              THR1,THR2,THR3,IALARM)
        IF(IALARM.NE.0) GOTO 130
C
C  Add these bonds to the TOPO matrix.  Also modify the LEFTBD and
C  KDX arrays:
C
        CALL LEWTOP(JA,JDX,KDX,LEFTBD,ICNT,NATOMS)
  100 CONTINUE
C
C  Check for TOPO matrix for possible hypervalency:
C
      IF(JPRINT(77).EQ.0) THEN
        IHAT = 0
        IHCHG = 0
        ISUMCHG = 0
        DO 110 IA=1,NATOMS
          IHOCT = 0
          IHMUL = 0
          IHVAL = 2*ITOPO(IA,IA)
          DO 120 JA=1,NATOMS
            IHOCT = IHOCT + 2*ITOPO(IA,JA)
            IF(JA.EQ.IA) GO TO 120
            IF(ITOPO(IA,JA).GT.1) IHMUL = IHMUL + (ITOPO(IA,JA) - 1)
            IHVAL = IHVAL + ITOPO(IA,JA)
  120     CONTINUE
C  CMM Bypass for ghost atoms
          IF(IATNO(IA).EQ.0) GOTO 110
C
          INVAL = 2*NOMLPS(IATNO(IA))+NOMBDS(IATNO(IA))
          ISUMCHG = ISUMCHG + IHVAL - INVAL
C
C  Condition for possible hypervalency on an atom:  More than octet of
C     electrons [OR] all of the following: (1) 3rd row or higher,
C     (2) octet rule obeyed, (3) no multiple bonds, and (4) still net
C     (+) formal charge not accounted for by overall molecular charge.
C
C          IF((IHOCT.GT.8).OR.(IATNO(IA).GT.10.AND.
C     +        IHOCT.EQ.8.AND.IHMUL.EQ.0.AND.IHVAL.LT.INVAL)) THEN
C
C  CMM Modified to supersede the octet rule for d,f-block. 1-22-01
C  CMM Here the d-block duodectet rule or corresponding rule for f-block
C      would be treated as the octect rule in the main group.  However,
C      this may not be correspondingly useful as such "hypervalency" is
C      more stable in the transition metals.  2/06/01
          NX = 2*NVALPR(IATNO(IA))
          IF((IHOCT.GT.NX).OR.(IATNO(IA).GT.10.AND.
     +        IHOCT.EQ.NX.AND.IHMUL.EQ.0.AND.IHVAL.LT.INVAL)) THEN
C
            IHAT = IA
            IHCHG = IHVAL - INVAL
          END IF
  110   CONTINUE
        IF(IHAT.NE.0) THEN
          IHCHG = IHCHG - ISUMCHG
          IF(IHCHG.LT.0) THEN
            WRITE(LFNPR,920) IHAT
            IVALSP = 4
            RETURN
          END IF
        END IF
      END IF
C
C  Add this resonance structure to the list:
C
      IRES = NRES(1) + 1
      CALL TOPSTR(IRES,IDXRES,MAXRES,1,MAXREF,LSTRES,LEN)
      CALL TOPCMP(IDUP,IRES,IDXRES,MAXRES,1,MAXREF,LSTRES,LEN)
      IF(IDUP.EQ.0) THEN
        NRES(1) = NRES(1) + 1
        IF(JPRINT(57).NE.0) THEN
          WRITE(LFNPR,900) NRES(1),IDXRES(NRES(1),1)
          CALL TOPOUT
          WRITE(LFNPR,*)
        END IF
      END IF
C
C  Should we continue searching for structures:
C
  130 CONTINUE
      DO 140 IA = NATOMS,1,-1
        IF(IDX(IA).GT.0) THEN
          ICNT = IA
          GOTO 80
        ELSE IF(IDX(IA).LE.0) THEN
          IDX(IA) = 0
          KDX(IA) = 0
        END IF
  140 CONTINUE
  150 CONTINUE
C
C  Redistribute the formal charges and repeat search:
C
      CALL LEWDIS(ICH(1,1),IP,IATNO,NATOMS,IERR,0)
      IF(IERR.NE.0) THEN
        CALL LEWDIS(ICH(1,2),IM,IATNO,NATOMS,IERR,0)
        IF(IERR.NE.0) GO TO 160
        CALL LEWDIS(ICH(1,1),IP,IATNO,NATOMS,IERR,1)
      END IF
      GOTO 25
C
C  Allow checking of NPAIRS = 2 structures during second pass on
C     hypervalent cases if none found with NPAIRS = 1:
C
  160 IF(NPAIRS.LT.2.AND.NRES(1).EQ.0.AND.
     +   JPRINT(77).EQ.1.AND.IVALSP.EQ.-1) THEN
        IVALSP = 0
        NPAIRS = NPAIRS + 1
        GO TO 10
      ELSE
        RETURN
      END IF
C
  900 FORMAT(/1X,'Candidate structure from LEWIS:',I5,' [',I6,']')
  920 FORMAT(1X,'LEWIS:  Possible hypervalency for atom',I3,'; restart',
     +   ' with full density matrix')
      END
C***********************************************************************
      SUBROUTINE LEWATM(IAT,JAT,KDX,LEFTBD,ICNT,NATOMS)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION KDX(NATOMS),LEFTBD(NATOMS)
C
C  Choose the next atom to be examined:
C
      IF(KDX(IAT).EQ.0) THEN
        LAT = 0
        IMIN = 10
        DO 10 KAT = 1,NATOMS
          IF(LEFTBD(KAT).LT.IMIN.AND.LEFTBD(KAT).GT.0) THEN
            LAT  = KAT
            IMIN = LEFTBD(KAT)
          END IF
   10   CONTINUE
        IF(LAT.EQ.0) THEN
          DO 30 KAT = 1,NATOMS
            DO 20 KAT1 = 1,NATOMS
              IF(KAT.EQ.KDX(KAT1)) GOTO 30
C              IF(KDX(KAT).EQ.KDX(KAT1)) GOTO 30
   20       CONTINUE
            LAT = KAT
            GOTO 40
   30     CONTINUE
   40     CONTINUE
        END IF
        KDX(IAT) = LAT
        JAT      = LAT
        ICNT     = ICNT + 1
      ELSE
        JAT = KDX(IAT)
      END IF
      RETURN
      END
C***********************************************************************
      SUBROUTINE LEWBDS(IAT,JAT,IDX,JDX,WIBERG,LEFTBD,NATOMS,
     +                  THR1,THR2,THR3,IALARM)
C***********************************************************************
C 21-Jun-01  FAW  Added MAXBND [12] for maximum coordination > 6
C  7-Jan-94  JKB  Added check for triple bonds using parameter THR3
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXATM = 200)
      PARAMETER(MAXBND = 12)
      DIMENSION IDX(NATOMS),JDX(MAXBND,NATOMS),WIBERG(NATOMS,NATOMS),
     +          LEFTBD(NATOMS)
      DIMENSION MAYBND(MAXBND,MAXATM),NMAYBD(MAXATM),ITMP(MAXBND)
C
      SAVE MAYBND,NMAYBD,ONE
      DATA ONE/1.0D0/ONEH/1.5D0/
C
C  Should we use the list from a previous search on this atom:
C
      IF(IAT.NE.NATOMS.AND.IDX(IAT+1).NE.0) THEN
        IALARM = 0
        RETURN
      END IF
C
C  If there are no bonds left to this atom, move on:
C
      IF(LEFTBD(JAT).EQ.0) THEN
        DO 5 NBD = 1,MAXBND
          JDX(NBD,JAT) = 0
    5   CONTINUE
        IDX(IAT) = -1
        IALARM = 0
        RETURN
      END IF
C
C  Should the indices for this atom be initialized:
C
      IALARM = 1
      IF(IDX(IAT).EQ.0) THEN
        NMAYBD(JAT) = 0
        DO 20 KAT = 1,NATOMS
          IF(LEFTBD(KAT).NE.0.AND.JAT.NE.KAT) THEN
            IF(WIBERG(JAT,KAT).LT.ONE) THEN
              NBONDS = INT(WIBERG(JAT,KAT) + ONE - THR1)
            ELSE IF(WIBERG(JAT,KAT).LT.ONEH) THEN
              NBONDS = INT(WIBERG(JAT,KAT) + ONE - THR2)
            ELSE
              NBONDS = INT(WIBERG(JAT,KAT) + ONE - THR3)
            END IF
            DO 10 NBD = 1,MIN(NBONDS,LEFTBD(KAT))
              NMAYBD(JAT) = NMAYBD(JAT) + 1
              MAYBND(NMAYBD(JAT),JAT) = KAT
   10       CONTINUE
          END IF
   20   CONTINUE
        IF(NMAYBD(JAT).LT.LEFTBD(JAT)) THEN
          IDX(IAT) = -1
          RETURN
        END IF
C
        DO 30 NBD = 1,LEFTBD(JAT)
          JDX(NBD,JAT) = MAYBND(NBD,JAT)
   30   CONTINUE
        DO 40 NBD = LEFTBD(JAT)+1,MAXBND
          JDX(NBD,JAT) = 0
   40   CONTINUE
        IF(NMAYBD(JAT).EQ.LEFTBD(JAT)) THEN
          IDX(IAT) = -1
        ELSE
          IDX(IAT) = 1
        END IF
C
C  Update the indices for this atom:
C
      ELSE
        DO 50 NBD = 1,LEFTBD(JAT)
          ITMP(NBD) = JDX(NBD,JAT)
   50   CONTINUE
        JCNT = LEFTBD(JAT)
        DO 60 NBD = NMAYBD(JAT),1,-1
          IF(MAYBND(NBD,JAT).EQ.ITMP(JCNT)) THEN
            ITMP(JCNT) = NBD
            JCNT = JCNT - 1
          END IF
          IF(JCNT.EQ.0) GOTO 70
   60   CONTINUE
   70   CONTINUE
        DO 80 NBD = LEFTBD(JAT),1,-1
          IF(ITMP(NBD).LT.NMAYBD(JAT)) THEN
            IF(NBD.EQ.LEFTBD(JAT)) THEN
              ITMP(NBD) = ITMP(NBD) + 1
              MBD = NBD
              GOTO 90
            ELSE IF(ITMP(NBD)+1.LT.ITMP(NBD+1)) THEN
              ITMP(NBD) = ITMP(NBD) + 1
              MBD = NBD
              GOTO 90
            END IF
          END IF
   80   CONTINUE
        IDX(IAT) = -1
        RETURN
C
   90   CONTINUE
        DO 100 NBD = MBD+1,LEFTBD(JAT)
          ITMP(NBD) = ITMP(NBD-1) + 1
  100   CONTINUE
        DO 110 NBD = 1,LEFTBD(JAT)
          JDX(NBD,JAT) = MAYBND(ITMP(NBD),JAT)
  110   CONTINUE
        IDX(IAT) = 1
      END IF
      IALARM = 0
      RETURN
      END
C***********************************************************************
      SUBROUTINE LEWDIS(ICH,N,IATNO,NATOMS,IERR,INIT)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION ICH(NATOMS),IATNO(NATOMS)
C
C  Distribute N point charges over NATOMS centers:
C
      IERR = 0
C
C  Initialize ICH array
C
      IF(INIT.EQ.1) THEN
        DO 10 I = 1,NATOMS
          IF(I.LE.N) THEN
            ICH(I) = 1
          ELSE
            ICH(I) = 0
          END IF
   10   CONTINUE
        GOTO 50
      END IF
C
C  Increment the ICH array:
C
   20 IA = N
      IF(IA.LT.1) THEN
        IERR = -1
        RETURN
      END IF
   30 ICH(IA) = ICH(IA) + 1
      IF(ICH(IA).GT.NATOMS) THEN
        IA = IA - 1
        IF(IA.LT.1) THEN
          IERR = 1
          RETURN
        END IF
        GOTO 30
      END IF
      DO 40 I = IA+1,N
        ICH(I) = ICH(IA)
   40 CONTINUE
C
C  Is this satisfactory?
C
   50 DO 60 I = 1,N
        IF(IATNO(ICH(I)).LT.3) GOTO 20
   60 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE LEWTOP(JAT,JDX,KDX,LEFTBD,ICNT,NATOMS)
C***********************************************************************
C 21-Jun-01  FAW  Added MAXBND [12] for maximum coordination > 6
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXATM = 200)
      COMMON/NBSTR/ITOPO(MAXATM,MAXATM)
C
      PARAMETER(MAXBND = 12)
      DIMENSION JDX(MAXBND,NATOMS),KDX(NATOMS),LEFTBD(NATOMS)
C
      NEND = LEFTBD(JAT)
      DO 20 NBD = 1,NEND
        KAT = JDX(NBD,JAT)
        ITOPO(JAT,KAT) = ITOPO(JAT,KAT) + 1
        ITOPO(KAT,JAT) = ITOPO(JAT,KAT)
        LEFTBD(JAT) = LEFTBD(JAT) - 1
        LEFTBD(KAT) = LEFTBD(KAT) - 1
        DO 10 I = 1,ICNT
          IF(KDX(I).EQ.KAT) GOTO 20
   10   CONTINUE
        ICNT = ICNT + 1
        KDX(ICNT) = KAT
   20 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE NBORES(NRES,IDXRES,MAXRES,MAXREF,LSTRES,LEN,ISCR,
     +                  IVALSP)
C***********************************************************************
C 27-Oct-01  CMM  Don't reset IVALSP if exiting with ionic NBO structure
C 09-Aug-01  CMM  Corrected to accomodate ghost atoms
C 28-Apr-94  JKB  Expanded to allow all elements
C 31-Jan-94  JKB  Added check for hypervalency
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBSTR/ITOPO(MAXATM,MAXATM)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
C
      DIMENSION NRES(MAXREF),IDXRES(MAXRES,MAXREF),LSTRES(LEN),
     +          ISCR(10*NDIM)
      DIMENSION NOMBDS(118),NOMLPS(118)
C
      SAVE LSTAR,LCR
      SAVE NOMBDS,NOMLPS
      DATA LSTAR,LCR/1H*,2HCR/
      DATA NOMBDS/1,                                0,
     +            1,2,                    3,4,3,2,1,0,
     +            1,2,                    3,4,3,2,1,0,
     +            1,2,0,0,0,0,0,0,0,0,0,0,3,4,3,2,1,0,
     +            1,2,0,0,0,0,0,0,0,0,0,0,3,4,3,2,1,0,
     +            1,2,                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,
     +                0,0,0,0,0,0,0,0,0,0,3,4,3,2,1,0,
     +            1,2,                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,
     +                0,0,0,0,0,0,0,0,0,0,3,4,3,2,1,0/
      DATA NOMLPS/0,                                1,
     +            0,0,                    0,0,1,2,3,4,
     +            0,0,                    0,0,1,2,3,4,
     +            0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,
     +            0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,
     +            0,0,                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,
     +                0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,
     +            0,0,                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,
     +                0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4/
C
      IF(IVALSP.NE.3) IVALSP = 0
C
C  Retrieve NBO labels from DAF:
C
      CALL FENBLB(ISCR)
C
C  Construct a resonance structure from the LABEL array (i.e. take
C  the resonance structure found in the regular NBO analysis):
C
      CALL TOPZER(NATOMS)
      DO 10 IBAS = 1,NNAO
        IB = IBXM(IBAS)
        IF(LABEL(IB,2).NE.LSTAR.AND.LABEL(IB,1).NE.LCR) THEN
          II = LABEL(IB,4)
          JJ = LABEL(IB,5)
          IF(JJ.EQ.0) JJ = II
          ITOPO(II,JJ) = ITOPO(II,JJ) + 1
          ITOPO(JJ,II) = ITOPO(II,JJ)
        END IF
   10 CONTINUE
C
C  Check TOPO matrix for possible hypervalency (skip for
C      transition metal complexes):
C
      ITRANS = 0
      DO 20 IAT = 1,NATOMS
        IF((IATNO(IAT).GT.20.AND.IATNO(IAT).LT.31).OR.
     +     (IATNO(IAT).GT.38.AND.IATNO(IAT).LT.49).OR.
     +     (IATNO(IAT).GT.56.AND.IATNO(IAT).LT.81).OR.
     +     (IATNO(IAT).GT.88.AND.IATNO(IAT).LT.113)) ITRANS = 1
   20 CONTINUE
C
C  Check TOPO matrix for possible hypervalency:
C
      IF(JPRINT(77).EQ.0.AND.ITRANS.EQ.0) THEN
        IHAT = 0
        IHCHG = 0
        ISUMCHG = 0
        DO 110 IA=1,NATOMS
C  CMM Bypass ghost atoms
          IF(IATNO(IA).EQ.0) GOTO 110
C
          IHOCT = 0
          IHMUL = 0
          IHVAL = 2*ITOPO(IA,IA)
          DO 120 JA=1,NATOMS
            IHOCT = IHOCT + 2*ITOPO(IA,JA)
            IF(JA.EQ.IA) GO TO 120
            IF(ITOPO(IA,JA).GT.1) IHMUL = IHMUL + (ITOPO(IA,JA) - 1)
            IHVAL = IHVAL + ITOPO(IA,JA)
  120     CONTINUE
          INVAL = 2*NOMLPS(IATNO(IA))+NOMBDS(IATNO(IA))
          ISUMCHG = ISUMCHG + IHVAL - INVAL
C
C  Condition for possible hypervalency on an atom:  More than octet of
C     electrons [OR] all of the following: (1) 3rd row or higher,
C     (2) octet rule obeyed, (3) no multiple bonds, and (4) still net
C     (+) formal charge not accounted for by overall molecular charge.
C
          IF(IHOCT.GT.8) THEN
            IHAT = -IA
            WRITE(LFNPR,920)
            IVALSP = 4
            RETURN
          ELSE IF(IATNO(IA).GT.10.AND.
     +       IHOCT.EQ.8.AND.IHMUL.EQ.0.AND.IHVAL.LT.INVAL) THEN
            IHAT = IA
            IHCHG = IHVAL - INVAL
          ENDIF
  110   CONTINUE
        IF(IHAT.NE.0) THEN
          IHCHG = IHCHG - ISUMCHG
          IF(IHCHG.LT.0) THEN
            WRITE(LFNPR,930) IHAT
            IVALSP = 4
            RETURN
          END IF
        END IF
      END IF
C
C  Store this resonance structure in the list LSTRES:
C
      IRES = NRES(1) + 1
      CALL TOPSTR(IRES,IDXRES,MAXRES,1,MAXREF,LSTRES,LEN)
      CALL TOPCMP(IDUP,IRES,IDXRES,MAXRES,1,MAXREF,LSTRES,LEN)
C-----------------------------------------------------------------------
C  JNote: If there is only one structure (IREF=1,IRES=1), TOPCMP is
C         comparing it with a structure at position 2 in the array and
C         returning IDUP=1.  The fix below allows the structure to be
C         added to the list, but need to check why this occurs.
C-----------------------------------------------------------------------
C JKB  IF(IDUP.EQ.0) NRES(1) = NRES(1) + 1
      IF(IDUP.EQ.0.OR.NRES(1).EQ.0) NRES(1) = NRES(1) + 1
      IF(JPRINT(57).NE.0) THEN
        WRITE(LFNPR,900) NRES(1),IDXRES(NRES(1),1)
        CALL TOPOUT
        WRITE(LFNPR,*)
      END IF
      RETURN
  900 FORMAT(/1X,'Candidate structure from NBORES:',I5,' [',I6,']')
  920 FORMAT(1X,'NBORES: Hypervalency detected for atom',I3,'; restart',
     +   ' with full density matrix')
  930 FORMAT(1X,'NBORES: Possible hypervalency for atom',I3,'; restart',
     +   ' with full density matrix')
      END
C***********************************************************************
      SUBROUTINE KEKULE(ILIST,IDXRES,IRESET,MAXRES,NREF,MAXREF,LSTRES,
     +                  LEN)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXATM = 200)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBSTR/ITOPO(MAXATM,MAXATM)
      COMMON/NBTOPO/IORDER(MAXATM),JORDER(MAXATM),NTOPO(MAXATM,MAXATM),
     +            N3CTR,I3CTR(10,3)
C
      DIMENSION ILIST(MAXRES),IDXRES(MAXRES,MAXREF),LSTRES(LEN),
     +          IRESET(NREF)
C
C  Find resonance structures that are simply related by concerted
C  bond shifts (as in the two Kekule structures of benzene):
C
      IPOS = 0
      DO 110 IREF = 1,NREF
        IF(IRESET(IREF).LT.0) GOTO 110
        IPOS = IPOS + 1
        ILIST(IPOS) = IDXRES(1,IREF)
        IPOS = IPOS + 1
        IHLD = IPOS
        ILIST(IHLD) = 0
C
C  Get the IREF topo matrix and temporarily store it in NTOPO:
C
        CALL TOPGET(1,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
        DO 20 JAT = 1,NATOMS
          DO 10 IAT = 1,NATOMS
            NTOPO(IAT,JAT) = ITOPO(IAT,JAT)
   10     CONTINUE
   20   CONTINUE
C
C  Loop over pairs of structures:
C
        DO 100 JREF = 1,NREF
          IF(IRESET(JREF).LT.0) GOTO 100
          IF(IREF.NE.JREF) THEN
C
C  Get the JREF topo matrix and determine the difference between it
C  and the NTOPO matrix:
C
            CALL TOPGET(1,IDXRES,MAXRES,JREF,NREF,LSTRES,LEN)
            DO 40 JAT = 1,NATOMS
              DO 30 IAT = 1,NATOMS
                ITOPO(IAT,JAT) = ITOPO(IAT,JAT) - NTOPO(IAT,JAT)
   30         CONTINUE
   40       CONTINUE
C
C  The following characteristics of the `difference topo matrix' should
C  be sufficient to determine whether IREF and JREF are related by bond
C  shifts, or not:
C
C  All diagonal elements should be zero:
C
            DO 50 IAT = 1,NATOMS
              IF(ITOPO(IAT,IAT).NE.0) GOTO 100
   50       CONTINUE
C
C  Columns should sum to zero:
C
            DO 70 JAT = 1,NATOMS
              ISUM = 0
              DO 60 IAT = 1,NATOMS
                ISUM = ISUM + ITOPO(IAT,JAT)
   60         CONTINUE
              IF(ISUM.NE.0) GOTO 100
   70       CONTINUE
C
C  Two or more bonds should be formed:
C
            IBD = 0
            DO 90 JAT = 1,NATOMS-1
              DO 80 IAT = JAT+1,NATOMS
                IF(ITOPO(IAT,JAT).EQ.1) IBD = IBD + 1
   80         CONTINUE
   90       CONTINUE
            IF(IBD.LT.2) GOTO 100
C
C  So, we have a pair:
C
            ILIST(IHLD) = ILIST(IHLD) + 1
            IPOS = IPOS + 1
            ILIST(IPOS) = IDXRES(1,JREF)
          END IF
  100   CONTINUE
  110 CONTINUE
      IPOS = IPOS + 1
      ILIST(IPOS) = -1
      RETURN
      END
C***********************************************************************
      SUBROUTINE PARENT(IREF,RHOST,RHOT,DM,T,WIBERG,BNDOCC,POL,Q,V,BLK,
     +                  C,EVAL,BORB,P,TA,HYB,VA,VB,TOPO,SCR,IDON,IACC,
     +                  IDXRES,KPAR,MAXRES,MAXREF,IBDRES,ISRCH,NRTCTL)
C***********************************************************************
C  2-Jun-98  EDG  Add several additional error messages
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL BRANCH
C
C  NBO COMMON blocks:
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBTOPO/IORDER(MAXATM),JORDER(MAXATM),NTOPO(MAXATM,MAXATM),
     +            N3CTR,I3CTR(10,3)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION DM(NDIM,NDIM),T(NDIM,NDIM),WIBERG(NATOMS,NATOMS),
     + BNDOCC(NDIM),POL(NDIM,3),Q(MXAO,NDIM),V(NDIM),BLK(MXBO,MXBO),
     + C(MXBO,MXBO),EVAL(MXBO),BORB(MXBO),P(MXAO,MXAO),TA(MXAO,MXAO),
     + HYB(MXAO),VA(MXAO),VB(MXAO),TOPO(NATOMS,NATOMS),SCR(NDIM),
     + IDON(MAXRES,MAXREF),IACC(MAXRES,MAXREF),IDXRES(MAXRES,MAXREF),
     + KPAR(MAXRES,MAXREF),NRTCTL(10)
C
      SAVE ZERO,ONE,LSTAR
      DATA ZERO,ONE/0.0D0,1.0D0/
      DATA LSTAR/1H*/
C
C  Initialize search for reference structure IREF.  Note that a copy
C  of the TOPO matrix should be in both ITOPO and NTOPO by now (see
C  SR ATMORD):
C
      N3CTR = 0
      IFLG = 1
      IF(JPRINT(57).NE.0) IFLG = 0
      CALL FEDNAO(DM)
      IF(ISRCH.EQ.0) IDX = IDXRES(IREF,1)
      IF(ISRCH.EQ.1) IDX = IDXRES(1,IREF)
      IF(JPRINT(57).NE.0) THEN
        WRITE(LFNPR,900) IREF,IDX
        CALL TOPOUT
      END IF
C
C  Has this reference structure appeared previously in a secondary list?
C
      KDON = 0
      IF(ISRCH.EQ.1) THEN
        KREF = KPAR(1,IREF) / 10000
        KRES = MOD(KPAR(1,IREF),10000)
        IF(KRES.NE.0.AND.KREF.NE.0) THEN
          KDON = IDON(KRES,KREF)
          KACC = IACC(KRES,KREF)
        END IF
      END IF
C
C  If yes, use SHREWD (unless symmetry problems have been encountered):
C
      IF(KDON.GT.0.AND.NRTCTL(2).EQ.0) THEN
        CALL SHREWD(DM,T,BNDOCC,POL,Q,V,BLK,C,EVAL,BORB,P,TA,HYB,
     +              VA,VB,KREF,KDON,KACC,IFLG)
C
C  Otherwise, use NBCHSE:
C
      ELSE
        BRANCH = .TRUE.
        CALL NBCHSE(DM,T,WIBERG,BNDOCC,POL,Q,V,BLK,C,EVAL,BORB,P,TA,
     +              HYB,VA,VB,TOPO,IFLG,BRANCH)
      END IF
C
C  If problems were encountered while searching for this resonance
C  structure, mark it as bad:
C
      IF(IFLG.LT.0) THEN
        RHOST  = -ONE
        IBDRES = 1
        IF(JPRINT(57).NE.0) WRITE(LFNPR,920)
        RETURN
      ELSE
        IBDRES = 0
      END IF
C
C  Sort the NBOs:
C
      CALL SRTNBO(T,BNDOCC)
C
C  Transform the density matrix to the NBO basis:
C
      CALL SIMTRS(DM,T,SCR,NDIM,NNAO)
C
C  Compute rho* for this structure and make sure the resonance structure
C  accounts for all electrons:
C
      TOT   = ZERO
      RHOST = ZERO
      DO 10 I = 1,NNAO
        BNDOCC(I) = ABS(DM(I,I))
        TOT = TOT + BNDOCC(I)
        IF(LABEL(IBXM(I),2).EQ.LSTAR) THEN
          RHOST = RHOST + BNDOCC(I)
        END IF
   10 CONTINUE
C
C  Delete structures with high rho*:
C
      IF(RHOST.GT.RHOT) THEN
        IF(JPRINT(57).NE.0) WRITE(LFNPR,930) IREF,RHOST,RHOT
        RHOST  = -ONE
        IBDRES = 1
        RETURN
      END IF
C
      IF(JPRINT(57).NE.0) WRITE(LFNPR,910) IREF,RHOST
      RETURN
C
  900 FORMAT(/1X,'Reference resonance structure:',I5,' [',I6,']')
  910 FORMAT(/1X,'Rho*(   1,',I3,') = ',F10.5,/)
  920 FORMAT(/1X,'Unable to find reasonable reference resonance ',
     + 'structure',/)
  930 FORMAT(/1X,'Rho*(   1,',I3,') = ',F10.5,' is greater than ',
     + 'threshold (',F10.5,')',/)
      END
C***********************************************************************
      SUBROUTINE SHREWD(DM,T,BNDOCC,POL,Q,V,BLK,C,EVAL,BORB,P,TA,HYB,
     +                  VA,VB,IREF,IDON,IACC,IFLG)
C***********************************************************************
C 30-Jun-94  JKB  Added secondary threshold of occupancy -0.01/2.01e and
C                    total electrons +/-0.5e to allow for MP2, CI DM
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  `Shrewd' version of NBCHSE that searches for the NBOs of a particular
C  (target) Lewis structure given the NBOs of a related (parent) structure
C  and the single delocalizing interaction that relates the two.
C
C  Input:
C    DM    -- Density matrix in the NAO basis
C    IREF  -- Index of the parent structure
C    IDON  -- Donor orbital in the parent structure
C    IACC  -- Acceptor orbital in the parent structure
C    NTOPO -- TOPO matrix for the target structure (COMMON/NBTOPO/)
C
C  Output:
C    T     -- AO-NBO transformation for the target structure
C    IFLG  -- Set to -1 if target structure not found
C
      LOGICAL DETAIL,PRINT
      INTEGER UL
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       UL(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBNAO/NAOC(MAXBAS),NAOA(MAXBAS),LTYP(MAXBAS),IPRIN(MAXBAS)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBTHR/THRSET,PRJSET,ACCTHR,CRTSET,E2THR,ATHR,PTHR,ETHR,
     +             DTHR,DLTHR,CHSTHR,REFTHR,STTHR,PRTHR,THRNCS,THRNJC
      COMMON/NBTOPO/IORDER(MAXATM),JORDER(MAXATM),NTOPO(MAXATM,MAXATM),
     +            N3CTR,I3CTR(10,3)
      COMMON/IOCWAR/IOCWAR
C
      DIMENSION DM(NDIM,NDIM),T(NDIM,NDIM),BNDOCC(NDIM),POL(NDIM,3),
     +          Q(MXAO,NDIM),V(NDIM),BLK(MXBO,MXBO),C(MXBO,MXBO),
     +          EVAL(MXBO),BORB(MXBO),P(MXAO,MXAO),TA(MXAO,MXAO),
     +          HYB(MXAO),VA(MXAO),VB(MXAO)
      DIMENSION HYBEXP(3),KTOPO(MAXATM,MAXATM),LBL(MAXBAS,6),IBX(MAXBAS)
C
      SAVE ZERO,ZEROP,TENTH,TWO,TWOP,TOTP
      SAVE ZEROX,TWOX,TOTX
      SAVE ISTAR,IBLNK,LLP,LBD,LRY,LCR,IHCOR,IHVAL
      DATA ZERO,ZEROP,TENTH,TWO,TWOP,TOTP/0.0D0,1.0D-5,0.1D0,2.0D0,
     +     2.0001D0,5.0D-4/
      DATA ZEROX,TWOX,TOTX/1.D-1,2.1D0,5.0D-1/
      DATA ISTAR,IBLNK,LLP,LBD,LRY,LCR/1H*,1H ,2HLP,2HBD,2HRY,2HCR/
      DATA IHCOR,IHVAL/3HCor,3HVal/
C
      NOPVAL(I) = NORBS(I) - INO(I)
C
      DETAIL = .FALSE.
      IF(IWDETL.NE.0) DETAIL = .TRUE.
      PRINT = .FALSE.
      IF(IFLG.EQ.0) PRINT = .TRUE.
      IF(JPRINT(5).EQ.0) PRINT = .FALSE.
      IF(DETAIL) PRINT = .TRUE.
      PRJTHR = ABS(PRJSET)
      OCCTHR = TENTH
      IF(ISPIN.NE.0) OCCTHR = OCCTHR / 2
C
C  Zero arrays Q, POL, IATHY, INO, LABEL:
C
      DO 50 I = 1,NNAO
        DO 10 K = 1,2
          LABEL(I,K) = IBLNK
   10   CONTINUE
        DO 20 K = 3,6
          LABEL(I,K) = 0
   20   CONTINUE
        DO 30 K = 1,3
          POL(I,K) = ZERO
          IATHY(I,K) = 0
   30   CONTINUE
        DO 40 K = 1,MXAO
          Q(K,I) = ZERO
   40   CONTINUE
   50 CONTINUE
      DO 60 I = 1,NATOMS
        INO(I) = 0
   60 CONTINUE
C
C  Get the NBOs and labels for the parent structure from the DAF.
C  Transform DM to the NBO basis:
C
      CALL FETREF(T,LBL,IBX,IREF)
      CALL SIMTRS(DM,T,V,NDIM,NNAO)
C
C  Copy NTOPO to KTOPO:
C
      DO 80 I = 1,NATOMS
        DO 70 J = 1,NATOMS
          KTOPO(I,J) = NTOPO(I,J)
   70   CONTINUE
   80 CONTINUE
C
C  If the acceptor function is an antibond, find the corresponding bond:
C
      IACPT = IACC
      IF(LBL(IBX(IACC),1).EQ.LBD) THEN
        ISER = LBL(IBX(IACC),3)
        IAT1 = LBL(IBX(IACC),4)
        IAT2 = LBL(IBX(IACC),5)
        IAT3 = LBL(IBX(IACC),6)
        DO 100 IBAS = 1,NNAO
          IB = IBX(IBAS)
          IF(LBL(IB,1).EQ.LBD) THEN
            IF(LBL(IB,2).NE.ISTAR) THEN
              IF(LBL(IB,3).EQ.ISER) THEN
                IF(LBL(IB,4).EQ.IAT1) THEN
                  IF(LBL(IB,5).EQ.IAT2) THEN
                    IF(LBL(IB,6).EQ.IAT3) THEN
                      IACPT = IBAS
                      GOTO 110
                    END IF
                  END IF
                END IF
              END IF
            END IF
          END IF
  100   CONTINUE
        CALL NBHALT('SHREWD cannot find corresponding bond.')
      END IF
  110 CONTINUE
      IF(LBL(IBX(IDON),2).EQ.ISTAR) CALL NBHALT('Unoccupied donor?')
      IF(LBL(IBX(IACC),2).NE.ISTAR) CALL NBHALT('Occupied acceptor?')
C
C  Stash the set of orbitals common to both parent and target structures:
C
C  Core orbitals...
C
      IBD  = 0
      IAT2 = 0
      IAT3 = 0
      DO 140 IAT1 = 1,NATOMS
        IACCEP = 0
        IBB = 0
        DO 130 IBAS = 1,NNAO
          IF(IBAS.NE.IDON.AND.IBAS.NE.IACPT) THEN
            IB = IBX(IBAS)
            IF(LBL(IB,1).EQ.LCR.AND.LBL(IB,2).NE.ISTAR) THEN
              IF(LBL(IB,4).EQ.IAT1) THEN
                IBB = IBB + 1
                IF(IBB.EQ.1.AND.DETAIL) WRITE(LFNPR,890) IAT1,IAT2,IAT3
                J = 0
                DO 120 I = LL(IAT1),UL(IAT1)
                  J = J + 1
                  BORB(J) = T(I,IBAS)
  120           CONTINUE
                IBD = IBD + 1
                IF(DETAIL) WRITE(LFNPR,930) IBB,DM(IBAS,IBAS)
                IF(DETAIL) WRITE(LFNPR,940) (BORB(I),I=1,J)
                CALL STASH(BORB,IBD,IAT1,IAT2,IAT3,POL,Q,HYB)
                IACCEP = IACCEP + 1
                LABEL(IBD,1) = LCR
                LABEL(IBD,2) = IBLNK
                LABEL(IBD,3) = IACCEP
                LABEL(IBD,4) = IAT1
                LABEL(IBD,5) = IAT2
                LABEL(IBD,6) = IAT3
                BNDOCC(IBD)  = DM(IBAS,IBAS)
                IF(DETAIL) WRITE(LFNPR,960) IBB,IBD,(LABEL(IBD,I),I=1,3)
              END IF
            END IF
          END IF
  130   CONTINUE
  140 CONTINUE
C
C  Lone pairs...
C
      DO 170 IAT1 = 1,NATOMS
        IACCEP = 0
        IBB = 0
        DO 160 IBAS = 1,NNAO
          IF(IBAS.NE.IDON.AND.IBAS.NE.IACPT) THEN
            IB = IBX(IBAS)
            IF(LBL(IB,1).EQ.LLP.AND.LBL(IB,2).NE.ISTAR) THEN
              IF(LBL(IB,4).EQ.IAT1) THEN
                KTOPO(IAT1,IAT1) = KTOPO(IAT1,IAT1) - 1
                IBB = IBB + 1
                IF(IBB.EQ.1.AND.DETAIL) WRITE(LFNPR,890) IAT1,IAT2,IAT3
                J = 0
                DO 150 I = LL(IAT1),UL(IAT1)
                  J = J + 1
                  BORB(J) = T(I,IBAS)
  150           CONTINUE
                IBD = IBD + 1
                IF(DETAIL) WRITE(LFNPR,930) IBB,DM(IBAS,IBAS)
                IF(DETAIL) WRITE(LFNPR,940) (BORB(I),I=1,J)
                CALL STASH(BORB,IBD,IAT1,IAT2,IAT3,POL,Q,HYB)
                IACCEP = IACCEP + 1
                LABEL(IBD,1) = LLP
                LABEL(IBD,2) = IBLNK
                LABEL(IBD,3) = IACCEP
                LABEL(IBD,4) = IAT1
                LABEL(IBD,5) = IAT2
                LABEL(IBD,6) = IAT3
                BNDOCC(IBD)  = DM(IBAS,IBAS)
                IF(DETAIL) WRITE(LFNPR,960) IBB,IBD,(LABEL(IBD,I),I=1,3)
              END IF
            END IF
          END IF
  160   CONTINUE
  170 CONTINUE
C
C  Bonds...
C
      DO 210 IAT1 = 1,NATOMS-1
        DO 200 IAT2 = IAT1+1,NATOMS
          IACCEP = 0
          IBB = 0
          DO 195 IBAS = 1,NNAO
            IF(IBAS.NE.IDON.AND.IBAS.NE.IACPT) THEN
              IB = IBX(IBAS)
              IF(LBL(IB,1).EQ.LBD.AND.LBL(IB,2).NE.ISTAR) THEN
                IF(LBL(IB,4).EQ.IAT1.AND.LBL(IB,5).EQ.IAT2) THEN
                  KTOPO(IAT1,IAT2) = KTOPO(IAT1,IAT2) - 1
                  KTOPO(IAT2,IAT1) = KTOPO(IAT1,IAT2)
                  IBB = IBB + 1
                  IF(IBB.EQ.1.AND.DETAIL) WRITE(LFNPR,890)IAT1,IAT2,IAT3
                  J = 0
                  DO 180 I = LL(IAT1),UL(IAT1)
                    J = J + 1
                    BORB(J) = T(I,IBAS)
  180             CONTINUE
                  DO 190 I = LL(IAT2),UL(IAT2)
                    J = J + 1
                    BORB(J) = T(I,IBAS)
  190             CONTINUE
                  IBD = IBD + 1
                  IF(DETAIL) WRITE(LFNPR,930) IBB,DM(IBAS,IBAS)
                  IF(DETAIL) WRITE(LFNPR,940) (BORB(I),I=1,J)
                  CALL STASH(BORB,IBD,IAT1,IAT2,IAT3,POL,Q,HYB)
                  IACCEP = IACCEP + 1
                  LABEL(IBD,1) = LBD
                  LABEL(IBD,2) = IBLNK
                  LABEL(IBD,3) = IACCEP
                  LABEL(IBD,4) = IAT1
                  LABEL(IBD,5) = IAT2
                  LABEL(IBD,6) = IAT3
                  BNDOCC(IBD)  = DM(IBAS,IBAS)
                  IF(DETAIL) WRITE(LFNPR,960) IBB,IBD,
     +                                        (LABEL(IBD,I),I=1,3)
                END IF
              END IF
            END IF
  195     CONTINUE
  200   CONTINUE
  210 CONTINUE
C
C  Restore the NAO density matrix, place a copy in T (that's were DEPLET
C  expects to find it), and deplete the matrix of the density associated
C  with the NBOs common to both parent and target structures:
C
      CALL FEDNAO(DM)
      CALL COPY(DM,T,NDIM,NNAO,NNAO)
      CALL DEPLET(DM,T,Q,POL,BORB,BNDOCC,IBD)
C
C  Loop over elements of KTOPO constructing the remaining NBOs of the
C  target structure:
C
C  Lone pairs...
C
      IAT2 = 0
      DO 250 IAT1 = 1,NATOMS
        IF(KTOPO(IAT1,IAT1).NE.0) THEN
          CALL LOAD(DM,IAT1,IAT2,IAT3,BLK,NB)
          CALL NBJACOBI(NB,BLK,EVAL,C,MXBO,MXBO,1)
          CALL RANK(EVAL,NB,MXBO,LARC)
          IF(DETAIL) WRITE(LFNPR,900) IAT1,IAT2,IAT3
          IF(DETAIL) WRITE(LFNPR,910) KTOPO(IAT1,IAT1),OCCTHR
          IF(DETAIL) WRITE(LFNPR,920) (EVAL(IB),IB=1,NB)
          IB = 0
          IACCEP = NTOPO(IAT1,IAT1) - KTOPO(IAT1,IAT1)
          DO 240 II = 1,KTOPO(IAT1,IAT1)
  220       IB = IB + 1
            IF(IB.LE.NB.AND.EVAL(IB).GE.OCCTHR) THEN
              DO 230 I = 1,NB
                BORB(I) = C(I,LARC(IB))
  230         CONTINUE
              IF(DETAIL) WRITE(LFNPR,930) IB,EVAL(IB)
              IF(DETAIL) WRITE(LFNPR,940) (BORB(I),I=1,NB)
              CALL PRJEXP(BORB,IAT1,IAT2,IAT3,Q,P,TA,HYB,VA,VB,HYBEXP)
              IHYB = 1
              IF(DETAIL) WRITE(LFNPR,950) IHYB,HYBEXP(IHYB)
              IF(HYBEXP(IHYB).LT.PRJTHR) GOTO 220
              KTOPO(IAT1,IAT1) = KTOPO(IAT1,IAT1) - 1
              IBD = IBD + 1
              CALL STASH(BORB,IBD,IAT1,IAT2,IAT3,POL,Q,HYB)
              IACCEP = IACCEP + 1
              LABEL(IBD,1) = LLP
              LABEL(IBD,2) = IBLNK
              LABEL(IBD,3) = IACCEP
              LABEL(IBD,4) = IAT1
              LABEL(IBD,5) = IAT2
              LABEL(IBD,6) = IAT3
              BNDOCC(IBD)  = EVAL(IB)
              IF(DETAIL) WRITE(LFNPR,960) IB,IBD,(LABEL(IBD,I),I=1,3)
            END IF
  240     CONTINUE
        END IF
  250 CONTINUE
C
C  Bonds...
C
      DO 300 IAT1 = 1,NATOMS-1
        DO 290 IAT2 = IAT1+1,NATOMS
          IF(KTOPO(IAT1,IAT2).NE.0) THEN
            CALL LOAD(DM,IAT1,IAT2,IAT3,BLK,NB)
            CALL NBJACOBI(NB,BLK,EVAL,C,MXBO,MXBO,1)
            CALL RANK(EVAL,NB,MXBO,LARC)
            IF(DETAIL) WRITE(LFNPR,900) IAT1,IAT2,IAT3
            IF(DETAIL) WRITE(LFNPR,910) KTOPO(IAT1,IAT2),OCCTHR
            IF(DETAIL) WRITE(LFNPR,920) (EVAL(IB),IB=1,NB)
            IB = 0
            IACCEP = NTOPO(IAT1,IAT2) - KTOPO(IAT1,IAT2)
            DO 280 II = 1,KTOPO(IAT1,IAT2)
  260         IB = IB + 1
              IF(IB.LE.NB.AND.EVAL(IB).GE.OCCTHR) THEN
                DO 270 I = 1,NB
                  BORB(I) = C(I,LARC(IB))
  270           CONTINUE
                IF(DETAIL) WRITE(LFNPR,930) IB,EVAL(IB)
                IF(DETAIL) WRITE(LFNPR,940) (BORB(I),I=1,NB)
                CALL PRJEXP(BORB,IAT1,IAT2,IAT3,Q,P,TA,HYB,VA,VB,HYBEXP)
                IHYB = 1
                IF(DETAIL) WRITE(LFNPR,950) IHYB,HYBEXP(IHYB)
                IHYB = 2
                IF(DETAIL) WRITE(LFNPR,950) IHYB,HYBEXP(IHYB)
                IF(HYBEXP(1).LT.PRJTHR) GOTO 260
                IF(HYBEXP(2).LT.PRJTHR) GOTO 260
                KTOPO(IAT1,IAT2) = KTOPO(IAT1,IAT2) - 1
                KTOPO(IAT2,IAT1) = KTOPO(IAT1,IAT2)
                IBD = IBD + 1
                CALL STASH(BORB,IBD,IAT1,IAT2,IAT3,POL,Q,HYB)
                IACCEP = IACCEP + 1
                LABEL(IBD,1) = LBD
                LABEL(IBD,2) = IBLNK
                LABEL(IBD,3) = IACCEP
                LABEL(IBD,4) = IAT1
                LABEL(IBD,5) = IAT2
                LABEL(IBD,6) = IAT3
                BNDOCC(IBD)  = EVAL(IB)
                IF(DETAIL) WRITE(LFNPR,960) IB,IBD,(LABEL(IBD,I),I=1,3)
              END IF
  280       CONTINUE
          END IF
  290   CONTINUE
  300 CONTINUE
C
C  If any lone pair or bond orbitals were left behind, abort:
C
      DO 320 IAT1 = 1,NATOMS
        IF(KTOPO(IAT1,IAT1).NE.0) CALL NBHALT('Missing LP in SHREWD.')
        DO 310 IAT2 = IAT1+1,NATOMS
          IF(KTOPO(IAT1,IAT2).NE.0) CALL NBHALT('Missing BD in SHREWD.')
  310   CONTINUE
  320 CONTINUE
C
C  Symmetrically orthogonalize principal hybrids:
C
      IALARM = 0
      CALL ORTHYB(Q,BLK,TA,EVAL,C,IALARM,IFLG)
C
C  Alarm!!  Linear dependency in hybrids:
C
      IF(IALARM.NE.0) THEN
        IF(PRINT) WRITE(LFNPR,970) IALARM
        CALL FEDNAO(DM)
        IFLG = -1
        JPRINT(1) = -1
        RETURN
      END IF
C
C  Augment open-valence atoms with non-arbitrary hybrids:
C
      DO 390 IAT = 1,NATOMS
        IF(NOPVAL(IAT).GT.0) THEN
          NMB = 0
          DO 330 I = LL(IAT),UL(IAT)
            IF(LTYP(I).EQ.IHCOR) NMB = NMB + 1
            IF(LTYP(I).EQ.IHVAL) NMB = NMB + 1
  330     CONTINUE
          IOCC = 0
          IOCCLP = 0
          DO 340 IB = 1,IBD
            IF(LABEL(IB,4).EQ.IAT.OR.LABEL(IB,5).EQ.IAT) THEN
              IOCC = IOCC + 1
              IF(LABEL(IB,1).EQ.LLP) IOCCLP = IOCCLP + 1
            END IF
  340     CONTINUE
          NEXLP = NMB - IOCC
          IF(NEXLP.LT.0) NEXLP = 0
          NOCC = INO(IAT)
          CALL NBFPRJ(P,IAT,Q,NOCC,TA,VA,VB)
          NORB = NORBS(IAT)
          NAUGM = NORB - NOCC
          CALL AUGMNT(P,BLK,C,EVAL,DM,TA,BORB,V,LARC,IAT,NOCC,NORB)
C
C  Stash and label extra lone pairs that AUGMNT put in BLK:
C
          DO 360 IAUGM = 1,NEXLP
            DO 350 J = 1,NORB
              BORB(J) = BLK(J,IAUGM)
  350       CONTINUE
            IBD = IBD + 1
            CALL STASH(BORB,IBD,IAT,0,0,POL,Q,HYB)
            LABEL(IBD,1) = LLP
            LABEL(IBD,2) = ISTAR
            LABEL(IBD,3) = IAUGM + IOCCLP
            LABEL(IBD,4) = IAT
            LABEL(IBD,5) = 0
            LABEL(IBD,6) = 0
  360     CONTINUE
C
C  Stash and label the Rydberg orbitals that AUGMNT put in BLK:
C
          IRYD = 0
          NSTART = NEXLP + 1
          DO 380 IAUGM = NSTART,NAUGM
            DO 370 J = 1,NORB
              BORB(J) = BLK(J,IAUGM)
  370       CONTINUE
            IBD = IBD + 1
            IRYD = IRYD + 1
            CALL STASH(BORB,IBD,IAT,0,0,POL,Q,HYB)
            LABEL(IBD,1) = LRY
            LABEL(IBD,2) = ISTAR
            LABEL(IBD,3) = IRYD
            LABEL(IBD,4) = IAT
            LABEL(IBD,5) = 0
            LABEL(IBD,6) = 0
  380     CONTINUE
        END IF
  390 CONTINUE
C
C  Include antibond labels:
C
      IBO = IBD
      DO 410 I = 1,IBO
        IF(LABEL(I,1).NE.LCR) THEN
          IF(LABEL(I,1).NE.LLP) THEN
            IF(LABEL(I,1).NE.LRY) THEN
              IBD = IBD + 1
              DO 400 J = 1,6
                LABEL(IBD,J) = LABEL(I,J)
  400         CONTINUE
              LABEL(IBD,2) = ISTAR
            END IF
          END IF
        END IF
  410 CONTINUE
      IF(IBD.NE.NNAO) CALL NBHALT('Miscounted orbitals in SR SHREWD.')
C
C  Restore density matrix:
C
      CALL FEDNAO(DM)
C
C  Find new polarization parameters for orthonormal hybrids:
C
      CALL REPOL(DM,Q,POL,BLK,EVAL,C,IBD)
C
C  Form final T-NAB (NAO to NBO transformation) from orthonormal hybrids:
C
      CALL FORMT(T,Q,POL)
C
C  Find occupancies, number of electrons, and number of occupied orbitals:
C
      TOTELE = ZERO
      DO 440 I = 1,NNAO
        OCCI = ZERO
        DO 430 J = 1,NNAO
          DO 420 K = 1,NNAO
            OCCI = OCCI + T(J,I) * DM(J,K) * T(K,I)
  420     CONTINUE
  430   CONTINUE
        IF(OCCI.LE.-ZEROP.AND.OCCI.GT.-ZEROX) THEN
          IOCWAR = IOCWAR + 1
          IF(IOCWAR.LE.5) WRITE(LFNPR,1305) OCCI,I
          IF(IOCWAR.EQ.5) WRITE(LFNPR,1306)
        END IF
        IF(OCCI.LT.ZERO.AND.OCCI.GT.-ZEROP) OCCI = ZERO
        IF(OCCI.GE.TWOP.AND.OCCI.LT.TWOX) THEN
          IOCWAR = IOCWAR + 1
          IF(IOCWAR.LE.5) WRITE(LFNPR,1305) OCCI,I
          IF(IOCWAR.EQ.5) WRITE(LFNPR,1306)
        END IF
        IF(OCCI.GT.TWO.AND.OCCI.LT.TWOP) OCCI = TWO
        IF(OCCI.LT.-ZEROX.OR.OCCI.GT.TWOX) THEN
          WRITE(LFNPR,1300) OCCI,I
          IFLG = -1
          JPRINT(1) = -1
          RETURN
        END IF
        BNDOCC(I) = OCCI
        V(I) = OCCI
        TOTELE = TOTELE + BNDOCC(I)
  440 CONTINUE
      NEL = INT(TOTELE + TENTH)
      ELECHK = ABS(TOTELE - DFLOAT(NEL))
      IF(ELECHK.GE.TOTP.AND.ELECHK.LT.TOTX) WRITE(LFNPR,1315) TOTELE
      IF(ELECHK.GT.TOTX) THEN
        WRITE(LFNPR,1310) TOTELE
        IFLG = -1
        JPRINT(1) = -1
        RETURN
      END IF
      TOTELE = NEL
      NOCC = NEL
      IF(ISPIN.EQ.0) NOCC = NOCC/2
C
C  If the number of unstarred orbitals is not equal to the number of occupied
C  MOs, then simply rank the orbitals by occupancy, and ``unstarr'' the NOCC
C  highest occupied:  (This can be dangerous!  However, many of the subsequent
C  routines assume the only NOCC orbitals are starred, and therefore, any
C  discrepancy must be corrected.)
C
      NOSTR = 0
      DO 450 I = 1,NNAO
        IF(LABEL(IBXM(I),2).NE.ISTAR) NOSTR = NOSTR + 1
  450 CONTINUE
      IF(NOSTR.NE.NOCC) THEN
        CALL RANK(V,NNAO,NDIM,LARC)
        DO 460 I = 1,NOCC
          IR = LARC(I)
          LABEL(IBXM(IR),2) = IBLNK
  460   CONTINUE
        DO 470 I = NOCC+1,NNAO
          IR = LARC(I)
          LABEL(IBXM(IR),2) = ISTAR
  470   CONTINUE
      END IF
      RETURN
C
  890 FORMAT(/1X,'Selecting orbitals between the following atoms:',
     +          3I4)
  900 FORMAT(/1X,'Search of DM block between the following atoms:',
     +          3I4)
  910 FORMAT(6X,'Select',I3,' orbital(s) with eigenvalue > ',F9.6)
  920 FORMAT(6X,8F9.6)
  930 FORMAT(6X,'Eigenvector (',I2,') has occupancy ',F9.6,':')
  940 FORMAT(11X,8F7.4)
  950 FORMAT(11X,'Hybrid ',I1,' in eigenvector has a projection ',
     +    'expectation of ',F6.3)
  960 FORMAT(6X,'Eigenvector (',I2,') accepted: Number',I3,'.  ',
     + ' Label:',A2,A1,'(',I2,')')
  970 FORMAT(//1X,'Linearly independent hybrids for atom',I3,
     +' cannot be found.',/1X,'NBO program must abort.')
 1300 FORMAT(/1X,'FATAL ERROR:  Non-physical NBO occupancy (',F8.5,
     + ' electrons), orbital',I4,'.',/4X,
     + 'Check input data or density.')
 1305 FORMAT(/1X,'WARNING:  Non-physical NBO occupancy (',F8.5,
     + ' electrons), orbital',I4,'.',/4X,
     + 'Check input data or density.  Program will continue.')
 1306 FORMAT(/1X,'NON-PHYSICAL OCCUPANCIES!  Further warning ',
     + 'messages suppressed.')
 1310 FORMAT(/1X,'FATAL ERROR:  Total number of electrons (',F10.5,
     + ') not an integer:',/4X,
     + 'Check input data or density.')
 1315 FORMAT(/1X,'WARNING:  Total number of electrons (',F10.5,
     + ') not an integer.  Program will continue.')
      END
C***********************************************************************
      SUBROUTINE NBSLCT(RHOSTR,NRES,IRESET,KPTR,IDXRES,MAXRES,NREF,
     +                  MAXREF,NRTCTL)
C***********************************************************************
C 26-Jul-06  EDG  Renamed from SELECT to NBSLCT to avoid xlf conflict
C 12-Apr-01  CMM  Set down THRESH (thus RHOMIN) when NREF > MAXREF
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION RHOSTR(MAXRES,MAXREF),NRES(MAXREF),KPTR(MAXRES),
     +          IDXRES(MAXRES,MAXREF),IRESET(MAXREF),NRTCTL(10)
C
      SAVE ZERO,ONE,TWO,HUNDRD,EPS,THRESH
      DATA ZERO,ONE,TWO,HUNDRD/0.0D0,1.0D0,2.0D0,1.0D2/
      DATA EPS,THRESH/1.0D-3,0.6D0/
C
      JFLG = 0
C
C  Find the structure of lowest rho*:
C
      RHOMIN = HUNDRD
      DO IRES = 1,NRES(1)
        KPTR(IRES) = 0
        IF(RHOSTR(IRES,1).GE.ZERO) THEN
          RHOMIN = MIN(RHOMIN,RHOSTR(IRES,1))
          KPTR(IRES) = 1
        END IF
      ENDDO
   10 CONTINUE
C
C  Set the rho* threshold:
C  After first run-through, set it down a notch. CMM 3/29/01
C
      IF(JFLG.GT.0) THEN
        THRESH = THRESH/TWO
        WRITE (LFNPR, 890) THRESH
      END IF
C
      RHOTHR = RHOMIN + THRESH
      IF(ISPIN.NE.0) RHOTHR = RHOMIN + THRESH / TWO
      IF(NRTCTL(3).EQ.0) RHOTHR = HUNDRD
C
C  Accept all structures with rho* less than threshold:
C
      NREF = 0
      DO 20 IRES = 1,NRES(1)
        IF(KPTR(IRES).GT.0) THEN
          IF(RHOSTR(IRES,1).LT.RHOTHR) THEN
            NREF = NREF + 1
            KPTR(IRES) = -KPTR(IRES)
          END IF
        END IF
   20 CONTINUE
      IF(NREF.EQ.0) THEN
        WRITE(LFNPR,900)
        CALL NBHALT('SR SELECT cannot find any reference structures.')
      END IF
C
C  Delete the resonance structures of high rho*:
C
      DO 30 IRES = 1,NRES(1)
        IF(KPTR(IRES).GT.0) THEN
          KPTR(IRES) = 0
        ELSE
          KPTR(IRES) = ABS(KPTR(IRES))
        END IF
   30 CONTINUE
C
C  Skip the following loop after first run-through. CMM 3/29/01
C
      IF(JFLG.GT.0) GOTO 70
C
C  For each distinct TOPO matrix, accept only the structure(s) of lowest
C  rho*:
C
      DO 60 IRES = 1,NRES(1)
        IF(KPTR(IRES).GT.0) THEN
          IDX = IDXRES(IRES,1)
          RHO = RHOSTR(IRES,1)
          DO 40 JRES = IRES+1,NRES(1)
            IF(KPTR(JRES).GT.0) THEN
              IF(IDXRES(JRES,1).EQ.IDX) THEN
                IF(RHOSTR(JRES,1).LT.RHO) RHO = RHOSTR(JRES,1)
              END IF
            END IF
   40     CONTINUE
          DO 50 JRES = IRES,NRES(1)
            IF(KPTR(JRES).GT.0) THEN
              IF(IDXRES(JRES,1).EQ.IDX) THEN
                IF(RHOSTR(JRES,1).GT.RHO+EPS) THEN
                  KPTR(JRES) = 0
                  NREF = NREF - 1
                END IF
              END IF
            END IF
   50     CONTINUE
        END IF
   60 CONTINUE
C
C  Condense the list of reference structures:
C
   70 IFLG = 0
      IRES = NRES(1)
   80 CONTINUE
      IF(IRES.GT.1) THEN
        IRESM1 = IRES - 1
        IF(KPTR(IRES).GT.0.AND.KPTR(IRESM1).EQ.0) THEN
          KPTR(IRESM1) = KPTR(IRES)
          KPTR(IRES)   = 0
          RHOSTR(IRESM1,1) = RHOSTR(IRES,1)
          IDXRES(IRESM1,1) = IDXRES(IRES,1)
          IFLG = 1
        END IF
        IRES = IRESM1
        GOTO 80
      END IF
      IF(IFLG.EQ.1) GOTO 70
      IF(NREF.GT.MAXREF) THEN
        WRITE(LFNPR,910) MAXREF,NREF
C
C  Instead of halting, try setting down the rho* threshold. CMM 3/29/01
        JFLG = JFLG + 1
        IF(JFLG.LT.10) GOTO 10
        CALL NBHALT('Lowering rho* threshold still gave no ref. struc.')
      END IF
C
C  Finally, reorganize the RHOSTR and IDXRES arrays:
C
      DO 90 IREF = 1,NREF
        RHOSTR(1,IREF) = RHOSTR(IREF,1)
        IDXRES(1,IREF) = IDXRES(IREF,1)
        IRESET(IREF) = 1
        NRES(IREF)   = 1
   90 CONTINUE
      DO 110 IREF = 1,MAXREF
        DO 100 IRES = 2,MAXRES
          RHOSTR(IRES,IREF) = -ONE
          IDXRES(IRES,IREF) = 0
  100   CONTINUE
  110 CONTINUE
      RETURN
C
C 890 FORMAT stmt added for iterative lowering of THRESH.  3/29/01 CMM
  890 FORMAT(/1X,'Lowering rho* threshold to ',F8.5,' above minimum')
  900 FORMAT(/1X,'Valid reference structure must be supplied via the ',
     + '$NRTSTR keylist.')
  910 FORMAT(/1X,'The NRT program is currently configured to handle ',
     + I2,' reference structures',/1X,'which is insufficient for the ',
     + 'present calculation.  Increase this number',/1X,'to least ',
     + I2,' using the NRTMEM keyword of the $NBO keylist.')
      END
C***********************************************************************
      SUBROUTINE REFRS(IREF,T,BNDOCC,OCCR,TR,SCR1,SCR2,SCR3,GAMMA,
     +                 GAMMAW,IST,IOCC,NREF,NAO,IVALSP)
C***********************************************************************
C 28-Jan-94  JKB  Added more specific checks for inconsistent valence space
C                 IVALSP used to set flag in NRTDRV and restart NRTFDM
C-----------------------------------------------------------------------
C
C  Stash the NBO occupancies for the REFerence Resonance Structure
C  in OCCR.  Setup the pointer array IST.  Prepare the valence NAO
C  density difference matrix:
C
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXBAS = 2000)
C
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
C
      DIMENSION T(NDIM,NDIM),BNDOCC(NDIM),OCCR(NDIM,NREF),TR(NAO,NAO),
     +          SCR1(NAO,NAO),SCR2(NAO,NAO),SCR3(NAO),
     +          GAMMA(NAO*(NAO+1)/2),GAMMAW(NAO*(NAO+1)/2,NREF),
     +          IST(NDIM,NREF),IOCC(NDIM)
C
      SAVE LCR,LRY,LSTAR
      SAVE ZERO,ONE,TWO
      DATA LCR,LRY,LSTAR/2HCR,2HRY,1H*/
      DATA ZERO,ONE,TWO/0.0D0,1.0D0,2.0D0/
C
C  Stash the NBO occupancies in OCCR:
C
      DO 10 J = 1,NNAO
        OCCR(J,IREF) = BNDOCC(J)
   10 CONTINUE
C
C  Valence orbital space condition:
C
C  IVALSP = 0 : Valence space accepted
C           1 : Symmetric orthogonalization problem detected in SYMORT
C           5 : Inconsistent valence orbital count due to hypervalency
C
C  Setup IST array (0 = core, 1 = valence, 2 = Rydberg):
C
      IVALSP = 0
      ICNT = 0
      DO 20 I = 1,NNAO
        IF(LABEL(IBXM(I),1).EQ.LCR) THEN
          IST(I,IREF) = 0
        ELSE IF(LABEL(IBXM(I),1).EQ.LRY) THEN
          IST(I,IREF) = 2
        ELSE
          ICNT = ICNT + 1
          IST(I,IREF) = 1
        END IF
   20 CONTINUE
      IF(ICNT.GT.NAO.AND.JPRINT(77).EQ.0) THEN
        WRITE(LFNPR,900) NAO,ICNT
        IVALSP = 5
        RETURN
      ELSE IF(ICNT.LT.NAO.AND.JPRINT(77).EQ.0) THEN
        WRITE(LFNPR,910)
      END IF
C
C  Prepare a list of occupied valence NBOs and compute the valence density:
C
      IF(JPRINT(77).EQ.0) THEN
        DO 30 I = 1,NNAO
          IOCC(I) = -1
          IF(LABEL(IBXM(I),2).NE.LSTAR) IOCC(I) = 1
   30   CONTINUE
        CALL GETDM(T,GAMMAW(1,IREF),TR,SCR1,SCR2,SCR3,IST(1,IREF),IOCC,
     +             NAO,IVALSP)
        IF(IVALSP.EQ.1) RETURN
C
C  Prepare a list of occupied NBOs and calculate full density:
C
      ELSE
        NOCC = 0
        DO 35 I = 1,NNAO
          IF(LABEL(IBXM(I),2).NE.LSTAR) THEN
            NOCC = NOCC + 1
            IOCC(NOCC) = I
          END IF
   35   CONTINUE
        ETA = TWO
        IF(ISPIN.NE.0) ETA = ONE
        IJ = 0
        DO 60 J = 1,NAO
          DO 50 I = 1,J
            IJ = IJ + 1
            DMIJ = ZERO
            DO 40 K = 1,NOCC
              L = IOCC(K)
              DMIJ = DMIJ + ETA * T(I,L) * T(J,L)
   40       CONTINUE
            GAMMAW(IJ,IREF) = DMIJ
   50     CONTINUE
   60   CONTINUE
      END IF
C
C  Calculate density difference:
C
      LNAO = NAO * (NAO+1) / 2
      DO 70 I = 1,LNAO
        GAMMAW(I,IREF) = GAMMAW(I,IREF) - GAMMA(I)
   70 CONTINUE
      RETURN
C
  900 FORMAT(/1X,'Hypervalent compound detected; expected to find',
     +   I4,' orbitals but found',I4,'.',/1X,'Reallocate scratch ',
     +   'vector and restart using full AO density matrix.')
  910 FORMAT(/1X,'Hypovalent compound detected.')
      END
C***********************************************************************
      SUBROUTINE EXPECT(IRES,T,BNDOCC,OCC,OCCR,TR,SCR,IPTR,MAXRES,IREF,
     +                  NREF,NELEC)
C***********************************************************************
C
C  Compute the expectation values of the density operator for the
C  IRESth resonance structure in the basis of NBOs for the reference
C  resonance structure:
C
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBSTR/ITOPO(MAXATM,MAXATM)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBFLAG/ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      LOGICAL ROHF,UHF,CI,OPEN,COMPLX,ALPHA,BETA,MCSCF,AUHF,ORTHO
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
C
      DIMENSION T(NDIM,NDIM),BNDOCC(NDIM),OCC(NDIM,MAXRES,NREF),
     +       OCCR(NDIM,NREF),TR(NDIM,NDIM),SCR(NDIM,NDIM),IPTR(NDIM)
C
      SAVE ZERO,ONE,TWO
      SAVE LCR,LSTAR
      DATA ZERO,ONE,TWO/0.0D0,1.0D0,2.0D0/
      DATA LCR,LSTAR/2HCR,1H*/
C
C  Determine which NBOs we should consider to be occupied:
C
      DO 10 IBAS = 1,NNAO
        IPTR(IBAS) = 0
   10 CONTINUE
      DO 15 IBAS = 1,NNAO
        IB = IBXM(IBAS)
        IF(LABEL(IB,1).EQ.LCR.AND.LABEL(IB,2).NE.LSTAR) IPTR(IBAS) = 1
   15 CONTINUE
      DO 50 IAT = 1,NATOMS
        IA = IAT
        DO 40 JAT = IAT,NATOMS
          JA = JAT
          IF(JAT.EQ.IAT) JA = 0
          DO 30 IT = 1,ITOPO(IAT,JAT)
            IFLG = 0
            OFLG = ZERO
            DO 20 IBAS = 1,NNAO
              IF(IPTR(IBAS).EQ.0.AND.BNDOCC(IBAS).GE.OFLG) THEN
                IB = IBXM(IBAS)
                IF(LABEL(IB,4).EQ.IA.AND.LABEL(IB,5).EQ.JA) THEN
                  IF(LABEL(IB,2).NE.LSTAR) THEN
                    IFLG = IBAS
                    OFLG = BNDOCC(IBAS)
                  END IF
                END IF
              END IF
   20       CONTINUE
            IF(IFLG.EQ.0)
     +  CALL NBHALT('Problems labeling occupied orbitals in SR EXPECT')
            IPTR(IFLG) = 1
   30     CONTINUE
   40   CONTINUE
   50 CONTINUE
C
C  Make sure we haven't made any mistakes:
C
      ICNT = 0
      DO 60 IBAS = 1,NNAO
        ICNT = ICNT + IPTR(IBAS)
   60 CONTINUE
      IF(.NOT.OPEN) ICNT = 2 * ICNT
      IF(ICNT.NE.NELEC) CALL NBHALT('Miscounted electrons in SR EXPECT')
C
C  Compute the expectation values of the density operator for this
C  resonance structure in the NBO basis of the reference structure:
C
      ETA = TWO
      IF(OPEN) ETA = ONE
      DO 90 JB = 1,NNAO
        DO 80 IB = 1,NNAO
          SCR(IB,JB) = ZERO
          DO 70 IR = 1,NNAO
            SCR(IB,JB) = SCR(IB,JB) + T(IR,IB) * TR(IR,JB)
   70     CONTINUE
   80   CONTINUE
   90 CONTINUE
      DO 110 JB = 1,NNAO
        TEMP = ZERO
        DO 100 IB = 1,NNAO
          TEMP = TEMP + IPTR(IB) * ETA * SCR(IB,JB) * SCR(IB,JB)
  100   CONTINUE
        OCC(JB,IRES,IREF) = TEMP - OCCR(JB,IREF)
  110 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE IONIC(IRES,T,XION,NLOW,MAXRES,IREF,NREF)
C***********************************************************************
C
C  Evaluate the fractional ionic character for each bond in IRES:
C
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
C
      DIMENSION T(NDIM,NDIM),XION(NLOW,MAXRES,NREF)
C
      SAVE ZERO,LSTAR
      DATA ZERO/0.0D0/
      DATA LSTAR/1H*/
C
C  Initialize array:
C
      DO 10 I = 1,NLOW
        XION(I,IRES,IREF) = ZERO
   10 CONTINUE
C
C  Extract polarization coefficients (for 2-center bonds) from T:
C
      DO 40 IB = 1,NNAO
        IX = IBXM(IB)
        IF(LABEL(IX,2).NE.LSTAR) THEN
          IF(LABEL(IX,5).NE.0.AND.LABEL(IX,6).EQ.0) THEN
            IAT = LABEL(IX,4)
            JAT = LABEL(IX,5)
            IF(JAT.GT.IAT) THEN
              ITMP = IAT
              IAT  = JAT
              JAT  = ITMP
            END IF
            POLI = ZERO
            DO 20 IN = LL(IAT),LU(IAT)
              POLI = POLI + T(IN,IB) * T(IN,IB)
   20       CONTINUE
            POLJ = ZERO
            DO 30 IN = LL(JAT),LU(JAT)
              POLJ = POLJ + T(IN,IB) * T(IN,IB)
   30       CONTINUE
C
C  Compute the ionicity of this bond:
C
            TEMP = ABS(POLI - POLJ) / (POLI + POLJ)
            IPTR = (IAT - 1) * (IAT - 2) / 2 + JAT
            XION(IPTR,IRES,IREF) = XION(IPTR,IRES,IREF) + TEMP
          END IF
        END IF
   40 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE NBPREP(DM,TNBO,HYB,T,THYB,SCR)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
      COMMON/NBNAO/NAOC(MAXBAS),NAOA(MAXBAS),LTYP1(MAXBAS),
     +       IPRIN(MAXBAS)
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LTYP(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBSTOR/NBOLBL(MAXBAS,6),NHOCTR(MAXBAS)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION DM(NDIM,NDIM),T(NDIM,NDIM),HYB(MXAO),THYB(NDIM,NDIM),
     +          TNBO(NDIM,NDIM),SCR(NDIM)
      DIMENSION PCT(5)
C
      SAVE LLP,LBD,LCR,LRY
      SAVE ZERO,ONE,THRESH
      SAVE LSTAR
      DATA LLP,LBD,LCR,LRY/2HLP,2HBD,2HCR,2HRY/
      DATA ZERO,ONE,THRESH/0.0D0,1.0D0,1.0D-4/
      DATA LSTAR/1H*/
C
C  Form the NAO-NHO transformation:
C
      NHYB = 0
      DO 190 NBOND = 1,NNAO
        IB = IBXM(NBOND)
        LBL = LABEL(IB,1)
        IF(LBL.EQ.LLP.OR.LBL.EQ.LCR.OR.LBL.EQ.LRY) NCTR = 1
        IF(LBL.EQ.LBD) NCTR = 2
C
C  Loop over atomic centers of bond orbital NBOND:
C
        DO 180 ICTR = 1,NCTR
          I = LABEL(IB,ICTR+3)
          KL = LL(I)
          KU = LU(I)
          DO 110 K = 1,MXAO
            LTYP(K) = 0
            HYB(K) = ZERO
  110     CONTINUE
C
C  Choose sign for polarization coefficients:
C
          ISGN = 1
          IF(LABEL(IB,2).NE.LSTAR) GO TO 120
          IF(ICTR.LT.2) GO TO 120
          ISGN = -ISGN
  120     CONTINUE
C
C  Extract hybrid (HYB) from transformation matrix T; LTYP(I) is the
C  orbital angular momentum quantum no. of A.O. # I:
C
          KH = 0
          DO 130 K = KL,KU
            KH = KH + 1
            HYB(KH) = T(K,NBOND)
            LTYP(KH) = NAOA(K)/100
  130     CONTINUE
          CALL HTYPE(HYB,LTYP,MXAO,KH,COEF,PCT,NL,ISGN)
          IF(ABS(COEF).LT.THRESH) GO TO 180
C
C  Check to see if this orbital has been found before:
C
          DO 150 IHYB = 1,NHYB
            TEMP = ZERO
            IH = 0
            DO 140 K = KL,KU
              IH = IH + 1
              TEMP = TEMP + HYB(IH)*THYB(K,IHYB)
  140       CONTINUE
            IF(ABS(ABS(TEMP)-ONE).LT.THRESH) GO TO 180
            IF(ABS(TEMP).GT.THRESH) THEN
              WRITE(LFNPR,900) NHYB+1,NBOND,ICTR,TEMP,IHYB
              CALL NBHALT('NBPREP: Non-negligible overlap of NHOs.')
            END IF
  150     CONTINUE
C
C  Add this hybrid to the temporary THYB:
C
          NHYB = NHYB + 1
          IF(NHYB.GT.NNAO) CALL NBHALT('NBPREP: Too many hybrids.')
          DO 160 K = 1,NNAO
            THYB(K,NHYB) = ZERO
  160     CONTINUE
          IH = 0
          DO 170 K = KL,KU
            IH = IH + 1
            THYB(K,NHYB) = HYB(IH)
  170     CONTINUE
          NHOCTR(NHYB) = LABEL(IB,ICTR+3)
  180   CONTINUE
  190 CONTINUE
      IF(NHYB.LT.NNAO) CALL NBHALT('NBPREP: Missing hybrids.')
C
C  Compute the NHO-NBO transformation:
C
      DO 220 JB = 1,NNAO
        DO 210 IB = 1,NNAO
          TNBO(IB,JB) = ZERO
          DO 200 KB = 1,NNAO
            TNBO(IB,JB) = TNBO(IB,JB) + THYB(KB,IB) * T(KB,JB)
  200     CONTINUE
  210   CONTINUE
  220 CONTINUE
C
C  Transform the density matrix to the NHO basis:
C
      CALL FEDNAO(DM)
      CALL SIMTRS(DM,THYB,SCR,NDIM,NNAO)
C
C  Place a copy of the NBO labels in temporary storage:
C
      DO 240 I = 1,6
        DO 230 IB = 1,NNAO
          NBOLBL(IB,I) = LABEL(IB,I)
  230   CONTINUE
  240 CONTINUE
      RETURN
C
  900 FORMAT(/1X,'Hybrid',I4,' (NBO',I4,', Center',I3,') has a ',
     + 'non-negligible overlap of ',F8.5,/,1X,'with hybrid',I4,'.')
      END
C***********************************************************************
      SUBROUTINE ARROWS(DM,T,DELOC,SCR,NRES,IRESET,IDON,IACC,IDXRES,
     +                  MAXRES,IREF,NREF,LSTRES,LEN,IAT1,IAT2,IDXCOV,
     +                  IIONC,NRTCTL)
C***********************************************************************
C  4-Dec-96  EDG  Allow ionic forms for APOLAR runs
C 27-Jul-94  EDG  Commented code for long bonded structures removed
C 31-Jan-94  JKB  Modified to allow storage of multiple LP-LP*
C                    interactions/covalent forms
C  JNote:  Variables IAT1 and IAT2 were converted to arrays for this
C      purpose, but RETURN below remains until problem in CONDNS solved.
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
C  Add to the list (LSTRES) of resonance structures, the parent lewis
C  structure (NTOPO) and secondary Lewis structures suggested by the
C  principal delocalization interaction of the NBO array:
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBSTOR/NBOLBL(MAXBAS,6),NHOCTR(MAXBAS)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBSTR/ITOPO(MAXATM,MAXATM)
      COMMON/NBTOPO/IORDER(MAXATM),JORDER(MAXATM),NTOPO(MAXATM,MAXATM),
     +            N3CTR,I3CTR(10,3)
      COMMON/NBTHR/THRSET,PRJSET,ACCTHR,CRTSET,E2THR,ATHR,PTHR,ETHR,
     +             DTHR,DLTHR,CHSTHR,REFTHR,STTHR,PRTHR,THRNCS,THRNJC
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
C
      DIMENSION DM(NDIM,NDIM),T(NDIM,NDIM),DELOC(NDIM,NDIM),SCR(NDIM),
     +          NRES(NREF),IDON(MAXRES,NREF),IACC(MAXRES,NREF),
     +          IDXRES(MAXRES,NREF),LSTRES(LEN),IRESET(NREF)
      DIMENSION IHYB(4),ICTR(4),NRTCTL(10)
      DIMENSION IAT1(MAXATM),IAT2(MAXATM),IDXCOV(MAXATM)
C
      SAVE KCR,KRY,KSTAR
      SAVE ZERO,EPS,CUTOFF,TWO
      DATA KCR,KRY,KSTAR/2HCR,2HRY,1H*/
      DATA ZERO,EPS,CUTOFF,TWO/0.0D0,1.0D-6,2.0D-3,2.0D0/
C
C  Keep a copy of ITOPO in NTOPO (note that SR GETREL requires that
C  the parent structure be stored in NTOPO):
C
      DO 20 JAT = 1,NATOMS
        DO 10 IAT = 1,NATOMS
          NTOPO(IAT,JAT) = ITOPO(IAT,JAT)
   10   CONTINUE
   20 CONTINUE
C
C  Set the threshold on the delocalization list:
C
      THRESH = ABS(DLTHR)
C
C  Loop over NBOs, searching for alternative resonance structures:
C
      IIONC = 0
      DO 110 IBO = 1,NNAO
C
C  Skip this NBO if it is not a filled, valence Lewis orbital:
C
        IB = IBXM(IBO)
        IF(LABEL(IB,1).EQ.KCR) GOTO 110
        IF(LABEL(IB,1).EQ.KRY) GOTO 110
        IF(LABEL(IB,2).EQ.KSTAR) GOTO 110
C
C  Get the delocalization list, LARC:
C
        IF(IWFOCK.EQ.1) THEN
          IFLG = 0
          CALL GETDEL(IBO,TWO,THRESH,THRESH,NL,LARC,SCR,DELOC,IFLG)
        ELSE
          IFLG = 1
          CALL GETDEL(IBO,TWO,CUTOFF,CUTOFF,NL,LARC,SCR,DELOC,IFLG)
        END IF
C
C  Loop over delocalizing NBOs, skipping Rydbergs and filled orbitals:
C
        IF(NL.LE.0) GO TO 110
        DO 100 IP = 1,NL
          IBOP = LARC(IP)
          IF(LABEL(IBXM(IBOP),1).EQ.KRY) GOTO 100
          IF(LABEL(IBXM(IBOP),2).NE.KSTAR) GOTO 100
C
C  Determine the relationship of IBOP to IBO (geminal, vicinal, etc.):
C
          CALL GETREL(IBO,IBOP,IUNIT1,IUNIT2,IREL,IA,IB,IC,ID)
          IF(IB.EQ.0.OR.IC.EQ.0)
     *  CALL NBHALT('ARROWS: Error in GETREL connectivity information.')
C
C  Skip this interaction if it is a bond with its own antibond (except APOLAR):
C
          IF(IREL.EQ.1.AND.IA.EQ.ID.AND.IWAPOL.EQ.0) GOTO 100
C
C  Return here if we have to take multiple passes:
C
          IPASS = 0
   30     IPASS = IPASS + 1
C
C  Restore ITOPO from NTOPO:
C
          DO 50 JAT = 1,NATOMS
            DO 40 IAT = 1,NATOMS
              ITOPO(IAT,JAT) = NTOPO(IAT,JAT)
   40       CONTINUE
   50     CONTINUE
C
C  Case: remote delocalization (search for a single resonance structure
C  which describes this interaction, based on off-diagonal NHO density
C  matrix elements):
C
          IF(IREL.EQ.0) THEN
            NCTR = 0
            DO 60 JB = 1,NNAO
              IF(ABS(T(JB,IBO)).GT.EPS) THEN
                NCTR = NCTR + 1
                IHYB(NCTR) = -JB
                ICTR(NCTR) = NHOCTR(JB)
              END IF
   60       CONTINUE
            DO 70 JB = 1,NNAO
              IF(ABS(T(JB,IBOP)).GT.EPS) THEN
                NCTR = NCTR + 1
                IHYB(NCTR) = JB
                ICTR(NCTR) = NHOCTR(JB)
              END IF
   70       CONTINUE
            IAT = 0
            JAT = 0
            HOLD = ZERO
            DO 90 KC = 1,NCTR-1
              DO 80 JC = KC+1,NCTR
                IF(IHYB(KC)*IHYB(JC).LT.0) THEN
                  IH = ABS(IHYB(KC))
                  JH = ABS(IHYB(JC))
                  IF(ABS(DM(IH,JH)).GT.ABS(HOLD)) THEN
                    IAT = ICTR(KC)
                    JAT = ICTR(JC)
                    HOLD = DM(IH,JH)
                  END IF
                END IF
   80         CONTINUE
   90       CONTINUE
            IF(IAT.NE.IA.AND.IAT.NE.IB)
     *          CALL NBHALT('Problems in SR ARROWS(I)')
            IF(JAT.NE.IC.AND.JAT.NE.ID)
     *          CALL NBHALT('Problems in SR ARROWS(J)')
            IF(IAT.NE.IB) THEN
              IT = IA
              IA = IB
              IB = IT
            END IF
            IF(JAT.NE.IC) THEN
              IT = IC
              IC = ID
              ID = IT
            END IF
            IF(IA.NE.0) THEN
              ITOPO(IA,IB) = ITOPO(IA,IB) - 1
              ITOPO(IB,IA) = ITOPO(IA,IB)
            ELSE
              ITOPO(IB,IB) = ITOPO(IB,IB) - 1
            END IF
            IF(ID.NE.0) THEN
              ITOPO(IC,ID) = ITOPO(IC,ID) - 1
              ITOPO(ID,IC) = ITOPO(IC,ID)
              ITOPO(ID,ID) = ITOPO(ID,ID) + 1
            END IF
            ITOPO(IB,IC) = ITOPO(IB,IC) + 1
            ITOPO(IC,IB) = ITOPO(IB,IC)
            NRES(IREF) = NRES(IREF) + 1
            IRES = NRES(IREF)
            CALL TOPSTR(IRES,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
            CALL TOPCMP(IDP,IRES,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
            IDON(IRES,IREF) = IBO
            IACC(IRES,IREF) = IBOP
C
C  Case: geminal delocalization (only to check the case of A-B(=C)-D
C  since all other geminal delocalization combinations lead to structures
C  with adjacent formal charges, i.e. ionic structures):
C
          ELSE IF(IREL.EQ.1.AND.IA.NE.0.AND.ID.NE.0) THEN
            ITOPO(IA,IB) = ITOPO(IA,IB) - 1
            ITOPO(IB,IA) = ITOPO(IA,IB)
            ITOPO(IC,ID) = ITOPO(IC,ID) - 1
            ITOPO(ID,IC) = ITOPO(IC,ID)
            ITOPO(IB,IB) = ITOPO(IB,IB) + 1
            ITOPO(ID,ID) = ITOPO(ID,ID) + 1
            NRES(IREF) = NRES(IREF) + 1
            IRES = NRES(IREF)
            CALL TOPSTR(IRES,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
            CALL TOPCMP(IDP,IRES,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
            IDON(IRES,IREF) = IBO
            IACC(IRES,IREF) = IBOP
C
C  Case: vicinal or remote delocalization.  First try "double bond-
C  no bond" resonance:
C
          ELSE IF(IREL.GE.2) THEN
            IF(IA.NE.0) THEN
              ITOPO(IA,IB) = ITOPO(IA,IB) - 1
              ITOPO(IB,IA) = ITOPO(IA,IB)
            ELSE
              ITOPO(IB,IB) = ITOPO(IB,IB) - 1
            END IF
            IF(ID.NE.0) THEN
              ITOPO(IC,ID) = ITOPO(IC,ID) - 1
              ITOPO(ID,IC) = ITOPO(IC,ID)
              ITOPO(ID,ID) = ITOPO(ID,ID) + 1
            END IF
            ITOPO(IB,IC) = ITOPO(IB,IC) + 1
            ITOPO(IC,IB) = ITOPO(IB,IC)
            NRES(IREF) = NRES(IREF) + 1
            IRES = NRES(IREF)
            CALL TOPSTR(IRES,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
            CALL TOPCMP(IDP,IRES,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
            IDON(IRES,IREF) = IBO
            IACC(IRES,IREF) = IBOP
          END IF
C
C  Should atom permutations be performed:
C
          IF(IREL.GT.2) THEN
            IF(IREL.EQ.3) THEN
              IF(IPASS.EQ.1) THEN
                IT = IA
                IA = IB
                IB = IT
                GOTO 30
              END IF
            ELSE IF(IREL.EQ.4) THEN
              IF(IPASS.EQ.1) THEN
                IT = ID
                ID = IC
                IC = IT
                GOTO 30
              END IF
            ELSE IF(IREL.EQ.5) THEN
              IF(IPASS.EQ.1) THEN
                IT = IA
                IA = IB
                IB = IT
                IT = ID
                ID = IC
                IC = IT
                GOTO 30
              END IF
            END IF
          END IF
C
C  Parent structure must be ionic if LP-LP* interactions are discovered:
C
          IF(IA.EQ.0.AND.ID.EQ.0.AND.NRTCTL(1).NE.-2) THEN
            CALL IONTST(IRES,IREF,IB,IC,IDXRES,MAXRES,NREF,LSTRES,LEN,
     +                  IDEL)
            IF(IDEL.EQ.1) THEN
              IF(JPRINT(57).NE.0) WRITE(LFNPR,910) IREF
              IRESET(IREF) = -3
              NRES(IREF) = 1
              IIONC = IIONC + 1
              IDXCOV(IIONC) = IDXRES(IRES,IREF)
              IAT1(IIONC) = IB
              IAT2(IIONC) = IC
C
C  JKB - Comment out or remove RETURN to look for other LP-LP*.
              RETURN
C
            END IF
          END IF
  100   CONTINUE
  110 CONTINUE
      RETURN
C
  910 FORMAT(1X,'Reference',I4,' is ionic.  CONDNS will delete it.')
      END
C***********************************************************************
      SUBROUTINE NEWLBL
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NAOCTR(MAXBAS),NAOL(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LTYP(MAXBAS),IATHY(MAXBAS,3)
      COMMON/NBSTOR/NBOLBL(MAXBAS,6),NHOCTR(MAXBAS)
C
C  Move a copy of the NBO labels from COMMON/NBSTOR/ to COMMON/NBBAS/:
C
      DO 20 I = 1,6
        DO 10 IB = 1,NNAO
          LABEL(IB,I) = NBOLBL(IB,I)
   10   CONTINUE
   20 CONTINUE
      RETURN
      END
C***********************************************************************
      SUBROUTINE IONTST(IRES,IREF,IAT1,IAT2,IDXRES,MAXRES,NREF,LSTRES,
     +                  LEN,IDEL)
C***********************************************************************
C 28-Apr-94  JKB  Expanded to include transition metals
C 30-Jan-94  JKB  Expanded to include all Group A elements through Xe
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXATM = 200)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBSTR/ITOPO(MAXATM,MAXATM)
      COMMON/NBATOM/IATNO(MAXATM),INO(MAXATM),NORBS(MAXATM),LL(MAXATM),
     +       LU(MAXATM),IZNUC(MAXATM),IATCR(MAXATM)
C
      DIMENSION IDXRES(MAXRES,NREF),LSTRES(LEN)
      DIMENSION NUC(118)
C
      SAVE NUC
      DATA NUC/1,                                   2,
     +         1,2,                       3,4,5,6,7,8,
     +         1,2,                       3,4,5,6,7,8,
     +         1,2,3,4,5,6,7,8,9,10,11,12,3,4,5,6,7,8,
     +         1,2,3,4,5,6,7,8,9,10,11,12,3,4,5,6,7,8,
     +         1,2,               3,4,5,6,7,8,9,10,11,12,13,14,15,16,
     +             3,4,5,6,7,8,9,10,11,12,3,4,5,6,7,8,
     +         1,2,               3,4,5,6,7,8,9,10,11,12,13,14,15,16,
     +             3,4,5,6,7,8,9,10,11,12,3,4,5,6,7,8/
C
C  Calculate the formal charges on atoms IAT1,IAT2 for the parent
C  and IRESth secondary structures of IREF:
C
      IDEL = 0
C
C  Retrieve the parent TOPO matrix:
C
      CALL TOPGET(1,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
C
C  Determine the formal charges on atoms IAT1,IAT2:
C
      ICHRG = NUC(IATNO(IAT1))
      IF(ICHRG.EQ.0)
     +  CALL NBHALT('No valence electrons detected in SR IONTST.')
      DO 10 IAT = 1,NATOMS
        ICHRG = ICHRG - ITOPO(IAT,IAT1)
   10 CONTINUE
      ICHRG = ICHRG - ITOPO(IAT1,IAT1)
      JCHRG = NUC(IATNO(IAT2))
      IF(JCHRG.EQ.0)
     +  CALL NBHALT('No valence electrons detected in ST IONTST.')
      DO 20 IAT = 1,NATOMS
        JCHRG = JCHRG - ITOPO(IAT,IAT2)
   20 CONTINUE
      JCHRG = JCHRG - ITOPO(IAT2,IAT2)
      IP = ABS(ICHRG) + ABS(JCHRG)
C
C  Retrieve the secondary TOPO matrix:
C
      CALL TOPGET(IRES,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
C
C  Determine the formal charges on atoms IAT1,IAT2:
C
      ICHRG = NUC(IATNO(IAT1))
      DO 30 IAT = 1,NATOMS
        ICHRG = ICHRG - ITOPO(IAT,IAT1)
   30 CONTINUE
      ICHRG = ICHRG - ITOPO(IAT1,IAT1)
      JCHRG = NUC(IATNO(IAT2))
      DO 40 IAT = 1,NATOMS
        JCHRG = JCHRG - ITOPO(IAT,IAT2)
   40 CONTINUE
      JCHRG = JCHRG - ITOPO(IAT2,IAT2)
      IS = ABS(ICHRG) + ABS(JCHRG)
C
C  If IS < IP, delete the `ionic' parent structure (ARROWS will
C       replace with a covalent form):
C
      IF(IS.LT.IP) IDEL = 1
      RETURN
      END
C***********************************************************************
      SUBROUTINE CONDNS(IREF,XION,KPAR,NRES,IRESET,IDXRES,MAXRES,NREF,
     +                  NLOW,IAT1,IAT2,IDXCOV,IIONC)
C***********************************************************************
C 31-Jan-94  JKB  Modified to allow structures from multiple LP-LP*
C                     interactions to be removed/replaced.
C  JNote:  This modification is not completed, and should be done a better
C     way, but the changes below would work to some extent.  Need CONDNS to
C     recognize multiple LP-LP* interactions (leading to different distinct
C     covalent structures, as well as the case of two LP-LP* from the same
C     atom (net charge 2-) or to the same atom (net charge 2+, as in MgF2).
C-----------------------------------------------------------------------
C
C  Condense the list of resonance structures, removing covalent-ionic
C  resonance forms.
C
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXATM = 200)
      DIMENSION NRES(NREF),IRESET(NREF),IDXRES(MAXRES,NREF),
     +          XION(NLOW,MAXRES,NREF),KPAR(MAXRES,NREF)
      DIMENSION IAT1(MAXATM),IAT2(MAXATM),IDXCOV(MAXATM)
C
      SAVE ONE
      DATA ONE/1.0D0/
C
C  Only delete the ionic form if LP-LP* interactions were found in SR
C  ARROWS:
C
      IF(IRESET(IREF).EQ.-3) THEN
        NIRPL = 0
        DO 10 KION=1,IIONC
C
C  IDXCOV(KION) is the index (LSTRES) that identifies the covalent
C     forms corresponding to all LP-LP* interactions
C  Does the covalent form already appear in the reference list?
C
          ICREF = 0
          DO 20 JREF = 1,NREF
            IF(IREF.NE.JREF) THEN
              IF(IDXRES(1,JREF).EQ.IDXCOV(KION)) ICREF = JREF
            END IF
   20     CONTINUE
C
C  If not, add it to the list.  If it's the first LP-LP* interaction,
C      store covalent structure in place of ionic reference, otherwise
C      append to end of reference list:
C
          IF(ICREF.EQ.0) THEN
            IF(NIRPL.EQ.0) THEN
              NRES(IREF) = 1
              IDXRES(1,IREF) = IDXCOV(KION)
            ELSE
              NIRPL = NIRPL + 1
              NREF = NREF + 1
              NRES(NREF) = 1
              IDXRES(1,NREF) = IDXCOV(KION)
              IRESET(NREF) = 1
            END IF
          ELSE
            NRES(IREF) = 0
            IDXRES(1,IREF) = 0
            IRESET(IREF) = -4
          END IF
C
C  Does the ionic structure appear in the secondary list of some
C  other reference?  If so, replace it by the covalent forms and
C  update the bond ionicities:
C
C-----------------------------------------------------------------------
C  JNote:  Cannot find which variable is the total number of structures in
C     a reference manifold.  Want to replace/store the first LP-LP* covalent
C     structure where the ionic one was, and append further ones to end of
C     manifold.  RETURN in SR ARROWS is left in (exit on first LP-LP*
C     interaction found) because of this; remove later to get more LP-LP*.
C-----------------------------------------------------------------------
C
          KREF = KPAR(1,IREF) / 10000
          KRES = MOD(KPAR(1,IREF),10000)
          IF(KRES.NE.0.AND.KREF.NE.0) THEN
            IDXRES(KRES,KREF) = IDXCOV(KION)
            IJ = (IAT1(KION) - 1) * (IAT1(KION) - 2) / 2 + IAT2(KION)
            XION(IJ,KRES,KREF) = XION(IJ,KRES,KREF) + ONE
          END IF
   10   CONTINUE
      END IF
      RETURN
      END
C***********************************************************************
      SUBROUTINE SECRES(IRES,DM,T,RHOSTR,BNDOCC,TNBO,SCR,IDON,IACC,
     +                  IDXRES,LSTRES,MAXRES,IREF,NREF,LEN)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
      COMMON/NBTOPO/IORDER(MAXATM),JORDER(MAXATM),NTOPO(MAXATM,MAXATM),
     +            N3CTR,I3CTR(10,3)
      COMMON/NBSTR/ITOPO(MAXATM,MAXATM)
      COMMON/NBSTOR/NBOLBL(MAXBAS,6),NHOCTR(MAXBAS)
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
C
      DIMENSION DM(NDIM,NDIM),T(NDIM,NDIM),RHOSTR(MAXRES,NREF),
     +          BNDOCC(NDIM),TNBO(NDIM,NDIM),SCR(NDIM),
     +          IDON(MAXRES,NREF),IACC(MAXRES,NREF),IDXRES(MAXRES,NREF),
     +          LSTRES(LEN)
C
      DIMENSION BLOCK(2,2),EVAL(2),EVEC(2,2)
      DIMENSION ICTR(4),IORB(4),IHYB(4)
C
      SAVE LBLNK,LSTAR,LBD,LLP
      SAVE ZERO,EPS,TOTP,TOTX,TENTH,ONE,TWO
      DATA LBLNK,LSTAR,LBD,LLP/1H ,1H*,2HBD,2HLP/
      DATA ZERO,EPS,TOTP,TOTX,TENTH,ONE,TWO/0.0D0,1.0D-7,1.0D-4,
     +     5D-1,0.1D0,1.0D0,2.0D0/
C
C  Compute bond orbitals for the resonance structure specified in
C  ITOPO:
C
C  Get the topo matrix for the parent resonance structure:
C
      CALL TOPGET(1,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
      DO 20 IAT = 1,NATOMS
        DO 10 JAT = 1,NATOMS
          NTOPO(JAT,IAT) = ITOPO(JAT,IAT)
   10   CONTINUE
   20 CONTINUE
C
C  And get the topo matrix for the resonance structure which we are
C  about to compute:
C
      CALL TOPGET(IRES,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
      IF(JPRINT(57).NE.0) THEN
        WRITE(LFNPR,890) IRES,IDXRES(IRES,IREF)
        CALL TOPOUT
      END IF
C
C  By difference, we can tell where bonds and lone pairs should be
C  added to or removed from the parent structure:
C
      DO 40 IAT = 1,NATOMS
        DO 30 JAT = 1,NATOMS
          NTOPO(JAT,IAT) = ITOPO(JAT,IAT) - NTOPO(JAT,IAT)
   30   CONTINUE
   40 CONTINUE
C
C  Form a list of the hybrids (in IHYB) involved in the delocalization.
C  Also, form a list of the atomic centers (in ICTR) on which these hybrids
C  reside.  Entries in IHYB for donor hybrids are set negative:
C
      NCTR = 0
      QDONB = ZERO
      QDONA = ZERO
      DO 50 IB = 1,NNAO
        IF(ABS(T(IB,IDON(IRES,IREF))).GT.EPS) THEN
          NCTR = NCTR + 1
          IHYB(NCTR) = -IB
          ICTR(NCTR) =  NHOCTR(IB)
          COEF = T(IB,IDON(IRES,IREF))
          QDONB = QDONB + COEF * COEF * DM(IB,IB)
        END IF
   50 CONTINUE
      IF(NCTR.EQ.2) THEN
        IHA   = ABS(IHYB(1))
        IHB   = ABS(IHYB(2))
        COEFA = T(IHA,IDON(IRES,IREF))
        COEFB = T(IHB,IDON(IRES,IREF))
        TEMP  = TWO * COEFA * COEFB * DM(IHA,IHB)
        QDONA = COEFA * COEFA * DM(IHB,IHB)
        QDONA = QDONA + COEFB * COEFB * DM(IHA,IHA)
        QDONA = QDONA - TEMP
        QDONB = QDONB + TEMP
      END IF
      IF(NCTR.GT.2) THEN
        IF(JPRINT(57).EQ.0) THEN
          WRITE(LFNPR,890) IRES,IDXRES(IRES,IREF)
          CALL TOPOUT
        END IF
        WRITE(LFNPR,900) NCTR,IDON(IRES,IREF),IRES
        CALL NBHALT('SECRES: Too many hybrids found for NBO.')
      END IF
      NDCTR = NCTR
      DO 60 IB = 1,NNAO
        IF(ABS(T(IB,IACC(IRES,IREF))).GT.EPS) THEN
          NCTR = NCTR + 1
          IHYB(NCTR) = IB
          ICTR(NCTR) = NHOCTR(IB)
        END IF
   60 CONTINUE
      IF(NCTR-NDCTR.GT.2) THEN
        IF(JPRINT(57).EQ.0) THEN
          WRITE(LFNPR,890) IRES,IDXRES(IRES,IREF)
          CALL TOPOUT
        END IF
        WRITE(LFNPR,900) NCTR,IACC(IRES,IREF),IRES
        CALL NBHALT('SECRES: Too many hybrids found for NBO.')
      END IF
C
C  Beware...  This may be an interaction between a bond and its
C  own antibond:
C
      IF(NCTR.EQ.4) THEN
        IF(IHYB(1)+IHYB(3).EQ.0.AND.IHYB(2)+IHYB(4).EQ.0) THEN
          DO 55 IAT = 1,NATOMS
            IF(NTOPO(IAT,IAT).GT.0) THEN
              IF(ICTR(1).EQ.IAT) IHYB(1) = ABS(IHYB(1))
              IF(ICTR(2).EQ.IAT) IHYB(2) = ABS(IHYB(2))
            END IF
   55     CONTINUE
          NCTR = 2
        END IF
      END IF
C
C  Make sure nothing has gone wrong so far.  Determine whether we still have
C  the correct number of electron pairs in this secondary structure, and
C  whether the atomic centers of the `new' electron pairs are the atomic
C  centers involved in the IDON->IACC orbital interaction:
C
      ICNT = 0
      DO 80 IAT = 1,NATOMS
        DO 70 JAT = 1,IAT
          ICNT = ICNT + NTOPO(JAT,IAT)
   70   CONTINUE
   80 CONTINUE
      IF(ICNT.NE.0) THEN
        IF(JPRINT(57).EQ.0) THEN
          WRITE(LFNPR,890) IRES,IDXRES(IRES,IREF)
          CALL TOPOUT
        END IF
        IF(ICNT.GT.0) THEN
          WRITE(LFNPR,910)
        ELSE
          WRITE(LFNPR,920)
        END IF
        CALL NBHALT('SECRES: Incompatibility in electron pairs.')
      END IF
      DO 110 IAT = 1,NATOMS
        DO 100 JAT = 1,NATOMS
          IF(NTOPO(IAT,JAT).GT.0) THEN
            DO 90 IC = 1,NCTR
              IF(IAT.EQ.ICTR(IC)) GOTO 100
   90       CONTINUE
            IF(JPRINT(57).EQ.0) THEN
              WRITE(LFNPR,890) IRES,IDXRES(IRES,IREF)
              CALL TOPOUT
            END IF
            WRITE(LFNPR,930) IAT,IDON(IRES,IREF),IACC(IRES,IREF)
         CALL NBHALT('SECRES: Wrong atomic center for NBO interaction.')
          END IF
  100   CONTINUE
  110 CONTINUE
C
C  Determine the complete set of NBOs which are involved in this
C  delocalization:
C
      NORB = 2
      IORB(1) = IDON(IRES,IREF)
      IORB(2) = IACC(IRES,IREF)
      IF(NCTR.GT.2) THEN
        NORB = -NORB
        DO 140 I = 1,2
          IBD = IBXM(IORB(I))
          LAB = LABEL(IBD,1)
          IF(LAB.EQ.LBD) THEN
            DO 130 IB = 1,NNAO
              DO 120 J = 1,ABS(NORB)
                IF(IB.EQ.IORB(J)) GOTO 130
  120         CONTINUE
              IF(LABEL(IBXM(IB),1).NE.LABEL(IBD,1)) GOTO 130
              IF(LABEL(IBXM(IB),3).NE.LABEL(IBD,3)) GOTO 130
              IF(LABEL(IBXM(IB),4).NE.LABEL(IBD,4)) GOTO 130
              IF(LABEL(IBXM(IB),5).NE.LABEL(IBD,5)) GOTO 130
              IF(LABEL(IBXM(IB),6).NE.LABEL(IBD,6)) GOTO 130
              NORB = ABS(NORB) + 1
              IF(NORB.GT.4) THEN
                IF(JPRINT(57).EQ.0) THEN
                  WRITE(LFNPR,890) IRES,IDXRES(IRES,IREF)
                  CALL TOPOUT
                END IF
                WRITE(LFNPR,940) IRES
                CALL NBHALT('SECRES: Problems finding deloc. NBOs')
              END IF
              IORB(NORB) = IB
  130       CONTINUE
            IF(NORB.LT.0) THEN
              IF(JPRINT(57).EQ.0) THEN
                WRITE(LFNPR,890) IRES,IDXRES(IRES,IREF)
                CALL TOPOUT
              END IF
              WRITE(LFNPR,950) IORB(I)
          CALL NBHALT('SECRES: Cannot find bond or antibond partner.')
            END IF
            NORB = -NORB
          END IF
  140   CONTINUE
        NORB = ABS(NORB)
      END IF
C
C  Copy the NBOs from T to TNBO, except for the NORB NBOs listed in IORB:
C
      CALL COPY(T,TNBO,NDIM,NNAO,NNAO)
      DO 160 I = 1,NORB
        IB = IORB(I)
        DO 150 J = 1,NNAO
          TNBO(J,IB) = ZERO
  150   CONTINUE
        LABEL(IBXM(IB),4) = 0
  160 CONTINUE
C
C  Now, form new bond orbitals from the hybrids in IORB, according to the
C  entries in the NTOPO matrix:
C
      DO 230 IAT = 2,NATOMS
        DO 220 JAT = 1,IAT-1
          IF(NTOPO(JAT,IAT).GT.0) THEN
            DO 170 IC = 1,NCTR
              IF(ICTR(IC).EQ.IAT) II = IC
              IF(ICTR(IC).EQ.JAT) JJ = IC
  170       CONTINUE
            IF(IHYB(II)*IHYB(JJ).GT.0)
     +         CALL NBHALT('SECRES: Problem forming bond from hybrids.')
C
C  Prepare the density block:
C
            IF(IHYB(II).GT.0) THEN
              KK = II
              LL = JJ
            ELSE
              KK = JJ
              LL = II
            END IF
            IHYB(II) = ABS(IHYB(II))
            IHYB(JJ) = ABS(IHYB(JJ))
            POLD = T(IHYB(KK),IACC(IRES,IREF))
            POLD = POLD * POLD
            POLA = T(IHYB(LL),IDON(IRES,IREF))
            POLA = MAX(ZERO,ONE - POLA * POLA)
            BLOCK(1,1) = DM(IHYB(II),IHYB(II))
            BLOCK(2,1) = DM(IHYB(JJ),IHYB(II))
            BLOCK(1,2) = DM(IHYB(II),IHYB(JJ))
            BLOCK(2,2) = DM(IHYB(JJ),IHYB(JJ))
            IF(II.EQ.KK) THEN
              BLOCK(1,1) = BLOCK(1,1) + POLD * QDONB
              BLOCK(2,2) = POLA * QDONA
            ELSE
              BLOCK(1,1) = POLA * QDONA
              BLOCK(2,2) = BLOCK(2,2) + POLD * QDONB
            END IF
C
C  Diagonalize the 2x2 block of the NHO density matrix to compute the
C  new bond:
C
            CALL NBJACOBI(2,BLOCK,EVAL,EVEC,2,2,0)
C
C  Assume the bond has higher occupancy than the antibond.  Write
C  the eigenvectors to TNBO:
C
            IBD  = 1
            IBDS = 2
            IF(EVAL(1).LT.EVAL(2)) THEN
              IBD  = 2
              IBDS = 1
            END IF
            DO 180 IB = 1,NNAO
              IF(LABEL(IBXM(IB),4).EQ.0) THEN
                TNBO(IHYB(II),IB) = EVEC(1,IBD)
                TNBO(IHYB(JJ),IB) = EVEC(2,IBD)
                LABEL(IBXM(IB),1) = LBD
                LABEL(IBXM(IB),2) = LBLNK
                LABEL(IBXM(IB),3) = 0
                LABEL(IBXM(IB),4) = MIN(ICTR(II),ICTR(JJ))
                LABEL(IBXM(IB),5) = MAX(ICTR(II),ICTR(JJ))
                LABEL(IBXM(IB),6) = 0
                GOTO 190
              END IF
  180       CONTINUE
            CALL NBHALT('SECRES: No place for bond in TNBO.')
  190       CONTINUE
            DO 200 IB = NNAO,1,-1
              IF(LABEL(IBXM(IB),4).EQ.0) THEN
                TNBO(IHYB(II),IB) = EVEC(1,IBDS)
                TNBO(IHYB(JJ),IB) = EVEC(2,IBDS)
                LABEL(IBXM(IB),1) = LBD
                LABEL(IBXM(IB),2) = LSTAR
                LABEL(IBXM(IB),3) = 0
                LABEL(IBXM(IB),4) = MIN(ICTR(II),ICTR(JJ))
                LABEL(IBXM(IB),5) = MAX(ICTR(II),ICTR(JJ))
                LABEL(IBXM(IB),6) = 0
                GOTO 210
              END IF
  200       CONTINUE
            CALL NBHALT('SECRES: No place for antibond in TNBO.')
  210       CONTINUE
            ICTR(II) = 0
            ICTR(JJ) = 0
          END IF
  220   CONTINUE
  230 CONTINUE
C
C  Likewise, add lone pairs to TNBO:
C
      DO 260 IAT = 1,NATOMS
        IF(NTOPO(IAT,IAT).GT.0) THEN
          DO 250 IC = 1,NCTR
            IF(ICTR(IC).EQ.IAT.AND.IHYB(IC).GT.0) THEN
              DO 240 IB = 1,NNAO
                IF(LABEL(IBXM(IB),4).EQ.0) THEN
                  TNBO(IHYB(IC),IB) = ONE
                  LABEL(IBXM(IB),1) = LLP
                  LABEL(IBXM(IB),2) = LBLNK
                  LABEL(IBXM(IB),3) = 0
                  LABEL(IBXM(IB),4) = IAT
                  LABEL(IBXM(IB),5) = 0
                  LABEL(IBXM(IB),6) = 0
                  ICTR(IC) = 0
                  GOTO 260
                END IF
  240         CONTINUE
              CALL NBHALT('SECRES: No place for lone pair in TNBO.')
            END IF
  250     CONTINUE
        END IF
  260 CONTINUE
C
C  Finally, complete the set of orbitals according to the entries of ICTR:
C
      DO 280 IC = 1,NCTR
        IF(ICTR(IC).NE.0) THEN
          IF(IHYB(IC).GT.0) THEN
            LAB = LBLNK
            IBMIN = 1
            IBMAX = NNAO
            IBSTP = 1
          ELSE
            LAB = LSTAR
            IBMIN = NNAO
            IBMAX = 1
            IBSTP = -1
          END IF
          IHYB(IC) = ABS(IHYB(IC))
          DO 270 IB = IBMIN,IBMAX,IBSTP
            IF(LABEL(IBXM(IB),4).EQ.0) THEN
              TNBO(IHYB(IC),IB) = ONE
              LABEL(IBXM(IB),1) = LLP
              LABEL(IBXM(IB),2) = LAB
              LABEL(IBXM(IB),3) = 0
              LABEL(IBXM(IB),4) = ICTR(IC)
              LABEL(IBXM(IB),5) = 0
              LABEL(IBXM(IB),6) = 0
              ICTR(IC) = 0
              GOTO 280
            END IF
  270     CONTINUE
          CALL NBHALT('SECRES: No place for lone pair* in TNBO.')
        END IF
  280 CONTINUE
C
C  Compute the orbital occupancies and rho* for this resonance structure:
C
      TOT   = ZERO
      RHOST = ZERO
      DO 310 IB = 1,NNAO
        BNDOCC(IB) = ZERO
        DO 300 IR = 1,NNAO
          DO 290 IS = 1,NNAO
            BNDOCC(IB) = BNDOCC(IB) + TNBO(IR,IB)*DM(IR,IS)*TNBO(IS,IB)
  290     CONTINUE
  300   CONTINUE
        TOT = TOT + BNDOCC(IB)
        IF(LABEL(IBXM(IB),2).EQ.LSTAR) RHOST = RHOST + BNDOCC(IB)
  310 CONTINUE
      RHOSTR(IRES,IREF) = RHOST
      IF(JPRINT(57).NE.0) WRITE(LFNPR,970) IRES,IREF,RHOSTR(IRES,IREF)
      NELEC = INT(TOT + TENTH)
      ELECHK = ABS(DFLOAT(NELEC) - TOT)
      IF(ELECHK.GE.TOTP.AND.ELECHK.LT.TOTX) WRITE(LFNPR,965) TOT,IRES
      IF(ELECHK.GT.TOTX) THEN
        IF(JPRINT(57).EQ.0) THEN
          WRITE(LFNPR,890) IRES,IDXRES(IRES,IREF)
          CALL TOPOUT
        END IF
        WRITE(LFNPR,960) TOT,IRES
        CALL NBHALT('SECRES: Non-integer number of electrons found.')
      END IF
C
C  Lastly, fix the NBO labels:
C
      DO 320 IB = 1,NNAO
        LABEL(IBXM(IB),3) = 0
  320 CONTINUE
      CALL COPY(BNDOCC,SCR,NDIM,NNAO,1)
      CALL RANK(SCR,NNAO,NDIM,LARC)
      DO 340 I = 1,NNAO
        IB = LARC(I)
        IF(LABEL(IBXM(IB),3).EQ.0) THEN
          ICNT = 1
          LABEL(IBXM(IB),3) = ICNT
          DO 330 J = I+1,NNAO
            IC = LARC(J)
            IF(LABEL(IBXM(IC),1).EQ.LABEL(IBXM(IB),1).AND.
     +         LABEL(IBXM(IC),2).EQ.LABEL(IBXM(IB),2).AND.
     +         LABEL(IBXM(IC),4).EQ.LABEL(IBXM(IB),4).AND.
     +         LABEL(IBXM(IC),5).EQ.LABEL(IBXM(IB),5).AND.
     +         LABEL(IBXM(IC),6).EQ.LABEL(IBXM(IB),6)) THEN
              ICNT = ICNT + 1
              LABEL(IBXM(IC),3) = ICNT
            END IF
  330     CONTINUE
        END IF
  340 CONTINUE
      RETURN
C
  890 FORMAT(//1X,'Resonance structure:',I5,' [',I6,']')
  900 FORMAT(/1X,'FATAL ERROR:  ',I3,' hybrids found for NBO',I4,' in',
     + ' resonance structure',I4,'.',/1X,'                The NRT ',
     + 'program can only handle 1-center and 2-center NBOs.')
  910 FORMAT(/1X,'FATAL ERROR:  Too many electron pairs in resonance ',
     + 'structure',I4,'.')
  920 FORMAT(/1X,'FATAL ERROR:  Too few electron pairs in resonance ',
     + 'structure',I4,'.')
  930 FORMAT(/1X,'FATAL ERROR:  Atomic center',I3,' is not involved ',
     + 'in the',I4,'-',I4,' NBO interaction.')
  940 FORMAT(/1X,'FATAL ERROR:  SR SECRES had problems finding ',
     + 'set of delocalizing NBOs',/1X,'              which leads to ',
     + 'resonance structure ',I4,'.')
  950 FORMAT(/1X,'FATAL ERROR:  SR SECRES cannot find the bond or ',
     + 'antibond partner for NBO',I4,'.')
  960 FORMAT(/1X,'FATAL ERROR:  Non-integer number of electrons (',
     + F9.5,') found in resonance',/4X,'structure',I4,'.')
  965 FORMAT(/1X,'WARNING:  Non-integer number of electrons (',F9.5,
     + ') found in resonance',/4X,'structure',I4,
     + '.  Program will continue.')
  970 FORMAT(/1X,'Rho*(',I4,',',I3,') = ',F10.5)
      END
C***********************************************************************
      SUBROUTINE SETAPP(NUMRES,NRES,ILIST,IDXRES,MAXRES,IREF,NREF)
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      DIMENSION NRES(NREF),ILIST(MAXRES),IDXRES(MAXRES,NREF)
C
C  Should additional Kekule structures be added to this reference
C  manifold:
C
      NUMRES = 0
      IPOS = 0
   10 IPOS = IPOS + 1
      IF(ILIST(IPOS).EQ.-1) RETURN
      IF(ILIST(IPOS).NE.IDXRES(1,IREF)) THEN
        IPOS = IPOS + 1
        IPOS = IPOS + ILIST(IPOS)
        GOTO 10
      ELSE
        IPOS = IPOS + 1
        NUMRES = ILIST(IPOS)
      END IF
      IF(NUMRES.EQ.0) RETURN
C
C  Add structures to secondary list:
C
      IPT = 0
      DO 30 I = 1,NUMRES
        IPOS = IPOS + 1
        DO 20 IRES = 1,NRES(IREF)
          IF(IDXRES(IRES,IREF).EQ.ILIST(IPOS)) GOTO 30
   20   CONTINUE
        IPT = IPT + 1
        IDXRES(NRES(IREF)+IPT,IREF) = ILIST(IPOS)
   30 CONTINUE
      NRES(IREF) = NRES(IREF) + IPT
      NUMRES = IPT
      RETURN
      END
C***********************************************************************
      SUBROUTINE APPEND(IRES,DM,T,RHOSTR,DELOC,BNDOCC,TNBO,SCR,ICTR,
     +                  IMAKE,IBRAK,IDN,QDN,IAC,QAC,IPAR,IHYB,IDON,
     +                  IACC,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
C***********************************************************************
C 13-Jul-94  JKB  Revised calls to NBHALT to print specific messages
C 12-Jul-94  JKB  Allow correlated densities as in SR ARROWS (w/IFLG=1)
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
C
      PARAMETER(MAXATM = 200,MAXBAS = 2000)
      COMMON/NBSTR/ITOPO(MAXATM,MAXATM)
      COMMON/NBTOPO/IORDER(MAXATM),JORDER(MAXATM),NTOPO(MAXATM,MAXATM),
     +            N3CTR,I3CTR(10,3)
      COMMON/NBSTOR/NBOLBL(MAXBAS,6),NHOCTR(MAXBAS)
      COMMON/NBINFO/ISPIN,NATOMS,NDIM,NBAS,NNAO,MXBO,MXAO,MXAOLM,MUNIT
      COMMON/NBBAS/LABEL(MAXBAS,6),NBOUNI(MAXBAS),NBOTYP(MAXBAS),
     +       LSTOCC(MAXBAS),IBXM(MAXBAS),LARC(MAXBAS),LBL(MAXBAS),
     +       LORBC(MAXBAS),LORB(MAXBAS)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
C
      DIMENSION DM(NDIM,NDIM),T(NDIM,NDIM),RHOSTR(MAXRES,NREF),
     +          DELOC(NDIM,NDIM),BNDOCC(NDIM),TNBO(NDIM,NDIM),
     +          SCR(NDIM),IDXRES(MAXRES,NREF),LSTRES(LEN),
     +          IDON(MAXRES,NREF),IACC(MAXRES,NREF),ICTR(NATOMS),
     +          IMAKE(2,NATOMS),IBRAK(2,NATOMS),IDN(NATOMS),
     +          QDN(NATOMS),IAC(NATOMS),QAC(NATOMS),IPAR(NATOMS),
     +          IHYB(NATOMS)
      DIMENSION BLOCK(2,2),EVAL(2),EVEC(2,2)
C
      SAVE ZERO,CUTOFF,TENTH,PT5,ONE,TWO,THRESH,BIG
      SAVE LBLNK,LSTAR,LBD
      DATA ZERO,CUTOFF,TENTH,PT5,ONE,TWO,THRESH,BIG/0.0D0,1.0D-4,0.1D0,
     +     0.5D0,1.0D0,2.0D0,5.0D0,1.0D6/
      DATA LBLNK,LSTAR,LBD/1H ,1H*,2HBD/
C
C  Note in the donor and acceptor arrays that this structure was not
C  obtained in the usual way with ARROWS:
C
      IDON(IRES,IREF) = -1
      IACC(IRES,IREF) = -1
C
C  Get the topo matrix for this structure and copy it to NTOPO:
C
      CALL TOPGET(IRES,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
      DO 20 JAT = 1,NATOMS
        DO 10 IAT = 1,NATOMS
          NTOPO(IAT,JAT) = ITOPO(IAT,JAT)
   10   CONTINUE
   20 CONTINUE
      IF(JPRINT(57).NE.0) THEN
        WRITE(LFNPR,900) IRES,IDXRES(IRES,IREF)
        CALL TOPOUT
      END IF
C
C  Also, get the topo matrix for the reference structure and compute
C  the difference between it and the NTOPO matrix:
C
      CALL TOPGET(1,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
      DO 40 JAT = 1,NATOMS
        DO 30 IAT = 1,NATOMS
          NTOPO(IAT,JAT) = NTOPO(IAT,JAT) - ITOPO(IAT,JAT)
   30   CONTINUE
   40 CONTINUE
C
C  Get a list of the atomic centers involved in the bond shift:
C
      NC = 0
      DO 60 JAT = 1,NATOMS
        DO 50 IAT = 1,NATOMS
          IF(NTOPO(IAT,JAT).EQ.1) THEN
            NC = NC + 1
            ICTR(NC) = IAT
          END IF
   50   CONTINUE
   60 CONTINUE
      IF(NC.GT.NATOMS) THEN
        WRITE(LFNPR,940) IRES,IREF
        WRITE(LFNPR,945) (kk,ictr(kk),kk=1,nc)
        CALL NBHALT('APPEND: Too many atomic centers found.')
      END IF
C
C  Also, get lists of the bonds which are broken, and those that are
C  made:
C
      NM = 0
      NB = 0
      DO 80 IAT = 1,NATOMS-1
        DO 70 JAT = IAT+1,NATOMS
          IF(NTOPO(IAT,JAT).EQ.1) THEN
            NM = NM + 1
            IMAKE(1,NM) = IAT
            IMAKE(2,NM) = JAT
          ELSE IF(NTOPO(IAT,JAT).EQ.-1) THEN
            NB = NB + 1
            IBRAK(1,NB) = IAT
            IBRAK(2,NB) = JAT
          END IF
   70   CONTINUE
   80 CONTINUE
      IF(NM.GT.NATOMS) THEN
         WRITE(LFNPR,960) IRES,IREF
         CALL NBHALT('APPEND: Too many bonds made to an atom.')
      END IF
      IF(NB.GT.NATOMS) THEN
         WRITE(LFNPR,965) IRES,IREF
         CALL NBHALT('APPEND: Too many bonds broken from an atom.')
      END IF
      IF(NB.NE.NM) THEN
         WRITE(LFNPR,970) IRES,IREF
         CALL NBHALT('APPEND: Bonds made not equal to bonds broken.')
      END IF
C
C  Find a list of donor NBOs by examining orbital occupancy:
C
      DO 120 IB = 1,NB
        IDN(IB) = 0
        QDN(IB) = BIG
        DO 110 IBP = 1,NNAO
          IBD = IBXM(IBP)
          IF(LABEL(IBD,1).NE.LBD) GOTO 110
          IF(LABEL(IBD,2).EQ.LSTAR) GOTO 110
          IF(LABEL(IBD,4).NE.IBRAK(1,IB)) GOTO 110
          IF(LABEL(IBD,5).NE.IBRAK(2,IB)) GOTO 110
          IF(LABEL(IBD,6).NE.0) GOTO 110
          Q = ZERO
          DO 100 J = 1,NNAO
            DO 90 I = 1,NNAO
              Q = Q + T(I,IBP) * T(J,IBP) * DM(I,J)
   90       CONTINUE
  100     CONTINUE
          IF(Q.LT.QDN(IB).OR.IDN(IB).EQ.0) THEN
            QDN(IB) = Q
            IDN(IB) = IBP
          END IF
  110   CONTINUE
        IF(IDN(IB).EQ.0) THEN
          WRITE(LFNPR,980) IRES,IREF
          CALL NBHALT('APPEND: Inconsistent number of donor orbitals.')
        END IF
  120 CONTINUE
C
C  Get the acceptor orbitals and their occupancies:
C
      DO 160 IB = 1,NB
        IBD = IBXM(IDN(IB))
        IAC(IB) = 0
        DO 150 IBP = 1,NNAO
          IBDP = IBXM(IBP)
          IF(LABEL(IBDP,1).NE.LABEL(IBD,1)) GOTO 150
          IF(LABEL(IBDP,2).EQ.LABEL(IBD,2)) GOTO 150
          IF(LABEL(IBDP,3).NE.LABEL(IBD,3)) GOTO 150
          IF(LABEL(IBDP,4).NE.LABEL(IBD,4)) GOTO 150
          IF(LABEL(IBDP,5).NE.LABEL(IBD,5)) GOTO 150
          IF(LABEL(IBDP,6).NE.LABEL(IBD,6)) GOTO 150
          Q = ZERO
          DO 140 J = 1,NNAO
            DO 130 I = 1,NNAO
              Q = Q + T(I,IBP) * T(J,IBP) * DM(I,J)
  130       CONTINUE
  140     CONTINUE
          IAC(IB) = IBP
          QAC(IB) = Q
  150   CONTINUE
        IF(IAC(IB).EQ.0) THEN
          WRITE(LFNPR,985) IRES,IREF
          CALL NBHALT('APPEND: Inconsistent number acceptor orbitals.')
        END IF
  160 CONTINUE
C
C  Check the delocalization list, ensuring that the orbital interactions
C  are stronger than THRESH:
C
      DO 190 IB = 1,NB
        IBO = IDN(IB)
        IF(IWFOCK.EQ.1) THEN
          IFLG = 0
          CALL GETDEL(IBO,TWO,THRESH,THRESH,NL,LARC,SCR,DELOC,IFLG)
        ELSE
          IFLG = 1
          CALL GETDEL(IBO,TWO,CUTOFF,CUTOFF,NL,LARC,SCR,DELOC,IFLG)
        END IF
        NUM = 0
        DO 180 IBP = 1,NB
          IF(IB.NE.IBP) THEN
            DO 170 IL = 1,NL
              IF(LARC(IL).EQ.IAC(IBP)) THEN
                NUM = NUM + 1
                GOTO 180
              END IF
  170       CONTINUE
          END IF
  180   CONTINUE
        IF(NUM.LT.2) GOTO 800
  190 CONTINUE
C
C  Get a list of the hybrids involved:
C
      DO 240 IC = 1,NC
        DO 210 IB = 1,NB
          DO 200 I = 1,2
            IF(IBRAK(I,IB).EQ.ICTR(IC)) GOTO 220
  200     CONTINUE
  210   CONTINUE
        WRITE(LFNPR,990) ICTR(IC)
        CALL NBHALT('APPEND: Cannot find hybrids for broken bond.')
  220   CONTINUE
        IPAR(IC) = IB
        IHYB(IC) = 0
        HOLD = ZERO
        DO 230 IH = 1,NNAO
          IF(ICTR(IC).EQ.NHOCTR(IH)) THEN
            IF(ABS(T(IH,IDN(IB))).GT.HOLD) THEN
              IHYB(IC) = IH
              HOLD = ABS(T(IH,IDN(IB)))
            END IF
          END IF
  230   CONTINUE
        IF(IHYB(IC).EQ.0) THEN
          WRITE(LFNPR,995) IC
          CALL NBHALT('APPEND: Cannot find atom for broken bond.')
        END IF
  240 CONTINUE
C
C  Copy the NBOs from T to TNBO:
C
      CALL COPY(T,TNBO,NDIM,NNAO,NNAO)
      DO 250 I = 1,NB
        LABEL(IBXM(IDN(I)),4) = 0
        LABEL(IBXM(IAC(I)),4) = 0
        DO 245 IH = 1,NNAO
          TNBO(IH,IDN(I)) = ZERO
          TNBO(IH,IAC(I)) = ZERO
  245   CONTINUE
  250 CONTINUE
C
C  Make new bonds from the hybrids in IHYB:
C
      DO 330 IB = 1,NB
        IH = 0
        DO 260 IC = 1,NC
          IF(ICTR(IC).EQ.IMAKE(1,IB)) THEN
            IH = IHYB(IC)
            IP = IPAR(IC)
          END IF
  260   CONTINUE
        IF(IH.EQ.0) THEN
          WRITE(LFNPR,992) ICTR(IC)
          CALL NBHALT('APPEND: Cannot find hybrids for bond formed.')
        END IF
        JH = 0
        DO 270 IC = 1,NC
          IF(ICTR(IC).EQ.IMAKE(2,IB)) THEN
            JH = IHYB(IC)
            JP = IPAR(IC)
          END IF
  270   CONTINUE
        IF(JH.EQ.0) THEN
          WRITE(LFNPR,997) IC
          CALL NBHALT('APPEND: Cannot find atom for bond formed.')
        END IF
        FAC = ONE - T(IH,IDN(IP)) * T(IH,IDN(IP))
        Q   = QAC(IP)
        DO 280 IBP = 1,NB
          IF(IBP.NE.IP) THEN
            Q = Q + PT5 * QDN(IBP)
          END IF
  280   CONTINUE
        BLOCK(1,1) = FAC * Q
        FAC = ONE - T(JH,IDN(JP)) * T(JH,IDN(JP))
        Q   = QAC(JP)
        DO 290 IBP = 1,NB
          IF(IBP.NE.JP) THEN
            Q = Q + PT5 * QDN(IBP)
          END IF
  290   CONTINUE
        BLOCK(2,2) = FAC * Q
        BLOCK(1,2) = DM(IH,JH)
        BLOCK(2,1) = BLOCK(1,2)
C
C  Diagonalize the 2x2 block of the NHO density matrix to compute the
C  new bond:
C
        CALL NBJACOBI(2,BLOCK,EVAL,EVEC,2,2,0)
C
C  Assume the bond has higher occupancy than the antibond.  Write
C  the eigenvectors to TNBO:
C
        IBD  = 1
        IBDS = 2
        IF(EVAL(1).LT.EVAL(2)) THEN
          IBD  = 2
          IBDS = 1
        END IF
        DO 300 IBP = 1,NNAO
          IF(LABEL(IBXM(IBP),4).EQ.0) THEN
            TNBO(IH,IBP) = EVEC(1,IBD)
            TNBO(JH,IBP) = EVEC(2,IBD)
            LABEL(IBXM(IBP),1) = LBD
            LABEL(IBXM(IBP),2) = LBLNK
            LABEL(IBXM(IBP),3) = 0
            LABEL(IBXM(IBP),4) = MIN(IMAKE(1,IB),IMAKE(2,IB))
            LABEL(IBXM(IBP),5) = MAX(IMAKE(1,IB),IMAKE(2,IB))
            LABEL(IBXM(IBP),6) = 0
            GOTO 310
          END IF
  300   CONTINUE
        CALL NBHALT('APPEND: No place for bond in TNBO.')
  310   CONTINUE
        DO 320 IBP = NNAO,1,-1
          IF(LABEL(IBXM(IBP),4).EQ.0) THEN
            TNBO(IH,IBP) = EVEC(1,IBDS)
            TNBO(JH,IBP) = EVEC(2,IBDS)
            LABEL(IBXM(IBP),1) = LBD
            LABEL(IBXM(IBP),2) = LSTAR
            LABEL(IBXM(IBP),3) = 0
            LABEL(IBXM(IBP),4) = MIN(IMAKE(1,IB),IMAKE(2,IB))
            LABEL(IBXM(IBP),5) = MAX(IMAKE(1,IB),IMAKE(2,IB))
            LABEL(IBXM(IBP),6) = 0
            GOTO 330
          END IF
  320   CONTINUE
        CALL NBHALT('APPEND: No place for antibond in TNBO.')
  330 CONTINUE
C
C  Compute the orbital occupancies and rho* for this resonance structure:
C
      TOT   = ZERO
      RHOST = ZERO
      DO 360 IB = 1,NNAO
        BNDOCC(IB) = ZERO
        DO 350 IR = 1,NNAO
          DO 340 IS = 1,NNAO
            BNDOCC(IB) = BNDOCC(IB) + TNBO(IR,IB)*DM(IR,IS)*TNBO(IS,IB)
  340     CONTINUE
  350   CONTINUE
        TOT = TOT + BNDOCC(IB)
        IF(LABEL(IBXM(IB),2).EQ.LSTAR) RHOST = RHOST + BNDOCC(IB)
  360 CONTINUE
      RHOSTR(IRES,IREF) = RHOST
      IF(JPRINT(57).NE.0) WRITE(LFNPR,920) IRES,IREF,RHOSTR(IRES,IREF)
      NELEC = INT(TOT + TENTH)
      IF(ABS(DFLOAT(NELEC)-TOT).GT.CUTOFF) THEN
        IF(JPRINT(57).NE.0) THEN
          WRITE(LFNPR,900) IRES,IDXRES(IRES,IREF)
          CALL TOPOUT
        END IF
        WRITE(LFNPR,930) TOT,IRES,IREF
        CALL NBHALT('APPEND: Non-integer number of electrons found.')
        RETURN
      END IF
C
C  Fix the NBO labels:
C
      DO 370 IB = 1,NNAO
        LABEL(IBXM(IB),3) = 0
  370 CONTINUE
      CALL COPY(BNDOCC,SCR,NDIM,NNAO,1)
      CALL RANK(SCR,NNAO,NDIM,LARC)
      DO 390 I = 1,NNAO
        IB = LARC(I)
        IF(LABEL(IBXM(IB),3).EQ.0) THEN
          ICNT = 1
          LABEL(IBXM(IB),3) = ICNT
          DO 380 J = I+1,NNAO
            IC = LARC(J)
            IF(LABEL(IBXM(IC),1).EQ.LABEL(IBXM(IB),1).AND.
     +         LABEL(IBXM(IC),2).EQ.LABEL(IBXM(IB),2).AND.
     +         LABEL(IBXM(IC),4).EQ.LABEL(IBXM(IB),4).AND.
     +         LABEL(IBXM(IC),5).EQ.LABEL(IBXM(IB),5).AND.
     +         LABEL(IBXM(IC),6).EQ.LABEL(IBXM(IB),6)) THEN
              ICNT = ICNT + 1
              LABEL(IBXM(IC),3) = ICNT
            END IF
  380     CONTINUE
        END IF
  390 CONTINUE
C
C  Finally, put the IRES topo matrix in ITOPO:
C
      CALL TOPGET(IRES,IDXRES,MAXRES,IREF,NREF,LSTRES,LEN)
      RETURN
C
C  Remove this Kekule structure from the list of structures:
C
  800 CONTINUE
      IF(JPRINT(57).NE.0) WRITE(LFNPR,950)
      RHOSTR(IRES,IREF) = -ONE
      RETURN
C
  900 FORMAT(//1X,'Resonance structure:',I5,' [',I6,']')
  920 FORMAT(/1X,'Rho*(',I4,',',I3,') = ',F10.5)
  930 FORMAT(/1X,'APPEND:  Non-integer number of electrons (',F9.5,
     + ') found in resonance',/1X,'            structure (',I3,',',
     + I3,').')
  940 FORMAT(/1X,'APPEND:  Number of atomic centers in bond shift ',
     + 'greater than',/1X,'            total number of atoms in ',
     + 'structure (',I3,',',I3,').')
  945 FORMAT(1X,'Centers:',8(2I3,2X),2I3)
  950 FORMAT(/1X,'(Removed)')
  960 FORMAT(/1X,'APPEND:  Bonds made to atom',I4,' greater than ',
     + 'total number of atoms',/1X,'            in structure (',
     + I3,',',I3,').')
  965 FORMAT(/1X,'APPEND:  Bonds broken from atom',I4,' greater than ',
     + 'total number of atoms',/1X,'            in structure (',
     + I3,',',I3,').')
  970 FORMAT(/1X,'APPEND:  Bonds made not equal to bonds broken',
     + 'in structure (',I3,',',I3,').')
  980 FORMAT(/1X,'APPEND:  Inconsistent number of donor orbitals',
     + 'in structure (',I3,',',I3,').')
  985 FORMAT(/1X,'APPEND:  Inconsistent number of acceptor orbitals',
     + 'in structure (',I3,',',I3,').')
  990 FORMAT(/1X,'APPEND:  Cannot find hybrids for broken bond ',
     + 'to atom',I4,'.')
  992 FORMAT(/1X,'APPEND:  Cannot find hybrids for bond formed ',
     + 'to atom',I4,'.')
  995 FORMAT(/1X,'APPEND:  Cannot find atom on which broken bond ',
     + 'hybrid',I4,'is centered.')
  997 FORMAT(/1X,'APPEND:  Cannot find atom on which formed bond ',
     + 'hybrid',I4,'is centered.')
      END
C***********************************************************************
      SUBROUTINE HBRES(NRES,IDXRES,MAXRES,MAXREF,LSTRES,LEN,NRTCTL)
C***********************************************************************
C 12-Apr-01  CMM  Adds reference structures according to 3CHB symmetry.
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      INTEGER IRES,JRES,N3CHB,I3CHB,IHB
C
      PARAMETER(MAXATM = 200)
      PARAMETER(MAXHB = MAXATM/3)
      COMMON/NBSTR/ITOPO(MAXATM,MAXATM)
      COMMON/NBHB/N3CHB,I3CHB(MAXHB,3)
      COMMON/NBIO/LFNIN,LFNPR,LFNAO,LFNPNA,LFNNAO,LFNPNH,LFNNHO,LFNPNB,
     +            LFNNBO,LFNPNL,LFNNLM,LFNMO,LFNDM,LFNNAB,LFNPPA,LFNARC,
     +            LFNDAF,LFNLBL,LFNDEF,LFNBRK(100)
      COMMON/NBOPT/IWDM,IW3C,IWAPOL,IWHYBS,IWPNAO,IWTNAO,IWTNAB,
     + IWTNBO,IWFOCK,IWCUBF,IPSEUD,IPRINT,IWDETL,IWMULP,ICHOOS,
     + IWNBBP,IWMSP,IWFIXDM,IW3CHB,IWNJC,JCORE,JPRINT(100)
C
      DIMENSION NRES(MAXREF),IDXRES(MAXRES,MAXREF),LSTRES(LEN),NRTCTL(3)
C
C
C  Skip HBRES search?
C
      IF((NRES(1).EQ.0).OR.(N3CHB.EQ.0)) RETURN
C
C  Initialize:
C
      IF(JPRINT(57).NE.0) THEN
        WRITE(LFNPR,210)
      END IF
      NHBRES = 0
C
C  Loop over reference structures (including any generated in HBRES)
C
      JRES = NRES(1) + 1
      DO 100 IRES = 1,NRES(1)
        CALL TOPGET(IRES,IDXRES,MAXRES,1,1,LSTRES,LEN)
C
C  Loop over 3CHB moieties.  If the TOPO matrix for this reference
C  structure represents one resonance structure, generate the other.
C
        DO 50 IHB = 1,N3CHB
          IF((ITOPO(I3CHB(IHB,1),I3CHB(IHB,2)).EQ.1).AND.
     +       (ITOPO(I3CHB(IHB,2),I3CHB(IHB,3)).EQ.0).AND.
     +       (ITOPO(I3CHB(IHB,3),I3CHB(IHB,3)).GE.1)) THEN
            ITOPO(I3CHB(IHB,1),I3CHB(IHB,1)) =
     +        ITOPO(I3CHB(IHB,1),I3CHB(IHB,1)) + 1
            ITOPO(I3CHB(IHB,1),I3CHB(IHB,2))= 0
            ITOPO(I3CHB(IHB,2),I3CHB(IHB,1))= 0
            ITOPO(I3CHB(IHB,2),I3CHB(IHB,3))= 1
            ITOPO(I3CHB(IHB,3),I3CHB(IHB,2))= 1
            ITOPO(I3CHB(IHB,3),I3CHB(IHB,3)) =
     +        ITOPO(I3CHB(IHB,3),I3CHB(IHB,3)) - 1
          ELSE IF((ITOPO(I3CHB(IHB,1),I3CHB(IHB,1)).GE.1).AND.
     +            (ITOPO(I3CHB(IHB,1),I3CHB(IHB,2)).EQ.0).AND.
     +            (ITOPO(I3CHB(IHB,2),I3CHB(IHB,3)).EQ.1)) THEN
            ITOPO(I3CHB(IHB,1),I3CHB(IHB,1)) =
     +        ITOPO(I3CHB(IHB,1),I3CHB(IHB,1)) - 1
            ITOPO(I3CHB(IHB,1),I3CHB(IHB,2))= 1
            ITOPO(I3CHB(IHB,2),I3CHB(IHB,1))= 1
            ITOPO(I3CHB(IHB,2),I3CHB(IHB,3))= 0
            ITOPO(I3CHB(IHB,3),I3CHB(IHB,2))= 0
            ITOPO(I3CHB(IHB,3),I3CHB(IHB,3)) =
     +        ITOPO(I3CHB(IHB,3),I3CHB(IHB,3)) + 1
          END IF
C
C  Now check for duplication.
C
          CALL TOPSTR(JRES,IDXRES,MAXRES,1,MAXREF,LSTRES,LEN)
          CALL TOPCMP(IDUP,JRES,IDXRES,MAXRES,1,MAXREF,LSTRES,LEN)
          IF(IDUP.EQ.0) THEN
C
C  SR HBRES will only print out a warning when the NRTSTR list is uesd.
C  Otherwise, add any new TOPO matrices to the reference list.
C
            IF(NRTCTL(3).NE.0) THEN
              NHBRES = NHBRES + 1
              JRES = JRES + 1
              NRES(1) = NRES(1) + 1
              IF(JPRINT(57).NE.0) THEN
                WRITE(LFNPR,200) NRES(1), IDXRES(NRES(1),1)
                CALL TOPOUT
                WRITE(LFNPR,*)
              END IF
            ELSE
              WRITE(LFNPR,230) NHBRES
            END IF
          END IF
   50   CONTINUE
  100 CONTINUE
      WRITE(LFNPR,220) NHBRES
C
  200 FORMAT(/1X,'Candidate structure from HBRES:',I5,' [',I6,']')
  210 FORMAT(/1X,'Entering HBRES.')
  220 FORMAT(I4,' candidate reference structure(s) added by hyperbond',
     +' search (SR HBRES)')
  230 FORMAT(/1X,'WARNING: SR HBRES found ',I3,' reference structures',
     +       ' required by symmetry and missing from $NRTSTR keylist.',
     +       /1X,'  NRT will try to proceed.')
C
      END
C***********************************************************************
